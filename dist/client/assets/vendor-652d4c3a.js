function random(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
function isBrowser() {
  return typeof window !== "undefined";
}
function isFunction$5(val) {
  return {}.toString.call(val) === "[object Function]";
}
function isClass(func) {
  return typeof func === "function";
}
function isPromise$2(val) {
  return isInstanceOf(val, Promise);
}
function isArray$8(val) {
  return isInstanceOf(val, Array);
}
function isObject$4(val) {
  return typeof val == "object" && val != null && !isArray$8(val);
}
function isString$3(val) {
  return typeof val == "string";
}
function isInstanceOf(val, _class) {
  return val instanceof _class;
}
function arrayUniq(array2) {
  return [...new Set(array2)];
}
function arrayFlat(array2) {
  return array2.reduce((acc, val) => acc.concat(val), []);
}
function intersection$1([start1, end1], [start2, end2]) {
  return start1 >= start2 && start1 <= end2 || start2 >= start1 && start2 < end1;
}
function capitalize$2(s2) {
  if (typeof s2 !== "string")
    return "";
  return s2.charAt(0).toUpperCase() + s2.slice(1);
}
function camelToKebab(str2) {
  return str2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function arrayEquals$1(a8, b3) {
  return a8.length === b3.length && a8.every((v2, i2) => v2 === b3[i2]);
}
function applyMixins(derivedCtor, baseCtors) {
  baseCtors.forEach((baseCtor) => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
      const baseCtorName = Object.getOwnPropertyDescriptor(baseCtor.prototype, name);
      if (!baseCtorName) {
        return;
      }
      Object.defineProperty(derivedCtor.prototype, name, baseCtorName);
    });
  });
}
function generateUID() {
  let firstPart = Math.random() * 46656 | 0;
  let secondPart = Math.random() * 46656 | 0;
  firstPart = ("000" + firstPart.toString(36)).slice(-3);
  secondPart = ("000" + secondPart.toString(36)).slice(-3);
  return firstPart + secondPart;
}
function createConstructor(...propNames) {
  return class {
    constructor(...propValues) {
      propNames.forEach((name, idx) => {
        this[name] = propValues[idx];
      });
    }
  };
}
function sharedArrayBuffer() {
  let buffer2;
  if (typeof SharedArrayBuffer != "undefined") {
    buffer2 = SharedArrayBuffer;
  } else {
    buffer2 = ArrayBuffer;
  }
  return buffer2;
}
function toRadians(angle2) {
  return angle2 * (Math.PI / 180);
}
function hexaToNumber(hexa) {
  let val = hexa.replace("#", "");
  let alpha = 1;
  if (val.length === 3) {
    val = val.split("").map((v2) => v2 + v2).join("");
  }
  if (val.length === 8) {
    alpha = parseInt(val.substring(0, 2), 16) / 255;
    val = val.substring(2);
  }
  return {
    value: parseInt(val, 16),
    alpha
  };
}
function extractId$1(path2) {
  const id = path2.match(/([a-zA-Z0-9-_$!]+)\.[a-z0-9]+$/i);
  if (!id)
    return null;
  return id[1];
}
function basename(path2) {
  return path2.substring(path2.lastIndexOf("/") + 1);
}
function fps2ms(fps) {
  return 1e3 / fps;
}
function preciseNow() {
  return typeof performance !== "undefined" ? performance.now() : Date.now();
}
function round$1(num, decimals = 100) {
  return Math.round(num * decimals) / decimals;
}
function set$2(obj, path2, value2, onlyPlainObject = false) {
  if (Object(obj) !== obj)
    return obj;
  if (!Array.isArray(path2))
    path2 = path2.toString().match(/[^.[\]]+/g) || [];
  path2.slice(0, -1).reduce(
    (a8, c3, i2) => (
      // Iterate all of them except the last one
      Object(a8[c3]) === a8[c3] ? a8[c3] : a8[c3] = Math.abs(path2[i2 + 1]) >> 0 === +path2[i2 + 1] ? onlyPlainObject ? {} : [] : {}
    ),
    // No: assign a new plain object
    obj
  )[path2[path2.length - 1]] = value2;
  return obj;
}
function elementToPositionAbsolute$2(element) {
  element.style.position = "absolute";
  element.style.top = "0";
  element.style.left = "0";
  element.style.right = "0";
  element.style.bottom = "0";
  element.style.width = "100%";
  element.style.height = "100%";
}
const Utils = {
  random,
  isBrowser,
  isPromise: isPromise$2,
  isArray: isArray$8,
  isObject: isObject$4,
  isString: isString$3,
  isFunction: isFunction$5,
  isClass,
  isInstanceOf,
  arrayUniq,
  arrayFlat,
  arrayEquals: arrayEquals$1,
  intersection: intersection$1,
  applyMixins,
  capitalize: capitalize$2,
  sharedArrayBuffer,
  generateUID,
  createConstructor,
  toRadians,
  extractId: extractId$1,
  basename,
  fps2ms,
  preciseNow,
  hexaToNumber,
  set: set$2,
  round: round$1,
  camelToKebab,
  elementToPositionAbsolute: elementToPositionAbsolute$2
};
const Utils$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  applyMixins,
  arrayEquals: arrayEquals$1,
  arrayFlat,
  arrayUniq,
  basename,
  camelToKebab,
  capitalize: capitalize$2,
  createConstructor,
  default: Utils,
  elementToPositionAbsolute: elementToPositionAbsolute$2,
  extractId: extractId$1,
  fps2ms,
  generateUID,
  hexaToNumber,
  intersection: intersection$1,
  isArray: isArray$8,
  isBrowser,
  isClass,
  isFunction: isFunction$5,
  isInstanceOf,
  isObject: isObject$4,
  isPromise: isPromise$2,
  isString: isString$3,
  preciseNow,
  random,
  round: round$1,
  set: set$2,
  sharedArrayBuffer,
  toRadians
}, Symbol.toStringTag, { value: "Module" }));
var HitType;
(function(HitType2) {
  HitType2["Box"] = "box";
  HitType2["Circle"] = "circle";
  HitType2["Polygon"] = "polygon";
})(HitType || (HitType = {}));
var MoveClientMode;
(function(MoveClientMode2) {
  MoveClientMode2[MoveClientMode2["Disabled"] = 0] = "Disabled";
  MoveClientMode2[MoveClientMode2["ByDirection"] = 1] = "ByDirection";
  MoveClientMode2[MoveClientMode2["Drag"] = 2] = "Drag";
})(MoveClientMode || (MoveClientMode = {}));
var Behavior;
(function(Behavior2) {
  Behavior2[Behavior2["Direction"] = 0] = "Direction";
  Behavior2[Behavior2["Target"] = 1] = "Target";
})(Behavior || (Behavior = {}));
var Direction;
(function(Direction2) {
  Direction2[Direction2["Up"] = 1] = "Up";
  Direction2[Direction2["Down"] = 3] = "Down";
  Direction2[Direction2["Left"] = 4] = "Left";
  Direction2[Direction2["Right"] = 2] = "Right";
  Direction2[Direction2["UpRight"] = 1.5] = "UpRight";
  Direction2[Direction2["DownRight"] = 2.5] = "DownRight";
  Direction2[Direction2["DownLeft"] = 3.5] = "DownLeft";
  Direction2[Direction2["UpLeft"] = 2.5] = "UpLeft";
})(Direction || (Direction = {}));
var PlayerType;
(function(PlayerType2) {
  PlayerType2["Player"] = "player";
  PlayerType2["Event"] = "event";
  PlayerType2["Shape"] = "shape";
})(PlayerType || (PlayerType = {}));
var SocketMethods;
(function(SocketMethods2) {
  SocketMethods2["CameraFollow"] = "cameraFollow";
  SocketMethods2["ShowAnimation"] = "showAnimation";
  SocketMethods2["PlaySound"] = "playSound";
  SocketMethods2["ModeMove"] = "modeMove";
})(SocketMethods || (SocketMethods = {}));
var SocketEvents;
(function(SocketEvents2) {
  SocketEvents2["CallMethod"] = "callMethod";
  SocketEvents2["GameReload"] = "gameReload";
  SocketEvents2["ChangeServer"] = "changeServer";
  SocketEvents2["LoadScene"] = "loadScene";
})(SocketEvents || (SocketEvents = {}));
var Control;
(function(Control2) {
  Control2["Action"] = "action";
  Control2["Attack"] = "attack";
  Control2["Defense"] = "defense";
  Control2["Skill"] = "skill";
  Control2["Back"] = "back";
  Control2[Control2["Up"] = 1] = "Up";
  Control2[Control2["Down"] = 3] = "Down";
  Control2[Control2["Right"] = 2] = "Right";
  Control2[Control2["Left"] = 4] = "Left";
})(Control || (Control = {}));
var Input;
(function(Input2) {
  Input2["Break"] = "break";
  Input2["Backspace"] = "backspace";
  Input2["Tab"] = "tab";
  Input2["Clear"] = "clear";
  Input2["Enter"] = "enter";
  Input2["Shift"] = "shift";
  Input2["Ctrl"] = "ctrl";
  Input2["Alt"] = "alt";
  Input2["Pause"] = "pause/break";
  Input2["CapsLock"] = "caps lock";
  Input2["Escape"] = "escape";
  Input2["Conversion"] = "conversion";
  Input2["NonConversion"] = "non-conversion";
  Input2["Space"] = "space";
  Input2["PageUp"] = "page up";
  Input2["PageDown"] = "page down";
  Input2["End"] = "end";
  Input2["Home"] = "home";
  Input2[Input2["Left"] = 4] = "Left";
  Input2[Input2["Up"] = 1] = "Up";
  Input2[Input2["Right"] = 2] = "Right";
  Input2[Input2["Down"] = 3] = "Down";
  Input2["Select"] = "select";
  Input2["Print"] = "print";
  Input2["Execute"] = "execute";
  Input2["PrintScreen"] = "Print Screen";
  Input2["Insert"] = "insert";
  Input2["Delete"] = "delete";
  Input2["Zero"] = "0";
  Input2["One"] = "1";
  Input2["Two"] = "2";
  Input2["Three"] = "3";
  Input2["Four"] = "4";
  Input2["Five"] = "5";
  Input2["Six"] = "6";
  Input2["Seven"] = "7";
  Input2["Height"] = "8";
  Input2["Nine"] = "9";
  Input2["Equal"] = "=";
  Input2["Semicolon"] = "semicolon (firefox), equals";
  Input2["LessThan"] = "<";
  Input2["Equals"] = "equals (firefox)";
  Input2["Beta"] = "ß";
  Input2["At"] = "@";
  Input2["A"] = "a";
  Input2["B"] = "b";
  Input2["C"] = "c";
  Input2["D"] = "d";
  Input2["E"] = "e";
  Input2["F"] = "f";
  Input2["G"] = "g";
  Input2["H"] = "h";
  Input2["I"] = "i";
  Input2["J"] = "j";
  Input2["K"] = "k";
  Input2["L"] = "l";
  Input2["M"] = "m";
  Input2["N"] = "n";
  Input2["O"] = "o";
  Input2["P"] = "p";
  Input2["Q"] = "q";
  Input2["R"] = "r";
  Input2["S"] = "s";
  Input2["T"] = "t";
  Input2["U"] = "u";
  Input2["V"] = "v";
  Input2["W"] = "w";
  Input2["X"] = "x";
  Input2["Y"] = "y";
  Input2["Z"] = "z";
  Input2["SearchKey"] = "Windows Key / Left ⌘ / Chromebook Search key";
  Input2["NumPad0"] = "numpad 0";
  Input2["NumPad1"] = "numpad 1";
  Input2["NumPad2"] = "numpad 2";
  Input2["NumPad3"] = "numpad 3";
  Input2["NumPad4"] = "numpad 4";
  Input2["NumPad5"] = "numpad 5";
  Input2["NumPad6"] = "numpad 6";
  Input2["NumPad7"] = "numpad 7";
  Input2["NumPad8"] = "numpad 8";
  Input2["NumPad9"] = "numpad 9";
  Input2["Multiply"] = "multiply";
  Input2["Add"] = "add";
  Input2["Subtract"] = "subtract";
  Input2["DecimalPoint"] = "decimal point";
  Input2["Divide"] = "divide";
  Input2["F1"] = "f1";
  Input2["F2"] = "f2";
  Input2["F3"] = "f3";
  Input2["F4"] = "f4";
  Input2["F5"] = "f5";
  Input2["F6"] = "f6";
  Input2["F7"] = "f7";
  Input2["F8"] = "f8";
  Input2["F9"] = "f9";
  Input2["F10"] = "f10";
  Input2["F11"] = "f11";
  Input2["F12"] = "f12";
  Input2["F13"] = "f13";
  Input2["F14"] = "f14";
  Input2["F15"] = "f15";
  Input2["F16"] = "f16";
  Input2["F17"] = "f17";
  Input2["F18"] = "f18";
  Input2["F19"] = "f19";
  Input2["F20"] = "f20";
  Input2["F21"] = "f21";
  Input2["F22"] = "f22";
  Input2["F23"] = "f23";
  Input2["F24"] = "f24";
  Input2["NumLock"] = "num lock";
  Input2["ScrollLock"] = "scroll lock";
  Input2["CircumflexAccent"] = "^";
  Input2["ExclamationMark"] = "!";
  Input2["Hash"] = "#";
  Input2["Dollar"] = "$";
  Input2["AccentU"] = "ù";
  Input2["PageBackward"] = "page backward";
  Input2["PageForWard"] = "page forward";
  Input2["Star"] = "*";
  Input2["DecreaseVolume"] = "decrease volume level";
  Input2["IncreaseVolume"] = "increase volume level";
  Input2["Next"] = "next";
  Input2["Previous"] = "previous";
  Input2["Stop"] = "stop";
  Input2["PlayPause"] = "play/pause";
  Input2["Email"] = "e-mail";
  Input2["SemiColon"] = "semi-colon / ñ";
  Input2["EqualSign"] = "equal sign";
  Input2["Comma"] = "comma";
  Input2["Dash"] = "dash";
  Input2["FowardSlach"] = "forward slash / ç";
  Input2["GraveAccent"] = "grave accent / ñ / æ";
  Input2["OpenBracket"] = "open bracket";
  Input2["BackSlach"] = "back slash";
  Input2["CloseBracket"] = "close bracket / å";
  Input2["SingleQuote"] = "single quote / ø";
  Input2["BackQuote"] = "`";
  Input2["Altgr"] = "altgr";
})(Input || (Input = {}));
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f3 = n2.default;
  if (typeof f3 == "function") {
    var a8 = function a9() {
      if (this instanceof a9) {
        var args = [null];
        args.push.apply(args, arguments);
        var Ctor = Function.bind.apply(f3, args);
        return new Ctor();
      }
      return f3.apply(this, arguments);
    };
    a8.prototype = f3.prototype;
  } else
    a8 = {};
  Object.defineProperty(a8, "__esModule", {
    value: true
  });
  Object.keys(n2).forEach(function(k4) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k4);
    Object.defineProperty(a8, k4, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k4];
      }
    });
  });
  return a8;
}
var SAT$1 = { exports: {} };
(function(module, exports) {
  /** @preserve SAT.js - Version 0.9.0 - Copyright 2012 - 2021 - Jim Riecken <jimr@jimr.ca> - released under the MIT License. https://github.com/jriecken/sat-js */
  (function(root2, factory2) {
    {
      module["exports"] = factory2();
    }
  })(commonjsGlobal, function() {
    var SAT2 = {};
    function Vector(x2, y2) {
      this["x"] = x2 || 0;
      this["y"] = y2 || 0;
    }
    SAT2["Vector"] = Vector;
    SAT2["V"] = Vector;
    Vector.prototype["copy"] = Vector.prototype.copy = function(other) {
      this["x"] = other["x"];
      this["y"] = other["y"];
      return this;
    };
    Vector.prototype["clone"] = Vector.prototype.clone = function() {
      return new Vector(this["x"], this["y"]);
    };
    Vector.prototype["perp"] = Vector.prototype.perp = function() {
      var x2 = this["x"];
      this["x"] = this["y"];
      this["y"] = -x2;
      return this;
    };
    Vector.prototype["rotate"] = Vector.prototype.rotate = function(angle2) {
      var x2 = this["x"];
      var y2 = this["y"];
      this["x"] = x2 * Math.cos(angle2) - y2 * Math.sin(angle2);
      this["y"] = x2 * Math.sin(angle2) + y2 * Math.cos(angle2);
      return this;
    };
    Vector.prototype["reverse"] = Vector.prototype.reverse = function() {
      this["x"] = -this["x"];
      this["y"] = -this["y"];
      return this;
    };
    Vector.prototype["normalize"] = Vector.prototype.normalize = function() {
      var d2 = this.len();
      if (d2 > 0) {
        this["x"] = this["x"] / d2;
        this["y"] = this["y"] / d2;
      }
      return this;
    };
    Vector.prototype["add"] = Vector.prototype.add = function(other) {
      this["x"] += other["x"];
      this["y"] += other["y"];
      return this;
    };
    Vector.prototype["sub"] = Vector.prototype.sub = function(other) {
      this["x"] -= other["x"];
      this["y"] -= other["y"];
      return this;
    };
    Vector.prototype["scale"] = Vector.prototype.scale = function(x2, y2) {
      this["x"] *= x2;
      this["y"] *= typeof y2 != "undefined" ? y2 : x2;
      return this;
    };
    Vector.prototype["project"] = Vector.prototype.project = function(other) {
      var amt = this.dot(other) / other.len2();
      this["x"] = amt * other["x"];
      this["y"] = amt * other["y"];
      return this;
    };
    Vector.prototype["projectN"] = Vector.prototype.projectN = function(other) {
      var amt = this.dot(other);
      this["x"] = amt * other["x"];
      this["y"] = amt * other["y"];
      return this;
    };
    Vector.prototype["reflect"] = Vector.prototype.reflect = function(axis) {
      var x2 = this["x"];
      var y2 = this["y"];
      this.project(axis).scale(2);
      this["x"] -= x2;
      this["y"] -= y2;
      return this;
    };
    Vector.prototype["reflectN"] = Vector.prototype.reflectN = function(axis) {
      var x2 = this["x"];
      var y2 = this["y"];
      this.projectN(axis).scale(2);
      this["x"] -= x2;
      this["y"] -= y2;
      return this;
    };
    Vector.prototype["dot"] = Vector.prototype.dot = function(other) {
      return this["x"] * other["x"] + this["y"] * other["y"];
    };
    Vector.prototype["len2"] = Vector.prototype.len2 = function() {
      return this.dot(this);
    };
    Vector.prototype["len"] = Vector.prototype.len = function() {
      return Math.sqrt(this.len2());
    };
    function Circle2(pos, r2) {
      this["pos"] = pos || new Vector();
      this["r"] = r2 || 0;
      this["offset"] = new Vector();
    }
    SAT2["Circle"] = Circle2;
    Circle2.prototype["getAABBAsBox"] = Circle2.prototype.getAABBAsBox = function() {
      var r2 = this["r"];
      var corner = this["pos"].clone().add(this["offset"]).sub(new Vector(r2, r2));
      return new Box(corner, r2 * 2, r2 * 2);
    };
    Circle2.prototype["getAABB"] = Circle2.prototype.getAABB = function() {
      return this.getAABBAsBox().toPolygon();
    };
    Circle2.prototype["setOffset"] = Circle2.prototype.setOffset = function(offset) {
      this["offset"] = offset;
      return this;
    };
    function Polygon2(pos, points) {
      this["pos"] = pos || new Vector();
      this["angle"] = 0;
      this["offset"] = new Vector();
      this.setPoints(points || []);
    }
    SAT2["Polygon"] = Polygon2;
    Polygon2.prototype["setPoints"] = Polygon2.prototype.setPoints = function(points) {
      var lengthChanged = !this["points"] || this["points"].length !== points.length;
      if (lengthChanged) {
        var i3;
        var calcPoints = this["calcPoints"] = [];
        var edges = this["edges"] = [];
        var normals = this["normals"] = [];
        for (i3 = 0; i3 < points.length; i3++) {
          var p1 = points[i3];
          var p2 = i3 < points.length - 1 ? points[i3 + 1] : points[0];
          if (p1 !== p2 && p1.x === p2.x && p1.y === p2.y) {
            points.splice(i3, 1);
            i3 -= 1;
            continue;
          }
          calcPoints.push(new Vector());
          edges.push(new Vector());
          normals.push(new Vector());
        }
      }
      this["points"] = points;
      this._recalc();
      return this;
    };
    Polygon2.prototype["setAngle"] = Polygon2.prototype.setAngle = function(angle2) {
      this["angle"] = angle2;
      this._recalc();
      return this;
    };
    Polygon2.prototype["setOffset"] = Polygon2.prototype.setOffset = function(offset) {
      this["offset"] = offset;
      this._recalc();
      return this;
    };
    Polygon2.prototype["rotate"] = Polygon2.prototype.rotate = function(angle2) {
      var points = this["points"];
      var len = points.length;
      for (var i3 = 0; i3 < len; i3++) {
        points[i3].rotate(angle2);
      }
      this._recalc();
      return this;
    };
    Polygon2.prototype["translate"] = Polygon2.prototype.translate = function(x2, y2) {
      var points = this["points"];
      var len = points.length;
      for (var i3 = 0; i3 < len; i3++) {
        points[i3]["x"] += x2;
        points[i3]["y"] += y2;
      }
      this._recalc();
      return this;
    };
    Polygon2.prototype._recalc = function() {
      var calcPoints = this["calcPoints"];
      var edges = this["edges"];
      var normals = this["normals"];
      var points = this["points"];
      var offset = this["offset"];
      var angle2 = this["angle"];
      var len = points.length;
      var i3;
      for (i3 = 0; i3 < len; i3++) {
        var calcPoint = calcPoints[i3].copy(points[i3]);
        calcPoint["x"] += offset["x"];
        calcPoint["y"] += offset["y"];
        if (angle2 !== 0) {
          calcPoint.rotate(angle2);
        }
      }
      for (i3 = 0; i3 < len; i3++) {
        var p1 = calcPoints[i3];
        var p2 = i3 < len - 1 ? calcPoints[i3 + 1] : calcPoints[0];
        var e3 = edges[i3].copy(p2).sub(p1);
        normals[i3].copy(e3).perp().normalize();
      }
      return this;
    };
    Polygon2.prototype["getAABBAsBox"] = Polygon2.prototype.getAABBAsBox = function() {
      var points = this["calcPoints"];
      var len = points.length;
      var xMin = points[0]["x"];
      var yMin = points[0]["y"];
      var xMax = points[0]["x"];
      var yMax = points[0]["y"];
      for (var i3 = 1; i3 < len; i3++) {
        var point = points[i3];
        if (point["x"] < xMin) {
          xMin = point["x"];
        } else if (point["x"] > xMax) {
          xMax = point["x"];
        }
        if (point["y"] < yMin) {
          yMin = point["y"];
        } else if (point["y"] > yMax) {
          yMax = point["y"];
        }
      }
      return new Box(this["pos"].clone().add(new Vector(xMin, yMin)), xMax - xMin, yMax - yMin);
    };
    Polygon2.prototype["getAABB"] = Polygon2.prototype.getAABB = function() {
      return this.getAABBAsBox().toPolygon();
    };
    Polygon2.prototype["getCentroid"] = Polygon2.prototype.getCentroid = function() {
      var points = this["calcPoints"];
      var len = points.length;
      var cx = 0;
      var cy = 0;
      var ar = 0;
      for (var i3 = 0; i3 < len; i3++) {
        var p1 = points[i3];
        var p2 = i3 === len - 1 ? points[0] : points[i3 + 1];
        var a8 = p1["x"] * p2["y"] - p2["x"] * p1["y"];
        cx += (p1["x"] + p2["x"]) * a8;
        cy += (p1["y"] + p2["y"]) * a8;
        ar += a8;
      }
      ar = ar * 3;
      cx = cx / ar;
      cy = cy / ar;
      return new Vector(cx, cy);
    };
    function Box(pos, w2, h2) {
      this["pos"] = pos || new Vector();
      this["w"] = w2 || 0;
      this["h"] = h2 || 0;
    }
    SAT2["Box"] = Box;
    Box.prototype["toPolygon"] = Box.prototype.toPolygon = function() {
      var pos = this["pos"];
      var w2 = this["w"];
      var h2 = this["h"];
      return new Polygon2(new Vector(pos["x"], pos["y"]), [
        new Vector(),
        new Vector(w2, 0),
        new Vector(w2, h2),
        new Vector(0, h2)
      ]);
    };
    function Response() {
      this["a"] = null;
      this["b"] = null;
      this["overlapN"] = new Vector();
      this["overlapV"] = new Vector();
      this.clear();
    }
    SAT2["Response"] = Response;
    Response.prototype["clear"] = Response.prototype.clear = function() {
      this["aInB"] = true;
      this["bInA"] = true;
      this["overlap"] = Number.MAX_VALUE;
      return this;
    };
    var T_VECTORS = [];
    for (var i2 = 0; i2 < 10; i2++) {
      T_VECTORS.push(new Vector());
    }
    var T_ARRAYS = [];
    for (var i2 = 0; i2 < 5; i2++) {
      T_ARRAYS.push([]);
    }
    var T_RESPONSE = new Response();
    var TEST_POINT = new Box(new Vector(), 1e-6, 1e-6).toPolygon();
    function flattenPointsOn(points, normal, result) {
      var min = Number.MAX_VALUE;
      var max = -Number.MAX_VALUE;
      var len = points.length;
      for (var i3 = 0; i3 < len; i3++) {
        var dot = points[i3].dot(normal);
        if (dot < min) {
          min = dot;
        }
        if (dot > max) {
          max = dot;
        }
      }
      result[0] = min;
      result[1] = max;
    }
    function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {
      var rangeA = T_ARRAYS.pop();
      var rangeB = T_ARRAYS.pop();
      var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);
      var projectedOffset = offsetV.dot(axis);
      flattenPointsOn(aPoints, axis, rangeA);
      flattenPointsOn(bPoints, axis, rangeB);
      rangeB[0] += projectedOffset;
      rangeB[1] += projectedOffset;
      if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {
        T_VECTORS.push(offsetV);
        T_ARRAYS.push(rangeA);
        T_ARRAYS.push(rangeB);
        return true;
      }
      if (response) {
        var overlap = 0;
        if (rangeA[0] < rangeB[0]) {
          response["aInB"] = false;
          if (rangeA[1] < rangeB[1]) {
            overlap = rangeA[1] - rangeB[0];
            response["bInA"] = false;
          } else {
            var option1 = rangeA[1] - rangeB[0];
            var option2 = rangeB[1] - rangeA[0];
            overlap = option1 < option2 ? option1 : -option2;
          }
        } else {
          response["bInA"] = false;
          if (rangeA[1] > rangeB[1]) {
            overlap = rangeA[0] - rangeB[1];
            response["aInB"] = false;
          } else {
            var option1 = rangeA[1] - rangeB[0];
            var option2 = rangeB[1] - rangeA[0];
            overlap = option1 < option2 ? option1 : -option2;
          }
        }
        var absOverlap = Math.abs(overlap);
        if (absOverlap < response["overlap"]) {
          response["overlap"] = absOverlap;
          response["overlapN"].copy(axis);
          if (overlap < 0) {
            response["overlapN"].reverse();
          }
        }
      }
      T_VECTORS.push(offsetV);
      T_ARRAYS.push(rangeA);
      T_ARRAYS.push(rangeB);
      return false;
    }
    SAT2["isSeparatingAxis"] = isSeparatingAxis;
    function voronoiRegion(line, point) {
      var len2 = line.len2();
      var dp = point.dot(line);
      if (dp < 0) {
        return LEFT_VORONOI_REGION;
      } else if (dp > len2) {
        return RIGHT_VORONOI_REGION;
      } else {
        return MIDDLE_VORONOI_REGION;
      }
    }
    var LEFT_VORONOI_REGION = -1;
    var MIDDLE_VORONOI_REGION = 0;
    var RIGHT_VORONOI_REGION = 1;
    function pointInCircle(p2, c3) {
      var differenceV = T_VECTORS.pop().copy(p2).sub(c3["pos"]).sub(c3["offset"]);
      var radiusSq = c3["r"] * c3["r"];
      var distanceSq = differenceV.len2();
      T_VECTORS.push(differenceV);
      return distanceSq <= radiusSq;
    }
    SAT2["pointInCircle"] = pointInCircle;
    function pointInPolygon(p2, poly) {
      TEST_POINT["pos"].copy(p2);
      T_RESPONSE.clear();
      var result = testPolygonPolygon(TEST_POINT, poly, T_RESPONSE);
      if (result) {
        result = T_RESPONSE["aInB"];
      }
      return result;
    }
    SAT2["pointInPolygon"] = pointInPolygon;
    function testCircleCircle(a8, b3, response) {
      var differenceV = T_VECTORS.pop().copy(b3["pos"]).add(b3["offset"]).sub(a8["pos"]).sub(a8["offset"]);
      var totalRadius = a8["r"] + b3["r"];
      var totalRadiusSq = totalRadius * totalRadius;
      var distanceSq = differenceV.len2();
      if (distanceSq > totalRadiusSq) {
        T_VECTORS.push(differenceV);
        return false;
      }
      if (response) {
        var dist = Math.sqrt(distanceSq);
        response["a"] = a8;
        response["b"] = b3;
        response["overlap"] = totalRadius - dist;
        response["overlapN"].copy(differenceV.normalize());
        response["overlapV"].copy(differenceV).scale(response["overlap"]);
        response["aInB"] = a8["r"] <= b3["r"] && dist <= b3["r"] - a8["r"];
        response["bInA"] = b3["r"] <= a8["r"] && dist <= a8["r"] - b3["r"];
      }
      T_VECTORS.push(differenceV);
      return true;
    }
    SAT2["testCircleCircle"] = testCircleCircle;
    function testPolygonCircle(polygon, circle, response) {
      var circlePos = T_VECTORS.pop().copy(circle["pos"]).add(circle["offset"]).sub(polygon["pos"]);
      var radius = circle["r"];
      var radius2 = radius * radius;
      var points = polygon["calcPoints"];
      var len = points.length;
      var edge = T_VECTORS.pop();
      var point = T_VECTORS.pop();
      for (var i3 = 0; i3 < len; i3++) {
        var next = i3 === len - 1 ? 0 : i3 + 1;
        var prev2 = i3 === 0 ? len - 1 : i3 - 1;
        var overlap = 0;
        var overlapN = null;
        edge.copy(polygon["edges"][i3]);
        point.copy(circlePos).sub(points[i3]);
        if (response && point.len2() > radius2) {
          response["aInB"] = false;
        }
        var region = voronoiRegion(edge, point);
        if (region === LEFT_VORONOI_REGION) {
          edge.copy(polygon["edges"][prev2]);
          var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev2]);
          region = voronoiRegion(edge, point2);
          if (region === RIGHT_VORONOI_REGION) {
            var dist = point.len();
            if (dist > radius) {
              T_VECTORS.push(circlePos);
              T_VECTORS.push(edge);
              T_VECTORS.push(point);
              T_VECTORS.push(point2);
              return false;
            } else if (response) {
              response["bInA"] = false;
              overlapN = point.normalize();
              overlap = radius - dist;
            }
          }
          T_VECTORS.push(point2);
        } else if (region === RIGHT_VORONOI_REGION) {
          edge.copy(polygon["edges"][next]);
          point.copy(circlePos).sub(points[next]);
          region = voronoiRegion(edge, point);
          if (region === LEFT_VORONOI_REGION) {
            var dist = point.len();
            if (dist > radius) {
              T_VECTORS.push(circlePos);
              T_VECTORS.push(edge);
              T_VECTORS.push(point);
              return false;
            } else if (response) {
              response["bInA"] = false;
              overlapN = point.normalize();
              overlap = radius - dist;
            }
          }
        } else {
          var normal = edge.perp().normalize();
          var dist = point.dot(normal);
          var distAbs = Math.abs(dist);
          if (dist > 0 && distAbs > radius) {
            T_VECTORS.push(circlePos);
            T_VECTORS.push(normal);
            T_VECTORS.push(point);
            return false;
          } else if (response) {
            overlapN = normal;
            overlap = radius - dist;
            if (dist >= 0 || overlap < 2 * radius) {
              response["bInA"] = false;
            }
          }
        }
        if (overlapN && response && Math.abs(overlap) < Math.abs(response["overlap"])) {
          response["overlap"] = overlap;
          response["overlapN"].copy(overlapN);
        }
      }
      if (response) {
        response["a"] = polygon;
        response["b"] = circle;
        response["overlapV"].copy(response["overlapN"]).scale(response["overlap"]);
      }
      T_VECTORS.push(circlePos);
      T_VECTORS.push(edge);
      T_VECTORS.push(point);
      return true;
    }
    SAT2["testPolygonCircle"] = testPolygonCircle;
    function testCirclePolygon(circle, polygon, response) {
      var result = testPolygonCircle(polygon, circle, response);
      if (result && response) {
        var a8 = response["a"];
        var aInB = response["aInB"];
        response["overlapN"].reverse();
        response["overlapV"].reverse();
        response["a"] = response["b"];
        response["b"] = a8;
        response["aInB"] = response["bInA"];
        response["bInA"] = aInB;
      }
      return result;
    }
    SAT2["testCirclePolygon"] = testCirclePolygon;
    function testPolygonPolygon(a8, b3, response) {
      var aPoints = a8["calcPoints"];
      var aLen = aPoints.length;
      var bPoints = b3["calcPoints"];
      var bLen = bPoints.length;
      for (var i3 = 0; i3 < aLen; i3++) {
        if (isSeparatingAxis(a8["pos"], b3["pos"], aPoints, bPoints, a8["normals"][i3], response)) {
          return false;
        }
      }
      for (var i3 = 0; i3 < bLen; i3++) {
        if (isSeparatingAxis(a8["pos"], b3["pos"], aPoints, bPoints, b3["normals"][i3], response)) {
          return false;
        }
      }
      if (response) {
        response["a"] = a8;
        response["b"] = b3;
        response["overlapV"].copy(response["overlapN"]).scale(response["overlap"]);
      }
      return true;
    }
    SAT2["testPolygonPolygon"] = testPolygonPolygon;
    return SAT2;
  });
})(SAT$1);
var SATExports = SAT$1.exports;
const SAT = /* @__PURE__ */ getDefaultExportFromCjs(SATExports);
class HitClass {
  createObjectHitbox(x2, y2, z2, w2, h2) {
    return new SAT.Box(new SAT.Vector(x2, y2 - z2), w2, h2);
  }
  getHitbox(obj, offset) {
    let hitbox, type;
    if (!offset)
      offset = {
        x: 0,
        y: 0
      };
    const x2 = obj.x + offset.x;
    const y2 = obj.y + offset.y;
    if ("ellipse" in obj || obj.type == HitType.Circle) {
      type = HitType.Circle;
      const radius = obj.width / 2;
      hitbox = new SAT.Circle(new SAT.Vector(x2 + radius, y2 + radius), radius);
    } else if ("polygon" in obj) {
      type = HitType.Polygon;
      hitbox = new SAT.Polygon(new SAT.Vector(x2, y2), obj.polygon.map((pos) => new SAT.Vector(+pos.x, +pos.y)));
    } else if (!("polygon" in obj) && "width" in obj && "height" in obj) {
      type = HitType.Box;
      hitbox = new SAT.Box(new SAT.Vector(x2, y2), obj.width, obj.height);
    } else {
      hitbox = new SAT.Vector(x2, y2);
      type = obj.type;
    }
    return {
      hitbox,
      type,
      name: obj.name
    };
  }
  testPolyCollision(type, hit1, hit2) {
    let collided = false;
    if (type == HitType.Box) {
      if (hit1.pos.x <= hit2.pos.x + hit2.w && hit1.pos.x + hit1.w >= hit2.pos.x && hit1.pos.y <= hit2.pos.y + hit2.h && hit1.h + hit1.pos.y >= hit2.pos.y) {
        return true;
      }
      return false;
    }
    if (isInstanceOf(hit1, SAT.Box))
      hit1 = hit1.toPolygon();
    if (isInstanceOf(hit2, SAT.Box))
      hit2 = hit2.toPolygon();
    switch (type) {
      case HitType.Circle:
        collided = SAT.testPolygonCircle(hit1, hit2);
        break;
      case HitType.Polygon:
        collided = SAT.testPolygonPolygon(hit1, hit2);
        break;
    }
    return collided;
  }
}
const Hit = new HitClass();
var TiledLayerType;
(function(TiledLayerType2) {
  TiledLayerType2["Tile"] = "tilelayer";
  TiledLayerType2["ObjectGroup"] = "objectgroup";
  TiledLayerType2["Image"] = "imagelayer";
  TiledLayerType2["Group"] = "group";
})(TiledLayerType || (TiledLayerType = {}));
const global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup$2 = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited = false;
function init$1() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code.length; i2 < len; ++i2) {
    lookup$2[i2] = code[i2];
    revLookup[code.charCodeAt(i2)] = i2;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init$1();
  }
  var i2, j2, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L2 = 0;
  for (i2 = 0, j2 = 0; i2 < l2; i2 += 4, j2 += 3) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[L2++] = tmp >> 16 & 255;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[L2++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup$2[num >> 18 & 63] + lookup$2[num >> 12 & 63] + lookup$2[num >> 6 & 63] + lookup$2[num & 63];
}
function encodeChunk(uint82, start, end) {
  var tmp;
  var output = [];
  for (var i2 = start; i2 < end; i2 += 3) {
    tmp = (uint82[i2] << 16) + (uint82[i2 + 1] << 8) + uint82[i2 + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint82) {
  if (!inited) {
    init$1();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts2 = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts2.push(encodeChunk(uint82, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup$2[tmp >> 2];
    output += lookup$2[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup$2[tmp >> 10];
    output += lookup$2[tmp >> 4 & 63];
    output += lookup$2[tmp << 2 & 63];
    output += "=";
  }
  parts2.push(output);
  return parts2.join("");
}
function read$2(buffer2, offset, isLE, mLen, nBytes) {
  var e3, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset + i2];
  i2 += d2;
  e3 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e3 = e3 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e3 & (1 << -nBits) - 1;
  e3 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  if (e3 === 0) {
    e3 = 1 - eBias;
  } else if (e3 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e3 = e3 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e3 - mLen);
}
function write$2(buffer2, value2, offset, isLE, mLen, nBytes) {
  var e3, m2, c3;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m2 = isNaN(value2) ? 1 : 0;
    e3 = eMax;
  } else {
    e3 = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c3 = Math.pow(2, -e3)) < 1) {
      e3--;
      c3 *= 2;
    }
    if (e3 + eBias >= 1) {
      value2 += rt / c3;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c3 >= 2) {
      e3++;
      c3 /= 2;
    }
    if (e3 + eBias >= eMax) {
      m2 = 0;
      e3 = eMax;
    } else if (e3 + eBias >= 1) {
      m2 = (value2 * c3 - 1) * Math.pow(2, mLen);
      e3 = e3 + eBias;
    } else {
      m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e3 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e3 = e3 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i2] = e3 & 255, i2 += d2, e3 /= 256, eLen -= 8) {
  }
  buffer2[offset + i2 - d2] |= s2 * 128;
}
var toString$4 = {}.toString;
var isArray$7 = Array.isArray || function(arr) {
  return toString$4.call(arr) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var INSPECT_MAX_BYTES = 50;
Buffer$2.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
kMaxLength();
function kMaxLength() {
  return Buffer$2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length2) {
  if (kMaxLength() < length2) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length2);
    that.__proto__ = Buffer$2.prototype;
  } else {
    if (that === null) {
      that = new Buffer$2(length2);
    }
    that.length = length2;
  }
  return that;
}
function Buffer$2(arg, encodingOrOffset, length2) {
  if (!Buffer$2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$2)) {
    return new Buffer$2(arg, encodingOrOffset, length2);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from$1(this, arg, encodingOrOffset, length2);
}
Buffer$2.poolSize = 8192;
Buffer$2._augment = function(arr) {
  arr.__proto__ = Buffer$2.prototype;
  return arr;
};
function from$1(that, value2, encodingOrOffset, length2) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value2, encodingOrOffset, length2);
  }
  if (typeof value2 === "string") {
    return fromString(that, value2, encodingOrOffset);
  }
  return fromObject(that, value2);
}
Buffer$2.from = function(value2, encodingOrOffset, length2) {
  return from$1(null, value2, encodingOrOffset, length2);
};
if (Buffer$2.TYPED_ARRAY_SUPPORT) {
  Buffer$2.prototype.__proto__ = Uint8Array.prototype;
  Buffer$2.__proto__ = Uint8Array;
}
function assertSize(size2) {
  if (typeof size2 !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size2 < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size2, fill2, encoding) {
  assertSize(size2);
  if (size2 <= 0) {
    return createBuffer(that, size2);
  }
  if (fill2 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size2).fill(fill2, encoding) : createBuffer(that, size2).fill(fill2);
  }
  return createBuffer(that, size2);
}
Buffer$2.alloc = function(size2, fill2, encoding) {
  return alloc(null, size2, fill2, encoding);
};
function allocUnsafe(that, size2) {
  assertSize(size2);
  that = createBuffer(that, size2 < 0 ? 0 : checked(size2) | 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) {
    for (var i2 = 0; i2 < size2; ++i2) {
      that[i2] = 0;
    }
  }
  return that;
}
Buffer$2.allocUnsafe = function(size2) {
  return allocUnsafe(null, size2);
};
Buffer$2.allocUnsafeSlow = function(size2) {
  return allocUnsafe(null, size2);
};
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer$2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length2 = byteLength$1(string, encoding) | 0;
  that = createBuffer(that, length2);
  var actual = that.write(string, encoding);
  if (actual !== length2) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike$1(that, array2) {
  var length2 = array2.length < 0 ? 0 : checked(array2.length) | 0;
  that = createBuffer(that, length2);
  for (var i2 = 0; i2 < length2; i2 += 1) {
    that[i2] = array2[i2] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array2, byteOffset, length2) {
  array2.byteLength;
  if (byteOffset < 0 || array2.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array2.byteLength < byteOffset + (length2 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length2 === void 0) {
    array2 = new Uint8Array(array2);
  } else if (length2 === void 0) {
    array2 = new Uint8Array(array2, byteOffset);
  } else {
    array2 = new Uint8Array(array2, byteOffset, length2);
  }
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    that = array2;
    that.__proto__ = Buffer$2.prototype;
  } else {
    that = fromArrayLike$1(that, array2);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike$1(that, obj);
    }
    if (obj.type === "Buffer" && isArray$7(obj.data)) {
      return fromArrayLike$1(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length2) {
  if (length2 >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length2 | 0;
}
Buffer$2.isBuffer = isBuffer;
function internalIsBuffer(b3) {
  return !!(b3 != null && b3._isBuffer);
}
Buffer$2.compare = function compare(a8, b3) {
  if (!internalIsBuffer(a8) || !internalIsBuffer(b3)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a8 === b3)
    return 0;
  var x2 = a8.length;
  var y2 = b3.length;
  for (var i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
    if (a8[i2] !== b3[i2]) {
      x2 = a8[i2];
      y2 = b3[i2];
      break;
    }
  }
  if (x2 < y2)
    return -1;
  if (y2 < x2)
    return 1;
  return 0;
};
Buffer$2.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer$2.concat = function concat(list, length2) {
  if (!isArray$7(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer$2.alloc(0);
  }
  var i2;
  if (length2 === void 0) {
    length2 = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      length2 += list[i2].length;
    }
  }
  var buffer2 = Buffer$2.allocUnsafe(length2);
  var pos = 0;
  for (i2 = 0; i2 < list.length; ++i2) {
    var buf = list[i2];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer2, pos);
    pos += buf.length;
  }
  return buffer2;
};
function byteLength$1(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$2.byteLength = byteLength$1;
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$2.prototype._isBuffer = true;
function swap(b3, n2, m2) {
  var i2 = b3[n2];
  b3[n2] = b3[m2];
  b3[m2] = i2;
}
Buffer$2.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 2) {
    swap(this, i2, i2 + 1);
  }
  return this;
};
Buffer$2.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 4) {
    swap(this, i2, i2 + 3);
    swap(this, i2 + 1, i2 + 2);
  }
  return this;
};
Buffer$2.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 8) {
    swap(this, i2, i2 + 7);
    swap(this, i2 + 1, i2 + 6);
    swap(this, i2 + 2, i2 + 5);
    swap(this, i2 + 3, i2 + 4);
  }
  return this;
};
Buffer$2.prototype.toString = function toString() {
  var length2 = this.length | 0;
  if (length2 === 0)
    return "";
  if (arguments.length === 0)
    return utf8Slice(this, 0, length2);
  return slowToString.apply(this, arguments);
};
Buffer$2.prototype.equals = function equals(b3) {
  if (!internalIsBuffer(b3))
    throw new TypeError("Argument must be a Buffer");
  if (this === b3)
    return true;
  return Buffer$2.compare(this, b3) === 0;
};
Buffer$2.prototype.inspect = function inspect() {
  var str2 = "";
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str2 = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
    if (this.length > max)
      str2 += " ... ";
  }
  return "<Buffer " + str2 + ">";
};
Buffer$2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start === void 0) {
    start = 0;
  }
  if (end === void 0) {
    end = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target)
    return 0;
  var x2 = thisEnd - thisStart;
  var y2 = end - start;
  var len = Math.min(x2, y2);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i2 = 0; i2 < len; ++i2) {
    if (thisCopy[i2] !== targetCopy[i2]) {
      x2 = thisCopy[i2];
      y2 = targetCopy[i2];
      break;
    }
  }
  if (x2 < y2)
    return -1;
  if (y2 < x2)
    return 1;
  return 0;
};
function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
  if (buffer2.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer2.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer2.length + byteOffset;
  if (byteOffset >= buffer2.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer2.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer$2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer$2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i3) {
    if (indexSize === 1) {
      return buf[i3];
    } else {
      return buf.readUInt16BE(i3 * indexSize);
    }
  }
  var i2;
  if (dir) {
    var foundIndex = -1;
    for (i2 = byteOffset; i2 < arrLength; i2++) {
      if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i2;
        if (i2 - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i2 -= i2 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i2 = byteOffset; i2 >= 0; i2--) {
      var found = true;
      for (var j2 = 0; j2 < valLength; j2++) {
        if (read2(arr, i2 + j2) !== read2(val, j2)) {
          found = false;
          break;
        }
      }
      if (found)
        return i2;
    }
  }
  return -1;
}
Buffer$2.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer$2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer$2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length2) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length2) {
    length2 = remaining;
  } else {
    length2 = Number(length2);
    if (length2 > remaining) {
      length2 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length2 > strLen / 2) {
    length2 = strLen / 2;
  }
  for (var i2 = 0; i2 < length2; ++i2) {
    var parsed = parseInt(string.substr(i2 * 2, 2), 16);
    if (isNaN(parsed))
      return i2;
    buf[offset + i2] = parsed;
  }
  return i2;
}
function utf8Write(buf, string, offset, length2) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length2);
}
function asciiWrite(buf, string, offset, length2) {
  return blitBuffer(asciiToBytes(string), buf, offset, length2);
}
function latin1Write(buf, string, offset, length2) {
  return asciiWrite(buf, string, offset, length2);
}
function base64Write(buf, string, offset, length2) {
  return blitBuffer(base64ToBytes(string), buf, offset, length2);
}
function ucs2Write(buf, string, offset, length2) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length2);
}
Buffer$2.prototype.write = function write(string, offset, length2, encoding) {
  if (offset === void 0) {
    encoding = "utf8";
    length2 = this.length;
    offset = 0;
  } else if (length2 === void 0 && typeof offset === "string") {
    encoding = offset;
    length2 = this.length;
    offset = 0;
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length2)) {
      length2 = length2 | 0;
      if (encoding === void 0)
        encoding = "utf8";
    } else {
      encoding = length2;
      length2 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset;
  if (length2 === void 0 || length2 > remaining)
    length2 = remaining;
  if (string.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding)
    encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite(this, string, offset, length2);
      case "utf8":
      case "utf-8":
        return utf8Write(this, string, offset, length2);
      case "ascii":
        return asciiWrite(this, string, offset, length2);
      case "latin1":
      case "binary":
        return latin1Write(this, string, offset, length2);
      case "base64":
        return base64Write(this, string, offset, length2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, string, offset, length2);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer$2.prototype.toJSON = function toJSON() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i2 = start;
  while (i2 < end) {
    var firstByte = buf[i2];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i2 + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i2 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          fourthByte = buf[i2 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i2 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i2 = 0;
  while (i2 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i2 = start; i2 < end; ++i2) {
    ret += String.fromCharCode(buf[i2] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i2 = start; i2 < end; ++i2) {
    ret += String.fromCharCode(buf[i2]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i2 = start; i2 < end; ++i2) {
    out += toHex(buf[i2]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i2 = 0; i2 < bytes.length; i2 += 2) {
    res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
  }
  return res;
}
Buffer$2.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0)
      end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start)
    end = start;
  var newBuf;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$2.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$2(sliceLen, void 0);
    for (var i2 = 0; i2 < sliceLen; ++i2) {
      newBuf[i2] = this[i2 + start];
    }
  }
  return newBuf;
};
function checkOffset(offset, ext2, length2) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext2 > length2)
    throw new RangeError("Trying to access beyond buffer length");
}
Buffer$2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var val = this[offset];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength2 && (mul *= 256)) {
    val += this[offset + i2] * mul;
  }
  return val;
};
Buffer$2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength2, this.length);
  }
  var val = this[offset + --byteLength2];
  var mul = 1;
  while (byteLength2 > 0 && (mul *= 256)) {
    val += this[offset + --byteLength2] * mul;
  }
  return val;
};
Buffer$2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer$2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer$2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer$2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer$2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer$2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var val = this[offset];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength2 && (mul *= 256)) {
    val += this[offset + i2] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer$2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var i2 = byteLength2;
  var mul = 1;
  var val = this[offset + --i2];
  while (i2 > 0 && (mul *= 256)) {
    val += this[offset + --i2] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer$2.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  if (!(this[offset] & 128))
    return this[offset];
  return (255 - this[offset] + 1) * -1;
};
Buffer$2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer$2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer$2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read$2(this, offset, true, 23, 4);
};
Buffer$2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read$2(this, offset, false, 23, 4);
};
Buffer$2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read$2(this, offset, true, 52, 8);
};
Buffer$2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read$2(this, offset, false, 52, 8);
};
function checkInt(buf, value2, offset, ext2, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max || value2 < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext2 > buf.length)
    throw new RangeError("Index out of range");
}
Buffer$2.prototype.writeUIntLE = function writeUIntLE(value2, offset, byteLength2, noAssert) {
  value2 = +value2;
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value2, offset, byteLength2, maxBytes, 0);
  }
  var mul = 1;
  var i2 = 0;
  this[offset] = value2 & 255;
  while (++i2 < byteLength2 && (mul *= 256)) {
    this[offset + i2] = value2 / mul & 255;
  }
  return offset + byteLength2;
};
Buffer$2.prototype.writeUIntBE = function writeUIntBE(value2, offset, byteLength2, noAssert) {
  value2 = +value2;
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value2, offset, byteLength2, maxBytes, 0);
  }
  var i2 = byteLength2 - 1;
  var mul = 1;
  this[offset + i2] = value2 & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    this[offset + i2] = value2 / mul & 255;
  }
  return offset + byteLength2;
};
Buffer$2.prototype.writeUInt8 = function writeUInt8(value2, offset, noAssert) {
  value2 = +value2;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value2, offset, 1, 255, 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT)
    value2 = Math.floor(value2);
  this[offset] = value2 & 255;
  return offset + 1;
};
function objectWriteUInt16(buf, value2, offset, littleEndian) {
  if (value2 < 0)
    value2 = 65535 + value2 + 1;
  for (var i2 = 0, j2 = Math.min(buf.length - offset, 2); i2 < j2; ++i2) {
    buf[offset + i2] = (value2 & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
  }
}
Buffer$2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset, noAssert) {
  value2 = +value2;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value2, offset, 2, 65535, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16(this, value2, offset, true);
  }
  return offset + 2;
};
Buffer$2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset, noAssert) {
  value2 = +value2;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value2, offset, 2, 65535, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value2 >>> 8;
    this[offset + 1] = value2 & 255;
  } else {
    objectWriteUInt16(this, value2, offset, false);
  }
  return offset + 2;
};
function objectWriteUInt32(buf, value2, offset, littleEndian) {
  if (value2 < 0)
    value2 = 4294967295 + value2 + 1;
  for (var i2 = 0, j2 = Math.min(buf.length - offset, 4); i2 < j2; ++i2) {
    buf[offset + i2] = value2 >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
  }
}
Buffer$2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset, noAssert) {
  value2 = +value2;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value2, offset, 4, 4294967295, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value2 >>> 24;
    this[offset + 2] = value2 >>> 16;
    this[offset + 1] = value2 >>> 8;
    this[offset] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset, true);
  }
  return offset + 4;
};
Buffer$2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset, noAssert) {
  value2 = +value2;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value2, offset, 4, 4294967295, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value2 >>> 24;
    this[offset + 1] = value2 >>> 16;
    this[offset + 2] = value2 >>> 8;
    this[offset + 3] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset, false);
  }
  return offset + 4;
};
Buffer$2.prototype.writeIntLE = function writeIntLE(value2, offset, byteLength2, noAssert) {
  value2 = +value2;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
  }
  var i2 = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value2 & 255;
  while (++i2 < byteLength2 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
      sub = 1;
    }
    this[offset + i2] = (value2 / mul >> 0) - sub & 255;
  }
  return offset + byteLength2;
};
Buffer$2.prototype.writeIntBE = function writeIntBE(value2, offset, byteLength2, noAssert) {
  value2 = +value2;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
  }
  var i2 = byteLength2 - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i2] = value2 & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
      sub = 1;
    }
    this[offset + i2] = (value2 / mul >> 0) - sub & 255;
  }
  return offset + byteLength2;
};
Buffer$2.prototype.writeInt8 = function writeInt8(value2, offset, noAssert) {
  value2 = +value2;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value2, offset, 1, 127, -128);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT)
    value2 = Math.floor(value2);
  if (value2 < 0)
    value2 = 255 + value2 + 1;
  this[offset] = value2 & 255;
  return offset + 1;
};
Buffer$2.prototype.writeInt16LE = function writeInt16LE(value2, offset, noAssert) {
  value2 = +value2;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value2, offset, 2, 32767, -32768);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16(this, value2, offset, true);
  }
  return offset + 2;
};
Buffer$2.prototype.writeInt16BE = function writeInt16BE(value2, offset, noAssert) {
  value2 = +value2;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value2, offset, 2, 32767, -32768);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value2 >>> 8;
    this[offset + 1] = value2 & 255;
  } else {
    objectWriteUInt16(this, value2, offset, false);
  }
  return offset + 2;
};
Buffer$2.prototype.writeInt32LE = function writeInt32LE(value2, offset, noAssert) {
  value2 = +value2;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value2, offset, 4, 2147483647, -2147483648);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
    this[offset + 2] = value2 >>> 16;
    this[offset + 3] = value2 >>> 24;
  } else {
    objectWriteUInt32(this, value2, offset, true);
  }
  return offset + 4;
};
Buffer$2.prototype.writeInt32BE = function writeInt32BE(value2, offset, noAssert) {
  value2 = +value2;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value2, offset, 4, 2147483647, -2147483648);
  if (value2 < 0)
    value2 = 4294967295 + value2 + 1;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value2 >>> 24;
    this[offset + 1] = value2 >>> 16;
    this[offset + 2] = value2 >>> 8;
    this[offset + 3] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset, false);
  }
  return offset + 4;
};
function checkIEEE754(buf, value2, offset, ext2, max, min) {
  if (offset + ext2 > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value2, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value2, offset, 4);
  }
  write$2(buf, value2, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer$2.prototype.writeFloatLE = function writeFloatLE(value2, offset, noAssert) {
  return writeFloat(this, value2, offset, true, noAssert);
};
Buffer$2.prototype.writeFloatBE = function writeFloatBE(value2, offset, noAssert) {
  return writeFloat(this, value2, offset, false, noAssert);
};
function writeDouble(buf, value2, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value2, offset, 8);
  }
  write$2(buf, value2, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer$2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset, noAssert) {
  return writeDouble(this, value2, offset, true, noAssert);
};
Buffer$2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset, noAssert) {
  return writeDouble(this, value2, offset, false, noAssert);
};
Buffer$2.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start)
    start = 0;
  if (!end && end !== 0)
    end = this.length;
  if (targetStart >= target.length)
    targetStart = target.length;
  if (!targetStart)
    targetStart = 0;
  if (end > 0 && end < start)
    end = start;
  if (end === start)
    return 0;
  if (target.length === 0 || this.length === 0)
    return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start < 0 || start >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (end < 0)
    throw new RangeError("sourceEnd out of bounds");
  if (end > this.length)
    end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  var i2;
  if (this === target && start < targetStart && targetStart < end) {
    for (i2 = len - 1; i2 >= 0; --i2) {
      target[i2 + targetStart] = this[i2 + start];
    }
  } else if (len < 1e3 || !Buffer$2.TYPED_ARRAY_SUPPORT) {
    for (i2 = 0; i2 < len; ++i2) {
      target[i2 + targetStart] = this[i2 + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }
  return len;
};
Buffer$2.prototype.fill = function fill(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer$2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val)
    val = 0;
  var i2;
  if (typeof val === "number") {
    for (i2 = start; i2 < end; ++i2) {
      this[i2] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer$2(val, encoding).toString());
    var len = bytes.length;
    for (i2 = 0; i2 < end - start; ++i2) {
      this[i2 + start] = bytes[i2 % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str2) {
  str2 = stringtrim(str2).replace(INVALID_BASE64_RE, "");
  if (str2.length < 2)
    return "";
  while (str2.length % 4 !== 0) {
    str2 = str2 + "=";
  }
  return str2;
}
function stringtrim(str2) {
  if (str2.trim)
    return str2.trim();
  return str2.replace(/^\s+|\s+$/g, "");
}
function toHex(n2) {
  if (n2 < 16)
    return "0" + n2.toString(16);
  return n2.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length2 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i2 = 0; i2 < length2; ++i2) {
    codePoint = string.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length2) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str2) {
  var byteArray = [];
  for (var i2 = 0; i2 < str2.length; ++i2) {
    byteArray.push(str2.charCodeAt(i2) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str2, units) {
  var c3, hi, lo;
  var byteArray = [];
  for (var i2 = 0; i2 < str2.length; ++i2) {
    if ((units -= 2) < 0)
      break;
    c3 = str2.charCodeAt(i2);
    hi = c3 >> 8;
    lo = c3 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str2) {
  return toByteArray(base64clean(str2));
}
function blitBuffer(src, dst, offset, length2) {
  for (var i2 = 0; i2 < length2; ++i2) {
    if (i2 + offset >= dst.length || i2 >= src.length)
      break;
    dst[i2 + offset] = src[i2];
  }
  return i2;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var sax = {};
var domain;
function EventHandlers() {
}
EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
function EventEmitter$2() {
  EventEmitter$2.init.call(this);
}
EventEmitter$2.EventEmitter = EventEmitter$2;
EventEmitter$2.usingDomains = false;
EventEmitter$2.prototype.domain = void 0;
EventEmitter$2.prototype._events = void 0;
EventEmitter$2.prototype._maxListeners = void 0;
EventEmitter$2.defaultMaxListeners = 10;
EventEmitter$2.init = function() {
  this.domain = null;
  if (EventEmitter$2.usingDomains) {
    if (domain.active)
      ;
  }
  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$2.prototype.setMaxListeners = function setMaxListeners(n2) {
  if (typeof n2 !== "number" || n2 < 0 || isNaN(n2))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n2;
  return this;
};
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter$2.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter$2.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners2[i2].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners2[i2].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners2[i2].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners2[i2].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners2[i2].apply(self2, args);
  }
}
EventEmitter$2.prototype.emit = function emit(type) {
  var er, handler, len, args, i2, events2, domain2;
  var doError = type === "error";
  events2 = this._events;
  if (events2)
    doError = doError && events2.error == null;
  else if (!doError)
    return false;
  domain2 = this.domain;
  if (doError) {
    er = arguments[1];
    if (domain2) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain2;
      er.domainThrown = false;
      domain2.emit("error", er);
    } else if (er instanceof Error) {
      throw er;
    } else {
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
      err.context = er;
      throw err;
    }
    return false;
  }
  handler = events2[type];
  if (!handler)
    return false;
  var isFn = typeof handler === "function";
  len = arguments.length;
  switch (len) {
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    default:
      args = new Array(len - 1);
      for (i2 = 1; i2 < len; i2++)
        args[i2 - 1] = arguments[i2];
      emitMany(handler, isFn, this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m2;
  var events2;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = target._events;
  if (!events2) {
    events2 = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events2.newListener) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (!existing) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m2 = $getMaxListeners(target);
      if (m2 && m2 > 0 && existing.length > m2) {
        existing.warned = true;
        var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w2.name = "MaxListenersExceededWarning";
        w2.emitter = target;
        w2.type = type;
        w2.count = existing.length;
        emitWarning(w2);
      }
    }
  }
  return target;
}
function emitWarning(e3) {
  typeof console.warn === "function" ? console.warn(e3) : console.log(e3);
}
EventEmitter$2.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter$2.prototype.on = EventEmitter$2.prototype.addListener;
EventEmitter$2.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function _onceWrap(target, type, listener) {
  var fired = false;
  function g2() {
    target.removeListener(type, g2);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g2.listener = listener;
  return g2;
}
EventEmitter$2.prototype.once = function once(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$2.prototype.removeListener = function removeListener(type, listener) {
  var list, events2, position, i2, originalListener;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = this._events;
  if (!events2)
    return this;
  list = events2[type];
  if (!list)
    return this;
  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers();
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i2 = list.length; i2-- > 0; ) {
      if (list[i2] === listener || list[i2].listener && list[i2].listener === listener) {
        originalListener = list[i2].listener;
        position = i2;
        break;
      }
    }
    if (position < 0)
      return this;
    if (list.length === 1) {
      list[0] = void 0;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events2[type];
      }
    } else {
      spliceOne(list, position);
    }
    if (events2.removeListener)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter$2.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events2;
  events2 = this._events;
  if (!events2)
    return this;
  if (!events2.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events2[type]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    for (var i2 = 0, key; i2 < keys2.length; ++i2) {
      key = keys2[i2];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2) {
    do {
      this.removeListener(type, listeners2[listeners2.length - 1]);
    } while (listeners2[0]);
  }
  return this;
};
EventEmitter$2.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events2 = this._events;
  if (!events2)
    ret = [];
  else {
    evlistener = events2[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === "function")
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }
  return ret;
};
EventEmitter$2.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount$1.call(emitter, type);
  }
};
EventEmitter$2.prototype.listenerCount = listenerCount$1;
function listenerCount$1(type) {
  var events2 = this._events;
  if (events2) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter$2.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function spliceOne(list, index2) {
  for (var i2 = index2, k4 = i2 + 1, n2 = list.length; k4 < n2; i2 += 1, k4 += 1)
    list[i2] = list[k4];
  list.pop();
}
function arrayClone(arr, i2) {
  var copy3 = new Array(i2);
  while (i2--)
    copy3[i2] = arr[i2];
  return copy3;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr[i2].listener || arr[i2];
  }
  return ret;
}
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === "function") {
  cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === "function") {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e3) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e4) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e3) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e4) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue$1 = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue$1 = currentQueue.concat(queue$1);
  } else {
    queueIndex = -1;
  }
  if (queue$1.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue$1.length;
  while (len) {
    currentQueue = queue$1;
    queue$1 = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue$1.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick$2(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
  }
  queue$1.push(new Item(fun, args));
  if (queue$1.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array2) {
  this.fun = fun;
  this.array = array2;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title = "browser";
var platform = "browser";
var browser$1 = true;
var env = {};
var argv = [];
var version$1 = "";
var versions = {};
var release = {};
var config$1 = {};
function noop$1() {
}
var on$1 = noop$1;
var addListener2 = noop$1;
var once2 = noop$1;
var off = noop$1;
var removeListener2 = noop$1;
var removeAllListeners2 = noop$1;
var emit$1 = noop$1;
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var performance$1 = global$1.performance || {};
var performanceNow = performance$1.now || performance$1.mozNow || performance$1.msNow || performance$1.oNow || performance$1.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance$1) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime = /* @__PURE__ */ new Date();
function uptime() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var browser$1$1 = {
  nextTick: nextTick$2,
  title,
  browser: browser$1,
  env,
  argv,
  version: version$1,
  versions,
  on: on$1,
  addListener: addListener2,
  once: once2,
  off,
  removeListener: removeListener2,
  removeAllListeners: removeAllListeners2,
  emit: emit$1,
  binding,
  cwd,
  chdir,
  umask,
  hrtime,
  platform,
  release,
  config: config$1,
  uptime
};
var inherits;
if (typeof Object.create === "function") {
  inherits = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
const inherits$1 = inherits;
var formatRegExp = /%[sdj%]/g;
function format$1(f3) {
  if (!isString$2(f3)) {
    var objects = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      objects.push(inspect2(arguments[i2]));
    }
    return objects.join(" ");
  }
  var i2 = 1;
  var args = arguments;
  var len = args.length;
  var str2 = String(f3).replace(formatRegExp, function(x3) {
    if (x3 === "%%")
      return "%";
    if (i2 >= len)
      return x3;
    switch (x3) {
      case "%s":
        return String(args[i2++]);
      case "%d":
        return Number(args[i2++]);
      case "%j":
        try {
          return JSON.stringify(args[i2++]);
        } catch (_2) {
          return "[Circular]";
        }
      default:
        return x3;
    }
  });
  for (var x2 = args[i2]; i2 < len; x2 = args[++i2]) {
    if (isNull(x2) || !isObject$3(x2)) {
      str2 += " " + x2;
    } else {
      str2 += " " + inspect2(x2);
    }
  }
  return str2;
}
function deprecate(fn, msg) {
  if (isUndefined(global$1.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (browser$1$1.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (browser$1$1.throwDeprecation) {
        throw new Error(msg);
      } else if (browser$1$1.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
var debugs = {};
var debugEnviron;
function debuglog(set2) {
  if (isUndefined(debugEnviron))
    debugEnviron = {}.NODE_DEBUG || "";
  set2 = set2.toUpperCase();
  if (!debugs[set2]) {
    if (new RegExp("\\b" + set2 + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set2] = function() {
        var msg = format$1.apply(null, arguments);
        console.error("%s %d: %s", set2, pid, msg);
      };
    } else {
      debugs[set2] = function() {
      };
    }
  }
  return debugs[set2];
}
function inspect2(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined(ctx.depth))
    ctx.depth = 2;
  if (isUndefined(ctx.colors))
    ctx.colors = false;
  if (isUndefined(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
inspect2.colors = {
  "bold": [1, 22],
  "italic": [3, 23],
  "underline": [4, 24],
  "inverse": [7, 27],
  "white": [37, 39],
  "grey": [90, 39],
  "black": [30, 39],
  "blue": [34, 39],
  "cyan": [36, 39],
  "green": [32, 39],
  "magenta": [35, 39],
  "red": [31, 39],
  "yellow": [33, 39]
};
inspect2.styles = {
  "special": "cyan",
  "number": "yellow",
  "boolean": "yellow",
  "undefined": "grey",
  "null": "bold",
  "string": "green",
  "date": "magenta",
  // "name": intentionally not styling
  "regexp": "red"
};
function stylizeWithColor(str2, styleType) {
  var style = inspect2.styles[styleType];
  if (style) {
    return "\x1B[" + inspect2.colors[style][0] + "m" + str2 + "\x1B[" + inspect2.colors[style][1] + "m";
  } else {
    return str2;
  }
}
function stylizeNoColor(str2, styleType) {
  return str2;
}
function arrayToHash(array2) {
  var hash = {};
  array2.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value2, recurseTimes) {
  if (ctx.customInspect && value2 && isFunction$4(value2.inspect) && // Filter out the util module, it's inspect function is special
  value2.inspect !== inspect2 && // Also filter out any prototype objects using the circular check.
  !(value2.constructor && value2.constructor.prototype === value2)) {
    var ret = value2.inspect(recurseTimes, ctx);
    if (!isString$2(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value2);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value2);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value2);
  }
  if (isError(value2) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value2);
  }
  if (keys2.length === 0) {
    if (isFunction$4(value2)) {
      var name = value2.name ? ": " + value2.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    }
    if (isDate(value2)) {
      return ctx.stylize(Date.prototype.toString.call(value2), "date");
    }
    if (isError(value2)) {
      return formatError(value2);
    }
  }
  var base2 = "", array2 = false, braces = ["{", "}"];
  if (isArray$6(value2)) {
    array2 = true;
    braces = ["[", "]"];
  }
  if (isFunction$4(value2)) {
    var n2 = value2.name ? ": " + value2.name : "";
    base2 = " [Function" + n2 + "]";
  }
  if (isRegExp(value2)) {
    base2 = " " + RegExp.prototype.toString.call(value2);
  }
  if (isDate(value2)) {
    base2 = " " + Date.prototype.toUTCString.call(value2);
  }
  if (isError(value2)) {
    base2 = " " + formatError(value2);
  }
  if (keys2.length === 0 && (!array2 || value2.length == 0)) {
    return braces[0] + base2 + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value2);
  var output;
  if (array2) {
    output = formatArray(ctx, value2, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array2);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base2, braces);
}
function formatPrimitive(ctx, value2) {
  if (isUndefined(value2))
    return ctx.stylize("undefined", "undefined");
  if (isString$2(value2)) {
    var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value2))
    return ctx.stylize("" + value2, "number");
  if (isBoolean(value2))
    return ctx.stylize("" + value2, "boolean");
  if (isNull(value2))
    return ctx.stylize("null", "null");
}
function formatError(value2) {
  return "[" + Error.prototype.toString.call(value2) + "]";
}
function formatArray(ctx, value2, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i2 = 0, l2 = value2.length; i2 < l2; ++i2) {
    if (hasOwnProperty$4(value2, String(i2))) {
      output.push(formatProperty(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        String(i2),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
function formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array2) {
  var name, str2, desc;
  desc = Object.getOwnPropertyDescriptor(value2, key) || { value: value2[key] };
  if (desc.get) {
    if (desc.set) {
      str2 = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str2 = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str2 = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty$4(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str2) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str2 = formatValue(ctx, desc.value, null);
      } else {
        str2 = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str2.indexOf("\n") > -1) {
        if (array2) {
          str2 = str2.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str2 = "\n" + str2.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str2 = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array2 && key.match(/^\d+$/)) {
      return str2;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str2;
}
function reduceToSingleString(output, base2, braces) {
  var length2 = output.reduce(function(prev2, cur) {
    if (cur.indexOf("\n") >= 0)
      ;
    return prev2 + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length2 > 60) {
    return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
}
function isArray$6(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString$2(arg) {
  return typeof arg === "string";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re2) {
  return isObject$3(re2) && objectToString$2(re2) === "[object RegExp]";
}
function isObject$3(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d2) {
  return isObject$3(d2) && objectToString$2(d2) === "[object Date]";
}
function isError(e3) {
  return isObject$3(e3) && (objectToString$2(e3) === "[object Error]" || e3 instanceof Error);
}
function isFunction$4(arg) {
  return typeof arg === "function";
}
function objectToString$2(o2) {
  return Object.prototype.toString.call(o2);
}
function _extend(origin, add2) {
  if (!add2 || !isObject$3(add2))
    return origin;
  var keys2 = Object.keys(add2);
  var i2 = keys2.length;
  while (i2--) {
    origin[keys2[i2]] = add2[keys2[i2]];
  }
  return origin;
}
function hasOwnProperty$4(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
BufferList.prototype.push = function(v2) {
  var entry = { data: v2, next: null };
  if (this.length > 0)
    this.tail.next = entry;
  else
    this.head = entry;
  this.tail = entry;
  ++this.length;
};
BufferList.prototype.unshift = function(v2) {
  var entry = { data: v2, next: this.head };
  if (this.length === 0)
    this.tail = entry;
  this.head = entry;
  ++this.length;
};
BufferList.prototype.shift = function() {
  if (this.length === 0)
    return;
  var ret = this.head.data;
  if (this.length === 1)
    this.head = this.tail = null;
  else
    this.head = this.head.next;
  --this.length;
  return ret;
};
BufferList.prototype.clear = function() {
  this.head = this.tail = null;
  this.length = 0;
};
BufferList.prototype.join = function(s2) {
  if (this.length === 0)
    return "";
  var p2 = this.head;
  var ret = "" + p2.data;
  while (p2 = p2.next) {
    ret += s2 + p2.data;
  }
  return ret;
};
BufferList.prototype.concat = function(n2) {
  if (this.length === 0)
    return Buffer$2.alloc(0);
  if (this.length === 1)
    return this.head.data;
  var ret = Buffer$2.allocUnsafe(n2 >>> 0);
  var p2 = this.head;
  var i2 = 0;
  while (p2) {
    p2.data.copy(ret, i2);
    i2 += p2.data.length;
    p2 = p2.next;
  }
  return ret;
};
var isBufferEncoding = Buffer$2.isEncoding || function(encoding) {
  switch (encoding && encoding.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer$2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
StringDecoder.prototype.write = function(buffer2) {
  var charStr = "";
  while (this.charLength) {
    var available = buffer2.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer2.length;
    buffer2.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;
    if (this.charReceived < this.charLength) {
      return "";
    }
    buffer2 = buffer2.slice(available, buffer2.length);
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 55296 && charCode <= 56319) {
      this.charLength += this.surrogateSize;
      charStr = "";
      continue;
    }
    this.charReceived = this.charLength = 0;
    if (buffer2.length === 0) {
      return charStr;
    }
    break;
  }
  this.detectIncompleteChar(buffer2);
  var end = buffer2.length;
  if (this.charLength) {
    buffer2.copy(this.charBuffer, 0, buffer2.length - this.charReceived, end);
    end -= this.charReceived;
  }
  charStr += buffer2.toString(this.encoding, 0, end);
  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  if (charCode >= 55296 && charCode <= 56319) {
    var size2 = this.surrogateSize;
    this.charLength += size2;
    this.charReceived += size2;
    this.charBuffer.copy(this.charBuffer, size2, 0, size2);
    buffer2.copy(this.charBuffer, 0, 0, size2);
    return charStr.substring(0, end);
  }
  return charStr;
};
StringDecoder.prototype.detectIncompleteChar = function(buffer2) {
  var i2 = buffer2.length >= 3 ? 3 : buffer2.length;
  for (; i2 > 0; i2--) {
    var c3 = buffer2[buffer2.length - i2];
    if (i2 == 1 && c3 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (i2 <= 2 && c3 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (i2 <= 3 && c3 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i2;
};
StringDecoder.prototype.end = function(buffer2) {
  var res = "";
  if (buffer2 && buffer2.length)
    res = this.write(buffer2);
  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }
  return res;
};
function passThroughWrite(buffer2) {
  return buffer2.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer2) {
  this.charReceived = buffer2.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer2) {
  this.charReceived = buffer2.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
const stringDecoder = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  StringDecoder
}, Symbol.toStringTag, { value: "Module" }));
Readable.ReadableState = ReadableState;
var debug = debuglog("stream");
inherits$1(Readable, EventEmitter$2);
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options, stream2) {
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream2 instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);
  this._readableState = new ReadableState(options, this);
  this.readable = true;
  if (options && typeof options.read === "function")
    this._read = options.read;
  EventEmitter$2.call(this);
}
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;
  if (!state.objectMode && typeof chunk === "string") {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = Buffer$2.from(chunk, encoding);
      encoding = "";
    }
  }
  return readableAddChunk(this, state, chunk, encoding, false);
};
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, "", true);
};
Readable.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};
function readableAddChunk(stream2, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream2.emit("error", er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream2, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e3 = new Error("stream.push() after EOF");
      stream2.emit("error", e3);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream2.emit("error", _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront)
        state.reading = false;
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream2.emit("data", chunk);
          stream2.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream2);
        }
      }
      maybeReadMore(stream2, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
Readable.prototype.setEncoding = function(enc) {
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};
var MAX_HWM = 8388608;
function computeNewHighWaterMark(n2) {
  if (n2 >= MAX_HWM) {
    n2 = MAX_HWM;
  } else {
    n2--;
    n2 |= n2 >>> 1;
    n2 |= n2 >>> 2;
    n2 |= n2 >>> 4;
    n2 |= n2 >>> 8;
    n2 |= n2 >>> 16;
    n2++;
  }
  return n2;
}
function howMuchToRead(n2, state) {
  if (n2 <= 0 || state.length === 0 && state.ended)
    return 0;
  if (state.objectMode)
    return 1;
  if (n2 !== n2) {
    if (state.flowing && state.length)
      return state.buffer.head.data.length;
    else
      return state.length;
  }
  if (n2 > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n2);
  if (n2 <= state.length)
    return n2;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}
Readable.prototype.read = function(n2) {
  debug("read", n2);
  n2 = parseInt(n2, 10);
  var state = this._readableState;
  var nOrig = n2;
  if (n2 !== 0)
    state.emittedReadable = false;
  if (n2 === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug("read: emitReadable", state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }
  n2 = howMuchToRead(n2, state);
  if (n2 === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }
  var doRead = state.needReadable;
  debug("need readable", doRead);
  if (state.length === 0 || state.length - n2 < state.highWaterMark) {
    doRead = true;
    debug("length less than watermark", doRead);
  }
  if (state.ended || state.reading) {
    doRead = false;
    debug("reading or ended", doRead);
  } else if (doRead) {
    debug("do read");
    state.reading = true;
    state.sync = true;
    if (state.length === 0)
      state.needReadable = true;
    this._read(state.highWaterMark);
    state.sync = false;
    if (!state.reading)
      n2 = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n2 > 0)
    ret = fromList(n2, state);
  else
    ret = null;
  if (ret === null) {
    state.needReadable = true;
    n2 = 0;
  } else {
    state.length -= n2;
  }
  if (state.length === 0) {
    if (!state.ended)
      state.needReadable = true;
    if (nOrig !== n2 && state.ended)
      endReadable(this);
  }
  if (ret !== null)
    this.emit("data", ret);
  return ret;
};
function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer$2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream2, state) {
  if (state.ended)
    return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  emitReadable(stream2);
}
function emitReadable(stream2) {
  var state = stream2._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      nextTick$2(emitReadable_, stream2);
    else
      emitReadable_(stream2);
  }
}
function emitReadable_(stream2) {
  debug("emit readable");
  stream2.emit("readable");
  flow(stream2);
}
function maybeReadMore(stream2, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick$2(maybeReadMore_, stream2, state);
  }
}
function maybeReadMore_(stream2, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0");
    stream2.read(0);
    if (len === state.length)
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}
Readable.prototype._read = function(n2) {
  this.emit("error", new Error("not implemented"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
  var doEnd = !pipeOpts || pipeOpts.end !== false;
  var endFn = doEnd ? onend2 : cleanup;
  if (state.endEmitted)
    nextTick$2(endFn);
  else
    src.once("end", endFn);
  dest.on("unpipe", onunpipe);
  function onunpipe(readable) {
    debug("onunpipe");
    if (readable === src) {
      cleanup();
    }
  }
  function onend2() {
    debug("onend");
    dest.end();
  }
  var ondrain = pipeOnDrain(src);
  dest.on("drain", ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    dest.removeListener("drain", ondrain);
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src.removeListener("end", onend2);
    src.removeListener("end", cleanup);
    src.removeListener("data", ondata);
    cleanedUp = true;
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }
  var increasedAwaitDrain = false;
  src.on("data", ondata);
  function ondata(chunk) {
    debug("ondata");
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp) {
        debug("false write response, pause", src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }
  function onerror(er) {
    debug("onerror", er);
    unpipe();
    dest.removeListener("error", onerror);
    if (listenerCount(dest, "error") === 0)
      dest.emit("error", er);
  }
  prependListener2(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug("unpipe");
    src.unpipe(dest);
  }
  dest.emit("pipe", src);
  if (!state.flowing) {
    debug("pipe resume");
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners("data").length) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;
  if (state.pipesCount === 0)
    return this;
  if (state.pipesCount === 1) {
    if (dest && dest !== state.pipes)
      return this;
    if (!dest)
      dest = state.pipes;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit("unpipe", this);
    return this;
  }
  if (!dest) {
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit("unpipe", this);
    }
    return this;
  }
  var i2 = indexOf2(state.pipes, dest);
  if (i2 === -1)
    return this;
  state.pipes.splice(i2, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];
  dest.emit("unpipe", this);
  return this;
};
Readable.prototype.on = function(ev, fn) {
  var res = EventEmitter$2.prototype.on.call(this, ev, fn);
  if (ev === "data") {
    if (this._readableState.flowing !== false)
      this.resume();
  } else if (ev === "readable") {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        nextTick$2(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug("resume");
    state.flowing = true;
    resume(this, state);
  }
  return this;
};
function resume(stream2, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick$2(resume_, stream2, state);
  }
}
function resume_(stream2, state) {
  if (!state.reading) {
    debug("resume read 0");
    stream2.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream2.emit("resume");
  flow(stream2);
  if (state.flowing && !state.reading)
    stream2.read(0);
}
Readable.prototype.pause = function() {
  debug("call pause flowing=%j", this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  return this;
};
function flow(stream2) {
  var state = stream2._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream2.read() !== null) {
  }
}
Readable.prototype.wrap = function(stream2) {
  var state = this._readableState;
  var paused = false;
  var self2 = this;
  stream2.on("end", function() {
    debug("wrapped end");
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self2.push(chunk);
    }
    self2.push(null);
  });
  stream2.on("data", function(chunk) {
    debug("wrapped data");
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (state.objectMode && (chunk === null || chunk === void 0))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;
    var ret = self2.push(chunk);
    if (!ret) {
      paused = true;
      stream2.pause();
    }
  });
  for (var i2 in stream2) {
    if (this[i2] === void 0 && typeof stream2[i2] === "function") {
      this[i2] = function(method) {
        return function() {
          return stream2[method].apply(stream2, arguments);
        };
      }(i2);
    }
  }
  var events2 = ["error", "close", "destroy", "pause", "resume"];
  forEach(events2, function(ev) {
    stream2.on(ev, self2.emit.bind(self2, ev));
  });
  self2._read = function(n2) {
    debug("wrapped _read", n2);
    if (paused) {
      paused = false;
      stream2.resume();
    }
  };
  return self2;
};
Readable._fromList = fromList;
function fromList(n2, state) {
  if (state.length === 0)
    return null;
  var ret;
  if (state.objectMode)
    ret = state.buffer.shift();
  else if (!n2 || n2 >= state.length) {
    if (state.decoder)
      ret = state.buffer.join("");
    else if (state.buffer.length === 1)
      ret = state.buffer.head.data;
    else
      ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    ret = fromListPartial(n2, state.buffer, state.decoder);
  }
  return ret;
}
function fromListPartial(n2, list, hasStrings) {
  var ret;
  if (n2 < list.head.data.length) {
    ret = list.head.data.slice(0, n2);
    list.head.data = list.head.data.slice(n2);
  } else if (n2 === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n2, list) : copyFromBuffer(n2, list);
  }
  return ret;
}
function copyFromBufferString(n2, list) {
  var p2 = list.head;
  var c3 = 1;
  var ret = p2.data;
  n2 -= ret.length;
  while (p2 = p2.next) {
    var str2 = p2.data;
    var nb = n2 > str2.length ? str2.length : n2;
    if (nb === str2.length)
      ret += str2;
    else
      ret += str2.slice(0, n2);
    n2 -= nb;
    if (n2 === 0) {
      if (nb === str2.length) {
        ++c3;
        if (p2.next)
          list.head = p2.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p2;
        p2.data = str2.slice(nb);
      }
      break;
    }
    ++c3;
  }
  list.length -= c3;
  return ret;
}
function copyFromBuffer(n2, list) {
  var ret = Buffer$2.allocUnsafe(n2);
  var p2 = list.head;
  var c3 = 1;
  p2.data.copy(ret);
  n2 -= p2.data.length;
  while (p2 = p2.next) {
    var buf = p2.data;
    var nb = n2 > buf.length ? buf.length : n2;
    buf.copy(ret, ret.length - n2, 0, nb);
    n2 -= nb;
    if (n2 === 0) {
      if (nb === buf.length) {
        ++c3;
        if (p2.next)
          list.head = p2.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p2;
        p2.data = buf.slice(nb);
      }
      break;
    }
    ++c3;
  }
  list.length -= c3;
  return ret;
}
function endReadable(stream2) {
  var state = stream2._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick$2(endReadableNT, state, stream2);
  }
}
function endReadableNT(state, stream2) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream2.readable = false;
    stream2.emit("end");
  }
}
function forEach(xs, f3) {
  for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
    f3(xs[i2], i2);
  }
}
function indexOf2(xs, x2) {
  for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
    if (xs[i2] === x2)
      return i2;
  }
  return -1;
}
Writable.WritableState = WritableState;
inherits$1(Writable, EventEmitter$2);
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options, stream2) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream2 instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream2, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
function Writable(options) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);
  this._writableState = new WritableState(options, this);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function")
      this._write = options.write;
    if (typeof options.writev === "function")
      this._writev = options.writev;
  }
  EventEmitter$2.call(this);
}
Writable.prototype.pipe = function() {
  this.emit("error", new Error("Cannot pipe, not readable"));
};
function writeAfterEnd(stream2, cb) {
  var er = new Error("write after end");
  stream2.emit("error", er);
  nextTick$2(cb, er);
}
function validChunk(stream2, state, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer$2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream2.emit("error", er);
    nextTick$2(cb, er);
    valid = false;
  }
  return valid;
}
Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (Buffer$2.isBuffer(chunk))
    encoding = "buffer";
  else if (!encoding)
    encoding = state.defaultEncoding;
  if (typeof cb !== "function")
    cb = nop;
  if (state.ended)
    writeAfterEnd(this, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function() {
  var state = this._writableState;
  state.corked++;
};
Writable.prototype.uncork = function() {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
      clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  if (typeof encoding === "string")
    encoding = encoding.toLowerCase();
  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
    throw new TypeError("Unknown encoding: " + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer$2.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream2, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer$2.isBuffer(chunk))
    encoding = "buffer";
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (!ret)
    state.needDrain = true;
  if (state.writing || state.corked) {
    var last2 = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last2) {
      last2.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream2, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream2, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream2._writev(chunk, state.onwrite);
  else
    stream2._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream2, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    nextTick$2(cb, er);
  else
    cb(er);
  stream2._writableState.errorEmitted = true;
  stream2.emit("error", er);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream2, er) {
  var state = stream2._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er)
    onwriteError(stream2, state, sync, er, cb);
  else {
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream2, state);
    }
    if (sync) {
      nextTick$2(afterWrite, stream2, state, finished, cb);
    } else {
      afterWrite(stream2, state, finished, cb);
    }
  }
}
function afterWrite(stream2, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream2, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream2, state);
}
function onwriteDrain(stream2, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream2.emit("drain");
  }
}
function clearBuffer(stream2, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream2._writev && entry && entry.next) {
    var l2 = state.bufferedRequestCount;
    var buffer2 = new Array(l2);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    while (entry) {
      buffer2[count] = entry;
      entry = entry.next;
      count += 1;
    }
    doWrite(stream2, state, true, state.length, buffer2, "", holder.finish);
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream2, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      if (state.writing) {
        break;
      }
    }
    if (entry === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error("not implemented"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== void 0)
    this.write(chunk, encoding);
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream2, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream2.emit("prefinish");
  }
}
function finishMaybe(stream2, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream2, state);
      state.finished = true;
      stream2.emit("finish");
    } else {
      prefinish(stream2, state);
    }
  }
  return need;
}
function endWritable(stream2, state, cb) {
  state.ending = true;
  finishMaybe(stream2, state);
  if (cb) {
    if (state.finished)
      nextTick$2(cb);
    else
      stream2.once("finish", cb);
  }
  state.ended = true;
  stream2.writable = false;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
inherits$1(Duplex, Readable);
var keys = Object.keys(Writable.prototype);
for (var v$1 = 0; v$1 < keys.length; v$1++) {
  var method = keys[v$1];
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
}
function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false)
    this.readable = false;
  if (options && options.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  nextTick$2(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
inherits$1(Transform$1, Duplex);
function TransformState(stream2) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream2, er, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream2, er, data) {
  var ts = stream2._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb)
    return stream2.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data !== null && data !== void 0)
    stream2.push(data);
  cb(er);
  var rs = stream2._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream2._read(rs.highWaterMark);
  }
}
function Transform$1(options) {
  if (!(this instanceof Transform$1))
    return new Transform$1(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  var stream2 = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function")
      this._flush(function(er) {
        done(stream2, er);
      });
    else
      done(stream2);
  });
}
Transform$1.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};
Transform$1.prototype._transform = function(chunk, encoding, cb) {
  throw new Error("Not implemented");
};
Transform$1.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};
Transform$1.prototype._read = function(n2) {
  var ts = this._transformState;
  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
function done(stream2, er) {
  if (er)
    return stream2.emit("error", er);
  var ws = stream2._writableState;
  var ts = stream2._transformState;
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream2.push(null);
}
inherits$1(PassThrough, Transform$1);
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform$1.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
inherits$1(Stream, EventEmitter$2);
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform$1;
Stream.PassThrough = PassThrough;
Stream.Stream = Stream;
function Stream() {
  EventEmitter$2.call(this);
}
Stream.prototype.pipe = function(dest, options) {
  var source = this;
  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }
  source.on("data", ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  dest.on("drain", ondrain);
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on("end", onend2);
    source.on("close", onclose);
  }
  var didOnEnd = false;
  function onend2() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    dest.end();
  }
  function onclose() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    if (typeof dest.destroy === "function")
      dest.destroy();
  }
  function onerror(er) {
    cleanup();
    if (EventEmitter$2.listenerCount(this, "error") === 0) {
      throw er;
    }
  }
  source.on("error", onerror);
  dest.on("error", onerror);
  function cleanup() {
    source.removeListener("data", ondata);
    dest.removeListener("drain", ondrain);
    source.removeListener("end", onend2);
    source.removeListener("close", onclose);
    source.removeListener("error", onerror);
    dest.removeListener("error", onerror);
    source.removeListener("end", cleanup);
    source.removeListener("close", cleanup);
    dest.removeListener("close", cleanup);
  }
  source.on("end", cleanup);
  source.on("close", cleanup);
  dest.on("close", cleanup);
  dest.emit("pipe", source);
  return dest;
};
const stream = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Duplex,
  PassThrough,
  Readable,
  Stream,
  Transform: Transform$1,
  Writable,
  default: Stream
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(stream);
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(stringDecoder);
(function(exports) {
  (function(sax2) {
    sax2.parser = function(strict, opt) {
      return new SAXParser(strict, opt);
    };
    sax2.SAXParser = SAXParser;
    sax2.SAXStream = SAXStream;
    sax2.createStream = createStream;
    sax2.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    sax2.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict, opt);
      }
      var parser2 = this;
      clearBuffers(parser2);
      parser2.q = parser2.c = "";
      parser2.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
      parser2.opt = opt || {};
      parser2.opt.lowercase = parser2.opt.lowercase || parser2.opt.lowercasetags;
      parser2.looseCase = parser2.opt.lowercase ? "toLowerCase" : "toUpperCase";
      parser2.tags = [];
      parser2.closed = parser2.closedRoot = parser2.sawRoot = false;
      parser2.tag = parser2.error = null;
      parser2.strict = !!strict;
      parser2.noscript = !!(strict || parser2.opt.noscript);
      parser2.state = S2.BEGIN;
      parser2.strictEntities = parser2.opt.strictEntities;
      parser2.ENTITIES = parser2.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
      parser2.attribList = [];
      if (parser2.opt.xmlns) {
        parser2.ns = Object.create(rootNS);
      }
      parser2.trackPosition = parser2.opt.position !== false;
      if (parser2.trackPosition) {
        parser2.position = parser2.line = parser2.column = 0;
      }
      emit3(parser2, "onready");
    }
    if (!Object.create) {
      Object.create = function(o2) {
        function F2() {
        }
        F2.prototype = o2;
        var newf = new F2();
        return newf;
      };
    }
    if (!Object.keys) {
      Object.keys = function(o2) {
        var a8 = [];
        for (var i2 in o2)
          if (o2.hasOwnProperty(i2))
            a8.push(i2);
        return a8;
      };
    }
    function checkBufferLength(parser2) {
      var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;
      for (var i2 = 0, l2 = buffers.length; i2 < l2; i2++) {
        var len = parser2[buffers[i2]].length;
        if (len > maxAllowed) {
          switch (buffers[i2]) {
            case "textNode":
              closeText(parser2);
              break;
            case "cdata":
              emitNode(parser2, "oncdata", parser2.cdata);
              parser2.cdata = "";
              break;
            case "script":
              emitNode(parser2, "onscript", parser2.script);
              parser2.script = "";
              break;
            default:
              error2(parser2, "Max buffer length exceeded: " + buffers[i2]);
          }
        }
        maxActual = Math.max(maxActual, len);
      }
      var m2 = sax2.MAX_BUFFER_LENGTH - maxActual;
      parser2.bufferCheckPosition = m2 + parser2.position;
    }
    function clearBuffers(parser2) {
      for (var i2 = 0, l2 = buffers.length; i2 < l2; i2++) {
        parser2[buffers[i2]] = "";
      }
    }
    function flushBuffers(parser2) {
      closeText(parser2);
      if (parser2.cdata !== "") {
        emitNode(parser2, "oncdata", parser2.cdata);
        parser2.cdata = "";
      }
      if (parser2.script !== "") {
        emitNode(parser2, "onscript", parser2.script);
        parser2.script = "";
      }
    }
    SAXParser.prototype = {
      end: function() {
        end(this);
      },
      write: write5,
      resume: function() {
        this.error = null;
        return this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        flushBuffers(this);
      }
    };
    var Stream2;
    try {
      Stream2 = require$$0.Stream;
    } catch (ex) {
      Stream2 = function() {
      };
    }
    var streamWraps = sax2.EVENTS.filter(function(ev) {
      return ev !== "error" && ev !== "end";
    });
    function createStream(strict, opt) {
      return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
      if (!(this instanceof SAXStream)) {
        return new SAXStream(strict, opt);
      }
      Stream2.apply(this);
      this._parser = new SAXParser(strict, opt);
      this.writable = true;
      this.readable = true;
      var me = this;
      this._parser.onend = function() {
        me.emit("end");
      };
      this._parser.onerror = function(er) {
        me.emit("error", er);
        me._parser.error = null;
      };
      this._decoder = null;
      streamWraps.forEach(function(ev) {
        Object.defineProperty(me, "on" + ev, {
          get: function() {
            return me._parser["on" + ev];
          },
          set: function(h2) {
            if (!h2) {
              me.removeAllListeners(ev);
              me._parser["on" + ev] = h2;
              return h2;
            }
            me.on(ev, h2);
          },
          enumerable: true,
          configurable: false
        });
      });
    }
    SAXStream.prototype = Object.create(Stream2.prototype, {
      constructor: {
        value: SAXStream
      }
    });
    SAXStream.prototype.write = function(data) {
      if (typeof Buffer$2 === "function" && typeof Buffer$2.isBuffer === "function" && Buffer$2.isBuffer(data)) {
        if (!this._decoder) {
          var SD = require$$1.StringDecoder;
          this._decoder = new SD("utf8");
        }
        data = this._decoder.write(data);
      }
      this._parser.write(data.toString());
      this.emit("data", data);
      return true;
    };
    SAXStream.prototype.end = function(chunk) {
      if (chunk && chunk.length) {
        this.write(chunk);
      }
      this._parser.end();
      return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
      var me = this;
      if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
        me._parser["on" + ev] = function() {
          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args.splice(0, 0, ev);
          me.emit.apply(me, args);
        };
      }
      return Stream2.prototype.on.call(me, ev, handler);
    };
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c3) {
      return c3 === " " || c3 === "\n" || c3 === "\r" || c3 === "	";
    }
    function isQuote(c3) {
      return c3 === '"' || c3 === "'";
    }
    function isAttribEnd(c3) {
      return c3 === ">" || isWhitespace(c3);
    }
    function isMatch(regex, c3) {
      return regex.test(c3);
    }
    function notMatch(regex, c3) {
      return !isMatch(regex, c3);
    }
    var S2 = 0;
    sax2.STATE = {
      BEGIN: S2++,
      // leading byte order mark or whitespace
      BEGIN_WHITESPACE: S2++,
      // leading whitespace
      TEXT: S2++,
      // general stuff
      TEXT_ENTITY: S2++,
      // &amp and such.
      OPEN_WAKA: S2++,
      // <
      SGML_DECL: S2++,
      // <!BLARG
      SGML_DECL_QUOTED: S2++,
      // <!BLARG foo "bar
      DOCTYPE: S2++,
      // <!DOCTYPE
      DOCTYPE_QUOTED: S2++,
      // <!DOCTYPE "//blah
      DOCTYPE_DTD: S2++,
      // <!DOCTYPE "//blah" [ ...
      DOCTYPE_DTD_QUOTED: S2++,
      // <!DOCTYPE "//blah" [ "foo
      COMMENT_STARTING: S2++,
      // <!-
      COMMENT: S2++,
      // <!--
      COMMENT_ENDING: S2++,
      // <!-- blah -
      COMMENT_ENDED: S2++,
      // <!-- blah --
      CDATA: S2++,
      // <![CDATA[ something
      CDATA_ENDING: S2++,
      // ]
      CDATA_ENDING_2: S2++,
      // ]]
      PROC_INST: S2++,
      // <?hi
      PROC_INST_BODY: S2++,
      // <?hi there
      PROC_INST_ENDING: S2++,
      // <?hi "there" ?
      OPEN_TAG: S2++,
      // <strong
      OPEN_TAG_SLASH: S2++,
      // <strong /
      ATTRIB: S2++,
      // <a
      ATTRIB_NAME: S2++,
      // <a foo
      ATTRIB_NAME_SAW_WHITE: S2++,
      // <a foo _
      ATTRIB_VALUE: S2++,
      // <a foo=
      ATTRIB_VALUE_QUOTED: S2++,
      // <a foo="bar
      ATTRIB_VALUE_CLOSED: S2++,
      // <a foo="bar"
      ATTRIB_VALUE_UNQUOTED: S2++,
      // <a foo=bar
      ATTRIB_VALUE_ENTITY_Q: S2++,
      // <foo bar="&quot;"
      ATTRIB_VALUE_ENTITY_U: S2++,
      // <foo bar=&quot
      CLOSE_TAG: S2++,
      // </a
      CLOSE_TAG_SAW_WHITE: S2++,
      // </a   >
      SCRIPT: S2++,
      // <script> ...
      SCRIPT_ENDING: S2++
      // <script> ... <
    };
    sax2.XML_ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'"
    };
    sax2.ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'",
      "AElig": 198,
      "Aacute": 193,
      "Acirc": 194,
      "Agrave": 192,
      "Aring": 197,
      "Atilde": 195,
      "Auml": 196,
      "Ccedil": 199,
      "ETH": 208,
      "Eacute": 201,
      "Ecirc": 202,
      "Egrave": 200,
      "Euml": 203,
      "Iacute": 205,
      "Icirc": 206,
      "Igrave": 204,
      "Iuml": 207,
      "Ntilde": 209,
      "Oacute": 211,
      "Ocirc": 212,
      "Ograve": 210,
      "Oslash": 216,
      "Otilde": 213,
      "Ouml": 214,
      "THORN": 222,
      "Uacute": 218,
      "Ucirc": 219,
      "Ugrave": 217,
      "Uuml": 220,
      "Yacute": 221,
      "aacute": 225,
      "acirc": 226,
      "aelig": 230,
      "agrave": 224,
      "aring": 229,
      "atilde": 227,
      "auml": 228,
      "ccedil": 231,
      "eacute": 233,
      "ecirc": 234,
      "egrave": 232,
      "eth": 240,
      "euml": 235,
      "iacute": 237,
      "icirc": 238,
      "igrave": 236,
      "iuml": 239,
      "ntilde": 241,
      "oacute": 243,
      "ocirc": 244,
      "ograve": 242,
      "oslash": 248,
      "otilde": 245,
      "ouml": 246,
      "szlig": 223,
      "thorn": 254,
      "uacute": 250,
      "ucirc": 251,
      "ugrave": 249,
      "uuml": 252,
      "yacute": 253,
      "yuml": 255,
      "copy": 169,
      "reg": 174,
      "nbsp": 160,
      "iexcl": 161,
      "cent": 162,
      "pound": 163,
      "curren": 164,
      "yen": 165,
      "brvbar": 166,
      "sect": 167,
      "uml": 168,
      "ordf": 170,
      "laquo": 171,
      "not": 172,
      "shy": 173,
      "macr": 175,
      "deg": 176,
      "plusmn": 177,
      "sup1": 185,
      "sup2": 178,
      "sup3": 179,
      "acute": 180,
      "micro": 181,
      "para": 182,
      "middot": 183,
      "cedil": 184,
      "ordm": 186,
      "raquo": 187,
      "frac14": 188,
      "frac12": 189,
      "frac34": 190,
      "iquest": 191,
      "times": 215,
      "divide": 247,
      "OElig": 338,
      "oelig": 339,
      "Scaron": 352,
      "scaron": 353,
      "Yuml": 376,
      "fnof": 402,
      "circ": 710,
      "tilde": 732,
      "Alpha": 913,
      "Beta": 914,
      "Gamma": 915,
      "Delta": 916,
      "Epsilon": 917,
      "Zeta": 918,
      "Eta": 919,
      "Theta": 920,
      "Iota": 921,
      "Kappa": 922,
      "Lambda": 923,
      "Mu": 924,
      "Nu": 925,
      "Xi": 926,
      "Omicron": 927,
      "Pi": 928,
      "Rho": 929,
      "Sigma": 931,
      "Tau": 932,
      "Upsilon": 933,
      "Phi": 934,
      "Chi": 935,
      "Psi": 936,
      "Omega": 937,
      "alpha": 945,
      "beta": 946,
      "gamma": 947,
      "delta": 948,
      "epsilon": 949,
      "zeta": 950,
      "eta": 951,
      "theta": 952,
      "iota": 953,
      "kappa": 954,
      "lambda": 955,
      "mu": 956,
      "nu": 957,
      "xi": 958,
      "omicron": 959,
      "pi": 960,
      "rho": 961,
      "sigmaf": 962,
      "sigma": 963,
      "tau": 964,
      "upsilon": 965,
      "phi": 966,
      "chi": 967,
      "psi": 968,
      "omega": 969,
      "thetasym": 977,
      "upsih": 978,
      "piv": 982,
      "ensp": 8194,
      "emsp": 8195,
      "thinsp": 8201,
      "zwnj": 8204,
      "zwj": 8205,
      "lrm": 8206,
      "rlm": 8207,
      "ndash": 8211,
      "mdash": 8212,
      "lsquo": 8216,
      "rsquo": 8217,
      "sbquo": 8218,
      "ldquo": 8220,
      "rdquo": 8221,
      "bdquo": 8222,
      "dagger": 8224,
      "Dagger": 8225,
      "bull": 8226,
      "hellip": 8230,
      "permil": 8240,
      "prime": 8242,
      "Prime": 8243,
      "lsaquo": 8249,
      "rsaquo": 8250,
      "oline": 8254,
      "frasl": 8260,
      "euro": 8364,
      "image": 8465,
      "weierp": 8472,
      "real": 8476,
      "trade": 8482,
      "alefsym": 8501,
      "larr": 8592,
      "uarr": 8593,
      "rarr": 8594,
      "darr": 8595,
      "harr": 8596,
      "crarr": 8629,
      "lArr": 8656,
      "uArr": 8657,
      "rArr": 8658,
      "dArr": 8659,
      "hArr": 8660,
      "forall": 8704,
      "part": 8706,
      "exist": 8707,
      "empty": 8709,
      "nabla": 8711,
      "isin": 8712,
      "notin": 8713,
      "ni": 8715,
      "prod": 8719,
      "sum": 8721,
      "minus": 8722,
      "lowast": 8727,
      "radic": 8730,
      "prop": 8733,
      "infin": 8734,
      "ang": 8736,
      "and": 8743,
      "or": 8744,
      "cap": 8745,
      "cup": 8746,
      "int": 8747,
      "there4": 8756,
      "sim": 8764,
      "cong": 8773,
      "asymp": 8776,
      "ne": 8800,
      "equiv": 8801,
      "le": 8804,
      "ge": 8805,
      "sub": 8834,
      "sup": 8835,
      "nsub": 8836,
      "sube": 8838,
      "supe": 8839,
      "oplus": 8853,
      "otimes": 8855,
      "perp": 8869,
      "sdot": 8901,
      "lceil": 8968,
      "rceil": 8969,
      "lfloor": 8970,
      "rfloor": 8971,
      "lang": 9001,
      "rang": 9002,
      "loz": 9674,
      "spades": 9824,
      "clubs": 9827,
      "hearts": 9829,
      "diams": 9830
    };
    Object.keys(sax2.ENTITIES).forEach(function(key) {
      var e3 = sax2.ENTITIES[key];
      var s3 = typeof e3 === "number" ? String.fromCharCode(e3) : e3;
      sax2.ENTITIES[key] = s3;
    });
    for (var s2 in sax2.STATE) {
      sax2.STATE[sax2.STATE[s2]] = s2;
    }
    S2 = sax2.STATE;
    function emit3(parser2, event, data) {
      parser2[event] && parser2[event](data);
    }
    function emitNode(parser2, nodeType, data) {
      if (parser2.textNode)
        closeText(parser2);
      emit3(parser2, nodeType, data);
    }
    function closeText(parser2) {
      parser2.textNode = textopts(parser2.opt, parser2.textNode);
      if (parser2.textNode)
        emit3(parser2, "ontext", parser2.textNode);
      parser2.textNode = "";
    }
    function textopts(opt, text) {
      if (opt.trim)
        text = text.trim();
      if (opt.normalize)
        text = text.replace(/\s+/g, " ");
      return text;
    }
    function error2(parser2, er) {
      closeText(parser2);
      if (parser2.trackPosition) {
        er += "\nLine: " + parser2.line + "\nColumn: " + parser2.column + "\nChar: " + parser2.c;
      }
      er = new Error(er);
      parser2.error = er;
      emit3(parser2, "onerror", er);
      return parser2;
    }
    function end(parser2) {
      if (parser2.sawRoot && !parser2.closedRoot)
        strictFail(parser2, "Unclosed root tag");
      if (parser2.state !== S2.BEGIN && parser2.state !== S2.BEGIN_WHITESPACE && parser2.state !== S2.TEXT) {
        error2(parser2, "Unexpected end");
      }
      closeText(parser2);
      parser2.c = "";
      parser2.closed = true;
      emit3(parser2, "onend");
      SAXParser.call(parser2, parser2.strict, parser2.opt);
      return parser2;
    }
    function strictFail(parser2, message) {
      if (typeof parser2 !== "object" || !(parser2 instanceof SAXParser)) {
        throw new Error("bad call to strictFail");
      }
      if (parser2.strict) {
        error2(parser2, message);
      }
    }
    function newTag(parser2) {
      if (!parser2.strict)
        parser2.tagName = parser2.tagName[parser2.looseCase]();
      var parent = parser2.tags[parser2.tags.length - 1] || parser2;
      var tag = parser2.tag = { name: parser2.tagName, attributes: {} };
      if (parser2.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser2.attribList.length = 0;
      emitNode(parser2, "onopentagstart", tag);
    }
    function qname(name, attribute) {
      var i2 = name.indexOf(":");
      var qualName = i2 < 0 ? ["", name] : name.split(":");
      var prefix = qualName[0];
      var local = qualName[1];
      if (attribute && name === "xmlns") {
        prefix = "xmlns";
        local = "";
      }
      return { prefix, local };
    }
    function attrib(parser2) {
      if (!parser2.strict) {
        parser2.attribName = parser2.attribName[parser2.looseCase]();
      }
      if (parser2.attribList.indexOf(parser2.attribName) !== -1 || parser2.tag.attributes.hasOwnProperty(parser2.attribName)) {
        parser2.attribName = parser2.attribValue = "";
        return;
      }
      if (parser2.opt.xmlns) {
        var qn = qname(parser2.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;
        if (prefix === "xmlns") {
          if (local === "xml" && parser2.attribValue !== XML_NAMESPACE) {
            strictFail(
              parser2,
              "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser2.attribValue
            );
          } else if (local === "xmlns" && parser2.attribValue !== XMLNS_NAMESPACE) {
            strictFail(
              parser2,
              "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser2.attribValue
            );
          } else {
            var tag = parser2.tag;
            var parent = parser2.tags[parser2.tags.length - 1] || parser2;
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }
            tag.ns[local] = parser2.attribValue;
          }
        }
        parser2.attribList.push([parser2.attribName, parser2.attribValue]);
      } else {
        parser2.tag.attributes[parser2.attribName] = parser2.attribValue;
        emitNode(parser2, "onattribute", {
          name: parser2.attribName,
          value: parser2.attribValue
        });
      }
      parser2.attribName = parser2.attribValue = "";
    }
    function openTag(parser2, selfClosing) {
      if (parser2.opt.xmlns) {
        var tag = parser2.tag;
        var qn = qname(parser2.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || "";
        if (tag.prefix && !tag.uri) {
          strictFail(parser2, "Unbound namespace prefix: " + JSON.stringify(parser2.tagName));
          tag.uri = qn.prefix;
        }
        var parent = parser2.tags[parser2.tags.length - 1] || parser2;
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function(p2) {
            emitNode(parser2, "onopennamespace", {
              prefix: p2,
              uri: tag.ns[p2]
            });
          });
        }
        for (var i2 = 0, l2 = parser2.attribList.length; i2 < l2; i2++) {
          var nv = parser2.attribList[i2];
          var name = nv[0];
          var value2 = nv[1];
          var qualName = qname(name, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri = prefix === "" ? "" : tag.ns[prefix] || "";
          var a8 = {
            name,
            value: value2,
            prefix,
            local,
            uri
          };
          if (prefix && prefix !== "xmlns" && !uri) {
            strictFail(parser2, "Unbound namespace prefix: " + JSON.stringify(prefix));
            a8.uri = prefix;
          }
          parser2.tag.attributes[name] = a8;
          emitNode(parser2, "onattribute", a8);
        }
        parser2.attribList.length = 0;
      }
      parser2.tag.isSelfClosing = !!selfClosing;
      parser2.sawRoot = true;
      parser2.tags.push(parser2.tag);
      emitNode(parser2, "onopentag", parser2.tag);
      if (!selfClosing) {
        if (!parser2.noscript && parser2.tagName.toLowerCase() === "script") {
          parser2.state = S2.SCRIPT;
        } else {
          parser2.state = S2.TEXT;
        }
        parser2.tag = null;
        parser2.tagName = "";
      }
      parser2.attribName = parser2.attribValue = "";
      parser2.attribList.length = 0;
    }
    function closeTag(parser2) {
      if (!parser2.tagName) {
        strictFail(parser2, "Weird empty close tag.");
        parser2.textNode += "</>";
        parser2.state = S2.TEXT;
        return;
      }
      if (parser2.script) {
        if (parser2.tagName !== "script") {
          parser2.script += "</" + parser2.tagName + ">";
          parser2.tagName = "";
          parser2.state = S2.SCRIPT;
          return;
        }
        emitNode(parser2, "onscript", parser2.script);
        parser2.script = "";
      }
      var t2 = parser2.tags.length;
      var tagName = parser2.tagName;
      if (!parser2.strict) {
        tagName = tagName[parser2.looseCase]();
      }
      var closeTo = tagName;
      while (t2--) {
        var close = parser2.tags[t2];
        if (close.name !== closeTo) {
          strictFail(parser2, "Unexpected close tag");
        } else {
          break;
        }
      }
      if (t2 < 0) {
        strictFail(parser2, "Unmatched closing tag: " + parser2.tagName);
        parser2.textNode += "</" + parser2.tagName + ">";
        parser2.state = S2.TEXT;
        return;
      }
      parser2.tagName = tagName;
      var s3 = parser2.tags.length;
      while (s3-- > t2) {
        var tag = parser2.tag = parser2.tags.pop();
        parser2.tagName = parser2.tag.name;
        emitNode(parser2, "onclosetag", parser2.tagName);
        var x2 = {};
        for (var i2 in tag.ns) {
          x2[i2] = tag.ns[i2];
        }
        var parent = parser2.tags[parser2.tags.length - 1] || parser2;
        if (parser2.opt.xmlns && tag.ns !== parent.ns) {
          Object.keys(tag.ns).forEach(function(p2) {
            var n2 = tag.ns[p2];
            emitNode(parser2, "onclosenamespace", { prefix: p2, uri: n2 });
          });
        }
      }
      if (t2 === 0)
        parser2.closedRoot = true;
      parser2.tagName = parser2.attribValue = parser2.attribName = "";
      parser2.attribList.length = 0;
      parser2.state = S2.TEXT;
    }
    function parseEntity(parser2) {
      var entity = parser2.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = "";
      if (parser2.ENTITIES[entity]) {
        return parser2.ENTITIES[entity];
      }
      if (parser2.ENTITIES[entityLC]) {
        return parser2.ENTITIES[entityLC];
      }
      entity = entityLC;
      if (entity.charAt(0) === "#") {
        if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }
      entity = entity.replace(/^0+/, "");
      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser2, "Invalid character entity");
        return "&" + parser2.entity + ";";
      }
      return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser2, c3) {
      if (c3 === "<") {
        parser2.state = S2.OPEN_WAKA;
        parser2.startTagPosition = parser2.position;
      } else if (!isWhitespace(c3)) {
        strictFail(parser2, "Non-whitespace before first tag.");
        parser2.textNode = c3;
        parser2.state = S2.TEXT;
      }
    }
    function charAt(chunk, i2) {
      var result = "";
      if (i2 < chunk.length) {
        result = chunk.charAt(i2);
      }
      return result;
    }
    function write5(chunk) {
      var parser2 = this;
      if (this.error) {
        throw this.error;
      }
      if (parser2.closed) {
        return error2(
          parser2,
          "Cannot write after close. Assign an onready handler."
        );
      }
      if (chunk === null) {
        return end(parser2);
      }
      if (typeof chunk === "object") {
        chunk = chunk.toString();
      }
      var i2 = 0;
      var c3 = "";
      while (true) {
        c3 = charAt(chunk, i2++);
        parser2.c = c3;
        if (!c3) {
          break;
        }
        if (parser2.trackPosition) {
          parser2.position++;
          if (c3 === "\n") {
            parser2.line++;
            parser2.column = 0;
          } else {
            parser2.column++;
          }
        }
        switch (parser2.state) {
          case S2.BEGIN:
            parser2.state = S2.BEGIN_WHITESPACE;
            if (c3 === "\uFEFF") {
              continue;
            }
            beginWhiteSpace(parser2, c3);
            continue;
          case S2.BEGIN_WHITESPACE:
            beginWhiteSpace(parser2, c3);
            continue;
          case S2.TEXT:
            if (parser2.sawRoot && !parser2.closedRoot) {
              var starti = i2 - 1;
              while (c3 && c3 !== "<" && c3 !== "&") {
                c3 = charAt(chunk, i2++);
                if (c3 && parser2.trackPosition) {
                  parser2.position++;
                  if (c3 === "\n") {
                    parser2.line++;
                    parser2.column = 0;
                  } else {
                    parser2.column++;
                  }
                }
              }
              parser2.textNode += chunk.substring(starti, i2 - 1);
            }
            if (c3 === "<" && !(parser2.sawRoot && parser2.closedRoot && !parser2.strict)) {
              parser2.state = S2.OPEN_WAKA;
              parser2.startTagPosition = parser2.position;
            } else {
              if (!isWhitespace(c3) && (!parser2.sawRoot || parser2.closedRoot)) {
                strictFail(parser2, "Text data outside of root node.");
              }
              if (c3 === "&") {
                parser2.state = S2.TEXT_ENTITY;
              } else {
                parser2.textNode += c3;
              }
            }
            continue;
          case S2.SCRIPT:
            if (c3 === "<") {
              parser2.state = S2.SCRIPT_ENDING;
            } else {
              parser2.script += c3;
            }
            continue;
          case S2.SCRIPT_ENDING:
            if (c3 === "/") {
              parser2.state = S2.CLOSE_TAG;
            } else {
              parser2.script += "<" + c3;
              parser2.state = S2.SCRIPT;
            }
            continue;
          case S2.OPEN_WAKA:
            if (c3 === "!") {
              parser2.state = S2.SGML_DECL;
              parser2.sgmlDecl = "";
            } else if (isWhitespace(c3))
              ;
            else if (isMatch(nameStart, c3)) {
              parser2.state = S2.OPEN_TAG;
              parser2.tagName = c3;
            } else if (c3 === "/") {
              parser2.state = S2.CLOSE_TAG;
              parser2.tagName = "";
            } else if (c3 === "?") {
              parser2.state = S2.PROC_INST;
              parser2.procInstName = parser2.procInstBody = "";
            } else {
              strictFail(parser2, "Unencoded <");
              if (parser2.startTagPosition + 1 < parser2.position) {
                var pad = parser2.position - parser2.startTagPosition;
                c3 = new Array(pad).join(" ") + c3;
              }
              parser2.textNode += "<" + c3;
              parser2.state = S2.TEXT;
            }
            continue;
          case S2.SGML_DECL:
            if ((parser2.sgmlDecl + c3).toUpperCase() === CDATA) {
              emitNode(parser2, "onopencdata");
              parser2.state = S2.CDATA;
              parser2.sgmlDecl = "";
              parser2.cdata = "";
            } else if (parser2.sgmlDecl + c3 === "--") {
              parser2.state = S2.COMMENT;
              parser2.comment = "";
              parser2.sgmlDecl = "";
            } else if ((parser2.sgmlDecl + c3).toUpperCase() === DOCTYPE) {
              parser2.state = S2.DOCTYPE;
              if (parser2.doctype || parser2.sawRoot) {
                strictFail(
                  parser2,
                  "Inappropriately located doctype declaration"
                );
              }
              parser2.doctype = "";
              parser2.sgmlDecl = "";
            } else if (c3 === ">") {
              emitNode(parser2, "onsgmldeclaration", parser2.sgmlDecl);
              parser2.sgmlDecl = "";
              parser2.state = S2.TEXT;
            } else if (isQuote(c3)) {
              parser2.state = S2.SGML_DECL_QUOTED;
              parser2.sgmlDecl += c3;
            } else {
              parser2.sgmlDecl += c3;
            }
            continue;
          case S2.SGML_DECL_QUOTED:
            if (c3 === parser2.q) {
              parser2.state = S2.SGML_DECL;
              parser2.q = "";
            }
            parser2.sgmlDecl += c3;
            continue;
          case S2.DOCTYPE:
            if (c3 === ">") {
              parser2.state = S2.TEXT;
              emitNode(parser2, "ondoctype", parser2.doctype);
              parser2.doctype = true;
            } else {
              parser2.doctype += c3;
              if (c3 === "[") {
                parser2.state = S2.DOCTYPE_DTD;
              } else if (isQuote(c3)) {
                parser2.state = S2.DOCTYPE_QUOTED;
                parser2.q = c3;
              }
            }
            continue;
          case S2.DOCTYPE_QUOTED:
            parser2.doctype += c3;
            if (c3 === parser2.q) {
              parser2.q = "";
              parser2.state = S2.DOCTYPE;
            }
            continue;
          case S2.DOCTYPE_DTD:
            parser2.doctype += c3;
            if (c3 === "]") {
              parser2.state = S2.DOCTYPE;
            } else if (isQuote(c3)) {
              parser2.state = S2.DOCTYPE_DTD_QUOTED;
              parser2.q = c3;
            }
            continue;
          case S2.DOCTYPE_DTD_QUOTED:
            parser2.doctype += c3;
            if (c3 === parser2.q) {
              parser2.state = S2.DOCTYPE_DTD;
              parser2.q = "";
            }
            continue;
          case S2.COMMENT:
            if (c3 === "-") {
              parser2.state = S2.COMMENT_ENDING;
            } else {
              parser2.comment += c3;
            }
            continue;
          case S2.COMMENT_ENDING:
            if (c3 === "-") {
              parser2.state = S2.COMMENT_ENDED;
              parser2.comment = textopts(parser2.opt, parser2.comment);
              if (parser2.comment) {
                emitNode(parser2, "oncomment", parser2.comment);
              }
              parser2.comment = "";
            } else {
              parser2.comment += "-" + c3;
              parser2.state = S2.COMMENT;
            }
            continue;
          case S2.COMMENT_ENDED:
            if (c3 !== ">") {
              strictFail(parser2, "Malformed comment");
              parser2.comment += "--" + c3;
              parser2.state = S2.COMMENT;
            } else {
              parser2.state = S2.TEXT;
            }
            continue;
          case S2.CDATA:
            if (c3 === "]") {
              parser2.state = S2.CDATA_ENDING;
            } else {
              parser2.cdata += c3;
            }
            continue;
          case S2.CDATA_ENDING:
            if (c3 === "]") {
              parser2.state = S2.CDATA_ENDING_2;
            } else {
              parser2.cdata += "]" + c3;
              parser2.state = S2.CDATA;
            }
            continue;
          case S2.CDATA_ENDING_2:
            if (c3 === ">") {
              if (parser2.cdata) {
                emitNode(parser2, "oncdata", parser2.cdata);
              }
              emitNode(parser2, "onclosecdata");
              parser2.cdata = "";
              parser2.state = S2.TEXT;
            } else if (c3 === "]") {
              parser2.cdata += "]";
            } else {
              parser2.cdata += "]]" + c3;
              parser2.state = S2.CDATA;
            }
            continue;
          case S2.PROC_INST:
            if (c3 === "?") {
              parser2.state = S2.PROC_INST_ENDING;
            } else if (isWhitespace(c3)) {
              parser2.state = S2.PROC_INST_BODY;
            } else {
              parser2.procInstName += c3;
            }
            continue;
          case S2.PROC_INST_BODY:
            if (!parser2.procInstBody && isWhitespace(c3)) {
              continue;
            } else if (c3 === "?") {
              parser2.state = S2.PROC_INST_ENDING;
            } else {
              parser2.procInstBody += c3;
            }
            continue;
          case S2.PROC_INST_ENDING:
            if (c3 === ">") {
              emitNode(parser2, "onprocessinginstruction", {
                name: parser2.procInstName,
                body: parser2.procInstBody
              });
              parser2.procInstName = parser2.procInstBody = "";
              parser2.state = S2.TEXT;
            } else {
              parser2.procInstBody += "?" + c3;
              parser2.state = S2.PROC_INST_BODY;
            }
            continue;
          case S2.OPEN_TAG:
            if (isMatch(nameBody, c3)) {
              parser2.tagName += c3;
            } else {
              newTag(parser2);
              if (c3 === ">") {
                openTag(parser2);
              } else if (c3 === "/") {
                parser2.state = S2.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace(c3)) {
                  strictFail(parser2, "Invalid character in tag name");
                }
                parser2.state = S2.ATTRIB;
              }
            }
            continue;
          case S2.OPEN_TAG_SLASH:
            if (c3 === ">") {
              openTag(parser2, true);
              closeTag(parser2);
            } else {
              strictFail(parser2, "Forward-slash in opening tag not followed by >");
              parser2.state = S2.ATTRIB;
            }
            continue;
          case S2.ATTRIB:
            if (isWhitespace(c3)) {
              continue;
            } else if (c3 === ">") {
              openTag(parser2);
            } else if (c3 === "/") {
              parser2.state = S2.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c3)) {
              parser2.attribName = c3;
              parser2.attribValue = "";
              parser2.state = S2.ATTRIB_NAME;
            } else {
              strictFail(parser2, "Invalid attribute name");
            }
            continue;
          case S2.ATTRIB_NAME:
            if (c3 === "=") {
              parser2.state = S2.ATTRIB_VALUE;
            } else if (c3 === ">") {
              strictFail(parser2, "Attribute without value");
              parser2.attribValue = parser2.attribName;
              attrib(parser2);
              openTag(parser2);
            } else if (isWhitespace(c3)) {
              parser2.state = S2.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c3)) {
              parser2.attribName += c3;
            } else {
              strictFail(parser2, "Invalid attribute name");
            }
            continue;
          case S2.ATTRIB_NAME_SAW_WHITE:
            if (c3 === "=") {
              parser2.state = S2.ATTRIB_VALUE;
            } else if (isWhitespace(c3)) {
              continue;
            } else {
              strictFail(parser2, "Attribute without value");
              parser2.tag.attributes[parser2.attribName] = "";
              parser2.attribValue = "";
              emitNode(parser2, "onattribute", {
                name: parser2.attribName,
                value: ""
              });
              parser2.attribName = "";
              if (c3 === ">") {
                openTag(parser2);
              } else if (isMatch(nameStart, c3)) {
                parser2.attribName = c3;
                parser2.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser2, "Invalid attribute name");
                parser2.state = S2.ATTRIB;
              }
            }
            continue;
          case S2.ATTRIB_VALUE:
            if (isWhitespace(c3)) {
              continue;
            } else if (isQuote(c3)) {
              parser2.q = c3;
              parser2.state = S2.ATTRIB_VALUE_QUOTED;
            } else {
              strictFail(parser2, "Unquoted attribute value");
              parser2.state = S2.ATTRIB_VALUE_UNQUOTED;
              parser2.attribValue = c3;
            }
            continue;
          case S2.ATTRIB_VALUE_QUOTED:
            if (c3 !== parser2.q) {
              if (c3 === "&") {
                parser2.state = S2.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser2.attribValue += c3;
              }
              continue;
            }
            attrib(parser2);
            parser2.q = "";
            parser2.state = S2.ATTRIB_VALUE_CLOSED;
            continue;
          case S2.ATTRIB_VALUE_CLOSED:
            if (isWhitespace(c3)) {
              parser2.state = S2.ATTRIB;
            } else if (c3 === ">") {
              openTag(parser2);
            } else if (c3 === "/") {
              parser2.state = S2.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c3)) {
              strictFail(parser2, "No whitespace between attributes");
              parser2.attribName = c3;
              parser2.attribValue = "";
              parser2.state = S2.ATTRIB_NAME;
            } else {
              strictFail(parser2, "Invalid attribute name");
            }
            continue;
          case S2.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c3)) {
              if (c3 === "&") {
                parser2.state = S2.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser2.attribValue += c3;
              }
              continue;
            }
            attrib(parser2);
            if (c3 === ">") {
              openTag(parser2);
            } else {
              parser2.state = S2.ATTRIB;
            }
            continue;
          case S2.CLOSE_TAG:
            if (!parser2.tagName) {
              if (isWhitespace(c3)) {
                continue;
              } else if (notMatch(nameStart, c3)) {
                if (parser2.script) {
                  parser2.script += "</" + c3;
                  parser2.state = S2.SCRIPT;
                } else {
                  strictFail(parser2, "Invalid tagname in closing tag.");
                }
              } else {
                parser2.tagName = c3;
              }
            } else if (c3 === ">") {
              closeTag(parser2);
            } else if (isMatch(nameBody, c3)) {
              parser2.tagName += c3;
            } else if (parser2.script) {
              parser2.script += "</" + parser2.tagName;
              parser2.tagName = "";
              parser2.state = S2.SCRIPT;
            } else {
              if (!isWhitespace(c3)) {
                strictFail(parser2, "Invalid tagname in closing tag");
              }
              parser2.state = S2.CLOSE_TAG_SAW_WHITE;
            }
            continue;
          case S2.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace(c3)) {
              continue;
            }
            if (c3 === ">") {
              closeTag(parser2);
            } else {
              strictFail(parser2, "Invalid characters in closing tag");
            }
            continue;
          case S2.TEXT_ENTITY:
          case S2.ATTRIB_VALUE_ENTITY_Q:
          case S2.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer2;
            switch (parser2.state) {
              case S2.TEXT_ENTITY:
                returnState = S2.TEXT;
                buffer2 = "textNode";
                break;
              case S2.ATTRIB_VALUE_ENTITY_Q:
                returnState = S2.ATTRIB_VALUE_QUOTED;
                buffer2 = "attribValue";
                break;
              case S2.ATTRIB_VALUE_ENTITY_U:
                returnState = S2.ATTRIB_VALUE_UNQUOTED;
                buffer2 = "attribValue";
                break;
            }
            if (c3 === ";") {
              parser2[buffer2] += parseEntity(parser2);
              parser2.entity = "";
              parser2.state = returnState;
            } else if (isMatch(parser2.entity.length ? entityBody : entityStart, c3)) {
              parser2.entity += c3;
            } else {
              strictFail(parser2, "Invalid character in entity name");
              parser2[buffer2] += "&" + parser2.entity + c3;
              parser2.entity = "";
              parser2.state = returnState;
            }
            continue;
          default:
            throw new Error(parser2, "Unknown state: " + parser2.state);
        }
      }
      if (parser2.position >= parser2.bufferCheckPosition) {
        checkBufferLength(parser2);
      }
      return parser2;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    if (!String.fromCodePoint) {
      (function() {
        var stringFromCharCode2 = String.fromCharCode;
        var floor2 = Math.floor;
        var fromCodePoint = function() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index2 = -1;
          var length2 = arguments.length;
          if (!length2) {
            return "";
          }
          var result = "";
          while (++index2 < length2) {
            var codePoint = Number(arguments[index2]);
            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 1114111 || // not a valid Unicode code point
            floor2(codePoint) !== codePoint) {
              throw RangeError("Invalid code point: " + codePoint);
            }
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index2 + 1 === length2 || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode2.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) {
          Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint,
            configurable: true,
            writable: true
          });
        } else {
          String.fromCodePoint = fromCodePoint;
        }
      })();
    }
  })(exports);
})(sax);
class TiledProperties {
  constructor(data) {
    this.properties = {};
    this.properties = (data == null ? void 0 : data.properties) ?? {};
  }
  getProperty(name, defaultValue2) {
    const val = this.properties[name];
    if (val === void 0) {
      return defaultValue2;
    }
    return val;
  }
  hasProperty(name) {
    return !!this.properties[name];
  }
  setProperty(name, value2) {
    this.properties[name] = value2;
  }
  getType() {
    return this.class || this["type"];
  }
}
const FLIPPED_HORIZONTALLY_FLAG = 2147483648;
const FLIPPED_VERTICALLY_FLAG = 1073741824;
const FLIPPED_DIAGONALLY_FLAG = 536870912;
const ROTATED_HEXAGONAL_120_FLAG = 268435456;
class TileGid extends TiledProperties {
  constructor(obj) {
    super(obj);
    this.obj = obj;
    this._gid = obj == null ? void 0 : obj.gid;
  }
  static getRealGid(gid) {
    return gid & ~(FLIPPED_HORIZONTALLY_FLAG | FLIPPED_VERTICALLY_FLAG | FLIPPED_DIAGONALLY_FLAG | ROTATED_HEXAGONAL_120_FLAG);
  }
  get horizontalFlip() {
    return !!(this._gid & FLIPPED_HORIZONTALLY_FLAG);
  }
  get verticalFlip() {
    return !!(this._gid & FLIPPED_VERTICALLY_FLAG);
  }
  get diagonalFlip() {
    return !!(this._gid & FLIPPED_DIAGONALLY_FLAG);
  }
  get rotatedHex120() {
    return !!(this._gid & ROTATED_HEXAGONAL_120_FLAG);
  }
  get gid() {
    return TileGid.getRealGid(this._gid);
  }
  set gid(val) {
    this._gid = val;
  }
}
let Tile$1 = class Tile extends TileGid {
  constructor(tile) {
    super(tile);
    this.tile = tile;
    Reflect.deleteProperty(tile, "gid");
    Object.assign(this, tile);
  }
};
class TiledObjectClass extends TileGid {
  constructor(object) {
    super(object);
    this.layerName = "";
    Object.assign(this, object);
    if (object == null ? void 0 : object.gid) {
      this.y -= this.height;
    }
  }
}
class Layer extends TiledProperties {
  get size() {
    return this.data.length;
  }
  constructor(layer, tilesets, parent) {
    super(layer);
    this.tilesets = tilesets;
    this.parent = parent;
    this.cacheTiles = false;
    this.tiles = [];
    Object.assign(this, layer);
    this.mapObjects();
    this.mergePropertiesWithParent();
    this.cacheTiles = this.getProperty("cache-tiles", false);
    if (this.cacheTiles)
      this.propertiesTiles();
  }
  createTile(gid, tileIndex, layerIndex) {
    if (gid == 0) {
      return;
    }
    const realGid = TileGid.getRealGid(gid);
    const tileset = Layer.findTileSet(realGid, this.tilesets);
    if (!tileset) {
      return void 0;
    }
    const tile = tileset.getTile(realGid - tileset.firstgid);
    if (tile) {
      return new Tile$1({
        ...tile.tile,
        gid,
        index: tileIndex,
        layerIndex
      });
    }
    return new Tile$1({
      gid,
      index: tileIndex,
      layerIndex
    });
  }
  mergePropertiesWithParent() {
    const parent = this.getLayerParent();
    if (!this.properties)
      this.properties = {};
    if (!parent)
      return;
    for (let key in parent.properties) {
      const val = parent.properties[key];
      const valChild = this.properties[key];
      if (valChild === void 0) {
        this.properties[key] = val;
      } else {
        if (key == "z") {
          this.properties[key] += val;
        } else {
          continue;
        }
      }
    }
    this.opacity = Math.round((parent.opacity ?? 1) * (this.opacity ?? 1) * 100) / 100;
    this.offsetx = (parent.offsetx ?? 0) + (this.offsetx ?? 0);
    this.offsety = (parent.offsety ?? 0) + (this.offsety ?? 0);
    this.locked = parent.locked ?? false;
  }
  propertiesTiles() {
    if (!this.data)
      return;
    const data = this.data;
    for (let i2 = 0; i2 < data.length; i2++) {
      const id = data[i2];
      this.tiles.push(this.createTile(id, i2));
    }
  }
  mapObjects() {
    if (this.objects) {
      this.objects = this.objects.map((object) => {
        const obj = new TiledObjectClass(object);
        obj.layerName = this.name;
        return obj;
      });
    }
  }
  getTileByIndex(tileIndex) {
    if (this.cacheTiles) {
      return this.tiles[tileIndex];
    }
    return this.createTile(this.data[tileIndex], tileIndex);
  }
  static findTileSet(gid, tileSets) {
    let tileset;
    for (let i2 = tileSets.length - 1; i2 >= 0; i2--) {
      tileset = tileSets[i2];
      if (tileset.firstgid && tileset.firstgid <= gid) {
        break;
      }
    }
    return tileset;
  }
  getLayerParent() {
    return this.parent;
  }
  tilesForEach(cb) {
    for (let i2 = 0; i2 < this.data.length; i2++) {
      if (this.cacheTiles) {
        cb(this.tiles[i2], i2);
        continue;
      }
      cb(this.createTile(this.data[i2], i2), i2);
    }
  }
  setData(tileIndex, gid) {
    this.data[tileIndex] = gid;
  }
}
class Tileset extends TiledProperties {
  constructor(tileset) {
    super(tileset);
    this.tileset = tileset;
    this.cacheTileId = /* @__PURE__ */ new Map();
    Object.assign(this, tileset);
    this.margin = this.margin ?? 0;
    this.spacing = this.spacing ?? 0;
    for (let tile of tileset.tiles) {
      this.addTile(tile);
    }
    Reflect.deleteProperty(this, "tiles");
  }
  addTile(tileObj) {
    const tile = new Tile$1(tileObj);
    this.cacheTileId.set(tile.id, tile);
    return tile;
  }
  getTile(id) {
    return this.cacheTileId.get(+id);
  }
}
let bufferTilesets = {};
class MapClass extends TiledProperties {
  constructor(map2) {
    super(map2 ?? {});
    this.tilesets = [];
    this.layers = [];
    this.tmpLayers = [];
    this.tilesIndex = {};
    this.allocateMemory = 0;
    this.lowMemory = false;
    if (map2)
      this.load(map2);
  }
  load(map2) {
    Object.assign(this, map2);
    if (this.hasProperty("low-memory")) {
      this.lowMemory = this.getProperty("low-memory", false);
    }
    this.tmpLayers = [];
    this.mapTilesets();
    this.mapLayers(this.layers);
    this.layers = [...this.tmpLayers];
    Reflect.deleteProperty(this, "tmpLayers");
    this.setTilesIndex();
    this.data = map2;
  }
  /**
   * @title Width of the map in pixels
   * @prop {number} [widthPx]
   * @readonly
   * @memberof Map
   * @memberof RpgSceneMap
   * */
  get widthPx() {
    return this.width * this.tilewidth;
  }
  /**
  * @title Height of the map in pixels
  * @prop {number} [heightPx]
  * @readonly
  * @memberof Map
  * @memberof RpgSceneMap
  * */
  get heightPx() {
    return this.height * this.tileheight;
  }
  /**
   * @title The depth of the map in pixels (this is the height of a tile ;))
   * @prop {number} map.zTileHeight
   * @readonly
   * @memberof Map
   * @memberof RpgSceneMap
   * */
  get zTileHeight() {
    return this.tileheight;
  }
  /**
   * Find a layer by name. Returns `undefined` is the layer is not found
    * @title Get Layer by name
   * @method map.getLayerByName(name)
   * @param {string} name layer name
   * @returns {LayerInfo | undefined}
   * @example
   *  ```ts
   *  const tiles = map.getLayerByName(0, 0)
   *  ```
   * @memberof Map
   * @memberof RpgSceneMap
   */
  getLayerByName(name) {
    return this.layers.find((layer) => layer.name == name);
  }
  /**
  * Get the tile index on the tileset
  *
  * @title Get index of tile
  * @method map.getTileIndex(x,y)
  * @param {number} x Position X
  * @param {number} x Position Y
  * @returns {number}
  * @memberof Map
  * @memberof RpgSceneMap
  */
  getTileIndex(x2, y2, [z2] = [0]) {
    return this.width * Math.floor((y2 - z2) / this.tileheight) + Math.floor(x2 / this.tilewidth);
  }
  getTilePosition(index2) {
    return {
      y: Math.floor(index2 / this.width) * this.tileheight,
      x: index2 % this.width * this.tilewidth
    };
  }
  /**
   * Find the point of origin (top left) of a tile. Of course, its position depends on the size of the tile
    * @title Get origin position of tile
   * @method map.getTileOriginPosition(x,y)
   * @param {number} x Position X
   * @param {number} x Position Y
   * @returns { {x: number, y: number }}
   * @example
   *  ```ts
   *  // If the size of a tile is 32x32px
   *  const position = map.getTileOriginPosition(35, 12)
   *  console.log(position) // { x: 32, y: 0 }
   *  ```
   * @memberof Map
   * @memberof RpgSceneMap
   */
  getTileOriginPosition(x2, y2) {
    return {
      x: Math.floor(x2 / this.tilewidth) * this.tilewidth,
      y: Math.floor(y2 / this.tileheight) * this.tileheight
    };
  }
  /**
  * Recover tiles according to a position
   * @title Get tile by position
  * @method map.getTileByPosition(x,y)
  * @param {number} x Position X
  * @param {number} x Position Y
  * @returns {TileInfo}
  * @example
  *  ```ts
  *  const tiles = map.getTileByPosition(0, 0)
  *  ```
  * @memberof Map
  * @memberof RpgSceneMap
  */
  getTileByPosition(x2, y2, z2 = [0, 0], options = {}) {
    const tileIndex = this.getTileIndex(x2, y2, [z2[0]]);
    return this.getTileByIndex(tileIndex, z2, options);
  }
  /**
   * Retrieves tiles according to its index
    * @title Get tile by index
   * @method map.getTileByIndex(tileIndex)
   * @param {number} tileIndex tile index
   * @returns {TileInfo}
   * @example
   *  ```ts
   *  const index = map.getTileIndex(0, 0)
   *  const tiles = map.getTileByIndex(index)
   *  ```
   * @memberof Map
   * @memberof RpgSceneMap
   */
  getTileByIndex(tileIndex, zPlayer = [0, 0], options = {
    populateTiles: true
  }) {
    const zA = Math.floor(zPlayer[0] / this.zTileHeight);
    Math.floor(zPlayer[1] / this.zTileHeight);
    const level = this.tilesIndex[zA];
    const obj = {
      tiles: [],
      hasCollision: true,
      isOverlay: false,
      objectGroups: [],
      tileIndex
    };
    if (!level) {
      return obj;
    }
    const [layer] = this.layers;
    const getTileByPointer = (pointer = 0) => {
      const pos = tileIndex * this.realAllocateMemory + pointer;
      const gid = level[pos];
      if (gid === 0) {
        return obj;
      }
      const tile2 = layer.createTile(gid, tileIndex, level[pos + 1]);
      if (tile2)
        obj.tiles.push(tile2);
    };
    if (options.populateTiles) {
      for (let i2 = 0; i2 < this.realAllocateMemory; i2 += 2) {
        getTileByPointer(i2);
      }
    } else {
      getTileByPointer();
    }
    const [tile] = obj.tiles;
    if (tile) {
      obj.hasCollision = tile.getProperty("collision", false);
      obj.objectGroups = tile.objects ?? [];
    }
    return obj;
  }
  getAllObjects() {
    return this.layers.reduce((prev2, current) => {
      if (!current.objects)
        return prev2;
      return prev2.concat(...current.objects);
    }, []);
  }
  getData() {
    return {
      ...this.data,
      layers: this.layers
    };
  }
  setTile(x2, y2, layerFilter, tileInfo) {
    if (this.lowMemory) {
      throw "Impossible to change a tile with the lowMemory option";
    }
    const tileIndex = this.getTileIndex(x2, y2);
    let fnFilter;
    let tilesEdited = {};
    if (typeof layerFilter == "string") {
      fnFilter = (layer) => layer.name == layerFilter;
    } else {
      fnFilter = layerFilter;
    }
    for (let i2 = 0; i2 < this.layers.length; i2++) {
      const layer = this.layers[i2];
      if (!fnFilter(layer))
        continue;
      let tile;
      const oldTile = this.getTileByIndex(tileIndex);
      if (tileInfo.gid) {
        tile = layer.createTile(tileInfo.gid, tileIndex);
      }
      if (!tile)
        continue;
      for (let key in tileInfo) {
        if (key == "gid")
          continue;
        tile[key] = tileInfo[key];
      }
      tilesEdited[layer.name] = {
        gid: tile.gid,
        properties: tile.properties
      };
      this.setTileIndex(layer, oldTile.tiles[0], tile, tileIndex, i2);
      layer.setData(tileIndex, tile.gid);
    }
    return {
      x: x2,
      y: y2,
      tiles: tilesEdited
    };
  }
  removeCacheTileset(name) {
    delete bufferTilesets[name];
  }
  clearCacheTilesets() {
    bufferTilesets = {};
  }
  mapTilesets() {
    this.tilesets = this.tilesets.map((tileset) => {
      if (bufferTilesets[tileset.name]) {
        const instance = bufferTilesets[tileset.name];
        instance.firstgid = tileset.firstgid;
        return instance;
      }
      const _tileset = new Tileset(tileset);
      bufferTilesets[_tileset.name] = _tileset;
      return _tileset;
    });
  }
  mapLayers(layers = [], parent) {
    for (let layer of layers) {
      const layerInstance = new Layer(layer, this.tilesets, parent);
      this.tmpLayers.push(layerInstance);
      if (layer.layers) {
        this.mapLayers(layer.layers, layerInstance);
      }
    }
    if (this.lowMemory)
      this.allocateMemory = 1;
    if (!this.allocateMemory)
      this.allocateMemory = this.layers.length;
  }
  setTileIndex(layer, oldTile, newTile, tileIndex, layerIndex) {
    const startPos = tileIndex * this.realAllocateMemory;
    let pointer = startPos + this.realAllocateMemory - 2;
    const zLayer = layer.getProperty("z", 0);
    const zTile = oldTile.getProperty("z", 0);
    let z2 = zLayer + zTile;
    while (pointer >= startPos) {
      const zlayer = this.tilesIndex[z2];
      if (zlayer[pointer] === oldTile.gid && zlayer[pointer + 1] === layerIndex) {
        this.tilesIndex[z2][pointer] = newTile.gid;
      }
      pointer -= 2;
    }
  }
  /**
   * We multiply by 2 because 2 entries are stored for a tile: its GID and the Layer Index
   *
   * Example If I have 3 layers, The array will have the following form
   *
   * [
   *  GID of Layer 3,
   *  Layer Index of Layer 3,
   *  GID of Layer 2,
   *  Layer Index of Layer 2,
   *  GID of Layer 1,
   *  Layer Index of Layer 1,
   * ... others tiles
   * ]
   *
   * The size in memory of the map is therefore:
   *
   * `(map width * map height * number of layers * 4) bytes`
   *
   * > We multiply by 4, because an element takes 2 bytes and has 2 elements for a tile is 4 bytes in all
   *
   * Example (a 100x100 map with 5 layers)
   *
   * `100 * 100 * 5 * 4 = 200000 bytes = ~195 Kb`
   *
   * If we define on lowMemory then the calculation is the following
   *
   * `(map width * map height * 4) bytes`
   *
   * Example
   *
   * `100 * 100 * 4 = 40000 bytes = ~39 Kb`
   */
  get realAllocateMemory() {
    return this.allocateMemory * 2;
  }
  /**
   * We keep each tile in memory classified by z value. The values are ordered from the end to the beginning so that the first element of the array (when retrieved with getTileByIndex() is the tile on the highest layer. This way, the tile search is very fast for collisions
   *
   */
  addTileIndex(layer, tile, tileIndex, layerIndex) {
    if (!tile || tile && tile.gid == 0) {
      return;
    }
    const zLayer = layer.getProperty("z", 0);
    const zTile = tile.getProperty("z", 0);
    let z2 = zLayer + zTile;
    if (!this.tilesIndex[z2]) {
      const buffer2 = new ArrayBuffer(layer.size * this.realAllocateMemory * 2);
      this.tilesIndex[z2] = new Uint16Array(buffer2);
    }
    const startPos = tileIndex * this.realAllocateMemory;
    let pointer = startPos + this.realAllocateMemory - 2;
    while (this.tilesIndex[z2][pointer] !== 0 && pointer > startPos) {
      pointer -= 2;
    }
    this.tilesIndex[z2][pointer] = tile.gid;
    this.tilesIndex[z2][pointer + 1] = layerIndex;
    this.tilesIndex[z2][startPos] = tile.gid;
    this.tilesIndex[z2][startPos + 1] = layerIndex;
  }
  setTilesIndex() {
    for (let i2 = 0; i2 < this.layers.length; i2++) {
      const layer = this.layers[i2];
      if (layer.type != TiledLayerType.Tile) {
        continue;
      }
      layer.tilesForEach((tile, index2) => {
        this.addTileIndex(layer, tile, index2, i2);
      });
    }
  }
}
class Vector2d {
  constructor(x2, y2, z2 = 0) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
  }
  set(vector) {
    this.x = vector.x;
    this.y = vector.y;
    this.z = vector.z;
    return this;
  }
  add(vector) {
    this.x += vector.x;
    this.y += vector.y;
    return this;
  }
  subtract(vector) {
    this.x -= vector.x;
    this.y -= vector.y;
    return this;
  }
  multiply(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(scalar) {
    this.x /= scalar;
    this.y /= scalar;
    return this;
  }
  distanceWith(vector) {
    const dx = this.x - vector.x;
    const dy = this.y - vector.y;
    return Math.sqrt(dx ** 2 + dy ** 2);
  }
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  copy() {
    return new Vector2d(this.x, this.y, this.z);
  }
  normalize() {
    return this.divide(this.magnitude());
  }
  isEqual(vector) {
    return this.x === vector.x && this.y === vector.y && this.z === vector.z;
  }
  hasDifferentValues(vector) {
    return this.x !== vector.x || this.y !== vector.y || this.z !== vector.z;
  }
}
class Vector2dZero extends Vector2d {
  constructor() {
    super(0, 0);
  }
}
var ShapePositioning;
(function(ShapePositioning2) {
  ShapePositioning2["Default"] = "default";
  ShapePositioning2["Center"] = "center";
})(ShapePositioning || (ShapePositioning = {}));
class RpgShape extends TiledObjectClass {
  constructor(obj) {
    super();
    this.type = HitType.Box;
    this.class = "";
    this.name = "";
    this.playersIn = {};
    this.clientContainer = null;
    this.positioning = ShapePositioning.Default;
    this.components = [];
    Reflect.deleteProperty(obj, "id");
    this.set(obj);
  }
  setPos(type, val) {
    if (!this.hitbox.pos)
      return;
    if (this.isShapePosition()) {
      this.hitbox[type] = val;
    } else {
      this.hitbox.pos[type] = val;
    }
  }
  get hasCollision() {
    return this.getProperty("collision", false);
  }
  // alias
  get id() {
    return this.name;
  }
  get hitbox() {
    if (this.fixEvent) {
      this._hitbox.pos.x = this.fixEvent.position.x;
      this._hitbox.pos.y = this.fixEvent.position.y;
      switch (this.positioning) {
        case ShapePositioning.Center:
          this._hitbox.pos.x -= this._hitbox.w / 2 - this.fixEvent.hitbox.w / 2;
          this._hitbox.pos.y -= this._hitbox.h / 2 - this.fixEvent.hitbox.h / 2;
          break;
      }
    }
    return this._hitbox;
  }
  set hitbox(val) {
    this._hitbox = val;
  }
  /**
  * Get/Set width
  * @title width
  * @prop { number } width
  * @since 3.0.0-beta.5
  * @memberof Shape
  */
  get width() {
    return this.hitbox.w || 0;
  }
  set width(val) {
    this.setPos("w", val);
  }
  /**
  * Get/Set height
  * @title height
  * @prop { number } height
  * @since 3.0.0-beta.5
  * @memberof Shape
  */
  get height() {
    return this.hitbox.h || 0;
  }
  set height(val) {
    this.setPos("h", val);
  }
  /**
  * Get/Set x
  * @title x
  * @prop { number } x
  * @memberof Shape
  */
  get x() {
    return this.hitbox.x || this.hitbox.pos.x;
  }
  set x(val) {
    this.setPos("x", val);
  }
  get z() {
    return this.getProperty("z");
  }
  /**
  * Get/Set y
  * @title y
  * @prop { number } y
  * @memberof Shape
  */
  get y() {
    return this.hitbox.y || this.hitbox.pos.y;
  }
  set y(val) {
    this.setPos("y", val);
  }
  get position() {
    return new Vector2d(this.x, this.y, this.z);
  }
  /**
  * Get/Set properties
   * @title Properties
  * @prop { object } Properties
  * @memberof Shape
  */
  isEvent() {
    return this.type == PlayerType.Event;
  }
  set(obj) {
    const hit = Hit.getHitbox(obj);
    Object.assign(this, hit);
    const objClone = {
      ...obj
    };
    ["width", "height", "x", "y"].forEach((prop) => Reflect.deleteProperty(objClone, prop));
    Object.assign(this, objClone);
    const findPoint = (prop, isMin) => {
      return this.hitbox.points.sort((a8, b3) => isMin ? a8[prop] - b3[prop] : b3[prop] - a8[prop])[0][prop];
    };
    if (this.type == HitType.Polygon) {
      this.hitbox.minX = findPoint("x", true);
      this.hitbox.maxX = findPoint("x", false);
      this.hitbox.minY = findPoint("y", true);
      this.hitbox.maxY = findPoint("y", false);
    }
    this.positioning = obj.positioning;
    this.fixEvent = obj.fixEvent;
    this.setComponent();
  }
  setComponent() {
    const color = this.getProperty("color");
    const image = this.getProperty("image");
    if (color) {
      this.components = [{
        id: "shape",
        value: {
          fill: color
        }
      }];
      return;
    }
    if (image) {
      this.components = [{
        id: "image",
        value: image
      }];
      return;
    }
    if (this.text) {
      this.components = [{
        id: "text",
        value: this.text.text
      }];
      return;
    }
    if (this.gid) {
      this.components = [{
        id: "tile",
        value: this.gid
      }];
      return;
    }
  }
  getType() {
    return this.class || this.type;
  }
  async in(player) {
    var _a;
    if (!this.playerIsIn(player)) {
      this.playersIn[player.id] = true;
      player.inShapes[this.name] = this;
      await player.execMethod("onInShape", [this]);
      await ((_a = this.fixEvent) == null ? void 0 : _a.execMethod("onDetectInShape", [player, this], this.fixEvent));
      await player.execMethod("onIn", [player], this);
      return true;
    }
    return false;
  }
  async out(player) {
    var _a;
    if (this.playerIsIn(player)) {
      delete this.playersIn[player.id];
      delete player.inShapes[this.name];
      await player.execMethod("onOutShape", [this]);
      await ((_a = this.fixEvent) == null ? void 0 : _a.execMethod("onDetectOutShape", [player, this], this.fixEvent));
      await player.execMethod("onOut", [player], this);
      return true;
    }
    return false;
  }
  /**
   * Whether the player is in this shape
   *
   * @title Player is in this shape ?
   * @method shape.playerIsIn(player)
   * @returns {boolean}
   * @memberof Shape
   */
  playerIsIn(player) {
    return !!this.playersIn[player.id];
  }
  isShapePosition() {
    return this.type !== HitType.Box && this.type !== HitType.Circle && this.type !== HitType.Polygon;
  }
  /**
    * Recover the player with the shape. You must have used the `attachShape()` method on the player
    *
    * @title Get Player Owner
    * @method shape.getPlayerOwner()
    * @returns {RpgPlayer | undefined}
    * @memberof Shape
    */
  getPlayerOwner() {
    return this.fixEvent;
  }
  /**
   * We get the rectangle of a shape (box, circle and polygon). We use in the grid system to recover a shape.
   * Generally we add a margin (size of a tile) to detect if the player enters or leaves a shape
   * @param margin
   * @returns { minX: number, minY: number, maxX: number, maxY: number }
   */
  getSizeBox(margin = 0) {
    if (this.type == HitType.Circle) {
      const radius = this.hitbox.r;
      return {
        minX: this.x - radius - margin,
        maxX: this.x + radius + margin,
        minY: this.y - radius - margin,
        maxY: this.y + radius + margin
      };
    }
    if (this.type == HitType.Polygon) {
      return {
        minX: this.x + this.hitbox.minX - margin,
        maxX: this.x + this.hitbox.maxX + margin,
        minY: this.y + this.hitbox.minY - margin,
        maxY: this.y + this.hitbox.maxY + margin
      };
    }
    return {
      minX: this.x - margin,
      maxX: this.x + this.width + margin,
      minY: this.y - margin,
      maxY: this.y + this.height + margin
    };
  }
}
class VirtualGrid {
  constructor(nbCellWidth, cellWidth, cellHeight) {
    this.nbCellWidth = nbCellWidth;
    this.cellWidth = cellWidth;
    this.cellHeight = cellHeight;
    this.cells = /* @__PURE__ */ new Map();
    this.inverseCells = /* @__PURE__ */ new Map();
  }
  zoom(nbCell) {
    this.nbCellWidth = Math.ceil(this.nbCellWidth / nbCell);
    this.cellWidth *= nbCell;
    this.cellHeight *= nbCell;
    return this;
  }
  getCellIndex(x2, y2) {
    return this.nbCellWidth * Math.floor(y2 / this.cellHeight) + Math.floor(x2 / this.cellWidth);
  }
  getCells(box, cb) {
    const {
      minX,
      minY,
      maxX,
      maxY
    } = box;
    const topLeft = this.getCellIndex(minX, minY);
    const topRight = this.getCellIndex(maxX, minY);
    const bottomLeft = this.getCellIndex(minX, maxY);
    const nbLines = (bottomLeft - topLeft) / this.nbCellWidth + 1;
    for (let j2 = 0; j2 < nbLines; j2++) {
      for (let i2 = topLeft; i2 <= topRight; i2++) {
        const index2 = i2 + j2 * this.nbCellWidth;
        cb(index2);
      }
    }
  }
  getObjectsByBox(box) {
    let objects = [];
    this.getCells(box, (index2) => {
      objects = [...objects, ...this.cells.get(index2) || []];
    });
    return new Set(objects);
  }
  getObjectsById(id) {
    let objects = [];
    const cells = this.inverseCells.get(id);
    cells == null ? void 0 : cells.forEach((index2) => {
      objects = [...objects, ...this.cells.get(index2) || []];
    });
    return new Set(objects);
  }
  clearObjectInCells(id) {
    var _a;
    if (this.inverseCells.has(id)) {
      (_a = this.inverseCells.get(id)) == null ? void 0 : _a.forEach((cellIndex) => {
        var _a2;
        (_a2 = this.cells.get(cellIndex)) == null ? void 0 : _a2.delete(id);
      });
      this.inverseCells.delete(id);
    }
  }
  insertInCells(id, box) {
    this.clearObjectInCells(id);
    const cells = /* @__PURE__ */ new Set();
    this.getCells(box, (index2) => {
      var _a;
      cells.add(index2);
      const memoryCells = this.cells.get(index2);
      if (!memoryCells) {
        this.cells.set(index2, /* @__PURE__ */ new Set());
      }
      (_a = this.cells.get(index2)) == null ? void 0 : _a.add(id);
    });
    this.inverseCells.set(id, cells);
  }
}
var extendStatics = function(d2, b3) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
    d3.__proto__ = b4;
  } || function(d3, b4) {
    for (var p2 in b4)
      if (Object.prototype.hasOwnProperty.call(b4, p2))
        d3[p2] = b4[p2];
  };
  return extendStatics(d2, b3);
};
function __extends(d2, b3) {
  if (typeof b3 !== "function" && b3 !== null)
    throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
  extendStatics(d2, b3);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve2) {
      resolve2(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f3, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f3)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f3 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y2 = 0;
      } finally {
        f3 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2])
      i2[n2] = function(v2) {
        return new Promise(function(a8, b3) {
          q2.push([n2, v2, a8, b3]) > 1 || resume2(n2, v2);
        });
      };
  }
  function resume2(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e3) {
      settle(q2[0][3], e3);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value2) {
    resume2("next", value2);
  }
  function reject(value2) {
    resume2("throw", value2);
  }
  function settle(f3, v2) {
    if (f3(v2), q2.shift(), q2.length)
      resume2(q2[0][0], q2[0][1]);
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve2, reject) {
        v2 = o2[n2](v2), settle(resolve2, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve2, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve2({ value: v3, done: d2 });
    }, reject);
  }
}
function isFunction$3(value2) {
  return typeof value2 === "function";
}
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors2) {
    _super(this);
    this.message = errors2 ? errors2.length + " errors occurred during unsubscription:\n" + errors2.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors2;
  };
});
function arrRemove(arr, item) {
  if (arr) {
    var index2 = arr.indexOf(item);
    0 <= index2 && arr.splice(index2, 1);
  }
}
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors2;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction$3(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e3) {
          errors2 = e3 instanceof UnsubscriptionError ? e3.errors : [e3];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors2 = errors2 !== null && errors2 !== void 0 ? errors2 : [];
              if (err instanceof UnsubscriptionError) {
                errors2 = __spreadArray(__spreadArray([], __read(errors2)), __read(err.errors));
              } else {
                errors2.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors2) {
        throw new UnsubscriptionError(errors2);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value2) {
  return value2 instanceof Subscription || value2 && "closed" in value2 && isFunction$3(value2.remove) && isFunction$3(value2.add) && isFunction$3(value2.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction$3(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    {
      throw err;
    }
  });
}
function noop() {
}
function errorContext(cb) {
  {
    cb();
  }
}
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error2, complete) {
    return new SafeSubscriber(next, error2, complete);
  };
  Subscriber2.prototype.next = function(value2) {
    if (this.isStopped)
      ;
    else {
      this._next(value2);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value2) {
    this.destination.next(value2);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value2) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value2);
      } catch (error2) {
        handleUnhandledError(error2);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error2) {
        handleUnhandledError(error2);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error2) {
        handleUnhandledError(error2);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error2, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction$3(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error2 !== null && error2 !== void 0 ? error2 : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error2) {
  {
    reportUnhandledError(error2);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x2) {
  return x2;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev2, fn) {
      return fn(prev2);
    }, input);
  };
}
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error2, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value2) {
          try {
            next(value2);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve2
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var value2;
      _this.subscribe(function(x2) {
        return value2 = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve2(value2);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value2) {
  return value2 && isFunction$3(value2.next) && isFunction$3(value2.error) && isFunction$3(value2.complete);
}
function isSubscriber(value2) {
  return value2 && value2 instanceof Subscriber || isObserver(value2) && isSubscription(value2);
}
function hasLift(source) {
  return isFunction$3(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init2) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init2(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value2) {
      try {
        onNext(value2);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value2) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value2);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value2) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value2);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value2) {
    _super.prototype.next.call(this, this._value = value2);
  };
  return BehaviorSubject2;
}(Subject);
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay) {
    return this;
  };
  return Action2;
}(Subscription);
var intervalProvider = {
  setInterval: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay) {
    var _a;
    if (delay === void 0) {
      delay = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay != null && this.delay === delay && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error2 = this._execute(state, delay);
    if (error2) {
      return error2;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e3) {
      errored = true;
      errorValue = e3 ? e3 : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);
var Scheduler$1 = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler$1.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error2;
    this._active = true;
    do {
      if (error2 = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error2) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error2;
    }
  };
  return AsyncScheduler2;
}(Scheduler$1);
var asyncScheduler = new AsyncScheduler(AsyncAction);
function isScheduler(value2) {
  return value2 && isFunction$3(value2.schedule);
}
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction$3(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
var isArrayLike = function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
};
function isPromise$1(value2) {
  return isFunction$3(value2 === null || value2 === void 0 ? void 0 : value2.then);
}
function isInteropObservable(input) {
  return isFunction$3(input[observable]);
}
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction$3(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();
function isIterable(input) {
  return isFunction$3(input === null || input === void 0 ? void 0 : input[iterator]);
}
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value2, done2;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value2 = _a.value, done2 = _a.done;
          if (!done2)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value2)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction$3(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise$1(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction$3(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array2) {
  return new Observable(function(subscriber) {
    for (var i2 = 0; i2 < array2.length && !subscriber.closed; i2++) {
      subscriber.next(array2[i2]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value2) {
      if (!subscriber.closed) {
        subscriber.next(value2);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value2 = iterable_1_1.value;
        subscriber.next(value2);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value2, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value2 = asyncIterable_1_1.value;
          subscriber.next(value2);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
  if (delay === void 0) {
    delay = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
function observeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value2);
      }, delay);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay);
    }));
  });
}
function subscribeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay));
  });
}
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i2 = 0;
    return scheduler.schedule(function() {
      if (i2 === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i2++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator$1;
    executeSchedule(subscriber, scheduler, function() {
      iterator$1 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value2;
        var done2;
        try {
          _a = iterator$1.next(), value2 = _a.value, done2 = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done2) {
          subscriber.complete();
        } else {
          subscriber.next(value2);
        }
      }, 0, true);
    });
    return function() {
      return isFunction$3(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return();
    };
  });
}
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise$1(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});
function lastValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve2, reject) {
    var _hasValue = false;
    var _value;
    source.subscribe({
      next: function(value2) {
        _value = value2;
        _hasValue = true;
      },
      error: reject,
      complete: function() {
        if (_hasValue) {
          resolve2(_value);
        } else if (hasConfig) {
          resolve2(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
  });
}
function map$7(project, thisArg) {
  return operate(function(source, subscriber) {
    var index2 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      subscriber.next(project.call(thisArg, value2, index2++));
    }));
  });
}
var isArray$5 = Array.isArray;
function callOrApply(fn, args) {
  return isArray$5(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map$7(function(args) {
    return callOrApply(fn, args);
  });
}
var isArray$4 = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf, objectProto$1 = Object.prototype, getKeys = Object.keys;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray$4(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys2 = getKeys(first_1);
      return {
        args: keys2.map(function(key) {
          return first_1[key];
        }),
        keys: keys2
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto$1;
}
function createObject(keys2, values) {
  return keys2.reduce(function(result, key, i2) {
    return result[key] = values[i2], result;
  }, {});
}
function combineLatest() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), observables = _a.args, keys2 = _a.keys;
  if (observables.length === 0) {
    return from([], scheduler);
  }
  var result = new Observable(combineLatestInit(observables, scheduler, keys2 ? function(values) {
    return createObject(keys2, values);
  } : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length2 = observables.length;
      var values = new Array(length2);
      var active = length2;
      var remainingFirstValues = length2;
      var _loop_1 = function(i3) {
        maybeSchedule(scheduler, function() {
          var source = from(observables[i3], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
            values[i3] = value2;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i2 = 0; i2 < length2; i2++) {
        _loop_1(i2);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index2 = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value2) {
    return active < concurrent ? doInnerSub(value2) : buffer2.push(value2);
  };
  var doInnerSub = function(value2) {
    expand && subscriber.next(value2);
    active++;
    var innerComplete = false;
    innerFrom(project(value2, index2++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction$3(resultSelector)) {
    return mergeMap(function(a8, i2) {
      return map$7(function(b3, ii) {
        return resultSelector(a8, b3, i2, ii);
      })(innerFrom(project(a8, i2)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}
function forkJoin() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), sources = _a.args, keys2 = _a.keys;
  var result = new Observable(function(subscriber) {
    var length2 = sources.length;
    if (!length2) {
      subscriber.complete();
      return;
    }
    var values = new Array(length2);
    var remainingCompletions = length2;
    var remainingEmissions = length2;
    var _loop_1 = function(sourceIndex2) {
      var hasValue = false;
      innerFrom(sources[sourceIndex2]).subscribe(createOperatorSubscriber(subscriber, function(value2) {
        if (!hasValue) {
          hasValue = true;
          remainingEmissions--;
        }
        values[sourceIndex2] = value2;
      }, function() {
        return remainingCompletions--;
      }, void 0, function() {
        if (!remainingCompletions || !hasValue) {
          if (!remainingEmissions) {
            subscriber.next(keys2 ? createObject(keys2, values) : values);
          }
          subscriber.complete();
        }
      }));
    };
    for (var sourceIndex = 0; sourceIndex < length2; sourceIndex++) {
      _loop_1(sourceIndex);
    }
  });
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function filter$1(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index2 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      return predicate.call(thisArg, value2, index2++) && subscriber.next(value2);
    }));
  });
}
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return operate(function(source, subscriber) {
    var activeTask = null;
    var lastValue = null;
    var lastTime = null;
    var emit3 = function() {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        var value2 = lastValue;
        lastValue = null;
        subscriber.next(value2);
      }
    };
    function emitWhenIdle() {
      var targetTime = lastTime + dueTime;
      var now = scheduler.now();
      if (now < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now);
        subscriber.add(activeTask);
        return;
      }
      emit3();
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      lastValue = value2;
      lastTime = scheduler.now();
      if (!activeTask) {
        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, function() {
      emit3();
      subscriber.complete();
    }, void 0, function() {
      lastValue = activeTask = null;
    }));
  });
}
function distinctUntilChanged(comparator2, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator2 = comparator2 !== null && comparator2 !== void 0 ? comparator2 : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      var currentKey = keySelector(value2);
      if (first || !comparator2(previousKey, currentKey)) {
        first = false;
        previousKey = currentKey;
        subscriber.next(value2);
      }
    }));
  });
}
function defaultCompare(a8, b3) {
  return a8 === b3;
}
function finalize(callback) {
  return operate(function(source, subscriber) {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}
function tap(observerOrNext, error2, complete) {
  var tapObserver = isFunction$3(observerOrNext) || error2 || complete ? { next: observerOrNext, error: error2, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value2);
      subscriber.next(value2);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}
const buffer = /* @__PURE__ */ new Map();
const bufferClient = /* @__PURE__ */ new Map();
class RpgCommonMap extends MapClass {
  constructor() {
    super(...arguments);
    this.shapes = {};
  }
  get tileWidth() {
    return this.tilewidth;
  }
  get tileHeight() {
    return this.tileheight;
  }
  /**
   * Retrieves the X position of the map in the world (0 if no world assigned)
   *
   * @title World X Position
   * @prop {number} [worldX]
   * @readonly
   * @since 3.0.0-beta.8
   * @memberof Map
   * */
  get worldX() {
    var _a, _b;
    return ((_b = (_a = this.getInWorldMaps()) == null ? void 0 : _a.getMapInfo(this.id)) == null ? void 0 : _b.x) || 0;
  }
  /**
   * Retrieves the Y position of the map in the world (0 if no world assigned)
   *
   * @title World Y Position
   * @prop {number} [worldY]
   * @readonly
   * @since 3.0.0-beta.8
   * @memberof Map
   * */
  get worldY() {
    var _a, _b;
    return ((_b = (_a = this.getInWorldMaps()) == null ? void 0 : _a.getMapInfo(this.id)) == null ? void 0 : _b.y) || 0;
  }
  /**
   * Memorize the maps so you don't have to make a new request or open a file each time you load a map
   */
  static get buffer() {
    return buffer;
  }
  /**
   * In RPG mode, to avoid confusion with buffer, we have a new variable to memorize the maps
   */
  static get bufferClient() {
    return bufferClient;
  }
  load(data) {
    super.load(data);
    this.gridTiles = new VirtualGrid(this.width, this.tileWidth, this.tileHeight);
    this.grid = new VirtualGrid(this.width, this.tileWidth, this.tileHeight).zoom(10);
    this.gridShapes = new VirtualGrid(this.width, this.tileWidth, this.tileHeight).zoom(20);
  }
  /**
   * Create a shape dynamically on the map
   *
   * Object:
   *  - (number) x: Position X
   *  - (number) y: Position Y
   *  - (number) width: Width
   *  - (number) height: Height
   *  - (object) properties (optionnal):
   *      - (number) z: Position Z
   *      - (hexadecimal) color: Color (shared with client)
   *      - (boolean) collision
   *      - You can your own properties
   *
   * @title Create Shape
   * @since 3.0.0-beta.3
   * @method map.createShape(obj)
   * @param {object} obj
   * @returns {RpgShape}
   * @memberof Map
   */
  createShape(obj) {
    const id = obj.name = obj.name || generateUID();
    const shape = new RpgShape(obj);
    this.shapes[id] = shape;
    if (!shape.isShapePosition()) {
      this.gridShapes.insertInCells(id, shape.getSizeBox(this.tileWidth));
    }
    return this.shapes[id];
  }
  /**
   * Delete a shape
   *
   * @title Delete Shape
   * @method map.removeShape(name)
   * @param {string} name Name of shape
   * @returns {void}
   * @memberof Map
   */
  removeShape(name) {
    delete this.shapes[name];
  }
  clearShapes() {
    this.shapes = {};
  }
  /**
   * Return all shapes on the map
   *
   * @title Get Shapes
   * @method map.getShapes()
   * @returns {RpgShape[]}
   * @memberof Map
   * @memberof RpgSceneMap
   */
  getShapes() {
    return Object.values(this.shapes);
  }
  /**
   * Returns a shape by its name. Returns undefined is nothing is found
   *
   * @title Get Shape by name
   * @method map.getShape(name)
   * @param {string} name Name of shape
   * @returns {RpgShape[] | undefined}
   * @memberof Map
   * @memberof RpgSceneMap
   */
  getShape(name) {
    return this.getShapes().find((shape) => shape.name == name);
  }
  getPositionByShape(filter2) {
    const startsFind = this.getShapes().filter(filter2);
    if (startsFind.length) {
      const start = startsFind[random(0, startsFind.length - 1)];
      return {
        x: start.hitbox.x,
        y: start.hitbox.y,
        z: start.properties.z * this.zTileHeight || 0
      };
    }
    return null;
  }
  /**
   * Get tile and verify collision with hitbox
   * @param hitbox
   * @param x
   * @param y
   * @param z
   * @returns TileInfo
   */
  getTile(hitbox, x2, y2, z2 = [0, 0]) {
    const tile = {
      ...this.getTileByPosition(x2, y2, z2)
    };
    const tilePos = this.getTileOriginPosition(x2, y2);
    if (tile.objectGroups) {
      for (let object of tile.objectGroups) {
        const hit = Hit.getHitbox(object, {
          x: tilePos.x,
          y: tilePos.y
        });
        if (hit.type) {
          const collided = Hit.testPolyCollision(hit.type, hit.hitbox, hitbox);
          if (collided) {
            tile.hasCollision = true;
          }
        }
      }
    }
    return tile;
  }
  /**
   * Assign the map to a world
    * @title Assign the map to a world
   * @method map.setInWorldMaps(name)
   * @param {RpgWorldMaps} worldMap world maps
   * @since 3.0.0-beta.8
   * @memberof Map
   */
  setInWorldMaps(worldMap) {
    this.worldMapParent = worldMap;
  }
  /**
   * Remove this map from the world
   * @title Remove this map from the world
   * @method map.removeFromWorldMaps()
   * @returns {boolean | undefined}
   * @since 3.0.0-beta.8
   * @memberof Map
   */
  removeFromWorldMaps() {
    var _a;
    return (_a = this.worldMapParent) == null ? void 0 : _a.removeMap(this.id);
  }
  /**
  * Recover the world attached to this map (`undefined` if no world attached)
   * @title Get attached World
  * @method map.getInWorldMaps()
  * @return {RpgCommonWorldMaps | undefined}
  * @since 3.0.0-beta.8
  * @memberof Map
  */
  getInWorldMaps() {
    return this.worldMapParent;
  }
  boundingMap(nextPosition, hitbox) {
    let bounding = false;
    if (nextPosition.x < 0) {
      nextPosition.x = 0;
      bounding = true;
    } else if (nextPosition.y < 0) {
      nextPosition.y = 0;
      bounding = true;
    } else if (nextPosition.x > this.widthPx - hitbox.w) {
      nextPosition.x = this.widthPx - hitbox.w;
      bounding = true;
    } else if (nextPosition.y > this.heightPx - hitbox.h) {
      nextPosition.y = this.heightPx - hitbox.h;
      bounding = true;
    }
    return {
      bounding,
      nextPosition
    };
  }
  _createMovingHitbox(gameEngine, tick$, mapId, hitboxes, options = {}) {
    const object = new AbstractObject(gameEngine, Utils.generateUID());
    object.disableVirtualGrid = true;
    object.map = mapId;
    object.speed = options.speed ?? 1;
    let i2 = 0;
    let frame = 0;
    const destroyHitbox$ = new Subject();
    return tick$.pipe(takeUntil(destroyHitbox$), filter$1(() => {
      frame++;
      return frame % object.speed == 0;
    }), map$7(() => {
      const hitbox = hitboxes[i2];
      if (!hitbox) {
        destroyHitbox$.next(object);
        destroyHitbox$.complete();
        return object;
      }
      object.position.x = hitbox.x;
      object.position.y = hitbox.y;
      object.setHitbox(hitbox.width, hitbox.height);
      i2++;
      return object;
    }), mergeMap((object2) => from(object2.isCollided(object2.position, {
      allSearch: true
    }))), map$7(() => object));
  }
}
let EventEmitter$1 = class EventEmitter {
  constructor() {
    this.listeners = {};
    this.listenersOnce = {};
  }
  has(name) {
    return !!this.listeners[name] || !!this.listenersOnce[name];
  }
  once(name, cb) {
    this.listenersOnce[name] = cb;
    return this;
  }
  on(name, cb) {
    if (!this.listeners[name])
      this.listeners[name] = [];
    this.listeners[name].push(cb);
    return this;
  }
  emit(name, data, rest = false) {
    const ret = [];
    if (this.listeners[name]) {
      for (let listener of this.listeners[name]) {
        if (rest)
          ret.push(listener(...data));
        else
          ret.push(listener(data));
      }
    }
    if (this.listenersOnce[name]) {
      if (rest)
        ret.push(this.listenersOnce[name](...data));
      else
        ret.push(this.listenersOnce[name](data));
    }
    return Promise.all(ret.map((val) => {
      if (!isPromise$2(val)) {
        return Promise.resolve(val);
      }
      return val;
    }));
  }
  off(name, listener) {
    if (!listener) {
      delete this.listeners[name];
      delete this.listenersOnce[name];
      return;
    }
    if (this.listeners[name]) {
      const index2 = this.listeners[name].indexOf(listener);
      if (index2 !== -1) {
        this.listeners[name].splice(index2, 1);
      }
    }
  }
  clear() {
    this.listeners = {};
    this.listenersOnce = {};
  }
};
var HookServer;
(function(HookServer2) {
  HookServer2["Start"] = "Server.Start";
  HookServer2["Step"] = "Server.Step";
  HookServer2["Auth"] = "Server.Auth";
  HookServer2["PlayerConnected"] = "Server.onConnected";
  HookServer2["PlayerDisconnected"] = "Server.onDisconnected";
  HookServer2["AddMap"] = "Server.AddMap";
  HookServer2["AddEvent"] = "Server.AddEvent";
  HookServer2["AddWorldMaps"] = "Server.AddWorldMaps";
  HookServer2["AddDatabase"] = "Server.AddDatabase";
  HookServer2["PlayerInput"] = "Server.onInput";
  HookServer2["PlayerJoinMap"] = "Server.onJoinMap";
  HookServer2["PlayerLeaveMap"] = "Server.onLeaveMap";
  HookServer2["PlayerLevelUp"] = "Server.onLevelUp";
  HookServer2["PlayerDead"] = "Server.onDead";
  HookServer2["PlayerInShape"] = "Server.onInShape";
  HookServer2["PlayerOutShape"] = "Server.onOutShape";
  HookServer2["PlayerMove"] = "Server.PlayerMove";
  HookServer2["PlayerCanChangeMap"] = "Server.PlayerCanChangeMap";
  HookServer2["ScalabilityPlayerConnected"] = "Server.ScalabilityPlayerConnected";
  HookServer2["ScalabilityChangeServer"] = "Server.ScalabilityChangeServer";
})(HookServer || (HookServer = {}));
var HookClient;
(function(HookClient2) {
  HookClient2["Start"] = "Client.Start";
  HookClient2["Step"] = "Client.Step";
  HookClient2["Connected"] = "Client.Connected";
  HookClient2["Disconnect"] = "Client.Disconnect";
  HookClient2["ConnectedError"] = "Client.ConnectedError";
  HookClient2["AddSpriteSheet"] = "Client.AddSpriteSheet";
  HookClient2["AddGui"] = "Client.AddGui";
  HookClient2["AddSound"] = "Client.AddSound";
  HookClient2["SendInput"] = "Client.SendInput";
  HookClient2["BeforeSceneLoading"] = "Client.BeforeSceneLoading";
  HookClient2["AfterSceneLoading"] = "Client.AfterSceneLoading";
  HookClient2["SceneMapLoading"] = "Client.SceneMapLoading";
  HookClient2["SceneAddSprite"] = "Client.SceneAddSprite";
  HookClient2["SceneOnChanges"] = "Client.SceneOnChanges";
  HookClient2["SceneDraw"] = "Client.SceneDraw";
  HookClient2["SceneRemoveSprite"] = "Client.SceneRemoveSprite";
  HookClient2["AddSprite"] = "Client.AddSprite";
  HookClient2["RemoveSprite"] = "Client.RemoveSprite";
  HookClient2["UpdateSprite"] = "Client.UpdateSprite";
  HookClient2["ChangesSprite"] = "Client.ChangesSprite";
  HookClient2["WindowResize"] = "Client.WindowResize";
  HookClient2["SpriteMove"] = "Client.SpriteMove";
})(HookClient || (HookClient = {}));
let PluginSystem$1 = class PluginSystem extends EventEmitter$1 {
  constructor() {
    super(...arguments);
    this.customHooks = {};
  }
  customHookExists(name) {
    return this.customHooks[name];
  }
  loadPlugins(plugins, shared, type) {
    if (!plugins)
      return;
    for (let plugin of plugins) {
      if (!plugin)
        continue;
      let plug = [];
      if (!isArray$8(plugin)) {
        plug = [plugin];
      } else {
        plug = plugin;
      }
      const [side, options] = plug;
      if (!side[type])
        continue;
      side[type]({
        RpgPlugin,
        ...shared
      }, options);
    }
  }
  loadServerPlugins(plugins, shared) {
    this.loadPlugins(plugins, shared, "server");
  }
  loadClientPlugins(plugins, shared) {
    this.loadPlugins(plugins, shared, "client");
  }
};
const RpgPlugin = new PluginSystem$1();
class GameWorker {
  constructor(options = {}) {
    this.options = options;
  }
  load() {
    return this;
  }
  call(methodName, data) {
    return this.pool.exec(methodName, [data]);
  }
}
var GameSide;
(function(GameSide2) {
  GameSide2["Server"] = "server";
  GameSide2["Client"] = "client";
  GameSide2["Worker"] = "worker";
})(GameSide || (GameSide = {}));
class RpgCommonGame extends EventEmitter$1 {
  initialize(side) {
    this.side = side;
    this.events = {};
  }
  get isWorker() {
    return this.side == "worker";
  }
  start(world) {
    this.world = world;
  }
  createWorkers(options) {
    return new GameWorker(options);
  }
  addObject(_class, playerId) {
    let event;
    if (!playerId)
      playerId = generateUID();
    if (isClass(_class)) {
      if (this.side == GameSide.Client) {
        event = new _class(this, playerId);
      } else {
        event = new _class(playerId);
      }
    } else {
      event = _class;
    }
    return event;
  }
  addPlayer(playerClass, playerId) {
    const player = this.addObject(playerClass, playerId);
    return player;
  }
  addEvent(eventClass, eventId) {
    const event = this.addObject(eventClass, eventId);
    return event;
  }
  addShape(obj) {
    const id = obj.name = obj.name || generateUID();
    const shape = new RpgShape(obj);
    shape.name = id;
    return shape;
  }
  async processInput(playerId, controls) {
    const player = this.world.getObject(playerId);
    const inputs = [];
    if (!player)
      return {
        player,
        inputs
      };
    while (player.pendingMove.length > 0) {
      const inputData = player.pendingMove.shift();
      let {
        input,
        deltaTimeInt
      } = inputData;
      let moving2 = false;
      if (controls && controls[input]) {
        const control = controls[input];
        const now = Date.now();
        const inputTime = player.inputsTimestamp[input] || 0;
        if (inputTime >= now) {
          continue;
        }
        if (control.delay) {
          let duration;
          let otherControls = [];
          if (typeof control.delay == "number") {
            duration = control.delay;
          } else {
            duration = control.delay.duration;
            if (control.delay.otherControls) {
              otherControls = control.delay.otherControls;
            }
          }
          player.inputsTimestamp[input] = now + duration;
          for (let control2 of otherControls) {
            player.inputsTimestamp[control2] = now + duration;
          }
        }
      }
      if (input == Control.Action) {
        await player.triggerCollisionWith(RpgCommonPlayer.ACTIONS.ACTION);
      } else if (input == Direction.Left || input == Direction.Right || input == Direction.Up || input == Direction.Down) {
        player.moving = true;
        moving2 = true;
        await player.moveByDirection(+input, deltaTimeInt || 1);
      }
      if (this.side == GameSide.Server) {
        await RpgPlugin.emit("Server.onInput", [player, {
          ...inputData,
          moving: moving2
        }], true);
      }
      inputs.push(input);
    }
    return {
      player,
      inputs
    };
  }
}
const ACTIONS = {
  IDLE: 0,
  RUN: 1,
  ACTION: 2
};
class AbstractObject {
  static get ACTIONS() {
    return ACTIONS;
  }
  constructor(gameEngine, playerId) {
    this.gameEngine = gameEngine;
    this.playerId = playerId;
    this.map = "";
    this.height = 0;
    this.width = 0;
    this.direction = 3;
    this.moving = false;
    this.checkCollision = true;
    this.clientModeMove = MoveClientMode.ByDirection;
    this.behavior = Behavior.Direction;
    this.inShapes = {};
    this.disableVirtualGrid = false;
    this.shapes = [];
    this.collisionWith = [];
    this._collisionWithTiles = [];
    this._collisionWithShapes = [];
    this.destroyMove$ = new Subject();
    this._destroy$ = new Subject();
    this._hitboxPos = new SAT.Vector(0, 0);
    this.setHitbox(this.width, this.height);
    this.position = {
      x: 0,
      y: 0,
      z: 0
    };
  }
  get id() {
    return this.playerId;
  }
  set id(str2) {
    this.playerId = str2;
  }
  updateInVirtualGrid() {
    const map2 = this.mapInstance;
    if (map2 && !this.disableVirtualGrid) {
      map2.grid.insertInCells(this.id, this.getSizeMaxShape());
    }
  }
  get canMove() {
    return this.clientModeMove == MoveClientMode.ByDirection;
  }
  set canMove(val) {
    this.clientModeMove = val ? MoveClientMode.ByDirection : MoveClientMode.Disabled;
  }
  /**
   * Get/Set position x, y and z of player
   *
   * z is the depth layer. By default, its value is 0. Collisions and overlays will be performed with other objects on the same z-position.
   *
   * @title Get/Set position
   * @prop { { x: number, y: number, z: number } } position
   * @memberof Player
   */
  set position(val) {
    if (this.isDestroyed)
      return;
    const {
      x: x2,
      y: y2,
      z: z2
    } = val;
    if (!isInstanceOf(val, Vector2d)) {
      val = new Vector2d(x2, y2, z2);
    }
    this._hitboxPos.x = x2;
    this._hitboxPos.y = y2;
    this._hitboxPos.z = z2;
    this.updateInVirtualGrid();
    this._position = new Proxy(val, {
      get: (target, prop) => target[prop],
      set: (target, prop, value2) => {
        this._hitboxPos[prop] = value2;
        target[prop] = value2;
        this.updateInVirtualGrid();
        return true;
      }
    });
  }
  get position() {
    return this._position;
  }
  get worldPositionX() {
    let x2 = this.position.x;
    if (this.mapInstance) {
      x2 += this.mapInstance.worldX;
    }
    return x2;
  }
  get worldPositionY() {
    let y2 = this.position.y;
    if (this.mapInstance) {
      y2 += this.mapInstance.worldY;
    }
    return y2;
  }
  set posX(val) {
    this.position.x = val;
  }
  set posY(val) {
    this.position.y = val;
  }
  set posZ(val) {
    this.position.z = val;
  }
  /** @internal */
  get mapInstance() {
    if (this.gameEngine.side == GameSide.Client) {
      return RpgCommonMap.bufferClient.get(this.map);
    }
    return RpgCommonMap.buffer.get(this.map);
  }
  /**
  *
  * Recovers all the colliding shapes of the current player
  *
  * @title Get Collision of shapes
  * @since 3.2.0
  * @readonly
  * @prop { RpgShape[] } shapes
  * @memberof Player
  * @memberof RpgSpriteLogic
  */
  get shapesCollision() {
    return this._collisionWithShapes;
  }
  /**
  *
  * Recovers all the colliding tiles of the current player
  *
  * @title Get Collision of tiles
  * @since 3.0.0-beta.4
  * @readonly
  * @prop { TileInfo[] } tiles
  * @memberof Player
  * @memberof RpgSpriteLogic
  */
  get tilesCollision() {
    return this._collisionWithTiles;
  }
  /**
   *
   * Recovers all other players and events colliding with the current player's hitbox
   *
   * @title Get Collision of other players/events
   * @since 3.0.0-beta.4
   * @readonly
   * @prop { (RpgPlayer | RpgEvent)[] } otherPlayersCollision
   * @memberof Player
   * @memberof RpgSpriteLogic
   */
  get otherPlayersCollision() {
    return this.collisionWith;
  }
  /**
   * Define the size of the player. You can set the hitbox for collisions
   *
   * ```ts
   * player.setSizes({
   *      width: 32,
   *      height: 32
   * })
   * ```
   *
   * and with hitbox:
   *
   *  ```ts
   * player.setSizes({
   *      width: 32,
   *      height: 32,
   *      hitbox: {
   *          width: 20,
   *          height: 20
   *      }
   * })
   * ```
   *
   * @title Set Sizes
   * @method player.setSizes(key,value)
   * @param { { width: number, height: number, hitbox?: { width: number, height: number } } } obj
   * @deprecated
   * @returns {void}
   * @memberof Player
   */
  setSizes(obj) {
    this.width = obj.width;
    this.height = obj.height;
    if (obj.hitbox) {
      this.hitbox = new SAT.Box(this._hitboxPos, obj.hitbox.width, obj.hitbox.height);
    }
  }
  /**
   * Define the hitbox of the player.
   *
   * ```ts
   * player.setHitbox(20, 20)
   * ```
   *
   * @title Set Hitbox
   * @method player.setHitbox(width,height)
   * @param {number} width
   * @param {number} height
   * @returns {void}
   * @memberof Player
   */
  setHitbox(width, height) {
    const map2 = this.mapInstance;
    if (map2) {
      this.width = map2.tileWidth;
      this.height = map2.tileHeight;
    }
    this.hitbox = new SAT.Box(this._hitboxPos, width, height);
    this.wHitbox = width;
    this.hHitbox = height;
    this.updateInVirtualGrid();
  }
  set wHitbox(val) {
    this.hitbox.w = val;
  }
  set hHitbox(val) {
    this.hitbox.h = val;
  }
  get wHitbox() {
    return this.hitbox.w;
  }
  get hHitbox() {
    return this.hitbox.h;
  }
  directionToAngle(direction) {
    const angle2 = (direction < 2 ? +direction + 2 : direction - 2) * 90;
    return toRadians(angle2);
  }
  /** @internal */
  defineNextPosition(direction, deltaTimeInt) {
    const angle2 = this.directionToAngle(direction);
    const computePosition = (prop) => {
      return this.position[prop] + this.speed * deltaTimeInt * (Math.round(Math[prop == "x" ? "cos" : "sin"](angle2) * 100) / 100);
    };
    const x2 = this.speed < 1 ? computePosition("x") : round$1(computePosition("x"));
    const y2 = this.speed < 1 ? computePosition("y") : round$1(computePosition("y"));
    return new Vector2d(x2, y2, ~~this.position.z);
  }
  /** @internal */
  setPosition({
    x: x2,
    y: y2,
    tileX,
    tileY
  }, move = true) {
    const {
      tileWidth,
      tileHeight
    } = this.mapInstance;
    if (x2 !== void 0)
      this.posX = x2;
    if (y2 !== void 0)
      this.posY = y2;
    if (tileX !== void 0)
      this.posX = tileX * tileWidth;
    if (tileY !== void 0)
      this.posY = tileY * tileHeight;
  }
  /** @internal */
  async triggerCollisionWith(type) {
    let doChanges = false;
    for (let collisionWith of this.collisionWith) {
      if (collisionWith.isDestroyed)
        continue;
      if (collisionWith instanceof RpgShape) {
        const goMap = collisionWith.getProperty("go-map");
        if (goMap && "changeMap" in this)
          await this.changeMap(goMap);
      } else {
        if (type == AbstractObject.ACTIONS.ACTION) {
          if ("onAction" in collisionWith) {
            await collisionWith.execMethod("onAction", [this]);
            doChanges = true;
          }
        } else if ("onPlayerTouch" in collisionWith) {
          await collisionWith.execMethod("onPlayerTouch", [this]);
          doChanges = true;
        }
      }
    }
    if (this.syncChanges && doChanges)
      this.syncChanges();
  }
  /** @internal */
  zCollision(other) {
    const z2 = this.position.z;
    const otherZ = other.position.z;
    return intersection$1([z2, z2 + this.height], [otherZ, otherZ + other.height]);
  }
  /** @internal */
  moveByDirection(direction, deltaTimeInt) {
    const nextPosition = this.defineNextPosition(direction, deltaTimeInt);
    return this.move(nextPosition);
  }
  /**
   * Retrieves a tile and checks if the player has a collision
   *
   * ```ts
   * const tileInfo = player.getTile(20, 30)
   * console.log(tileInfo)
   * ```
   *
   * Example of returns:
   *
   * ```ts
   *   {
   *       tiles: [
   *           {
   *               id: 0,
   *               terrain: [],
   *               probability: null,
   *               properties: [Object],
   *               animations: [],
   *               objectGroups: [],
   *               image: null,
   *               gid: 1
   *           }
   *       ],
   *       hasCollision: false,
   *       isOverlay: undefined,
   *       objectGroups: [],
   *       isClimbable: undefined,
   *       tileIndex: 93
   *   }
   * ```
   *
   * @title Get Tile
   * @since 3.0.0-beta.4
   * @method player.getTile(x,y,z?)
   * @param {number} x
   * @param {number} y
   * @param {number} [z]
   * @returns {object}
   * @memberof Player
   * @memberof RpgSpriteLogic
   */
  getTile(x2, y2, z2 = 0, hitbox) {
    const map2 = this.mapInstance;
    return map2.getTile(hitbox || this.hitbox, x2, y2, [z2, this.height]);
  }
  async collisionObjects(playerSizeBox, hitbox, triggers) {
    const map2 = this.mapInstance;
    if (!map2)
      return true;
    const events2 = this.gameEngine.world.getObjectsOfGroup(this.map, this);
    const objects = map2.grid.getObjectsByBox(playerSizeBox);
    let boolFound = false;
    for (let objectId of objects) {
      if (!events2[objectId])
        continue;
      const event = events2[objectId]["object"] || events2[objectId];
      if (event.id == this.id)
        continue;
      if (!this.zCollision(event))
        continue;
      const collided = Hit.testPolyCollision(HitType.Box, hitbox, event.hitbox);
      for (let shape of this.shapes) {
        await this.collisionWithShape(shape, event);
      }
      for (let shape of event.shapes) {
        await event.collisionWithShape(shape, this);
      }
      if (triggers == null ? void 0 : triggers.near)
        triggers.near(event);
      if (collided) {
        this.collisionWith.push(event);
        this.triggerCollisionWith();
        let throughOtherPlayer = false;
        if (event.type == PlayerType.Player && this.type == PlayerType.Player) {
          if (!(event.throughOtherPlayer || this.throughOtherPlayer)) {
            boolFound = true;
            if (!(triggers == null ? void 0 : triggers.allSearch))
              return true;
          } else {
            throughOtherPlayer = true;
          }
        }
        if (!throughOtherPlayer && !(event.through || this.through)) {
          boolFound = true;
          if (!(triggers == null ? void 0 : triggers.allSearch))
            return true;
        }
      }
      if (boolFound) {
        if (triggers == null ? void 0 : triggers.collision)
          triggers.collision(event);
      }
    }
    return boolFound;
  }
  /** @internal */
  async collisionWithShape(shape, player, nextPosition) {
    const collision = shape.hasCollision;
    const z2 = shape.z;
    if (shape.isShapePosition())
      return false;
    if (z2 !== void 0 && !this.zCollision({
      position: {
        z: z2
      },
      height: this.mapInstance.zTileHeight
    })) {
      return false;
    }
    let position;
    let {
      hitbox
    } = player;
    if (nextPosition) {
      position = nextPosition.copy();
    } else {
      position = player.position.copy();
    }
    const hitboxObj = Hit.createObjectHitbox(position.x, position.y, position.z, hitbox.w, hitbox.h);
    let collided = Hit.testPolyCollision(shape.type, hitboxObj, shape.hitbox);
    const playerPositionSaved = player.position.copy();
    const verifyIfPositionChanged = () => {
      if (this.position.z != playerPositionSaved.z && nextPosition) {
        nextPosition.z = this.position.z;
      }
      if (this.position.x != playerPositionSaved.x || this.position.y != playerPositionSaved.y) {
        return true;
      }
    };
    if (collided) {
      this._collisionWithShapes.push(shape);
      if (!collision)
        await shape.in(player);
      if (verifyIfPositionChanged() === true)
        return true;
      this.triggerCollisionWith();
      if (collision)
        return true;
    } else {
      await shape.out(player);
      if (verifyIfPositionChanged() === true)
        return true;
    }
    return false;
  }
  async collisionShapes(playerSizeBox, nextPosition, triggers) {
    const map2 = this.mapInstance;
    if (!map2)
      return false;
    const shapes = this.gameEngine.world.getShapesOfGroup(this.map);
    const shapesInGrid = this.gameEngine.side == GameSide.Client ? new Set(Object.keys(shapes)) : map2.gridShapes.getObjectsByBox(playerSizeBox);
    let boolFound = false;
    for (let shapeId of shapesInGrid) {
      const shape = shapes[shapeId]["object"] || shapes[shapeId];
      if (triggers == null ? void 0 : triggers.near)
        triggers.near(shape);
      const bool = await this.collisionWithShape(shape, this, nextPosition);
      if (bool) {
        if (triggers == null ? void 0 : triggers.collision)
          triggers.collision(shape);
        boolFound = true;
        if (!(triggers == null ? void 0 : triggers.allSearch))
          return true;
      }
    }
    return boolFound;
  }
  async computeNextPositionByTarget(nextPosition, target) {
    const pullDistance = target.distanceWith(nextPosition);
    if (pullDistance <= this.speed) {
      return nextPosition.set(target);
    }
    const pull2 = target.copy().subtract(nextPosition).multiply(1 / pullDistance);
    const totalPush = new Vector2dZero();
    let contenders = 0;
    const hitbox = Hit.createObjectHitbox(nextPosition.x, nextPosition.y, nextPosition.z, this.hitbox.w, this.hitbox.h);
    const createObstacle = function(x2, y2, radius) {
      const obstacle = new Vector2d(x2, y2);
      let push2 = nextPosition.copy().subtract(obstacle);
      let distance2 = nextPosition.distanceWith(obstacle) - radius - radius;
      if (distance2 < radius * 2 * 10) {
        ++contenders;
        if (distance2 < 1e-4)
          distance2 = 1e-4;
        let weight = 1 / distance2;
        totalPush.add(push2.multiply(weight));
      }
      return obstacle;
    };
    const area2 = this.mapInstance.tileheight * 2;
    this.mapInstance.gridTiles.getCells({
      minX: nextPosition.x - area2,
      maxX: nextPosition.x + area2,
      minY: nextPosition.y - area2,
      maxY: nextPosition.y + area2
    }, (index2) => {
      if (index2 < 0)
        return;
      const pos = this.mapInstance.getTilePosition(index2);
      const hitbox2 = Hit.createObjectHitbox(pos.x, pos.y, nextPosition.z, this.hitbox.w, this.hitbox.h);
      const radius = this.mapInstance.tilewidth / 2;
      const tile = this.getTile(pos.x, pos.y, nextPosition.z, hitbox2);
      if (tile.hasCollision) {
        createObstacle(pos.x, pos.y, radius);
      }
    });
    const playerSizeBox = this.getSizeMaxShape(nextPosition.x, nextPosition.y);
    await this.collisionObjects(playerSizeBox, hitbox, {
      collision: (event) => {
        const {
          x: x2,
          y: y2
        } = event.position;
        createObstacle(x2, y2, event.hitbox.w);
      },
      allSearch: true
    });
    await this.collisionShapes(playerSizeBox, nextPosition, {
      collision: (shape) => {
        const {
          x: x2,
          y: y2
        } = shape.position;
        createObstacle(x2, y2, shape.hitbox.w);
      },
      allSearch: true
    });
    pull2.multiply(Math.max(1, 4 * contenders)).add(totalPush).normalize();
    return nextPosition.add(pull2.multiply(this.speed));
  }
  async isCollided(nextPosition, options = {}) {
    var _a;
    this.collisionWith = [];
    this._collisionWithTiles = [];
    const prevMapId = this.map;
    const hitbox = Hit.createObjectHitbox(nextPosition.x, nextPosition.y, 0, this.hitbox.w, this.hitbox.h);
    const boundingMap = (_a = this.mapInstance) == null ? void 0 : _a.boundingMap(nextPosition, this.hitbox);
    let collided = false;
    if (boundingMap == null ? void 0 : boundingMap.bounding) {
      this.position.set(nextPosition);
      if (!options.allSearch)
        return true;
      else
        collided = true;
    }
    const tileCollision = (x2, y2) => {
      const tile = this.getTile(x2, y2, nextPosition.z, hitbox);
      if (tile.hasCollision) {
        this._collisionWithTiles.push(tile);
        return true;
      }
      return false;
    };
    if (tileCollision(nextPosition.x, nextPosition.y) || tileCollision(nextPosition.x + this.hitbox.w, nextPosition.y) || tileCollision(nextPosition.x, nextPosition.y + this.hitbox.h) || tileCollision(nextPosition.x + this.hitbox.w, nextPosition.y + this.hitbox.h)) {
      if (!options.allSearch)
        return true;
      else
        collided = true;
    }
    if (this.autoChangeMap && this.type == PlayerType.Player) {
      const changeMap = await this.autoChangeMap(nextPosition);
      if (changeMap) {
        return true;
      }
    }
    const playerSizeBox = this.getSizeMaxShape(nextPosition.x, nextPosition.y);
    if (await this.collisionObjects(playerSizeBox, hitbox, options)) {
      if (!options.allSearch)
        return true;
      else
        collided = true;
    }
    if (await this.collisionShapes(playerSizeBox, nextPosition, options)) {
      if (!options.allSearch)
        return true;
      else
        collided = true;
    }
    if (prevMapId != this.map) {
      return true;
    }
    return collided;
  }
  /**
   * Attach a shape to the player (and allow interaction with it)
   *
   * ```ts
   * import { ShapePositioning } from '@rpgjs/server'
   *
   * player.attachShape({
   *      width: 100,
   *      height: 100,
   *      positioning: ShapePositioning.Center
   * })
   * ```
   *
   * @title Attach Shape
   * @method player.attachShape(parameters)
   * @param { { width: number, height: number, positioning?, name?, properties?: object } } obj
   * - positioning: Indicate where the shape is placed.
   * - properties: An object in order to retrieve information when interacting with the shape
   * - name: The name of the shape
   * @since 3.0.0-beta.3
   * @returns {RpgShape}
   * @memberof Player
   */
  attachShape(obj) {
    obj.name = obj.name || generateUID();
    const shape = new RpgShape({
      ...obj,
      fixEvent: this
    });
    this.shapes.push(shape);
    return shape;
  }
  /**
   * Returns all shapes assigned to this player
   *
   * @title Get Shapes
   * @method player.getShapes()
   * @returns {RpgShape[]}
   * @since 3.0.0-beta.3
   * @memberof Player
   * @memberof RpgSpriteLogic
   */
  getShapes() {
    return this.shapes;
  }
  autoChangeDirection(nextPosition) {
    const {
      x: x2,
      y: y2
    } = this.position;
    const {
      x: nx,
      y: ny
    } = nextPosition;
    const diff = Math.abs(x2 - nx) > Math.abs(y2 - ny);
    if (diff) {
      if (nx > x2) {
        this.changeDirection(Direction.Right);
      } else {
        this.changeDirection(Direction.Left);
      }
    } else {
      if (ny > y2) {
        this.changeDirection(Direction.Down);
      } else {
        this.changeDirection(Direction.Up);
      }
    }
  }
  // @internal
  /**
   * We need to know if the event is deleted. Because when the event is deleted, you don't update the positions and you don't send the positions back to the client.
   */
  get isDestroyed() {
    return !!this._destroy$["_closed"];
  }
  /**
  * Stops the movement of the player who moves towards his target
  *
  * @title Stop Move To
  * @method player.stopMoveTo()
  * @returns {void}
  * @since 3.2.0
  * @memberof MoveManager
  */
  stopMoveTo() {
    if (this.destroyMove$.closed)
      return;
    this.moving = false;
    this.destroyMove$.next(true);
    this.destroyMove$.unsubscribe();
  }
  _lookToward(player, otherPlayer) {
    const {
      x: x2,
      y: y2
    } = player;
    const {
      x: ox,
      y: oy
    } = otherPlayer;
    const dx = ox - x2;
    const dy = oy - y2;
    if (Math.abs(dx) > Math.abs(dy)) {
      if (dx > 0) {
        return Direction.Right;
      } else {
        return Direction.Left;
      }
    } else {
      if (dy > 0) {
        return Direction.Down;
      } else {
        return Direction.Up;
      }
    }
  }
  _moveTo(tick$, positionTarget, options = {}) {
    let i2 = 0;
    let count = 0;
    const lastPositions = [];
    this.stopMoveTo();
    this.moving = true;
    this.destroyMove$ = new Subject();
    const {
      infinite,
      onStuck,
      onComplete
    } = options;
    const getPosition = () => {
      let pos;
      if ("x" in positionTarget) {
        pos = new Vector2d(positionTarget.x, positionTarget.y);
      } else {
        pos = positionTarget.position;
      }
      return pos;
    };
    return tick$.pipe(takeUntil(this.destroyMove$), takeUntil(this._destroy$), mergeMap(() => from(this.computeNextPositionByTarget(this.position.copy(), getPosition()))), filter$1(() => {
      return this.isDestroyed === false;
    }), map$7((position) => {
      this.autoChangeDirection(position);
      return this.position.set(position);
    }), tap((position) => {
      lastPositions[i2] = position.copy();
      i2++;
      count++;
      if (i2 >= 3) {
        i2 = 0;
      }
      if (lastPositions[2] && (lastPositions[0].isEqual(lastPositions[2]) || lastPositions[1].isEqual(lastPositions[2]) || lastPositions[0].isEqual(lastPositions[1]))) {
        this.direction = this._lookToward(this.position, getPosition());
        onStuck == null ? void 0 : onStuck(count);
        this.moving = false;
      } else if (this.position.isEqual(getPosition())) {
        onComplete == null ? void 0 : onComplete();
        if (!infinite) {
          this.stopMoveTo();
        }
      } else {
        count = 0;
        this.moving = true;
      }
    }));
  }
  /** @internal */
  async move(nextPosition) {
    this.autoChangeDirection(nextPosition);
    const notCollided = !await this.isCollided(nextPosition);
    if ((notCollided || !this.checkCollision) && !this.isDestroyed) {
      this.position = nextPosition.copy();
      await RpgPlugin.emit(HookServer.PlayerMove, this);
    }
    return true;
  }
  /**
   * Retrieves all shapes where the player is located
   *
   * @title Get In-Shapes
   * @method player.getInShapes()
   * @returns {RpgShape[]}
   * @since 3.0.0-beta.3
   * @memberof Player
   */
  getInShapes() {
    return Object.values(this.inShapes);
  }
  /**
  * Get the current direction.
  *
  * ```ts
  * player.getDirection()
  * ```
  *
  * @title Get Direction
  * @method player.getDirection()
  * @returns {Direction | number} direction
  * @memberof Player
  */
  getDirection(direction) {
    return direction || this.direction;
  }
  /**
  * Changes the player's direction
  *
  * ```ts
  * import { Direction } from '@rpgjs/server'
  *
  * player.changeDirection(Direction.Left)
  * ```
  *
  * @title Change direction
  * @method player.changeDirection(direction)
  * @param {Direction} direction
  * @enum {string}
  *
  * Direction.Left | left
  * Direction.Right | right
  * Direction.Up | up
  * Direction.Down | down
  * @returns {boolean} the direction has changed
  * @memberof Player
  */
  changeDirection(direction) {
    const dir = +this.getDirection(direction);
    if (dir === void 0)
      return false;
    this.direction = dir;
    return true;
  }
  /**
   * Gets the necessary number of pixels to allow the player to cross a tile.
   * This is the ratio between the height or width of the tile and the speed of the player.
   */
  get nbPixelInTile() {
    const direction = this.getDirection();
    switch (direction) {
      case Direction.Down:
      case Direction.Up:
        return Math.floor(this.mapInstance.tileHeight / this.speed);
      case Direction.Left:
      case Direction.Right:
        return Math.floor(this.mapInstance.tileWidth / this.speed);
      default:
        return NaN;
    }
  }
  getSizeMaxShape(x2, y2) {
    const _x = x2 || this.position.x;
    const _y = y2 || this.position.y;
    let minX = _x;
    let minY = _y;
    let maxX = _x + this.wHitbox;
    let maxY = _y + this.hHitbox;
    const shapes = this.getShapes();
    for (let shape of shapes) {
      if (shape.x < minX)
        minX = shape.x;
      if (shape.y < minY)
        minY = shape.y;
      const shapeMaxX = shape.x + shape.width;
      const shapeMaxY = shape.y + shape.height;
      if (shapeMaxX > maxX)
        maxX = shapeMaxX;
      if (shapeMaxY > maxY)
        maxY = shapeMaxY;
    }
    return {
      minX,
      minY,
      maxX,
      maxY
    };
  }
  /** @internal */
  async execMethod(methodName, methodData, instance) {
  }
}
class RpgCommonPlayer extends AbstractObject {
  constructor() {
    super(...arguments);
    this.events = [];
    this.layerName = "";
    this.data = {};
    this.pendingMove = [];
    this.inputsTimestamp = {};
  }
}
var PrebuiltGui;
(function(PrebuiltGui2) {
  PrebuiltGui2["Dialog"] = "rpg-dialog";
  PrebuiltGui2["MainMenu"] = "rpg-main-menu";
  PrebuiltGui2["Shop"] = "rpg-shop";
  PrebuiltGui2["Disconnect"] = "rpg-disconnect";
  PrebuiltGui2["Gameover"] = "rpg-gameover";
  PrebuiltGui2["Save"] = "rpg-save";
  PrebuiltGui2["Controls"] = "rpg-controls";
  PrebuiltGui2["Notification"] = "rpg-notification";
})(PrebuiltGui || (PrebuiltGui = {}));
class MockIo {
  constructor() {
    this.events = /* @__PURE__ */ new Map();
  }
  on(name, value2) {
    this.events.set(name, value2);
  }
  off(name) {
    this.events.delete(name);
  }
  once(name, value2) {
    this.on(name, value2);
  }
  _trigger(name, data, client) {
    const fn = this.events.get(name);
    if (fn)
      fn(data, client);
  }
}
class MockSocket {
  constructor(io, handshake) {
    this.io = io;
    this.handshake = handshake;
    this.id = "" + Math.random();
  }
  on(name, value2) {
    this.io.on(name, value2, this.id);
    return this;
  }
  once(name, value2) {
    this.io.once(name, value2, this.id);
    return this;
  }
  emit(name, data) {
    this.io.emit(name, data, this.id);
  }
  removeAllListeners(name) {
    return this.off(name);
  }
  off(name) {
    this.io.off(name, this.id);
  }
}
class MockServerIo extends MockIo {
  constructor() {
    super(...arguments);
    this.clients = /* @__PURE__ */ new Map();
  }
  connection(client, handshake) {
    const socket = new MockSocket(this, handshake);
    this.clients.set(socket.id, client);
    client.id = socket.id;
    this._trigger("connection", socket);
  }
  emit(name, data, id) {
    var _a;
    (_a = this.clients.get(id)) == null ? void 0 : _a._trigger(name, data);
  }
  clear() {
    this.clients.clear();
  }
}
new MockServerIo();
class Scheduler extends EventEmitter$1 {
  constructor() {
    super(...arguments);
    this.fps = 60;
    this.deltaTime = 0;
    this.frame = 0;
    this.timestamp = 0;
    this.requestedDelay = 0;
    this.lastTimestamp = 0;
    this._tick = new BehaviorSubject({
      timestamp: 0,
      deltaTime: 0,
      frame: 0,
      deltaRatio: 0
    });
    this._stop = false;
  }
  get tick() {
    return this._tick.asObservable();
  }
  nextTick(timestamp) {
    this.lastTimestamp = this.lastTimestamp || this.timestamp;
    this.deltaTime = Utils.preciseNow() - this.timestamp;
    this.timestamp = timestamp;
    this._tick.next({
      timestamp: this.timestamp,
      deltaTime: this.deltaTime,
      frame: this.frame,
      deltaRatio: ~~this.deltaTime / ~~Utils.fps2ms(this.fps)
    });
    this.lastTimestamp = this.timestamp;
    this.frame++;
  }
  /**
   * start the schedule
   * @return {Scheduler} returns this scheduler instance
   */
  start(options) {
    if (options.maxFps)
      this.maxFps = options.maxFps;
    if (options.fps)
      this.fps = options.fps;
    if (options.delay)
      this.requestedDelay = options.delay;
    const requestAnimationFrame2 = (fn) => {
      if (Utils.isBrowser()) {
        window.requestAnimationFrame(fn.bind(this));
      } else {
        setTimeout(() => {
          this.requestedDelay = 0;
          fn(Utils.preciseNow());
        }, Utils.fps2ms(this.fps) + this.requestedDelay);
      }
    };
    if (!this.maxFps) {
      const loop = (timestamp) => {
        requestAnimationFrame2(loop);
        this.nextTick(timestamp);
      };
      requestAnimationFrame2(loop);
    } else {
      const msInterval = Utils.fps2ms(this.maxFps);
      let now = Utils.preciseNow();
      let then = Utils.preciseNow();
      const loop = (timestamp) => {
        if (this._stop)
          return;
        requestAnimationFrame2(loop);
        now = Utils.preciseNow();
        const elapsed = now - then;
        if (elapsed > msInterval) {
          then = now - elapsed % msInterval;
          this.nextTick(timestamp);
        }
      };
      requestAnimationFrame2(loop);
    }
    return this;
  }
  stop() {
    this._stop = true;
    this._tick.complete();
  }
}
function warning(...message) {
  console.warn("[RPGJS Warning]", ...message);
}
var Side;
(function(Side2) {
  Side2["Server"] = "server";
  Side2["Client"] = "client";
})(Side || (Side = {}));
function RpgModule(options) {
  return (target) => {
    if (options.hooks) {
      target.hooks = options.hooks;
    }
    for (let key in options) {
      target.prototype[key] = options[key];
    }
  };
}
async function loadModules(modules, obj, middleware) {
  const {
    side,
    relations
  } = obj;
  let playerProps = {};
  let hooks = {};
  const getModuleClass = (module) => {
    if (!module)
      return null;
    let plug = [];
    if (!isArray$8(module)) {
      plug = [module];
    } else {
      plug = module;
    }
    const [moduleClassSides, options] = plug;
    const moduleClass = moduleClassSides[side];
    if (!moduleClass)
      return null;
    return {
      moduleClass,
      options
    };
  };
  for (let module of modules) {
    const moduleObject = getModuleClass(module);
    if (!moduleObject)
      continue;
    const {
      moduleClass
    } = moduleObject;
    if (moduleClass.hooks) {
      for (let key in moduleClass.hooks) {
        if (!hooks[key])
          hooks[key] = [];
        hooks[key] = [...hooks[key], ...moduleClass.hooks[key]];
      }
    }
  }
  for (let module of modules) {
    const moduleObject = getModuleClass(module);
    if (!moduleObject)
      continue;
    const {
      moduleClass,
      options
    } = moduleObject;
    let mod;
    if (options && side == Side.Client && options[Side.Server]) {
      warning(`Data that may be sensitive (normally visible only on the server side) are made optional and visible on the client side.
Instead, import the configuration with the server! flag into an import. Example: 

import config from 'server!./config

'`, options[Side.Server]);
    }
    if (options && !isClass(moduleClass) && isFunction$5(moduleClass)) {
      mod = new (moduleClass(options[side]))();
    } else if (isClass(moduleClass)) {
      mod = new moduleClass();
    } else {
      mod = moduleClass;
    }
    if (middleware) {
      mod = middleware(mod);
      if (isPromise$2(mod)) {
        mod = await mod;
      }
    }
    const {
      imports,
      maps,
      spritesheets: spritesheets2,
      sounds: sounds2,
      gui,
      scenes,
      engine,
      database,
      worldMaps,
      scalability,
      events: events2
    } = mod;
    if (imports) {
      await loadModules(imports, obj);
    }
    if (maps) {
      RpgPlugin.on(HookServer.AddMap, () => maps);
    }
    if (events2) {
      RpgPlugin.on(HookServer.AddEvent, () => events2);
    }
    if (worldMaps) {
      RpgPlugin.on(HookServer.AddWorldMaps, () => worldMaps);
    }
    if (database) {
      RpgPlugin.on(HookServer.AddDatabase, () => database);
    }
    if (spritesheets2) {
      RpgPlugin.on(HookClient.AddSpriteSheet, () => spritesheets2);
    }
    if (sounds2) {
      RpgPlugin.on(HookClient.AddSound, () => sounds2);
    }
    if (gui) {
      RpgPlugin.on(HookClient.AddGui, () => gui);
    }
    const player = side == Side.Server ? mod.player : mod.sprite;
    const loadRelations = (hook, relationName) => {
      if (!hook)
        return;
      for (let method in relations[relationName]) {
        const hookName = relations[relationName][method];
        if (hook[method])
          RpgPlugin.on(hookName, hook[method]);
      }
      if (hooks[relationName]) {
        for (let methodName of hooks[relationName]) {
          const hookName = side + "." + relationName + "." + methodName;
          RpgPlugin.customHooks[hookName] = true;
          if (hook[methodName])
            RpgPlugin.on(hookName, hook[methodName]);
        }
      }
    };
    loadRelations(player, "player");
    if (player && player.props) {
      playerProps = Object.assign(playerProps, player.props);
    }
    loadRelations(engine, "engine");
    if (scalability)
      loadRelations(scalability._hooks, "scalability");
    if (scenes)
      loadRelations(scenes.map, "sceneMap");
  }
  return {
    playerProps
  };
}
function hexToRGB(hex) {
  let r2 = parseInt(hex.substring(0, 2), 16);
  let g2 = parseInt(hex.substring(2, 4), 16);
  let b3 = parseInt(hex.substring(4, 6), 16);
  return [r2, g2, b3];
}
function RGBToHex(rgb) {
  let r2 = rgb[0].toString(16).padStart(2, "0");
  let g2 = rgb[1].toString(16).padStart(2, "0");
  let b3 = rgb[2].toString(16).padStart(2, "0");
  return r2 + g2 + b3;
}
function transitionColor(startColor, endColor, steps) {
  let startRGB = hexToRGB(startColor.replace("#", ""));
  let endRGB = hexToRGB(endColor.replace("#", ""));
  let deltaRGB = [(endRGB[0] - startRGB[0]) / steps, (endRGB[1] - startRGB[1]) / steps, (endRGB[2] - startRGB[2]) / steps];
  let colors = [];
  for (let i2 = 0; i2 < steps; i2++) {
    let color = [startRGB[0] + deltaRGB[0] * i2, startRGB[1] + deltaRGB[1] * i2, startRGB[2] + deltaRGB[2] * i2];
    colors.push(RGBToHex(color));
  }
  colors.push(endColor.replace("#", ""));
  return colors;
}
const DefaultInput = {
  [Control.Up]: {
    repeat: true,
    bind: Input.Up
  },
  [Control.Down]: {
    repeat: true,
    bind: Input.Down
  },
  [Control.Right]: {
    repeat: true,
    bind: Input.Right
  },
  [Control.Left]: {
    repeat: true,
    bind: Input.Left
  },
  [Control.Action]: {
    bind: [Input.Space, Input.Enter]
  },
  [Control.Back]: {
    bind: Input.Escape
  }
};
class InjectContext {
  constructor() {
    this.instances = /* @__PURE__ */ new Map();
  }
  inject(constructor, args = []) {
    const serviceName = constructor.name;
    if (!this.instances.has(serviceName)) {
      const instance = new constructor(this, ...args);
      if (instance["initialize"]) {
        instance["initialize"](...args);
      }
      this.instances.set(serviceName, instance);
    }
    return this.instances.get(serviceName);
  }
}
const keyCodeTable = {
  3: "break",
  8: "backspace",
  9: "tab",
  12: "clear",
  13: "enter",
  16: "shift",
  17: "ctrl",
  18: "alt",
  19: "pause/break",
  20: "caps lock",
  27: "escape",
  28: "conversion",
  29: "non-conversion",
  32: "space",
  33: "page up",
  34: "page down",
  35: "end",
  36: "home",
  37: Direction.Left,
  38: Direction.Up,
  39: Direction.Right,
  40: Direction.Down,
  41: "select",
  42: "print",
  43: "execute",
  44: "Print Screen",
  45: "insert",
  46: "delete",
  48: "n0",
  49: "n1",
  50: "n2",
  51: "n3",
  52: "n4",
  53: "n5",
  54: "n6",
  55: "n7",
  56: "n8",
  57: "n9",
  58: ":",
  59: "semicolon (firefox), equals",
  60: "<",
  61: "equals (firefox)",
  63: "ß",
  64: "@",
  65: "a",
  66: "b",
  67: "c",
  68: "d",
  69: "e",
  70: "f",
  71: "g",
  72: "h",
  73: "i",
  74: "j",
  75: "k",
  76: "l",
  77: "m",
  78: "n",
  79: "o",
  80: "p",
  81: "q",
  82: "r",
  83: "s",
  84: "t",
  85: "u",
  86: "v",
  87: "w",
  88: "x",
  89: "y",
  90: "z",
  91: "Windows Key / Left ⌘ / Chromebook Search key",
  92: "right window key",
  93: "Windows Menu / Right ⌘",
  96: "numpad 0",
  97: "numpad 1",
  98: "numpad 2",
  99: "numpad 3",
  100: "numpad 4",
  101: "numpad 5",
  102: "numpad 6",
  103: "numpad 7",
  104: "numpad 8",
  105: "numpad 9",
  106: "multiply",
  107: "add",
  108: "numpad period (firefox)",
  109: "subtract",
  110: "decimal point",
  111: "divide",
  112: "f1",
  113: "f2",
  114: "f3",
  115: "f4",
  116: "f5",
  117: "f6",
  118: "f7",
  119: "f8",
  120: "f9",
  121: "f10",
  122: "f11",
  123: "f12",
  124: "f13",
  125: "f14",
  126: "f15",
  127: "f16",
  128: "f17",
  129: "f18",
  130: "f19",
  131: "f20",
  132: "f21",
  133: "f22",
  134: "f23",
  135: "f24",
  144: "num lock",
  145: "scroll lock",
  160: "^",
  161: "!",
  163: "#",
  164: "$",
  165: "ù",
  166: "page backward",
  167: "page forward",
  169: "closing paren (AZERTY)",
  170: "*",
  171: "~ + * key",
  173: "minus (firefox), mute/unmute",
  174: "decrease volume level",
  175: "increase volume level",
  176: "next",
  177: "previous",
  178: "stop",
  179: "play/pause",
  180: "e-mail",
  181: "mute/unmute (firefox)",
  182: "decrease volume level (firefox)",
  183: "increase volume level (firefox)",
  186: "semi-colon / ñ",
  187: "equal sign",
  188: "comma",
  189: "dash",
  190: "period",
  191: "forward slash / ç",
  192: "grave accent / ñ / æ",
  193: "?, / or °",
  194: "numpad period (chrome)",
  219: "open bracket",
  220: "back slash",
  221: "close bracket / å",
  222: "single quote / ø",
  223: "`",
  224: "left or right ⌘ key (firefox)",
  225: "altgr",
  226: "< /git >",
  230: "GNOME Compose Key",
  231: "ç",
  233: "XF86Forward",
  234: "XF86Back",
  240: "alphanumeric",
  242: "hiragana/katakana",
  243: "half-width/full-width",
  244: "kanji",
  255: "toggle touchpad"
};
const directionCode = {
  [Direction.Up]: 1,
  [Direction.Right]: 2,
  [Direction.Down]: 3,
  [Direction.Left]: 4
};
const {
  isArray: isArray$3
} = Utils$1;
const inverse = (obj) => {
  const newObj = {};
  for (let key in obj) {
    const val = obj[key];
    newObj[val] = key;
  }
  return newObj;
};
const inverseKeyCodeTable = inverse(keyCodeTable);
class KeyboardControls {
  constructor(context2) {
    this.context = context2;
    this.clientEngine = this.context.inject(RpgClientEngine$2);
    this.keyState = {};
    this.boundKeys = {};
    this.stop = false;
    this.lastKeyPressed = null;
    this._controlsOptions = {};
    const {
      globalConfig
    } = this.clientEngine;
    this.setupListeners();
    this.setInputs({
      ...DefaultInput,
      ...globalConfig.inputs || {}
    });
  }
  /** @internal */
  preStep() {
    if (this.stop)
      return;
    const boundKeys = Object.keys(this.boundKeys);
    const applyInput = (keyName) => {
      const keyState = this.keyState[keyName];
      if (!keyState)
        return;
      const {
        isDown,
        count
      } = keyState;
      if (isDown) {
        const {
          repeat,
          method
        } = this.boundKeys[keyName].options;
        if (repeat || count == 0) {
          let parameters = this.boundKeys[keyName].parameters;
          if (typeof parameters === "function") {
            parameters = parameters();
          }
          if (method) {
            method(this.boundKeys[keyName]);
          } else {
            this.clientEngine.sendInput(this.boundKeys[keyName].actionName);
          }
          this.keyState[keyName].count++;
        }
      }
    };
    for (let keyName of boundKeys) {
      applyInput(keyName);
    }
  }
  // TODO, merge direction
  directionToAngle() {
    var _a;
    let directionVal = 0;
    let nbFound = 0;
    for (let keyName of Object.keys(this.boundKeys)) {
      if ((_a = this.keyState[keyName]) == null ? void 0 : _a.isDown) {
        if (directionCode[keyName]) {
          this.keyState[keyName] = null;
          directionVal += directionCode[keyName];
          nbFound++;
        }
      }
    }
    if (!nbFound)
      return;
    const index2 = directionVal / nbFound;
    if (this.keyState[index2] !== null) {
      this.keyState[index2] = {
        count: 0,
        isDown: true
      };
    }
    this.keyState[index2].isDown = true;
  }
  setupListeners() {
    document.addEventListener("keydown", (e3) => {
      this.onKeyChange(e3, true);
    });
    document.addEventListener("keyup", (e3) => {
      this.onKeyChange(e3, false);
    });
  }
  bindKey(keys2, actionName, options, parameters) {
    if (!isArray$3(keys2))
      keys2 = [keys2];
    const keyOptions = Object.assign({
      repeat: false
    }, options);
    keys2.forEach((keyName) => {
      this.boundKeys[keyName] = {
        actionName,
        options: keyOptions,
        parameters
      };
    });
  }
  applyKeyDown(name) {
    const code = inverseKeyCodeTable[name];
    const e3 = new Event("keydown");
    e3.keyCode = code;
    this.onKeyChange(e3, true);
  }
  applyKeyUp(name) {
    const code = inverseKeyCodeTable[name];
    const e3 = new Event("keyup");
    e3.keyCode = code;
    this.onKeyChange(e3, false);
  }
  applyKeyPress(name) {
    return new Promise((resolve2) => {
      this.applyKeyDown(name);
      setTimeout(() => {
        this.applyKeyUp(name);
        resolve2();
      }, 200);
    });
  }
  onKeyChange(e3, isDown) {
    e3 = e3 || window.event;
    const keyName = keyCodeTable[e3.keyCode];
    if (keyName && this.boundKeys[keyName]) {
      if (this.keyState[keyName] == null) {
        this.keyState[keyName] = {
          count: 0,
          isDown: true
        };
      }
      this.keyState[keyName].isDown = isDown;
      if (!isDown) {
        this.keyState[keyName].count = 0;
      }
      this.lastKeyPressed = isDown ? e3.keyCode : null;
    }
    if (isDown)
      this.clientEngine.keyChange.next(keyName);
  }
  /**
   * From the name of the entry, we retrieve the control information
   *
   * ```ts
   * import { Input, inject, KeyboardControls } from '@rpgjs/client'
   *
   * const controls = inject(KeyboardControls)
   * controls.getControl(Input.Enter)
    * if (control) {
   *    console.log(control.actionName) // action
   * }
   * ```
   * @title Get Control
   * @method getControl(inputName)
   * @param {string} inputName
   * @returns { { actionName: string, options: any } | undefined }
   * @memberof KeyboardControls
   */
  getControl(inputName) {
    return this.boundKeys[inputName];
  }
  /**
   * Returns all controls
   *
   * @method getControls()
   * @since 4.2.0
   * @returns { { [key: string]: BoundKey } }
   * @memberof KeyboardControls
   */
  getControls() {
    return this.boundKeys;
  }
  /**
   * Triggers an input according to the name of the control
   *
   * ```ts
   * import { Control, inject, KeyboardControls } from '@rpgjs/client'
   *
   * const controls = inject(KeyboardControls)
   * controls.applyControl(Control.Action)
   * ```
   *
   * You can put a second parameter or indicate on whether the key is pressed or released
   *
   * ```ts
   * import { Control, inject, KeyboardControls } from '@rpgjs/client'
   *
   * const controls = inject(KeyboardControls)
   * controls.applyControl(Control.Up, true) // keydown
   * controls.applyControl(Control.Up, false) // keyup
   * ```
   * @title Apply Control
   * @method applyControl(controlName,isDown)
   * @param {string} controlName
   * @param {boolean} [isDown]
   * @returns {Promise<void>}
   * @memberof KeyboardControls
   */
  async applyControl(controlName, isDown) {
    const control = this._controlsOptions[controlName];
    if (control) {
      const input = isArray$3(control.bind) ? control.bind[0] : control.bind;
      if (isDown === void 0) {
        await this.applyKeyPress(input);
      } else if (isDown) {
        this.applyKeyDown(input);
      } else {
        this.applyKeyUp(input);
      }
    }
  }
  /**
   * Stop listening to the inputs. Pressing a key won't do anything
   *
   * @title Stop Inputs
   * @method stopInputs()
   * @returns {void}
   * @memberof KeyboardControls
   */
  stopInputs() {
    this.stop = true;
  }
  /**
   * Listen to the inputs again
   *
   * @title Listen Inputs
   * @method listenInputs()
   * @returns {void}
   * @memberof KeyboardControls
   */
  listenInputs() {
    this.stop = false;
    this.keyState = {};
  }
  /**
   * Assign custom inputs to the scene
   *
   * The object is the following:
   *
   * * the key of the object is the name of the control. Either it is existing controls (Up, Dow, Left, Right, Action, Back) or customized controls
   * * The value is an object representing control information:
   *      * repeat {boolean} The key can be held down to repeat the action. (false by default)
   *      * bind {string | string[]} To which key is linked the control
   *      * method {Function} Function to be triggered. If you do not set this property, the name of the control is sent directly to the server.
   *      * delay {object|number} (since v3.2.0) Indicates how long (in milliseconds) the player can press the key again to perform the action
   *          * delay.duration
   *          * delay.otherControls {string | string[]} Indicates the other controls that will also have the delay at the same time
   *
   * ```ts
   * import { Control, Input, inject, KeyboardControls } from '@rpgjs/client'
   *
   * const controls = inject(KeyboardControls)
   * controls.setInputs({
          [Control.Up]: {
              repeat: true,
              bind: Input.Up
          },
          [Control.Down]: {
              repeat: true,
              bind: Input.Down
          },
          [Control.Right]: {
              repeat: true,
              bind: Input.Right
          },
          [Control.Left]: {
              repeat: true,
              bind: Input.Left
          },
          [Control.Action]: {
              bind: [Input.Space, Input.Enter]
          },
          [Control.Back]: {
              bind: Input.Escape
          },
           // The myscustom1 control is sent to the server when the A key is pressed.
          mycustom1: {
              bind: Input.A
          },
           // the myAction method is executed when the B key is pressed
          mycustom2: {
              bind: Input.B,
              method({ actionName }) {
                  console.log('cool', actionName)
              }
          },
           // The player can redo the action after 400ms
          mycustom3: {
              bind: Input.C,
              delay: 400 // ms
          },
           // The player can redo the action (mycustom4) and the directions after 400ms
          mycustom4: {
              bind: Input.C,
              delay: {
                  duration: 400,
                  otherControls: [Control.Up, Control.Down, Control.Left, Control.Right]
              }
          }
      })
   *
   * ```
   * @enum {string} Control
   *
   * Control.Up | up
   * Control.Down | down
   * Control.Left | left
   * Control.Right | right
   * Control.Action | action
   * Control.Back | back
   *
   * @enum {string} Mouse Event
   *
   * click | Click
   * dblclick | Double Click
   * mousedown | Mouse Down
   * mouseup | Mouse Up
   * mouseover | Mouse Over
   * mousemove | Mouse Move
   * mouseout | Mouse Out
   * contextmenu | Context Menu
   *
   *
   * @enum {string} Input
   *
   * break | Pause
  * backspace | Backspace / Delete
  * tab | Tab
  * clear | Clear
  * enter | Enter
  * shift | Shift
  * ctrl | Control
  * alt | Alt
  * pause/break | Pause / Break
  * caps lock | Caps Lock
  * escape | Escape
  * conversion | Conversion
  * non-conversion | Non-conversion
  * space | Space
  * page up | Page Up
  * page down | Page Down
  * end | End
  * home | Home
  * left | Left Arrow
  * up | Up Arrow
  * right | Right Arrow
  * down | Down Arrow
  * select | Select
  * print | Print
  * execute | Execute
  * Print Screen | Print Screen
  * insert | Insert
  * delete | Delete
  * n0 | 0
  * n1 | 1
  * n2 | 2
  * n3 | 3
  * n4 | 4
  * n5 | 5
  * n6 | 6
  * n7 | 7
  * n8 | 8
  * n9 | 9
  * : | Colon
  * semicolon (firefox), equals | Semicolon (Firefox), Equals
  * < | Less Than
  * equals (firefox) | Equals (Firefox)
  * ß | Eszett
  * @ | At
  * a | A
  * b | B
  * c | C
  * d | D
  * e | E
  * f | F
  * g | G
  * h | H
  * i | I
  * j | J
  * k | K
  * l | L
  * m | M
  * n | N
  * o | O
  * p | P
  * q | Q
  * r | R
  * s | S
  * t | T
  * u | U
  * v | V
  * w | W
  * x | X
  * y | Y
  * z | Z
  * Windows Key / Left ⌘ / Chromebook Search key | Windows Key / Left Command ⌘ / Chromebook Search Key
  * right window key | Right Windows Key
  * Windows Menu / Right ⌘ | Windows Menu / Right Command ⌘
  * numpad 0 | Numpad 0
  * numpad 1 | Numpad 1
  * numpad 2 | Numpad 2
  * numpad 3 | Numpad 3
  * numpad 4 | Numpad 4
  * numpad 5 | Numpad 5
  * numpad 6 | Numpad 6
  * numpad 7 | Numpad 7
  * numpad 8 | Numpad 8
  * numpad 9 | Numpad 9
  * multiply | Multiply
  * add | Add
  * numpad period (firefox) | Numpad Period (Firefox)
  * subtract | Subtract
  * decimal point | Decimal Point
  * divide | Divide
  * f1 | F1
  * f2 | F2
  * f3 | F3
  * f4 | F4
  * f5 | F5
  * f6 | F6
  * f7 | F7
  * f8 | F8
  * f9 | F9
  * f10 | F10
  * f11 | F11
  * f12 | F12
  * f13 | F13
  * f14 | F14
  * f15 | F15
  * f16 | F16
  * f17 | F17
  * f18 | F18
  * f19 | F19
  * f20 | F20
  * f21 | F21
  * f22 | F22
  * f23 | F23
  * f24 | F24
  * num lock | Num Lock
  * scroll lock | Scroll Lock
  * ^ | Caret
  * ! | Exclamation Point
  * # | Hash
  * $ | Dollar Sign
  * ù | Grave Accent U
  * page backward | Page Backward
  * page forward | Page Forward
  * closing paren (AZERTY) | Closing Parenthesis (AZERTY)
  * * | Asterisk
  * ~ + * key | Tilde + Asterisk Key
  * minus (firefox), mute/unmute | Minus (Firefox), Mute/Unmute
  * decrease volume level | Decrease Volume Level
  * increase volume level | Increase Volume Level
  * next | Next
  * previous | Previous
  * stop | Stop
  * play/pause | Play/Pause
  * e-mail | Email
  * mute/unmute (firefox) | Mute/Unmute (Firefox)
  * decrease volume level (firefox) | Decrease Volume Level (Firefox)
  * increase volume level (firefox) | Increase Volume Level (Firefox)
  * semi-colon / ñ | Semicolon / ñ
  * equal sign | Equal Sign
  * comma | Comma
  * dash | Dash
  * period | Period
  * forward slash / ç | Forward Slash / ç
  * grave accent / ñ / æ | Grave Accent / ñ / æ
  * ?, / or ° | ?, / or °
  * numpad period (chrome) | Numpad Period (Chrome)
  * open bracket | Open Bracket
  * back slash | Backslash
  * close bracket / å | Close Bracket / å
  * single quote / ø | Single Quote / ø
  * \` | Backtick
  * left or right ⌘ key (firefox) | Left or Right Command Key (Firefox)
  * altgr | AltGr
  * < /git > | < /git >
  * GNOME Compose Key | GNOME Compose Key
  * ç | ç
  * XF86Forward | XF86Forward
  * XF86Back | XF86Back
  * alphanumeric | Alphanumeric
  * hiragana/katakana | Hiragana/Katakana
  * half-width/full-width | Half-Width/Full-Width
  * kanji | Kanji
  * toggle touchpad | Toggle Touchpad
   *
   * @title Set Inputs
   * @method setInputs(inputs)
   * @param {object} inputs
   * @memberof KeyboardControls
   */
  setInputs(inputs) {
    if (!inputs)
      return;
    this.boundKeys = {};
    let inputsTransformed = {};
    for (let control in inputs) {
      const bind2 = inputs[control].bind;
      const transformBind = Array.isArray(bind2) ? bind2.map((b3) => this.transformDirectionInNumber(b3)) : this.transformDirectionInNumber(bind2);
      inputsTransformed[this.transformDirectionInNumber(control)] = {
        ...inputs[control],
        bind: transformBind
      };
    }
    for (let control in inputsTransformed) {
      const option = inputsTransformed[control];
      const {
        method,
        bind: bind2
      } = option;
      if (method) {
        option.method = method;
      }
      let inputsKey = bind2;
      if (!isArray$3(inputsKey)) {
        inputsKey = [bind2];
      }
      for (let input of inputsKey) {
        this.bindKey(input, control, option);
      }
    }
    this._controlsOptions = inputsTransformed;
  }
  get options() {
    return this._controlsOptions;
  }
  transformDirectionInNumber(direction) {
    switch (direction) {
      case "up":
        return 1;
      case "down":
        return 3;
      case "left":
        return 4;
      case "right":
        return 2;
    }
    return direction;
  }
}
var ENV = /* @__PURE__ */ ((ENV2) => {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
  return ENV2;
})(ENV || {});
var RENDERER_TYPE = /* @__PURE__ */ ((RENDERER_TYPE2) => {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
  return RENDERER_TYPE2;
})(RENDERER_TYPE || {});
var BUFFER_BITS = /* @__PURE__ */ ((BUFFER_BITS2) => {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
  return BUFFER_BITS2;
})(BUFFER_BITS || {});
var BLEND_MODES = /* @__PURE__ */ ((BLEND_MODES2) => {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
  return BLEND_MODES2;
})(BLEND_MODES || {});
var DRAW_MODES = /* @__PURE__ */ ((DRAW_MODES2) => {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  return DRAW_MODES2;
})(DRAW_MODES || {});
var FORMATS = /* @__PURE__ */ ((FORMATS2) => {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  return FORMATS2;
})(FORMATS || {});
var TARGETS = /* @__PURE__ */ ((TARGETS2) => {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  return TARGETS2;
})(TARGETS || {});
var TYPES = /* @__PURE__ */ ((TYPES2) => {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
  return TYPES2;
})(TYPES || {});
var SAMPLER_TYPES = /* @__PURE__ */ ((SAMPLER_TYPES2) => {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
  return SAMPLER_TYPES2;
})(SAMPLER_TYPES || {});
var SCALE_MODES = /* @__PURE__ */ ((SCALE_MODES2) => {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
  return SCALE_MODES2;
})(SCALE_MODES || {});
var WRAP_MODES = /* @__PURE__ */ ((WRAP_MODES2) => {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  return WRAP_MODES2;
})(WRAP_MODES || {});
var MIPMAP_MODES = /* @__PURE__ */ ((MIPMAP_MODES2) => {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
  return MIPMAP_MODES2;
})(MIPMAP_MODES || {});
var ALPHA_MODES = /* @__PURE__ */ ((ALPHA_MODES2) => {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
  return ALPHA_MODES2;
})(ALPHA_MODES || {});
var CLEAR_MODES = /* @__PURE__ */ ((CLEAR_MODES2) => {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
  return CLEAR_MODES2;
})(CLEAR_MODES || {});
var GC_MODES = /* @__PURE__ */ ((GC_MODES2) => {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
  return GC_MODES2;
})(GC_MODES || {});
var PRECISION = /* @__PURE__ */ ((PRECISION2) => {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
  return PRECISION2;
})(PRECISION || {});
var MASK_TYPES = /* @__PURE__ */ ((MASK_TYPES2) => {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
  MASK_TYPES2[MASK_TYPES2["COLOR"] = 4] = "COLOR";
  return MASK_TYPES2;
})(MASK_TYPES || {});
var COLOR_MASK_BITS = /* @__PURE__ */ ((COLOR_MASK_BITS2) => {
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["RED"] = 1] = "RED";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["GREEN"] = 2] = "GREEN";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["BLUE"] = 4] = "BLUE";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["ALPHA"] = 8] = "ALPHA";
  return COLOR_MASK_BITS2;
})(COLOR_MASK_BITS || {});
var MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
  return MSAA_QUALITY2;
})(MSAA_QUALITY || {});
var BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  return BUFFER_TYPE2;
})(BUFFER_TYPE || {});
const BrowserAdapter = {
  createCanvas: (width, height) => {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  },
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (url2, options) => fetch(url2, options),
  parseXML: (xml) => {
    const parser2 = new DOMParser();
    return parser2.parseFromString(xml, "text/xml");
  }
};
const settings = {
  ADAPTER: BrowserAdapter,
  RESOLUTION: 1,
  CREATE_IMAGE_BITMAP: false,
  ROUND_PIXELS: false
};
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function(navigator2) {
  return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
};
function createMatch(userAgent) {
  return function(regex) {
    return regex.test(userAgent);
  };
}
function isMobile$1(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent = nav.userAgent;
  var tmp = userAgent.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  tmp = userAgent.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  var match = createMatch(userAgent);
  var result = {
    apple: {
      phone: match(appleIphone) && !match(windowsPhone),
      ipod: match(appleIpod),
      tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
      universal: match(appleUniversal),
      device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
    },
    amazon: {
      phone: match(amazonPhone),
      tablet: !match(amazonPhone) && match(amazonTablet),
      device: match(amazonPhone) || match(amazonTablet)
    },
    android: {
      phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
      tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
      device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
    },
    windows: {
      phone: match(windowsPhone),
      tablet: match(windowsTablet),
      device: match(windowsPhone) || match(windowsTablet)
    },
    other: {
      blackberry: match(otherBlackBerry),
      blackberry10: match(otherBlackBerry10),
      opera: match(otherOpera),
      firefox: match(otherFirefox),
      chrome: match(otherChrome),
      device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
const isMobileCall = isMobile$1.default ?? isMobile$1;
const isMobile = isMobileCall(globalThis.navigator);
settings.RETINA_PREFIX = /@([0-9\.]+)x/;
settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
var eventemitter3 = { exports: {} };
(function(module) {
  var has2 = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context2, once3) {
    this.fn = fn;
    this.context = context2;
    this.once = once3 || false;
  }
  function addListener3(emitter, event, fn, context2, once3) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context2 || emitter, once3), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter3() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter3.prototype.eventNames = function eventNames2() {
    var names = [], events2, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events2 = this._events) {
      if (has2.call(events2, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events2));
    }
    return names;
  };
  EventEmitter3.prototype.listeners = function listeners2(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
      ee[i2] = handlers[i2].fn;
    }
    return ee;
  };
  EventEmitter3.prototype.listenerCount = function listenerCount2(event) {
    var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
    if (!listeners2)
      return 0;
    if (listeners2.fn)
      return 1;
    return listeners2.length;
  };
  EventEmitter3.prototype.emit = function emit3(event, a12, a23, a32, a42, a52) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners2 = this._events[evt], len = arguments.length, args, i2;
    if (listeners2.fn) {
      if (listeners2.once)
        this.removeListener(event, listeners2.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a12), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a12, a23), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a12, a23, a32), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a12, a23, a32, a42), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a12, a23, a32, a42, a52), true;
      }
      for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length2 = listeners2.length, j2;
      for (i2 = 0; i2 < length2; i2++) {
        if (listeners2[i2].once)
          this.removeListener(event, listeners2[i2].fn, void 0, true);
        switch (len) {
          case 1:
            listeners2[i2].fn.call(listeners2[i2].context);
            break;
          case 2:
            listeners2[i2].fn.call(listeners2[i2].context, a12);
            break;
          case 3:
            listeners2[i2].fn.call(listeners2[i2].context, a12, a23);
            break;
          case 4:
            listeners2[i2].fn.call(listeners2[i2].context, a12, a23, a32);
            break;
          default:
            if (!args)
              for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
            listeners2[i2].fn.apply(listeners2[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter3.prototype.on = function on2(event, fn, context2) {
    return addListener3(this, event, fn, context2, false);
  };
  EventEmitter3.prototype.once = function once3(event, fn, context2) {
    return addListener3(this, event, fn, context2, true);
  };
  EventEmitter3.prototype.removeListener = function removeListener3(event, fn, context2, once3) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn && (!once3 || listeners2.once) && (!context2 || listeners2.context === context2)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events2 = [], length2 = listeners2.length; i2 < length2; i2++) {
        if (listeners2[i2].fn !== fn || once3 && !listeners2[i2].once || context2 && listeners2[i2].context !== context2) {
          events2.push(listeners2[i2]);
        }
      }
      if (events2.length)
        this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter3.prototype.removeAllListeners = function removeAllListeners3(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
  EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
  EventEmitter3.prefixed = prefix;
  EventEmitter3.EventEmitter = EventEmitter3;
  {
    module.exports = EventEmitter3;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter2 = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
var earcut$2 = { exports: {} };
earcut$2.exports = earcut;
earcut$2.exports.default = earcut;
function earcut(data, holeIndices, dim) {
  dim = dim || 2;
  var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev)
    return triangles;
  var minX, minY, maxX, maxY, x2, y2, invSize;
  if (hasHoles)
    outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
  if (data.length > 80 * dim) {
    minX = maxX = data[0];
    minY = maxY = data[1];
    for (var i2 = dim; i2 < outerLen; i2 += dim) {
      x2 = data[i2];
      y2 = data[i2 + 1];
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
  return triangles;
}
function linkedList(data, start, end, dim, clockwise) {
  var i2, last2;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i2 = start; i2 < end; i2 += dim)
      last2 = insertNode(i2, data[i2], data[i2 + 1], last2);
  } else {
    for (i2 = end - dim; i2 >= start; i2 -= dim)
      last2 = insertNode(i2, data[i2], data[i2 + 1], last2);
  }
  if (last2 && equals2(last2, last2.next)) {
    removeNode(last2);
    last2 = last2.next;
  }
  return last2;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  var p2 = start, again;
  do {
    again = false;
    if (!p2.steiner && (equals2(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
      removeNode(p2);
      p2 = end = p2.prev;
      if (p2 === p2.next)
        break;
      again = true;
    } else {
      p2 = p2.next;
    }
  } while (again || p2 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  var stop = ear, prev2, next;
  while (ear.prev !== ear.next) {
    prev2 = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev2.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  var a8 = ear.prev, b3 = ear, c3 = ear.next;
  if (area(a8, b3, c3) >= 0)
    return false;
  var ax = a8.x, bx = b3.x, cx = c3.x, ay = a8.y, by = b3.y, cy = c3.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var p2 = c3.next;
  while (p2 !== a8) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  var a8 = ear.prev, b3 = ear, c3 = ear.next;
  if (area(a8, b3, c3) >= 0)
    return false;
  var ax = a8.x, bx = b3.x, cx = c3.x, ay = a8.y, by = b3.y, cy = c3.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  var p2 = ear.prevZ, n2 = ear.nextZ;
  while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a8 && p2 !== c3 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a8 && n2 !== c3 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  while (p2 && p2.z >= minZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a8 && p2 !== c3 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a8 && n2 !== c3 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  var p2 = start;
  do {
    var a8 = p2.prev, b3 = p2.next.next;
    if (!equals2(a8, b3) && intersects(a8, p2, p2.next, b3) && locallyInside(a8, b3) && locallyInside(b3, a8)) {
      triangles.push(a8.i / dim | 0);
      triangles.push(p2.i / dim | 0);
      triangles.push(b3.i / dim | 0);
      removeNode(p2);
      removeNode(p2.next);
      p2 = start = b3;
    }
    p2 = p2.next;
  } while (p2 !== start);
  return filterPoints(p2);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  var a8 = start;
  do {
    var b3 = a8.next.next;
    while (b3 !== a8.prev) {
      if (a8.i !== b3.i && isValidDiagonal(a8, b3)) {
        var c3 = splitPolygon(a8, b3);
        a8 = filterPoints(a8, a8.next);
        c3 = filterPoints(c3, c3.next);
        earcutLinked(a8, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c3, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b3 = b3.next;
    }
    a8 = a8.next;
  } while (a8 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue2 = [], i2, len, start, end, list;
  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    start = holeIndices[i2] * dim;
    end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue2.push(getLeftmost(list));
  }
  queue2.sort(compareX);
  for (i2 = 0; i2 < queue2.length; i2++) {
    outerNode = eliminateHole(queue2[i2], outerNode);
  }
  return outerNode;
}
function compareX(a8, b3) {
  return a8.x - b3.x;
}
function eliminateHole(hole, outerNode) {
  var bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  var bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
  do {
    if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
      var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        m2 = p2.x < p2.next.x ? p2 : p2.next;
        if (x2 === hx)
          return m2;
      }
    }
    p2 = p2.next;
  } while (p2 !== outerNode);
  if (!m2)
    return null;
  var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
  p2 = m2;
  do {
    if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
      tan = Math.abs(hy - p2.y) / (hx - p2.x);
      if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
        m2 = p2;
        tanMin = tan;
      }
    }
    p2 = p2.next;
  } while (p2 !== stop);
  return m2;
}
function sectorContainsSector(m2, p2) {
  return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  var p2 = start;
  do {
    if (p2.z === 0)
      p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
    p2.prevZ = p2.prev;
    p2.nextZ = p2.next;
    p2 = p2.next;
  } while (p2 !== start);
  p2.prevZ.nextZ = null;
  p2.prevZ = null;
  sortLinked(p2);
}
function sortLinked(list) {
  var i2, p2, q2, e3, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p2 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p2) {
      numMerges++;
      q2 = p2;
      pSize = 0;
      for (i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q2 = q2.nextZ;
        if (!q2)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q2) {
        if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
          e3 = p2;
          p2 = p2.nextZ;
          pSize--;
        } else {
          e3 = q2;
          q2 = q2.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e3;
        else
          list = e3;
        e3.prevZ = tail;
        tail = e3;
      }
      p2 = q2;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y2, minX, minY, invSize) {
  x2 = (x2 - minX) * invSize | 0;
  y2 = (y2 - minY) * invSize | 0;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x2 | y2 << 1;
}
function getLeftmost(start) {
  var p2 = start, leftmost = start;
  do {
    if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
      leftmost = p2;
    p2 = p2.next;
  } while (p2 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
function isValidDiagonal(a8, b3) {
  return a8.next.i !== b3.i && a8.prev.i !== b3.i && !intersectsPolygon(a8, b3) && // dones't intersect other edges
  (locallyInside(a8, b3) && locallyInside(b3, a8) && middleInside(a8, b3) && // locally visible
  (area(a8.prev, a8, b3.prev) || area(a8, b3.prev, b3)) || // does not create opposite-facing sectors
  equals2(a8, b3) && area(a8.prev, a8, a8.next) > 0 && area(b3.prev, b3, b3.next) > 0);
}
function area(p2, q2, r2) {
  return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
}
function equals2(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  var o1 = sign$1(area(p1, q1, p2));
  var o2 = sign$1(area(p1, q1, q2));
  var o3 = sign$1(area(p2, q2, p1));
  var o4 = sign$1(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p2, q2, r2) {
  return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
}
function sign$1(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a8, b3) {
  var p2 = a8;
  do {
    if (p2.i !== a8.i && p2.next.i !== a8.i && p2.i !== b3.i && p2.next.i !== b3.i && intersects(p2, p2.next, a8, b3))
      return true;
    p2 = p2.next;
  } while (p2 !== a8);
  return false;
}
function locallyInside(a8, b3) {
  return area(a8.prev, a8, a8.next) < 0 ? area(a8, b3, a8.next) >= 0 && area(a8, a8.prev, b3) >= 0 : area(a8, b3, a8.prev) < 0 || area(a8, a8.next, b3) < 0;
}
function middleInside(a8, b3) {
  var p2 = a8, inside = false, px = (a8.x + b3.x) / 2, py = (a8.y + b3.y) / 2;
  do {
    if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
      inside = !inside;
    p2 = p2.next;
  } while (p2 !== a8);
  return inside;
}
function splitPolygon(a8, b3) {
  var a23 = new Node(a8.i, a8.x, a8.y), b22 = new Node(b3.i, b3.x, b3.y), an = a8.next, bp = b3.prev;
  a8.next = b3;
  b3.prev = a8;
  a23.next = an;
  an.prev = a23;
  b22.next = a23;
  a23.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i2, x2, y2, last2) {
  var p2 = new Node(i2, x2, y2);
  if (!last2) {
    p2.prev = p2;
    p2.next = p2;
  } else {
    p2.next = last2.next;
    p2.prev = last2;
    last2.next.prev = p2;
    last2.next = p2;
  }
  return p2;
}
function removeNode(p2) {
  p2.next.prev = p2.prev;
  p2.prev.next = p2.next;
  if (p2.prevZ)
    p2.prevZ.nextZ = p2.nextZ;
  if (p2.nextZ)
    p2.nextZ.prevZ = p2.prevZ;
}
function Node(i2, x2, y2) {
  this.i = i2;
  this.x = x2;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
earcut.deviation = function(data, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
  if (hasHoles) {
    for (var i2 = 0, len = holeIndices.length; i2 < len; i2++) {
      var start = holeIndices[i2] * dim;
      var end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
      polygonArea -= Math.abs(signedArea(data, start, end, dim));
    }
  }
  var trianglesArea = 0;
  for (i2 = 0; i2 < triangles.length; i2 += 3) {
    var a8 = triangles[i2] * dim;
    var b3 = triangles[i2 + 1] * dim;
    var c3 = triangles[i2 + 2] * dim;
    trianglesArea += Math.abs(
      (data[a8] - data[c3]) * (data[b3 + 1] - data[a8 + 1]) - (data[a8] - data[b3]) * (data[c3 + 1] - data[a8 + 1])
    );
  }
  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data, start, end, dim) {
  var sum = 0;
  for (var i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
    sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
    j2 = i2;
  }
  return sum;
}
earcut.flatten = function(data) {
  var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
  for (var i2 = 0; i2 < data.length; i2++) {
    for (var j2 = 0; j2 < data[i2].length; j2++) {
      for (var d2 = 0; d2 < dim; d2++)
        result.vertices.push(data[i2][j2][d2]);
    }
    if (i2 > 0) {
      holeIndex += data[i2 - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
};
var earcutExports = earcut$2.exports;
const earcut$1 = /* @__PURE__ */ getDefaultExportFromCjs(earcutExports);
/*! https://mths.be/punycode v1.4.1 by @mathias */
var maxInt = 2147483647;
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter = "-";
var regexNonASCII = /[^\x20-\x7E]/;
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
var errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;
function error(type) {
  throw new RangeError(errors[type]);
}
function map$6(array2, fn) {
  var length2 = array2.length;
  var result = [];
  while (length2--) {
    result[length2] = fn(array2[length2]);
  }
  return result;
}
function mapDomain(string, fn) {
  var parts2 = string.split("@");
  var result = "";
  if (parts2.length > 1) {
    result = parts2[0] + "@";
    string = parts2[1];
  }
  string = string.replace(regexSeparators, ".");
  var labels = string.split(".");
  var encoded = map$6(labels, fn).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  var output = [], counter = 0, length2 = string.length, value2, extra;
  while (counter < length2) {
    value2 = string.charCodeAt(counter++);
    if (value2 >= 55296 && value2 <= 56319 && counter < length2) {
      extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value2);
        counter--;
      }
    } else {
      output.push(value2);
    }
  }
  return output;
}
function digitToBasic(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
  var k4 = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k4 += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k4 + (baseMinusTMin + 1) * delta / (delta + skew));
}
function encode$3(input) {
  var n2, delta, handledCPCount, basicLength, bias, j2, m2, q2, k4, t2, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
  input = ucs2decode(input);
  inputLength = input.length;
  n2 = initialN;
  delta = 0;
  bias = initialBias;
  for (j2 = 0; j2 < inputLength; ++j2) {
    currentValue = input[j2];
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  handledCPCount = basicLength = output.length;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {
      currentValue = input[j2];
      if (currentValue >= n2 && currentValue < m2) {
        m2 = currentValue;
      }
    }
    handledCPCountPlusOne = handledCPCount + 1;
    if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m2 - n2) * handledCPCountPlusOne;
    n2 = m2;
    for (j2 = 0; j2 < inputLength; ++j2) {
      currentValue = input[j2];
      if (currentValue < n2 && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue == n2) {
        for (q2 = delta, k4 = base; ; k4 += base) {
          t2 = k4 <= bias ? tMin : k4 >= bias + tMax ? tMax : k4 - bias;
          if (q2 < t2) {
            break;
          }
          qMinusT = q2 - t2;
          baseMinusT = base - t2;
          output.push(
            stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
          );
          q2 = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q2, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n2;
  }
  return output.join("");
}
function toASCII(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode$3(string) : string;
  });
}
function hasOwnProperty$3(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var isArray$2 = Array.isArray || function(xs) {
  return Object.prototype.toString.call(xs) === "[object Array]";
};
function stringifyPrimitive(v2) {
  switch (typeof v2) {
    case "string":
      return v2;
    case "boolean":
      return v2 ? "true" : "false";
    case "number":
      return isFinite(v2) ? v2 : "";
    default:
      return "";
  }
}
function stringify(obj, sep, eq2, name) {
  sep = sep || "&";
  eq2 = eq2 || "=";
  if (obj === null) {
    obj = void 0;
  }
  if (typeof obj === "object") {
    return map$5(objectKeys(obj), function(k4) {
      var ks = encodeURIComponent(stringifyPrimitive(k4)) + eq2;
      if (isArray$2(obj[k4])) {
        return map$5(obj[k4], function(v2) {
          return ks + encodeURIComponent(stringifyPrimitive(v2));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k4]));
      }
    }).join(sep);
  }
  if (!name)
    return "";
  return encodeURIComponent(stringifyPrimitive(name)) + eq2 + encodeURIComponent(stringifyPrimitive(obj));
}
function map$5(xs, f3) {
  if (xs.map)
    return xs.map(f3);
  var res = [];
  for (var i2 = 0; i2 < xs.length; i2++) {
    res.push(f3(xs[i2], i2));
  }
  return res;
}
var objectKeys = Object.keys || function(obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key))
      res.push(key);
  }
  return res;
};
function parse$2(qs, sep, eq2, options) {
  sep = sep || "&";
  eq2 = eq2 || "=";
  var obj = {};
  if (typeof qs !== "string" || qs.length === 0) {
    return obj;
  }
  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1e3;
  if (options && typeof options.maxKeys === "number") {
    maxKeys = options.maxKeys;
  }
  var len = qs.length;
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }
  for (var i2 = 0; i2 < len; ++i2) {
    var x2 = qs[i2].replace(regexp, "%20"), idx = x2.indexOf(eq2), kstr, vstr, k4, v2;
    if (idx >= 0) {
      kstr = x2.substr(0, idx);
      vstr = x2.substr(idx + 1);
    } else {
      kstr = x2;
      vstr = "";
    }
    k4 = decodeURIComponent(kstr);
    v2 = decodeURIComponent(vstr);
    if (!hasOwnProperty$3(obj, k4)) {
      obj[k4] = v2;
    } else if (isArray$2(obj[k4])) {
      obj[k4].push(v2);
    } else {
      obj[k4] = [obj[k4], v2];
    }
  }
  return obj;
}
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
  "javascript": true,
  "javascript:": true
}, hostlessProtocol = {
  "javascript": true,
  "javascript:": true
}, slashedProtocol = {
  "http": true,
  "https": true,
  "ftp": true,
  "gopher": true,
  "file": true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url2, parseQueryString, slashesDenoteHost) {
  if (url2 && isObject$3(url2) && url2 instanceof Url)
    return url2;
  var u2 = new Url();
  u2.parse(url2, parseQueryString, slashesDenoteHost);
  return u2;
}
Url.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
  return parse$1(this, url2, parseQueryString, slashesDenoteHost);
};
function parse$1(self2, url2, parseQueryString, slashesDenoteHost) {
  if (!isString$2(url2)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
  }
  var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url2 = uSplit.join(splitter);
  var rest = url2;
  rest = rest.trim();
  if (!slashesDenoteHost && url2.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      self2.path = rest;
      self2.href = rest;
      self2.pathname = simplePath[1];
      if (simplePath[2]) {
        self2.search = simplePath[2];
        if (parseQueryString) {
          self2.query = parse$2(self2.search.substr(1));
        } else {
          self2.query = self2.search.substr(1);
        }
      } else if (parseQueryString) {
        self2.search = "";
        self2.query = {};
      }
      return self2;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    self2.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      self2.slashes = true;
    }
  }
  var i2, hec, l2, p2;
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (i2 = 0; i2 < hostEndingChars.length; i2++) {
      hec = rest.indexOf(hostEndingChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      self2.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (i2 = 0; i2 < nonHostChars.length; i2++) {
      hec = rest.indexOf(nonHostChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    if (hostEnd === -1)
      hostEnd = rest.length;
    self2.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    parseHost(self2);
    self2.hostname = self2.hostname || "";
    var ipv6Hostname = self2.hostname[0] === "[" && self2.hostname[self2.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = self2.hostname.split(/\./);
      for (i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {
        var part = hostparts[i2];
        if (!part)
          continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j2 = 0, k4 = part.length; j2 < k4; j2++) {
            if (part.charCodeAt(j2) > 127) {
              newpart += "x";
            } else {
              newpart += part[j2];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i2);
            var notHost = hostparts.slice(i2 + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            self2.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (self2.hostname.length > hostnameMaxLen) {
      self2.hostname = "";
    } else {
      self2.hostname = self2.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      self2.hostname = toASCII(self2.hostname);
    }
    p2 = self2.port ? ":" + self2.port : "";
    var h2 = self2.hostname || "";
    self2.host = h2 + p2;
    self2.href += self2.host;
    if (ipv6Hostname) {
      self2.hostname = self2.hostname.substr(1, self2.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (i2 = 0, l2 = autoEscape.length; i2 < l2; i2++) {
      var ae = autoEscape[i2];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }
  var hash = rest.indexOf("#");
  if (hash !== -1) {
    self2.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    self2.search = rest.substr(qm);
    self2.query = rest.substr(qm + 1);
    if (parseQueryString) {
      self2.query = parse$2(self2.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    self2.search = "";
    self2.query = {};
  }
  if (rest)
    self2.pathname = rest;
  if (slashedProtocol[lowerProto] && self2.hostname && !self2.pathname) {
    self2.pathname = "/";
  }
  if (self2.pathname || self2.search) {
    p2 = self2.pathname || "";
    var s2 = self2.search || "";
    self2.path = p2 + s2;
  }
  self2.href = format(self2);
  return self2;
}
function urlFormat(obj) {
  if (isString$2(obj))
    obj = parse$1({}, obj);
  return format(obj);
}
function format(self2) {
  var auth = self2.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol2 = self2.protocol || "", pathname = self2.pathname || "", hash = self2.hash || "", host = false, query = "";
  if (self2.host) {
    host = auth + self2.host;
  } else if (self2.hostname) {
    host = auth + (self2.hostname.indexOf(":") === -1 ? self2.hostname : "[" + this.hostname + "]");
    if (self2.port) {
      host += ":" + self2.port;
    }
  }
  if (self2.query && isObject$3(self2.query) && Object.keys(self2.query).length) {
    query = stringify(self2.query);
  }
  var search = self2.search || query && "?" + query || "";
  if (protocol2 && protocol2.substr(-1) !== ":")
    protocol2 += ":";
  if (self2.slashes || (!protocol2 || slashedProtocol[protocol2]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/")
      pathname = "/" + pathname;
  } else if (!host) {
    host = "";
  }
  if (hash && hash.charAt(0) !== "#")
    hash = "#" + hash;
  if (search && search.charAt(0) !== "?")
    search = "?" + search;
  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace("#", "%23");
  return protocol2 + host + pathname + search + hash;
}
Url.prototype.format = function() {
  return format(this);
};
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};
Url.prototype.resolveObject = function(relative) {
  if (isString$2(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }
  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }
  result.hash = relative.hash;
  if (relative.href === "") {
    result.href = result.format();
    return result;
  }
  if (relative.slashes && !relative.protocol) {
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== "protocol")
        result[rkey] = relative[rkey];
    }
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = "/";
    }
    result.href = result.format();
    return result;
  }
  var relPath;
  if (relative.protocol && relative.protocol !== result.protocol) {
    if (!slashedProtocol[relative.protocol]) {
      var keys2 = Object.keys(relative);
      for (var v2 = 0; v2 < keys2.length; v2++) {
        var k4 = keys2[v2];
        result[k4] = relative[k4];
      }
      result.href = result.format();
      return result;
    }
    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      relPath = (relative.pathname || "").split("/");
      while (relPath.length && !(relative.host = relPath.shift()))
        ;
      if (!relative.host)
        relative.host = "";
      if (!relative.hostname)
        relative.hostname = "";
      if (relPath[0] !== "")
        relPath.unshift("");
      if (relPath.length < 2)
        relPath.unshift("");
      result.pathname = relPath.join("/");
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || "";
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    if (result.pathname || result.search) {
      var p2 = result.pathname || "";
      var s2 = result.search || "";
      result.path = p2 + s2;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }
  var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
  relPath = relative.pathname && relative.pathname.split("/") || [];
  if (psychotic) {
    result.hostname = "";
    result.port = null;
    if (result.host) {
      if (srcPath[0] === "")
        srcPath[0] = result.host;
      else
        srcPath.unshift(result.host);
    }
    result.host = "";
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === "")
          relPath[0] = relative.host;
        else
          relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
  }
  var authInHost;
  if (isRelAbs) {
    result.host = relative.host || relative.host === "" ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
  } else if (relPath.length) {
    if (!srcPath)
      srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.href = result.format();
    return result;
  }
  if (!srcPath.length) {
    result.pathname = null;
    if (result.search) {
      result.path = "/" + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }
  var last2 = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last2 === "." || last2 === "..") || last2 === "";
  var up = 0;
  for (var i2 = srcPath.length; i2 >= 0; i2--) {
    last2 = srcPath[i2];
    if (last2 === ".") {
      srcPath.splice(i2, 1);
    } else if (last2 === "..") {
      srcPath.splice(i2, 1);
      up++;
    } else if (up) {
      srcPath.splice(i2, 1);
      up--;
    }
  }
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift("..");
    }
  }
  if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
    srcPath.unshift("");
  }
  if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
    srcPath.push("");
  }
  var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
    authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }
  mustEndAbs = mustEndAbs || result.host && srcPath.length;
  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift("");
  }
  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join("/");
  }
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};
Url.prototype.parseHost = function() {
  return parseHost(this);
};
function parseHost(self2) {
  var host = self2.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      self2.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host)
    self2.hostname = host;
}
const url$1 = {
  parse: urlParse,
  format: urlFormat,
  resolve: urlResolve
};
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
  }
}
function removeUrlParams(url2) {
  const re2 = url2.split("?")[0];
  return re2.split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str2, find, replace) {
  return str2.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i2 = 0; i2 <= path2.length; ++i2) {
    if (i2 < path2.length) {
      code = path2.charCodeAt(i2);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i2 - 1 || dots === 1)
        ;
      else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i2;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path2.slice(lastSlash + 1, i2)}`;
        } else {
          res = path2.slice(lastSlash + 1, i2);
        }
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const path = {
  toPosix(path2) {
    return replaceAll(path2, "\\", "/");
  },
  isUrl(path2) {
    return /^https?:/.test(this.toPosix(path2));
  },
  isDataUrl(path2) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
  },
  hasProtocol(path2) {
    return /^[^/:]+:\//.test(this.toPosix(path2));
  },
  getProtocol(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let protocol2 = "";
    const isFile2 = /^file:\/\/\//.exec(path2);
    const isHttp = /^[^/:]+:\/\//.exec(path2);
    const isWindows = /^[^/:]+:\//.exec(path2);
    if (isFile2 || isHttp || isWindows) {
      const arr = (isFile2 == null ? void 0 : isFile2[0]) || (isHttp == null ? void 0 : isHttp[0]) || (isWindows == null ? void 0 : isWindows[0]);
      protocol2 = arr;
      path2 = path2.slice(arr.length);
    }
    return protocol2;
  },
  toAbsolute(url2, customBaseUrl, customRootUrl) {
    if (this.isDataUrl(url2))
      return url2;
    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.ADAPTER.getBaseUrl()));
    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
    assertPath(url2);
    url2 = this.toPosix(url2);
    if (url2.startsWith("/")) {
      return path.join(rootUrl, url2.slice(1));
    }
    const absolutePath = this.isAbsolute(url2) ? url2 : this.join(baseUrl, url2);
    return absolutePath;
  },
  normalize(path2) {
    path2 = this.toPosix(path2);
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    let protocol2 = "";
    const isAbsolute = path2.startsWith("/");
    if (this.hasProtocol(path2)) {
      protocol2 = this.rootname(path2);
      path2 = path2.slice(protocol2.length);
    }
    const trailingSeparator = path2.endsWith("/");
    path2 = normalizeStringPosix(path2, false);
    if (path2.length > 0 && trailingSeparator)
      path2 += "/";
    if (isAbsolute)
      return `/${path2}`;
    return protocol2 + path2;
  },
  isAbsolute(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    if (this.hasProtocol(path2))
      return true;
    return path2.startsWith("/");
  },
  join(...segments) {
    if (segments.length === 0) {
      return ".";
    }
    let joined;
    for (let i2 = 0; i2 < segments.length; ++i2) {
      const arg = segments[i2];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === void 0)
          joined = arg;
        else {
          const prevArg = segments[i2 - 1] ?? "";
          if (this.extname(prevArg)) {
            joined += `/../${arg}`;
          } else {
            joined += `/${arg}`;
          }
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    return this.normalize(joined);
  },
  dirname(path2) {
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    path2 = this.toPosix(path2);
    let code = path2.charCodeAt(0);
    const hasRoot = code === 47;
    let end = -1;
    let matchedSlash = true;
    const proto = this.getProtocol(path2);
    const origpath = path2;
    path2 = path2.slice(proto.length);
    for (let i2 = path2.length - 1; i2 >= 1; --i2) {
      code = path2.charCodeAt(i2);
      if (code === 47) {
        if (!matchedSlash) {
          end = i2;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1)
      return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
    if (hasRoot && end === 1)
      return "//";
    return proto + path2.slice(0, end);
  },
  rootname(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let root2 = "";
    if (path2.startsWith("/"))
      root2 = "/";
    else {
      root2 = this.getProtocol(path2);
    }
    if (this.isUrl(path2)) {
      const index2 = path2.indexOf("/", root2.length);
      if (index2 !== -1) {
        root2 = path2.slice(0, index2);
      } else
        root2 = path2;
      if (!root2.endsWith("/"))
        root2 += "/";
    }
    return root2;
  },
  basename(path2, ext2) {
    assertPath(path2);
    if (ext2)
      assertPath(ext2);
    path2 = removeUrlParams(this.toPosix(path2));
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i2;
    if (ext2 !== void 0 && ext2.length > 0 && ext2.length <= path2.length) {
      if (ext2.length === path2.length && ext2 === path2)
        return "";
      let extIdx = ext2.length - 1;
      let firstNonSlashEnd = -1;
      for (i2 = path2.length - 1; i2 >= 0; --i2) {
        const code = path2.charCodeAt(i2);
        if (code === 47) {
          if (!matchedSlash) {
            start = i2 + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i2 + 1;
          }
          if (extIdx >= 0) {
            if (code === ext2.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i2;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path2.length;
      return path2.slice(start, end);
    }
    for (i2 = path2.length - 1; i2 >= 0; --i2) {
      if (path2.charCodeAt(i2) === 47) {
        if (!matchedSlash) {
          start = i2 + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
    }
    if (end === -1)
      return "";
    return path2.slice(start, end);
  },
  extname(path2) {
    assertPath(path2);
    path2 = removeUrlParams(this.toPosix(path2));
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i2 = path2.length - 1; i2 >= 0; --i2) {
      const code = path2.charCodeAt(i2);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i2;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end);
  },
  parse(path2) {
    assertPath(path2);
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path2.length === 0)
      return ret;
    path2 = removeUrlParams(this.toPosix(path2));
    let code = path2.charCodeAt(0);
    const isAbsolute = this.isAbsolute(path2);
    let start;
    ret.root = this.rootname(path2);
    if (isAbsolute || this.hasProtocol(path2)) {
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i2 = path2.length - 1;
    let preDotState = 0;
    for (; i2 >= start; --i2) {
      code = path2.charCodeAt(i2);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i2;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute)
          ret.base = ret.name = path2.slice(1, end);
        else
          ret.base = ret.name = path2.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path2.slice(1, startDot);
        ret.base = path2.slice(1, end);
      } else {
        ret.name = path2.slice(startPart, startDot);
        ret.base = path2.slice(startPart, end);
      }
      ret.ext = path2.slice(startDot, end);
    }
    ret.dir = this.dirname(path2);
    return ret;
  },
  sep: "/",
  delimiter: ":"
};
const warnings = {};
function deprecation(version2, message, ignoreDepth = 3) {
  if (warnings[message]) {
    return;
  }
  let stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version2}`);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${message}
Deprecated since v${version2}`);
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version2}`);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}
function skipHello() {
  deprecation("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello");
}
function sayHello() {
  deprecation("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`);
}
let supported;
function isWebGLSupported() {
  if (typeof supported === "undefined") {
    supported = function supported2() {
      var _a;
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
      };
      try {
        if (!settings.ADAPTER.getWebGLRenderingContext()) {
          return false;
        }
        const canvas = settings.ADAPTER.createCanvas();
        let gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
        const success = !!((_a = gl == null ? void 0 : gl.getContextAttributes()) == null ? void 0 : _a.stencil);
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e3) {
        return false;
      }
    }();
  }
  return supported;
}
var r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, t = function(r2) {
  return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
}, n = function(r2, t2, n2) {
  return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
}, e$1 = function(r2, t2, n2) {
  return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
}, u = function(r2) {
  return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
}, a$1 = function(r2) {
  return { r: e$1(r2.r, 0, 255), g: e$1(r2.g, 0, 255), b: e$1(r2.b, 0, 255), a: e$1(r2.a) };
}, o$1 = function(r2) {
  return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
}, i$3 = /^#([0-9a-f]{3,8})$/i, s = function(r2) {
  var t2 = r2.toString(16);
  return t2.length < 2 ? "0" + t2 : t2;
}, h$1 = function(r2) {
  var t2 = r2.r, n2 = r2.g, e3 = r2.b, u2 = r2.a, a8 = Math.max(t2, n2, e3), o2 = a8 - Math.min(t2, n2, e3), i2 = o2 ? a8 === t2 ? (n2 - e3) / o2 : a8 === n2 ? 2 + (e3 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
  return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a8 ? o2 / a8 * 100 : 0, v: a8 / 255 * 100, a: u2 };
}, b$2 = function(r2) {
  var t2 = r2.h, n2 = r2.s, e3 = r2.v, u2 = r2.a;
  t2 = t2 / 360 * 6, n2 /= 100, e3 /= 100;
  var a8 = Math.floor(t2), o2 = e3 * (1 - n2), i2 = e3 * (1 - (t2 - a8) * n2), s2 = e3 * (1 - (1 - t2 + a8) * n2), h2 = a8 % 6;
  return { r: 255 * [e3, i2, o2, o2, s2, e3][h2], g: 255 * [s2, e3, e3, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e3, e3, i2][h2], a: u2 };
}, g$1 = function(r2) {
  return { h: u(r2.h), s: e$1(r2.s, 0, 100), l: e$1(r2.l, 0, 100), a: e$1(r2.a) };
}, d$1 = function(r2) {
  return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
}, f$2 = function(r2) {
  return b$2((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e3 = t2.l) < 50 ? e3 : 100 - e3) / 100) > 0 ? 2 * n2 / (e3 + n2) * 100 : 0, v: e3 + n2, a: t2.a }));
  var t2, n2, e3;
}, c$2 = function(r2) {
  return { h: (t2 = h$1(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e3 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e3 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
  var t2, n2, e3, u2;
}, l$1 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, p$1 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, m$2 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, y = { string: [[function(r2) {
  var t2 = i$3.exec(r2);
  return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(r2) {
  var t2 = v.exec(r2) || m$2.exec(r2);
  return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a$1({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
}, "rgb"], [function(t2) {
  var n2 = l$1.exec(t2) || p$1.exec(t2);
  if (!n2)
    return null;
  var e3, u2, a8 = g$1({ h: (e3 = n2[1], u2 = n2[2], void 0 === u2 && (u2 = "deg"), Number(e3) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
  return f$2(a8);
}, "hsl"]], object: [[function(r2) {
  var n2 = r2.r, e3 = r2.g, u2 = r2.b, o2 = r2.a, i2 = void 0 === o2 ? 1 : o2;
  return t(n2) && t(e3) && t(u2) ? a$1({ r: Number(n2), g: Number(e3), b: Number(u2), a: Number(i2) }) : null;
}, "rgb"], [function(r2) {
  var n2 = r2.h, e3 = r2.s, u2 = r2.l, a8 = r2.a, o2 = void 0 === a8 ? 1 : a8;
  if (!t(n2) || !t(e3) || !t(u2))
    return null;
  var i2 = g$1({ h: Number(n2), s: Number(e3), l: Number(u2), a: Number(o2) });
  return f$2(i2);
}, "hsl"], [function(r2) {
  var n2 = r2.h, a8 = r2.s, o2 = r2.v, i2 = r2.a, s2 = void 0 === i2 ? 1 : i2;
  if (!t(n2) || !t(a8) || !t(o2))
    return null;
  var h2 = function(r3) {
    return { h: u(r3.h), s: e$1(r3.s, 0, 100), v: e$1(r3.v, 0, 100), a: e$1(r3.a) };
  }({ h: Number(n2), s: Number(a8), v: Number(o2), a: Number(s2) });
  return b$2(h2);
}, "hsv"]] }, N$1 = function(r2, t2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var e3 = t2[n2][0](r2);
    if (e3)
      return [e3, t2[n2][1]];
  }
  return [null, void 0];
}, x = function(r2) {
  return "string" == typeof r2 ? N$1(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N$1(r2, y.object) : [null, void 0];
}, M$1 = function(r2, t2) {
  var n2 = c$2(r2);
  return { h: n2.h, s: e$1(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
}, H$1 = function(r2) {
  return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
}, $$1 = function(r2, t2) {
  var n2 = c$2(r2);
  return { h: n2.h, s: n2.s, l: e$1(n2.l + 100 * t2, 0, 100), a: n2.a };
}, j$2 = function() {
  function r2(r3) {
    this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return r2.prototype.isValid = function() {
    return null !== this.parsed;
  }, r2.prototype.brightness = function() {
    return n(H$1(this.rgba), 2);
  }, r2.prototype.isDark = function() {
    return H$1(this.rgba) < 0.5;
  }, r2.prototype.isLight = function() {
    return H$1(this.rgba) >= 0.5;
  }, r2.prototype.toHex = function() {
    return r3 = o$1(this.rgba), t2 = r3.r, e3 = r3.g, u2 = r3.b, i2 = (a8 = r3.a) < 1 ? s(n(255 * a8)) : "", "#" + s(t2) + s(e3) + s(u2) + i2;
    var r3, t2, e3, u2, a8, i2;
  }, r2.prototype.toRgb = function() {
    return o$1(this.rgba);
  }, r2.prototype.toRgbString = function() {
    return r3 = o$1(this.rgba), t2 = r3.r, n2 = r3.g, e3 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e3 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e3 + ")";
    var r3, t2, n2, e3, u2;
  }, r2.prototype.toHsl = function() {
    return d$1(c$2(this.rgba));
  }, r2.prototype.toHslString = function() {
    return r3 = d$1(c$2(this.rgba)), t2 = r3.h, n2 = r3.s, e3 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e3 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e3 + "%)";
    var r3, t2, n2, e3, u2;
  }, r2.prototype.toHsv = function() {
    return r3 = h$1(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
    var r3;
  }, r2.prototype.invert = function() {
    return w$1({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
    var r3;
  }, r2.prototype.saturate = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w$1(M$1(this.rgba, r3));
  }, r2.prototype.desaturate = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w$1(M$1(this.rgba, -r3));
  }, r2.prototype.grayscale = function() {
    return w$1(M$1(this.rgba, -1));
  }, r2.prototype.lighten = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w$1($$1(this.rgba, r3));
  }, r2.prototype.darken = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w$1($$1(this.rgba, -r3));
  }, r2.prototype.rotate = function(r3) {
    return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
  }, r2.prototype.alpha = function(r3) {
    return "number" == typeof r3 ? w$1({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
    var t2;
  }, r2.prototype.hue = function(r3) {
    var t2 = c$2(this.rgba);
    return "number" == typeof r3 ? w$1({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
  }, r2.prototype.isEqual = function(r3) {
    return this.toHex() === w$1(r3).toHex();
  }, r2;
}(), w$1 = function(r2) {
  return r2 instanceof j$2 ? r2 : new j$2(r2);
}, S$1 = [], k$3 = function(r2) {
  r2.forEach(function(r3) {
    S$1.indexOf(r3) < 0 && (r3(j$2, y), S$1.push(r3));
  });
};
function namesPlugin(e3, f3) {
  var a8 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
  for (var d2 in a8)
    r2[a8[d2]] = d2;
  var l2 = {};
  e3.prototype.toName = function(f4) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
      return "transparent";
    var d3, i2, n2 = r2[this.toHex()];
    if (n2)
      return n2;
    if (null == f4 ? void 0 : f4.closest) {
      var o2 = this.toRgb(), t2 = 1 / 0, b3 = "black";
      if (!l2.length)
        for (var c3 in a8)
          l2[c3] = new e3(a8[c3]).toRgb();
      for (var g2 in a8) {
        var u2 = (d3 = o2, i2 = l2[g2], Math.pow(d3.r - i2.r, 2) + Math.pow(d3.g - i2.g, 2) + Math.pow(d3.b - i2.b, 2));
        u2 < t2 && (t2 = u2, b3 = g2);
      }
      return b3;
    }
  };
  f3.string.push([function(f4) {
    var r3 = f4.toLowerCase(), d3 = "transparent" === r3 ? "#0000" : a8[r3];
    return d3 ? new e3(d3).toRgb() : null;
  }, "name"]);
}
k$3([namesPlugin]);
const _Color = class {
  constructor(value2 = 16777215) {
    this._value = null;
    this._components = new Float32Array(4);
    this._components.fill(1);
    this._int = 16777215;
    this.value = value2;
  }
  get red() {
    return this._components[0];
  }
  get green() {
    return this._components[1];
  }
  get blue() {
    return this._components[2];
  }
  get alpha() {
    return this._components[3];
  }
  setValue(value2) {
    this.value = value2;
    return this;
  }
  set value(value2) {
    if (value2 instanceof _Color) {
      this._value = this.cloneSource(value2._value);
      this._int = value2._int;
      this._components.set(value2._components);
    } else if (value2 === null) {
      throw new Error("Cannot set PIXI.Color#value to null");
    } else if (this._value === null || !this.isSourceEqual(this._value, value2)) {
      this.normalize(value2);
      this._value = this.cloneSource(value2);
    }
  }
  get value() {
    return this._value;
  }
  cloneSource(value2) {
    if (typeof value2 === "string" || typeof value2 === "number" || value2 instanceof Number || value2 === null) {
      return value2;
    } else if (Array.isArray(value2) || ArrayBuffer.isView(value2)) {
      return value2.slice(0);
    } else if (typeof value2 === "object" && value2 !== null) {
      return { ...value2 };
    }
    return value2;
  }
  isSourceEqual(value1, value2) {
    const type1 = typeof value1;
    const type2 = typeof value2;
    if (type1 !== type2) {
      return false;
    } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
      return value1 === value2;
    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
      if (value1.length !== value2.length) {
        return false;
      }
      return value1.every((v2, i2) => v2 === value2[i2]);
    } else if (value1 !== null && value2 !== null) {
      const keys1 = Object.keys(value1);
      const keys2 = Object.keys(value2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      return keys1.every((key) => value1[key] === value2[key]);
    }
    return value1 === value2;
  }
  toRgba() {
    const [r2, g2, b3, a8] = this._components;
    return { r: r2, g: g2, b: b3, a: a8 };
  }
  toRgb() {
    const [r2, g2, b3] = this._components;
    return { r: r2, g: g2, b: b3 };
  }
  toRgbaString() {
    const [r2, g2, b3] = this.toUint8RgbArray();
    return `rgba(${r2},${g2},${b3},${this.alpha})`;
  }
  toUint8RgbArray(out) {
    const [r2, g2, b3] = this._components;
    out = out ?? [];
    out[0] = Math.round(r2 * 255);
    out[1] = Math.round(g2 * 255);
    out[2] = Math.round(b3 * 255);
    return out;
  }
  toRgbArray(out) {
    out = out ?? [];
    const [r2, g2, b3] = this._components;
    out[0] = r2;
    out[1] = g2;
    out[2] = b3;
    return out;
  }
  toNumber() {
    return this._int;
  }
  toLittleEndianNumber() {
    const value2 = this._int;
    return (value2 >> 16) + (value2 & 65280) + ((value2 & 255) << 16);
  }
  multiply(value2) {
    const [r2, g2, b3, a8] = _Color.temp.setValue(value2)._components;
    this._components[0] *= r2;
    this._components[1] *= g2;
    this._components[2] *= b3;
    this._components[3] *= a8;
    this.refreshInt();
    this._value = null;
    return this;
  }
  premultiply(alpha, applyToRGB = true) {
    if (applyToRGB) {
      this._components[0] *= alpha;
      this._components[1] *= alpha;
      this._components[2] *= alpha;
    }
    this._components[3] = alpha;
    this.refreshInt();
    this._value = null;
    return this;
  }
  toPremultiplied(alpha, applyToRGB = true) {
    if (alpha === 1) {
      return (255 << 24) + this._int;
    }
    if (alpha === 0) {
      return applyToRGB ? 0 : this._int;
    }
    let r2 = this._int >> 16 & 255;
    let g2 = this._int >> 8 & 255;
    let b3 = this._int & 255;
    if (applyToRGB) {
      r2 = r2 * alpha + 0.5 | 0;
      g2 = g2 * alpha + 0.5 | 0;
      b3 = b3 * alpha + 0.5 | 0;
    }
    return (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b3;
  }
  toHex() {
    const hexString = this._int.toString(16);
    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
  }
  toHexa() {
    const alphaValue = Math.round(this._components[3] * 255);
    const alphaString = alphaValue.toString(16);
    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
  }
  setAlpha(alpha) {
    this._components[3] = this._clamp(alpha);
    return this;
  }
  round(steps) {
    const [r2, g2, b3] = this._components;
    this._components[0] = Math.round(r2 * steps) / steps;
    this._components[1] = Math.round(g2 * steps) / steps;
    this._components[2] = Math.round(b3 * steps) / steps;
    this.refreshInt();
    this._value = null;
    return this;
  }
  toArray(out) {
    out = out ?? [];
    const [r2, g2, b3, a8] = this._components;
    out[0] = r2;
    out[1] = g2;
    out[2] = b3;
    out[3] = a8;
    return out;
  }
  normalize(value2) {
    let r2;
    let g2;
    let b3;
    let a8;
    if ((typeof value2 === "number" || value2 instanceof Number) && value2 >= 0 && value2 <= 16777215) {
      const int = value2;
      r2 = (int >> 16 & 255) / 255;
      g2 = (int >> 8 & 255) / 255;
      b3 = (int & 255) / 255;
      a8 = 1;
    } else if ((Array.isArray(value2) || value2 instanceof Float32Array) && value2.length >= 3 && value2.length <= 4) {
      value2 = this._clamp(value2);
      [r2, g2, b3, a8 = 1] = value2;
    } else if ((value2 instanceof Uint8Array || value2 instanceof Uint8ClampedArray) && value2.length >= 3 && value2.length <= 4) {
      value2 = this._clamp(value2, 0, 255);
      [r2, g2, b3, a8 = 255] = value2;
      r2 /= 255;
      g2 /= 255;
      b3 /= 255;
      a8 /= 255;
    } else if (typeof value2 === "string" || typeof value2 === "object") {
      if (typeof value2 === "string") {
        const match = _Color.HEX_PATTERN.exec(value2);
        if (match) {
          value2 = `#${match[2]}`;
        }
      }
      const color = w$1(value2);
      if (color.isValid()) {
        ({ r: r2, g: g2, b: b3, a: a8 } = color.rgba);
        r2 /= 255;
        g2 /= 255;
        b3 /= 255;
      }
    }
    if (r2 !== void 0) {
      this._components[0] = r2;
      this._components[1] = g2;
      this._components[2] = b3;
      this._components[3] = a8;
      this.refreshInt();
    } else {
      throw new Error(`Unable to convert color ${value2}`);
    }
  }
  refreshInt() {
    this._clamp(this._components);
    const [r2, g2, b3] = this._components;
    this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b3 * 255 | 0);
  }
  _clamp(value2, min = 0, max = 1) {
    if (typeof value2 === "number") {
      return Math.min(Math.max(value2, min), max);
    }
    value2.forEach((v2, i2) => {
      value2[i2] = Math.min(Math.max(v2, min), max);
    });
    return value2;
  }
};
let Color = _Color;
Color.shared = new _Color();
Color.temp = new _Color();
Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
function hex2rgb(hex, out = []) {
  deprecation("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead");
  return Color.shared.setValue(hex).toRgbArray(out);
}
function hex2string(hex) {
  deprecation("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead");
  return Color.shared.setValue(hex).toHex();
}
function string2hex(string) {
  deprecation("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead");
  return Color.shared.setValue(string).toNumber();
}
function rgb2hex(rgb) {
  deprecation("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead");
  return Color.shared.setValue(rgb).toNumber();
}
function mapPremultipliedBlendModes() {
  const pm = [];
  const npm = [];
  for (let i2 = 0; i2 < 32; i2++) {
    pm[i2] = i2;
    npm[i2] = i2;
  }
  pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL;
  pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD;
  pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN;
  npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM;
  npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM;
  npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
  const array2 = [];
  array2.push(npm);
  array2.push(pm);
  return array2;
}
const premultiplyBlendMode = mapPremultipliedBlendModes();
function correctBlendMode(blendMode, premultiplied) {
  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
}
function premultiplyRgba(rgb, alpha, out, premultiply = true) {
  deprecation("7.2.0", `utils.premultiplyRgba has moved to Color.premultiply`);
  return Color.shared.setValue(rgb).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));
}
function premultiplyTint(tint, alpha) {
  deprecation("7.2.0", `utils.premultiplyTint has moved to Color.toPremultiplied`);
  return Color.shared.setValue(tint).toPremultiplied(alpha);
}
function premultiplyTintToRgba(tint, alpha, out, premultiply = true) {
  deprecation("7.2.0", `utils.premultiplyTintToRgba has moved to Color.premultiply`);
  return Color.shared.setValue(tint).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));
}
const DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
function createIndicesForQuads(size2, outBuffer = null) {
  const totalIndices = size2 * 6;
  outBuffer = outBuffer || new Uint16Array(totalIndices);
  if (outBuffer.length !== totalIndices) {
    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
  }
  for (let i2 = 0, j2 = 0; i2 < totalIndices; i2 += 6, j2 += 4) {
    outBuffer[i2 + 0] = j2 + 0;
    outBuffer[i2 + 1] = j2 + 1;
    outBuffer[i2 + 2] = j2 + 2;
    outBuffer[i2 + 3] = j2 + 0;
    outBuffer[i2 + 4] = j2 + 2;
    outBuffer[i2 + 5] = j2 + 3;
  }
  return outBuffer;
}
function getBufferType(array2) {
  if (array2.BYTES_PER_ELEMENT === 4) {
    if (array2 instanceof Float32Array) {
      return "Float32Array";
    } else if (array2 instanceof Uint32Array) {
      return "Uint32Array";
    }
    return "Int32Array";
  } else if (array2.BYTES_PER_ELEMENT === 2) {
    if (array2 instanceof Uint16Array) {
      return "Uint16Array";
    }
  } else if (array2.BYTES_PER_ELEMENT === 1) {
    if (array2 instanceof Uint8Array) {
      return "Uint8Array";
    }
  }
  return null;
}
const map$4 = { Float32Array, Uint32Array, Int32Array, Uint8Array };
function interleaveTypedArrays$1(arrays, sizes) {
  let outSize = 0;
  let stride = 0;
  const views = {};
  for (let i2 = 0; i2 < arrays.length; i2++) {
    stride += sizes[i2];
    outSize += arrays[i2].length;
  }
  const buffer2 = new ArrayBuffer(outSize * 4);
  let out = null;
  let littleOffset = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const size2 = sizes[i2];
    const array2 = arrays[i2];
    const type = getBufferType(array2);
    if (!views[type]) {
      views[type] = new map$4[type](buffer2);
    }
    out = views[type];
    for (let j2 = 0; j2 < array2.length; j2++) {
      const indexStart = (j2 / size2 | 0) * stride + littleOffset;
      const index2 = j2 % size2;
      out[indexStart + index2] = array2[j2];
    }
    littleOffset += size2;
  }
  return new Float32Array(buffer2);
}
function nextPow2(v2) {
  v2 += v2 === 0 ? 1 : 0;
  --v2;
  v2 |= v2 >>> 1;
  v2 |= v2 >>> 2;
  v2 |= v2 >>> 4;
  v2 |= v2 >>> 8;
  v2 |= v2 >>> 16;
  return v2 + 1;
}
function isPow2(v2) {
  return !(v2 & v2 - 1) && !!v2;
}
function log2(v2) {
  let r2 = (v2 > 65535 ? 1 : 0) << 4;
  v2 >>>= r2;
  let shift = (v2 > 255 ? 1 : 0) << 3;
  v2 >>>= shift;
  r2 |= shift;
  shift = (v2 > 15 ? 1 : 0) << 2;
  v2 >>>= shift;
  r2 |= shift;
  shift = (v2 > 3 ? 1 : 0) << 1;
  v2 >>>= shift;
  r2 |= shift;
  return r2 | v2 >> 1;
}
function removeItems(arr, startIdx, removeCount) {
  const length2 = arr.length;
  let i2;
  if (startIdx >= length2 || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length2 ? length2 - startIdx : removeCount;
  const len = length2 - removeCount;
  for (i2 = startIdx; i2 < len; ++i2) {
    arr[i2] = arr[i2 + removeCount];
  }
  arr.length = len;
}
function sign(n2) {
  if (n2 === 0)
    return 0;
  return n2 < 0 ? -1 : 1;
}
let nextUid = 0;
function uid$2() {
  return ++nextUid;
}
const _BoundingBox = class {
  constructor(left, top, right, bottom) {
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
  }
  get width() {
    return this.right - this.left;
  }
  get height() {
    return this.bottom - this.top;
  }
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
};
let BoundingBox = _BoundingBox;
BoundingBox.EMPTY = new _BoundingBox(0, 0, 0, 0);
const ProgramCache = {};
const TextureCache = /* @__PURE__ */ Object.create(null);
const BaseTextureCache = /* @__PURE__ */ Object.create(null);
function destroyTextureCache() {
  let key;
  for (key in TextureCache) {
    TextureCache[key].destroy();
  }
  for (key in BaseTextureCache) {
    BaseTextureCache[key].destroy();
  }
}
function clearTextureCache() {
  let key;
  for (key in TextureCache) {
    delete TextureCache[key];
  }
  for (key in BaseTextureCache) {
    delete BaseTextureCache[key];
  }
}
class CanvasRenderTarget {
  constructor(width, height, resolution) {
    this._canvas = settings.ADAPTER.createCanvas();
    this._context = this._canvas.getContext("2d");
    this.resolution = resolution || settings.RESOLUTION;
    this.resize(width, height);
  }
  clear() {
    this._checkDestroyed();
    this._context.setTransform(1, 0, 0, 1, 0, 0);
    this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
  }
  resize(desiredWidth, desiredHeight) {
    this._checkDestroyed();
    this._canvas.width = Math.round(desiredWidth * this.resolution);
    this._canvas.height = Math.round(desiredHeight * this.resolution);
  }
  destroy() {
    this._context = null;
    this._canvas = null;
  }
  get width() {
    this._checkDestroyed();
    return this._canvas.width;
  }
  set width(val) {
    this._checkDestroyed();
    this._canvas.width = Math.round(val);
  }
  get height() {
    this._checkDestroyed();
    return this._canvas.height;
  }
  set height(val) {
    this._checkDestroyed();
    this._canvas.height = Math.round(val);
  }
  get canvas() {
    this._checkDestroyed();
    return this._canvas;
  }
  get context() {
    this._checkDestroyed();
    return this._context;
  }
  _checkDestroyed() {
    if (this._canvas === null) {
      throw new TypeError("The CanvasRenderTarget has already been destroyed");
    }
  }
}
function checkRow(data, width, y2) {
  for (let x2 = 0, index2 = 4 * y2 * width; x2 < width; ++x2, index2 += 4) {
    if (data[index2 + 3] !== 0)
      return false;
  }
  return true;
}
function checkColumn(data, width, x2, top, bottom) {
  const stride = 4 * width;
  for (let y2 = top, index2 = top * stride + 4 * x2; y2 <= bottom; ++y2, index2 += stride) {
    if (data[index2 + 3] !== 0)
      return false;
  }
  return true;
}
function getCanvasBoundingBox(canvas) {
  const { width, height } = canvas;
  const context2 = canvas.getContext("2d", {
    willReadFrequently: true
  });
  if (context2 === null) {
    throw new TypeError("Failed to get canvas 2D context");
  }
  const imageData = context2.getImageData(0, 0, width, height);
  const data = imageData.data;
  let left = 0;
  let top = 0;
  let right = width - 1;
  let bottom = height - 1;
  while (top < height && checkRow(data, width, top))
    ++top;
  if (top === height)
    return BoundingBox.EMPTY;
  while (checkRow(data, width, bottom))
    --bottom;
  while (checkColumn(data, width, left, top, bottom))
    ++left;
  while (checkColumn(data, width, right, top, bottom))
    --right;
  ++right;
  ++bottom;
  return new BoundingBox(left, top, right, bottom);
}
function trimCanvas(canvas) {
  const boundingBox = getCanvasBoundingBox(canvas);
  const { width, height } = boundingBox;
  let data = null;
  if (!boundingBox.isEmpty()) {
    const context2 = canvas.getContext("2d");
    if (context2 === null) {
      throw new TypeError("Failed to get canvas 2D context");
    }
    data = context2.getImageData(boundingBox.left, boundingBox.top, width, height);
  }
  return { width, height, data };
}
function decomposeDataUri(dataUri) {
  const dataUriMatch = DATA_URI.exec(dataUri);
  if (dataUriMatch) {
    return {
      mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,
      subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,
      charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,
      encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,
      data: dataUriMatch[5]
    };
  }
  return void 0;
}
let tempAnchor;
function determineCrossOrigin(url$1$1, loc = globalThis.location) {
  if (url$1$1.startsWith("data:")) {
    return "";
  }
  loc = loc || globalThis.location;
  if (!tempAnchor) {
    tempAnchor = document.createElement("a");
  }
  tempAnchor.href = url$1$1;
  const parsedUrl = url$1.parse(tempAnchor.href);
  const samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}
function getResolutionOfUrl(url2, defaultValue2 = 1) {
  var _a;
  const resolution = (_a = settings.RETINA_PREFIX) == null ? void 0 : _a.exec(url2);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue2;
}
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTextureCache,
  BoundingBox,
  CanvasRenderTarget,
  DATA_URI,
  EventEmitter: EventEmitter2,
  ProgramCache,
  TextureCache,
  clearTextureCache,
  correctBlendMode,
  createIndicesForQuads,
  decomposeDataUri,
  deprecation,
  destroyTextureCache,
  determineCrossOrigin,
  earcut: earcut$1,
  getBufferType,
  getCanvasBoundingBox,
  getResolutionOfUrl,
  hex2rgb,
  hex2string,
  interleaveTypedArrays: interleaveTypedArrays$1,
  isMobile,
  isPow2,
  isWebGLSupported,
  log2,
  nextPow2,
  path,
  premultiplyBlendMode,
  premultiplyRgba,
  premultiplyTint,
  premultiplyTintToRgba,
  removeItems,
  rgb2hex,
  sayHello,
  sign,
  skipHello,
  string2hex,
  trimCanvas,
  uid: uid$2,
  url: url$1
}, Symbol.toStringTag, { value: "Module" }));
var ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
  ExtensionType2["Renderer"] = "renderer";
  ExtensionType2["Application"] = "application";
  ExtensionType2["RendererSystem"] = "renderer-webgl-system";
  ExtensionType2["RendererPlugin"] = "renderer-webgl-plugin";
  ExtensionType2["CanvasRendererSystem"] = "renderer-canvas-system";
  ExtensionType2["CanvasRendererPlugin"] = "renderer-canvas-plugin";
  ExtensionType2["Asset"] = "asset";
  ExtensionType2["LoadParser"] = "load-parser";
  ExtensionType2["ResolveParser"] = "resolve-parser";
  ExtensionType2["CacheParser"] = "cache-parser";
  ExtensionType2["DetectionParser"] = "detection-parser";
  return ExtensionType2;
})(ExtensionType || {});
const normalizeExtension = (ext2) => {
  if (typeof ext2 === "function" || typeof ext2 === "object" && ext2.extension) {
    if (!ext2.extension) {
      throw new Error("Extension class must have an extension object");
    }
    const metadata = typeof ext2.extension !== "object" ? { type: ext2.extension } : ext2.extension;
    ext2 = { ...metadata, ref: ext2 };
  }
  if (typeof ext2 === "object") {
    ext2 = { ...ext2 };
  } else {
    throw new Error("Invalid extension type");
  }
  if (typeof ext2.type === "string") {
    ext2.type = [ext2.type];
  }
  return ext2;
};
const normalizePriority = (ext2, defaultPriority) => normalizeExtension(ext2).priority ?? defaultPriority;
const extensions$1 = {
  _addHandlers: {},
  _removeHandlers: {},
  _queue: {},
  remove(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext2) => {
      ext2.type.forEach((type) => {
        var _a, _b;
        return (_b = (_a = this._removeHandlers)[type]) == null ? void 0 : _b.call(_a, ext2);
      });
    });
    return this;
  },
  add(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext2) => {
      ext2.type.forEach((type) => {
        const handlers = this._addHandlers;
        const queue2 = this._queue;
        if (!handlers[type]) {
          queue2[type] = queue2[type] || [];
          queue2[type].push(ext2);
        } else {
          handlers[type](ext2);
        }
      });
    });
    return this;
  },
  handle(type, onAdd, onRemove) {
    const addHandlers = this._addHandlers;
    const removeHandlers = this._removeHandlers;
    if (addHandlers[type] || removeHandlers[type]) {
      throw new Error(`Extension type ${type} already has a handler`);
    }
    addHandlers[type] = onAdd;
    removeHandlers[type] = onRemove;
    const queue2 = this._queue;
    if (queue2[type]) {
      queue2[type].forEach((ext2) => onAdd(ext2));
      delete queue2[type];
    }
    return this;
  },
  handleByMap(type, map2) {
    return this.handle(type, (extension) => {
      map2[extension.name] = extension.ref;
    }, (extension) => {
      delete map2[extension.name];
    });
  },
  handleByList(type, list, defaultPriority = -1) {
    return this.handle(type, (extension) => {
      if (list.includes(extension.ref)) {
        return;
      }
      list.push(extension.ref);
      list.sort((a8, b3) => normalizePriority(b3, defaultPriority) - normalizePriority(a8, defaultPriority));
    }, (extension) => {
      const index2 = list.indexOf(extension.ref);
      if (index2 !== -1) {
        list.splice(index2, 1);
      }
    });
  }
};
class ViewableBuffer {
  constructor(sizeOrBuffer) {
    if (typeof sizeOrBuffer === "number") {
      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
    } else if (sizeOrBuffer instanceof Uint8Array) {
      this.rawBinaryData = sizeOrBuffer.buffer;
    } else {
      this.rawBinaryData = sizeOrBuffer;
    }
    this.uint32View = new Uint32Array(this.rawBinaryData);
    this.float32View = new Float32Array(this.rawBinaryData);
  }
  get int8View() {
    if (!this._int8View) {
      this._int8View = new Int8Array(this.rawBinaryData);
    }
    return this._int8View;
  }
  get uint8View() {
    if (!this._uint8View) {
      this._uint8View = new Uint8Array(this.rawBinaryData);
    }
    return this._uint8View;
  }
  get int16View() {
    if (!this._int16View) {
      this._int16View = new Int16Array(this.rawBinaryData);
    }
    return this._int16View;
  }
  get uint16View() {
    if (!this._uint16View) {
      this._uint16View = new Uint16Array(this.rawBinaryData);
    }
    return this._uint16View;
  }
  get int32View() {
    if (!this._int32View) {
      this._int32View = new Int32Array(this.rawBinaryData);
    }
    return this._int32View;
  }
  view(type) {
    return this[`${type}View`];
  }
  destroy() {
    this.rawBinaryData = null;
    this._int8View = null;
    this._uint8View = null;
    this._int16View = null;
    this._uint16View = null;
    this._int32View = null;
    this.uint32View = null;
    this.float32View = null;
  }
  static sizeOf(type) {
    switch (type) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${type} isn't a valid view type`);
    }
  }
}
const fragTemplate$1 = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");
function generateIfTestSrc(maxIfs) {
  let src = "";
  for (let i2 = 0; i2 < maxIfs; ++i2) {
    if (i2 > 0) {
      src += "\nelse ";
    }
    if (i2 < maxIfs - 1) {
      src += `if(test == ${i2}.0){}`;
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  const shader = gl.createShader(gl.FRAGMENT_SHADER);
  while (true) {
    const fragmentSrc = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    gl.shaderSource(shader, fragmentSrc);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      maxIfs = maxIfs / 2 | 0;
    } else {
      break;
    }
  }
  return maxIfs;
}
const BLEND$1 = 0;
const OFFSET$1 = 1;
const CULLING$1 = 2;
const DEPTH_TEST$1 = 3;
const WINDING$1 = 4;
const DEPTH_MASK$1 = 5;
class State {
  constructor() {
    this.data = 0;
    this.blendMode = BLEND_MODES.NORMAL;
    this.polygonOffset = 0;
    this.blend = true;
    this.depthMask = true;
  }
  get blend() {
    return !!(this.data & 1 << BLEND$1);
  }
  set blend(value2) {
    if (!!(this.data & 1 << BLEND$1) !== value2) {
      this.data ^= 1 << BLEND$1;
    }
  }
  get offsets() {
    return !!(this.data & 1 << OFFSET$1);
  }
  set offsets(value2) {
    if (!!(this.data & 1 << OFFSET$1) !== value2) {
      this.data ^= 1 << OFFSET$1;
    }
  }
  get culling() {
    return !!(this.data & 1 << CULLING$1);
  }
  set culling(value2) {
    if (!!(this.data & 1 << CULLING$1) !== value2) {
      this.data ^= 1 << CULLING$1;
    }
  }
  get depthTest() {
    return !!(this.data & 1 << DEPTH_TEST$1);
  }
  set depthTest(value2) {
    if (!!(this.data & 1 << DEPTH_TEST$1) !== value2) {
      this.data ^= 1 << DEPTH_TEST$1;
    }
  }
  get depthMask() {
    return !!(this.data & 1 << DEPTH_MASK$1);
  }
  set depthMask(value2) {
    if (!!(this.data & 1 << DEPTH_MASK$1) !== value2) {
      this.data ^= 1 << DEPTH_MASK$1;
    }
  }
  get clockwiseFrontFace() {
    return !!(this.data & 1 << WINDING$1);
  }
  set clockwiseFrontFace(value2) {
    if (!!(this.data & 1 << WINDING$1) !== value2) {
      this.data ^= 1 << WINDING$1;
    }
  }
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(value2) {
    this.blend = value2 !== BLEND_MODES.NONE;
    this._blendMode = value2;
  }
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(value2) {
    this.offsets = !!value2;
    this._polygonOffset = value2;
  }
  toString() {
    return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
  }
  static for2d() {
    const state = new State();
    state.depthTest = false;
    state.blend = true;
    return state;
  }
}
const INSTALLED = [];
function autoDetectResource(source, options) {
  if (!source) {
    return null;
  }
  let extension = "";
  if (typeof source === "string") {
    const result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
    if (result) {
      extension = result[1].toLowerCase();
    }
  }
  for (let i2 = INSTALLED.length - 1; i2 >= 0; --i2) {
    const ResourcePlugin = INSTALLED[i2];
    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
      return new ResourcePlugin(source, options);
    }
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
class Runner {
  constructor(name) {
    this.items = [];
    this._name = name;
    this._aliasCount = 0;
  }
  emit(a0, a12, a23, a32, a42, a52, a62, a72) {
    if (arguments.length > 8) {
      throw new Error("max arguments reached");
    }
    const { name, items } = this;
    this._aliasCount++;
    for (let i2 = 0, len = items.length; i2 < len; i2++) {
      items[i2][name](a0, a12, a23, a32, a42, a52, a62, a72);
    }
    if (items === this.items) {
      this._aliasCount--;
    }
    return this;
  }
  ensureNonAliasedItems() {
    if (this._aliasCount > 0 && this.items.length > 1) {
      this._aliasCount = 0;
      this.items = this.items.slice(0);
    }
  }
  add(item) {
    if (item[this._name]) {
      this.ensureNonAliasedItems();
      this.remove(item);
      this.items.push(item);
    }
    return this;
  }
  remove(item) {
    const index2 = this.items.indexOf(item);
    if (index2 !== -1) {
      this.ensureNonAliasedItems();
      this.items.splice(index2, 1);
    }
    return this;
  }
  contains(item) {
    return this.items.includes(item);
  }
  removeAll() {
    this.ensureNonAliasedItems();
    this.items.length = 0;
    return this;
  }
  destroy() {
    this.removeAll();
    this.items = null;
    this._name = null;
  }
  get empty() {
    return this.items.length === 0;
  }
  get name() {
    return this._name;
  }
}
Object.defineProperties(Runner.prototype, {
  dispatch: { value: Runner.prototype.emit },
  run: { value: Runner.prototype.emit }
});
class Resource {
  constructor(width = 0, height = 0) {
    this._width = width;
    this._height = height;
    this.destroyed = false;
    this.internal = false;
    this.onResize = new Runner("setRealSize");
    this.onUpdate = new Runner("update");
    this.onError = new Runner("onError");
  }
  bind(baseTexture) {
    this.onResize.add(baseTexture);
    this.onUpdate.add(baseTexture);
    this.onError.add(baseTexture);
    if (this._width || this._height) {
      this.onResize.emit(this._width, this._height);
    }
  }
  unbind(baseTexture) {
    this.onResize.remove(baseTexture);
    this.onUpdate.remove(baseTexture);
    this.onError.remove(baseTexture);
  }
  resize(width, height) {
    if (width !== this._width || height !== this._height) {
      this._width = width;
      this._height = height;
      this.onResize.emit(width, height);
    }
  }
  get valid() {
    return !!this._width && !!this._height;
  }
  update() {
    if (!this.destroyed) {
      this.onUpdate.emit();
    }
  }
  load() {
    return Promise.resolve(this);
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  style(_renderer, _baseTexture, _glTexture) {
    return false;
  }
  dispose() {
  }
  destroy() {
    if (!this.destroyed) {
      this.destroyed = true;
      this.dispose();
      this.onError.removeAll();
      this.onError = null;
      this.onResize.removeAll();
      this.onResize = null;
      this.onUpdate.removeAll();
      this.onUpdate = null;
    }
  }
  static test(_source, _extension) {
    return false;
  }
}
class BufferResource extends Resource {
  constructor(source, options) {
    const { width, height } = options || {};
    if (!width || !height) {
      throw new Error("BufferResource width or height invalid");
    }
    super(width, height);
    this.data = source;
  }
  upload(renderer2, baseTexture, glTexture) {
    const gl = renderer2.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  }
  dispose() {
    this.data = null;
  }
  static test(source) {
    return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
  }
}
const defaultBufferOptions = {
  scaleMode: SCALE_MODES.NEAREST,
  format: FORMATS.RGBA,
  alphaMode: ALPHA_MODES.NPM
};
const _BaseTexture = class extends EventEmitter2 {
  constructor(resource = null, options = null) {
    super();
    options = Object.assign({}, _BaseTexture.defaultOptions, options);
    const {
      alphaMode,
      mipmap,
      anisotropicLevel,
      scaleMode,
      width,
      height,
      wrapMode,
      format: format2,
      type,
      target,
      resolution,
      resourceOptions
    } = options;
    if (resource && !(resource instanceof Resource)) {
      resource = autoDetectResource(resource, resourceOptions);
      resource.internal = true;
    }
    this.resolution = resolution || settings.RESOLUTION;
    this.width = Math.round((width || 0) * this.resolution) / this.resolution;
    this.height = Math.round((height || 0) * this.resolution) / this.resolution;
    this._mipmap = mipmap;
    this.anisotropicLevel = anisotropicLevel;
    this._wrapMode = wrapMode;
    this._scaleMode = scaleMode;
    this.format = format2;
    this.type = type;
    this.target = target;
    this.alphaMode = alphaMode;
    this.uid = uid$2();
    this.touched = 0;
    this.isPowerOfTwo = false;
    this._refreshPOT();
    this._glTextures = {};
    this.dirtyId = 0;
    this.dirtyStyleId = 0;
    this.cacheId = null;
    this.valid = width > 0 && height > 0;
    this.textureCacheIds = [];
    this.destroyed = false;
    this.resource = null;
    this._batchEnabled = 0;
    this._batchLocation = 0;
    this.parentTextureArray = null;
    this.setResource(resource);
  }
  get realWidth() {
    return Math.round(this.width * this.resolution);
  }
  get realHeight() {
    return Math.round(this.height * this.resolution);
  }
  get mipmap() {
    return this._mipmap;
  }
  set mipmap(value2) {
    if (this._mipmap !== value2) {
      this._mipmap = value2;
      this.dirtyStyleId++;
    }
  }
  get scaleMode() {
    return this._scaleMode;
  }
  set scaleMode(value2) {
    if (this._scaleMode !== value2) {
      this._scaleMode = value2;
      this.dirtyStyleId++;
    }
  }
  get wrapMode() {
    return this._wrapMode;
  }
  set wrapMode(value2) {
    if (this._wrapMode !== value2) {
      this._wrapMode = value2;
      this.dirtyStyleId++;
    }
  }
  setStyle(scaleMode, mipmap) {
    let dirty;
    if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
      this.scaleMode = scaleMode;
      dirty = true;
    }
    if (mipmap !== void 0 && mipmap !== this.mipmap) {
      this.mipmap = mipmap;
      dirty = true;
    }
    if (dirty) {
      this.dirtyStyleId++;
    }
    return this;
  }
  setSize(desiredWidth, desiredHeight, resolution) {
    resolution = resolution || this.resolution;
    return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
  }
  setRealSize(realWidth, realHeight, resolution) {
    this.resolution = resolution || this.resolution;
    this.width = Math.round(realWidth) / this.resolution;
    this.height = Math.round(realHeight) / this.resolution;
    this._refreshPOT();
    this.update();
    return this;
  }
  _refreshPOT() {
    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
  }
  setResolution(resolution) {
    const oldResolution = this.resolution;
    if (oldResolution === resolution) {
      return this;
    }
    this.resolution = resolution;
    if (this.valid) {
      this.width = Math.round(this.width * oldResolution) / resolution;
      this.height = Math.round(this.height * oldResolution) / resolution;
      this.emit("update", this);
    }
    this._refreshPOT();
    return this;
  }
  setResource(resource) {
    if (this.resource === resource) {
      return this;
    }
    if (this.resource) {
      throw new Error("Resource can be set only once");
    }
    resource.bind(this);
    this.resource = resource;
    return this;
  }
  update() {
    if (!this.valid) {
      if (this.width > 0 && this.height > 0) {
        this.valid = true;
        this.emit("loaded", this);
        this.emit("update", this);
      }
    } else {
      this.dirtyId++;
      this.dirtyStyleId++;
      this.emit("update", this);
    }
  }
  onError(event) {
    this.emit("error", this, event);
  }
  destroy() {
    if (this.resource) {
      this.resource.unbind(this);
      if (this.resource.internal) {
        this.resource.destroy();
      }
      this.resource = null;
    }
    if (this.cacheId) {
      delete BaseTextureCache[this.cacheId];
      delete TextureCache[this.cacheId];
      this.cacheId = null;
    }
    this.dispose();
    _BaseTexture.removeFromCache(this);
    this.textureCacheIds = null;
    this.destroyed = true;
  }
  dispose() {
    this.emit("dispose", this);
  }
  castToBaseTexture() {
    return this;
  }
  static from(source, options, strict = settings.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source === "string";
    let cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else {
      if (!source._pixiId) {
        const prefix = (options == null ? void 0 : options.pixiIdPrefix) || "pixiid";
        source._pixiId = `${prefix}_${uid$2()}`;
      }
      cacheId = source._pixiId;
    }
    let baseTexture = BaseTextureCache[cacheId];
    if (isFrame && strict && !baseTexture) {
      throw new Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);
    }
    if (!baseTexture) {
      baseTexture = new _BaseTexture(source, options);
      baseTexture.cacheId = cacheId;
      _BaseTexture.addToCache(baseTexture, cacheId);
    }
    return baseTexture;
  }
  static fromBuffer(buffer2, width, height, options) {
    buffer2 = buffer2 || new Float32Array(width * height * 4);
    const resource = new BufferResource(buffer2, { width, height });
    const type = buffer2 instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;
    return new _BaseTexture(resource, Object.assign({}, defaultBufferOptions, { type }, options));
  }
  static addToCache(baseTexture, id) {
    if (id) {
      if (!baseTexture.textureCacheIds.includes(id)) {
        baseTexture.textureCacheIds.push(id);
      }
      if (BaseTextureCache[id] && BaseTextureCache[id] !== baseTexture) {
        console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`);
      }
      BaseTextureCache[id] = baseTexture;
    }
  }
  static removeFromCache(baseTexture) {
    if (typeof baseTexture === "string") {
      const baseTextureFromCache = BaseTextureCache[baseTexture];
      if (baseTextureFromCache) {
        const index2 = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
        if (index2 > -1) {
          baseTextureFromCache.textureCacheIds.splice(index2, 1);
        }
        delete BaseTextureCache[baseTexture];
        return baseTextureFromCache;
      }
    } else if (baseTexture == null ? void 0 : baseTexture.textureCacheIds) {
      for (let i2 = 0; i2 < baseTexture.textureCacheIds.length; ++i2) {
        delete BaseTextureCache[baseTexture.textureCacheIds[i2]];
      }
      baseTexture.textureCacheIds.length = 0;
      return baseTexture;
    }
    return null;
  }
};
let BaseTexture = _BaseTexture;
BaseTexture.defaultOptions = {
  mipmap: MIPMAP_MODES.POW2,
  anisotropicLevel: 0,
  scaleMode: SCALE_MODES.LINEAR,
  wrapMode: WRAP_MODES.CLAMP,
  alphaMode: ALPHA_MODES.UNPACK,
  target: TARGETS.TEXTURE_2D,
  format: FORMATS.RGBA,
  type: TYPES.UNSIGNED_BYTE
};
BaseTexture._globalBatch = 0;
class BatchDrawCall {
  constructor() {
    this.texArray = null;
    this.blend = 0;
    this.type = DRAW_MODES.TRIANGLES;
    this.start = 0;
    this.size = 0;
    this.data = null;
  }
}
let UID$4 = 0;
let Buffer$1 = class Buffer {
  constructor(data, _static = true, index2 = false) {
    this.data = data || new Float32Array(1);
    this._glBuffers = {};
    this._updateID = 0;
    this.index = index2;
    this.static = _static;
    this.id = UID$4++;
    this.disposeRunner = new Runner("disposeBuffer");
  }
  update(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    this.data = data || this.data;
    this._updateID++;
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroy() {
    this.dispose();
    this.data = null;
  }
  set index(value2) {
    this.type = value2 ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;
  }
  get index() {
    return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
  }
  static from(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    return new Buffer(data);
  }
};
class Attribute {
  constructor(buffer2, size2 = 0, normalized = false, type = TYPES.FLOAT, stride, start, instance, divisor = 1) {
    this.buffer = buffer2;
    this.size = size2;
    this.normalized = normalized;
    this.type = type;
    this.stride = stride;
    this.start = start;
    this.instance = instance;
    this.divisor = divisor;
  }
  destroy() {
    this.buffer = null;
  }
  static from(buffer2, size2, normalized, type, stride) {
    return new Attribute(buffer2, size2, normalized, type, stride);
  }
}
const map$3 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(arrays, sizes) {
  let outSize = 0;
  let stride = 0;
  const views = {};
  for (let i2 = 0; i2 < arrays.length; i2++) {
    stride += sizes[i2];
    outSize += arrays[i2].length;
  }
  const buffer2 = new ArrayBuffer(outSize * 4);
  let out = null;
  let littleOffset = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const size2 = sizes[i2];
    const array2 = arrays[i2];
    const type = getBufferType(array2);
    if (!views[type]) {
      views[type] = new map$3[type](buffer2);
    }
    out = views[type];
    for (let j2 = 0; j2 < array2.length; j2++) {
      const indexStart = (j2 / size2 | 0) * stride + littleOffset;
      const index2 = j2 % size2;
      out[indexStart + index2] = array2[j2];
    }
    littleOffset += size2;
  }
  return new Float32Array(buffer2);
}
const byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };
let UID$3 = 0;
const map$2 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};
class Geometry {
  constructor(buffers = [], attributes = {}) {
    this.buffers = buffers;
    this.indexBuffer = null;
    this.attributes = attributes;
    this.glVertexArrayObjects = {};
    this.id = UID$3++;
    this.instanced = false;
    this.instanceCount = 1;
    this.disposeRunner = new Runner("disposeGeometry");
    this.refCount = 0;
  }
  addAttribute(id, buffer2, size2 = 0, normalized = false, type, stride, start, instance = false) {
    if (!buffer2) {
      throw new Error("You must pass a buffer when creating an attribute");
    }
    if (!(buffer2 instanceof Buffer$1)) {
      if (buffer2 instanceof Array) {
        buffer2 = new Float32Array(buffer2);
      }
      buffer2 = new Buffer$1(buffer2);
    }
    const ids = id.split("|");
    if (ids.length > 1) {
      for (let i2 = 0; i2 < ids.length; i2++) {
        this.addAttribute(ids[i2], buffer2, size2, normalized, type);
      }
      return this;
    }
    let bufferIndex = this.buffers.indexOf(buffer2);
    if (bufferIndex === -1) {
      this.buffers.push(buffer2);
      bufferIndex = this.buffers.length - 1;
    }
    this.attributes[id] = new Attribute(bufferIndex, size2, normalized, type, stride, start, instance);
    this.instanced = this.instanced || instance;
    return this;
  }
  getAttribute(id) {
    return this.attributes[id];
  }
  getBuffer(id) {
    return this.buffers[this.getAttribute(id).buffer];
  }
  addIndex(buffer2) {
    if (!(buffer2 instanceof Buffer$1)) {
      if (buffer2 instanceof Array) {
        buffer2 = new Uint16Array(buffer2);
      }
      buffer2 = new Buffer$1(buffer2);
    }
    buffer2.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    this.indexBuffer = buffer2;
    if (!this.buffers.includes(buffer2)) {
      this.buffers.push(buffer2);
    }
    return this;
  }
  getIndex() {
    return this.indexBuffer;
  }
  interleave() {
    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
      return this;
    const arrays = [];
    const sizes = [];
    const interleavedBuffer = new Buffer$1();
    let i2;
    for (i2 in this.attributes) {
      const attribute = this.attributes[i2];
      const buffer2 = this.buffers[attribute.buffer];
      arrays.push(buffer2.data);
      sizes.push(attribute.size * byteSizeMap$1[attribute.type] / 4);
      attribute.buffer = 0;
    }
    interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);
    for (i2 = 0; i2 < this.buffers.length; i2++) {
      if (this.buffers[i2] !== this.indexBuffer) {
        this.buffers[i2].destroy();
      }
    }
    this.buffers = [interleavedBuffer];
    if (this.indexBuffer) {
      this.buffers.push(this.indexBuffer);
    }
    return this;
  }
  getSize() {
    for (const i2 in this.attributes) {
      const attribute = this.attributes[i2];
      const buffer2 = this.buffers[attribute.buffer];
      return buffer2.data.length / (attribute.stride / 4 || attribute.size);
    }
    return 0;
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroy() {
    this.dispose();
    this.buffers = null;
    this.indexBuffer = null;
    this.attributes = null;
  }
  clone() {
    const geometry = new Geometry();
    for (let i2 = 0; i2 < this.buffers.length; i2++) {
      geometry.buffers[i2] = new Buffer$1(this.buffers[i2].data.slice(0));
    }
    for (const i2 in this.attributes) {
      const attrib = this.attributes[i2];
      geometry.attributes[i2] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
    }
    if (this.indexBuffer) {
      geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
      geometry.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    }
    return geometry;
  }
  static merge(geometries) {
    const geometryOut = new Geometry();
    const arrays = [];
    const sizes = [];
    const offsets = [];
    let geometry;
    for (let i2 = 0; i2 < geometries.length; i2++) {
      geometry = geometries[i2];
      for (let j2 = 0; j2 < geometry.buffers.length; j2++) {
        sizes[j2] = sizes[j2] || 0;
        sizes[j2] += geometry.buffers[j2].data.length;
        offsets[j2] = 0;
      }
    }
    for (let i2 = 0; i2 < geometry.buffers.length; i2++) {
      arrays[i2] = new map$2[getBufferType(geometry.buffers[i2].data)](sizes[i2]);
      geometryOut.buffers[i2] = new Buffer$1(arrays[i2]);
    }
    for (let i2 = 0; i2 < geometries.length; i2++) {
      geometry = geometries[i2];
      for (let j2 = 0; j2 < geometry.buffers.length; j2++) {
        arrays[j2].set(geometry.buffers[j2].data, offsets[j2]);
        offsets[j2] += geometry.buffers[j2].data.length;
      }
    }
    geometryOut.attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
      geometryOut.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      let offset = 0;
      let stride = 0;
      let offset2 = 0;
      let bufferIndexToCount = 0;
      for (let i2 = 0; i2 < geometry.buffers.length; i2++) {
        if (geometry.buffers[i2] !== geometry.indexBuffer) {
          bufferIndexToCount = i2;
          break;
        }
      }
      for (const i2 in geometry.attributes) {
        const attribute = geometry.attributes[i2];
        if ((attribute.buffer | 0) === bufferIndexToCount) {
          stride += attribute.size * byteSizeMap$1[attribute.type] / 4;
        }
      }
      for (let i2 = 0; i2 < geometries.length; i2++) {
        const indexBufferData = geometries[i2].indexBuffer.data;
        for (let j2 = 0; j2 < indexBufferData.length; j2++) {
          geometryOut.indexBuffer.data[j2 + offset2] += offset;
        }
        offset += geometries[i2].buffers[bufferIndexToCount].data.length / stride;
        offset2 += indexBufferData.length;
      }
    }
    return geometryOut;
  }
}
class BatchGeometry extends Geometry {
  constructor(_static = false) {
    super();
    this._buffer = new Buffer$1(null, _static, false);
    this._indexBuffer = new Buffer$1(null, _static, true);
    this.addAttribute("aVertexPosition", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, true, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, true, TYPES.FLOAT).addIndex(this._indexBuffer);
  }
}
const PI_2 = Math.PI * 2;
const RAD_TO_DEG = 180 / Math.PI;
const DEG_TO_RAD = Math.PI / 180;
var SHAPES = /* @__PURE__ */ ((SHAPES2) => {
  SHAPES2[SHAPES2["POLY"] = 0] = "POLY";
  SHAPES2[SHAPES2["RECT"] = 1] = "RECT";
  SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";
  SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";
  SHAPES2[SHAPES2["RREC"] = 4] = "RREC";
  return SHAPES2;
})(SHAPES || {});
class Point {
  constructor(x2 = 0, y2 = 0) {
    this.x = 0;
    this.y = 0;
    this.x = x2;
    this.y = y2;
  }
  clone() {
    return new Point(this.x, this.y);
  }
  copyFrom(p2) {
    this.set(p2.x, p2.y);
    return this;
  }
  copyTo(p2) {
    p2.set(this.x, this.y);
    return p2;
  }
  equals(p2) {
    return p2.x === this.x && p2.y === this.y;
  }
  set(x2 = 0, y2 = x2) {
    this.x = x2;
    this.y = y2;
    return this;
  }
  toString() {
    return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
  }
}
const tempPoints$1 = [new Point(), new Point(), new Point(), new Point()];
class Rectangle {
  constructor(x2 = 0, y2 = 0, width = 0, height = 0) {
    this.x = Number(x2);
    this.y = Number(y2);
    this.width = Number(width);
    this.height = Number(height);
    this.type = SHAPES.RECT;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  static get EMPTY() {
    return new Rectangle(0, 0, 0, 0);
  }
  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }
  copyFrom(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  }
  copyTo(rectangle) {
    rectangle.x = this.x;
    rectangle.y = this.y;
    rectangle.width = this.width;
    rectangle.height = this.height;
    return rectangle;
  }
  contains(x2, y2) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x2 >= this.x && x2 < this.x + this.width) {
      if (y2 >= this.y && y2 < this.y + this.height) {
        return true;
      }
    }
    return false;
  }
  intersects(other, transform) {
    if (!transform) {
      const x02 = this.x < other.x ? other.x : this.x;
      const x12 = this.right > other.right ? other.right : this.right;
      if (x12 <= x02) {
        return false;
      }
      const y02 = this.y < other.y ? other.y : this.y;
      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
      return y12 > y02;
    }
    const x0 = this.left;
    const x1 = this.right;
    const y0 = this.top;
    const y1 = this.bottom;
    if (x1 <= x0 || y1 <= y0) {
      return false;
    }
    const lt = tempPoints$1[0].set(other.left, other.top);
    const lb = tempPoints$1[1].set(other.left, other.bottom);
    const rt = tempPoints$1[2].set(other.right, other.top);
    const rb = tempPoints$1[3].set(other.right, other.bottom);
    if (rt.x <= lt.x || lb.y <= lt.y) {
      return false;
    }
    const s2 = Math.sign(transform.a * transform.d - transform.b * transform.c);
    if (s2 === 0) {
      return false;
    }
    transform.apply(lt, lt);
    transform.apply(lb, lb);
    transform.apply(rt, rt);
    transform.apply(rb, rb);
    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
      return false;
    }
    const nx = s2 * (lb.y - lt.y);
    const ny = s2 * (lt.x - lb.x);
    const n00 = nx * x0 + ny * y0;
    const n10 = nx * x1 + ny * y0;
    const n01 = nx * x0 + ny * y1;
    const n11 = nx * x1 + ny * y1;
    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
      return false;
    }
    const mx = s2 * (lt.y - rt.y);
    const my = s2 * (rt.x - lt.x);
    const m00 = mx * x0 + my * y0;
    const m10 = mx * x1 + my * y0;
    const m01 = mx * x0 + my * y1;
    const m11 = mx * x1 + my * y1;
    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
      return false;
    }
    return true;
  }
  pad(paddingX = 0, paddingY = paddingX) {
    this.x -= paddingX;
    this.y -= paddingY;
    this.width += paddingX * 2;
    this.height += paddingY * 2;
    return this;
  }
  fit(rectangle) {
    const x1 = Math.max(this.x, rectangle.x);
    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.max(this.y, rectangle.y);
    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = Math.max(x2 - x1, 0);
    this.y = y1;
    this.height = Math.max(y2 - y1, 0);
    return this;
  }
  ceil(resolution = 1, eps = 1e-3) {
    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
    this.x = Math.floor((this.x + eps) * resolution) / resolution;
    this.y = Math.floor((this.y + eps) * resolution) / resolution;
    this.width = x2 - this.x;
    this.height = y2 - this.y;
    return this;
  }
  enlarge(rectangle) {
    const x1 = Math.min(this.x, rectangle.x);
    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.min(this.y, rectangle.y);
    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = x2 - x1;
    this.y = y1;
    this.height = y2 - y1;
    return this;
  }
  toString() {
    return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}
class Circle {
  constructor(x2 = 0, y2 = 0, radius = 0) {
    this.x = x2;
    this.y = y2;
    this.radius = radius;
    this.type = SHAPES.CIRC;
  }
  clone() {
    return new Circle(this.x, this.y, this.radius);
  }
  contains(x2, y2) {
    if (this.radius <= 0) {
      return false;
    }
    const r2 = this.radius * this.radius;
    let dx = this.x - x2;
    let dy = this.y - y2;
    dx *= dx;
    dy *= dy;
    return dx + dy <= r2;
  }
  getBounds() {
    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  }
  toString() {
    return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
}
class Ellipse {
  constructor(x2 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
    this.x = x2;
    this.y = y2;
    this.width = halfWidth;
    this.height = halfHeight;
    this.type = SHAPES.ELIP;
  }
  clone() {
    return new Ellipse(this.x, this.y, this.width, this.height);
  }
  contains(x2, y2) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    let normx = (x2 - this.x) / this.width;
    let normy = (y2 - this.y) / this.height;
    normx *= normx;
    normy *= normy;
    return normx + normy <= 1;
  }
  getBounds() {
    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
  }
  toString() {
    return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}
class Polygon {
  constructor(...points) {
    let flat = Array.isArray(points[0]) ? points[0] : points;
    if (typeof flat[0] !== "number") {
      const p2 = [];
      for (let i2 = 0, il = flat.length; i2 < il; i2++) {
        p2.push(flat[i2].x, flat[i2].y);
      }
      flat = p2;
    }
    this.points = flat;
    this.type = SHAPES.POLY;
    this.closeStroke = true;
  }
  clone() {
    const points = this.points.slice();
    const polygon = new Polygon(points);
    polygon.closeStroke = this.closeStroke;
    return polygon;
  }
  contains(x2, y2) {
    let inside = false;
    const length2 = this.points.length / 2;
    for (let i2 = 0, j2 = length2 - 1; i2 < length2; j2 = i2++) {
      const xi = this.points[i2 * 2];
      const yi = this.points[i2 * 2 + 1];
      const xj = this.points[j2 * 2];
      const yj = this.points[j2 * 2 + 1];
      const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
      if (intersect) {
        inside = !inside;
      }
    }
    return inside;
  }
  toString() {
    return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
  }
}
class RoundedRectangle {
  constructor(x2 = 0, y2 = 0, width = 0, height = 0, radius = 20) {
    this.x = x2;
    this.y = y2;
    this.width = width;
    this.height = height;
    this.radius = radius;
    this.type = SHAPES.RREC;
  }
  clone() {
    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
  }
  contains(x2, y2) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x2 >= this.x && x2 <= this.x + this.width) {
      if (y2 >= this.y && y2 <= this.y + this.height) {
        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius) {
          return true;
        }
        let dx = x2 - (this.x + radius);
        let dy = y2 - (this.y + radius);
        const radius2 = radius * radius;
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x2 - (this.x + this.width - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dy = y2 - (this.y + this.height - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x2 - (this.x + radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
      }
    }
    return false;
  }
  toString() {
    return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
}
class Matrix {
  constructor(a8 = 1, b3 = 0, c3 = 0, d2 = 1, tx = 0, ty = 0) {
    this.array = null;
    this.a = a8;
    this.b = b3;
    this.c = c3;
    this.d = d2;
    this.tx = tx;
    this.ty = ty;
  }
  fromArray(array2) {
    this.a = array2[0];
    this.b = array2[1];
    this.c = array2[3];
    this.d = array2[4];
    this.tx = array2[2];
    this.ty = array2[5];
  }
  set(a8, b3, c3, d2, tx, ty) {
    this.a = a8;
    this.b = b3;
    this.c = c3;
    this.d = d2;
    this.tx = tx;
    this.ty = ty;
    return this;
  }
  toArray(transpose, out) {
    if (!this.array) {
      this.array = new Float32Array(9);
    }
    const array2 = out || this.array;
    if (transpose) {
      array2[0] = this.a;
      array2[1] = this.b;
      array2[2] = 0;
      array2[3] = this.c;
      array2[4] = this.d;
      array2[5] = 0;
      array2[6] = this.tx;
      array2[7] = this.ty;
      array2[8] = 1;
    } else {
      array2[0] = this.a;
      array2[1] = this.c;
      array2[2] = this.tx;
      array2[3] = this.b;
      array2[4] = this.d;
      array2[5] = this.ty;
      array2[6] = 0;
      array2[7] = 0;
      array2[8] = 1;
    }
    return array2;
  }
  apply(pos, newPos) {
    newPos = newPos || new Point();
    const x2 = pos.x;
    const y2 = pos.y;
    newPos.x = this.a * x2 + this.c * y2 + this.tx;
    newPos.y = this.b * x2 + this.d * y2 + this.ty;
    return newPos;
  }
  applyInverse(pos, newPos) {
    newPos = newPos || new Point();
    const id = 1 / (this.a * this.d + this.c * -this.b);
    const x2 = pos.x;
    const y2 = pos.y;
    newPos.x = this.d * id * x2 + -this.c * id * y2 + (this.ty * this.c - this.tx * this.d) * id;
    newPos.y = this.a * id * y2 + -this.b * id * x2 + (-this.ty * this.a + this.tx * this.b) * id;
    return newPos;
  }
  translate(x2, y2) {
    this.tx += x2;
    this.ty += y2;
    return this;
  }
  scale(x2, y2) {
    this.a *= x2;
    this.d *= y2;
    this.c *= x2;
    this.b *= y2;
    this.tx *= x2;
    this.ty *= y2;
    return this;
  }
  rotate(angle2) {
    const cos = Math.cos(angle2);
    const sin = Math.sin(angle2);
    const a12 = this.a;
    const c12 = this.c;
    const tx1 = this.tx;
    this.a = a12 * cos - this.b * sin;
    this.b = a12 * sin + this.b * cos;
    this.c = c12 * cos - this.d * sin;
    this.d = c12 * sin + this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;
    return this;
  }
  append(matrix) {
    const a12 = this.a;
    const b12 = this.b;
    const c12 = this.c;
    const d12 = this.d;
    this.a = matrix.a * a12 + matrix.b * c12;
    this.b = matrix.a * b12 + matrix.b * d12;
    this.c = matrix.c * a12 + matrix.d * c12;
    this.d = matrix.c * b12 + matrix.d * d12;
    this.tx = matrix.tx * a12 + matrix.ty * c12 + this.tx;
    this.ty = matrix.tx * b12 + matrix.ty * d12 + this.ty;
    return this;
  }
  setTransform(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    this.a = Math.cos(rotation + skewY) * scaleX;
    this.b = Math.sin(rotation + skewY) * scaleX;
    this.c = -Math.sin(rotation - skewX) * scaleY;
    this.d = Math.cos(rotation - skewX) * scaleY;
    this.tx = x2 - (pivotX * this.a + pivotY * this.c);
    this.ty = y2 - (pivotX * this.b + pivotY * this.d);
    return this;
  }
  prepend(matrix) {
    const tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      const a12 = this.a;
      const c12 = this.c;
      this.a = a12 * matrix.a + this.b * matrix.c;
      this.b = a12 * matrix.b + this.b * matrix.d;
      this.c = c12 * matrix.a + this.d * matrix.c;
      this.d = c12 * matrix.b + this.d * matrix.d;
    }
    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
    return this;
  }
  decompose(transform) {
    const a8 = this.a;
    const b3 = this.b;
    const c3 = this.c;
    const d2 = this.d;
    const pivot = transform.pivot;
    const skewX = -Math.atan2(-c3, d2);
    const skewY = Math.atan2(b3, a8);
    const delta = Math.abs(skewX + skewY);
    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
      transform.rotation = skewY;
      transform.skew.x = transform.skew.y = 0;
    } else {
      transform.rotation = 0;
      transform.skew.x = skewX;
      transform.skew.y = skewY;
    }
    transform.scale.x = Math.sqrt(a8 * a8 + b3 * b3);
    transform.scale.y = Math.sqrt(c3 * c3 + d2 * d2);
    transform.position.x = this.tx + (pivot.x * a8 + pivot.y * c3);
    transform.position.y = this.ty + (pivot.x * b3 + pivot.y * d2);
    return transform;
  }
  invert() {
    const a12 = this.a;
    const b12 = this.b;
    const c12 = this.c;
    const d12 = this.d;
    const tx1 = this.tx;
    const n2 = a12 * d12 - b12 * c12;
    this.a = d12 / n2;
    this.b = -b12 / n2;
    this.c = -c12 / n2;
    this.d = a12 / n2;
    this.tx = (c12 * this.ty - d12 * tx1) / n2;
    this.ty = -(a12 * this.ty - b12 * tx1) / n2;
    return this;
  }
  identity() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
    return this;
  }
  clone() {
    const matrix = new Matrix();
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  copyTo(matrix) {
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  copyFrom(matrix) {
    this.a = matrix.a;
    this.b = matrix.b;
    this.c = matrix.c;
    this.d = matrix.d;
    this.tx = matrix.tx;
    this.ty = matrix.ty;
    return this;
  }
  toString() {
    return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  static get IDENTITY() {
    return new Matrix();
  }
  static get TEMP_MATRIX() {
    return new Matrix();
  }
}
const ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
const uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
const vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
const vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
const rotationCayley = [];
const rotationMatrices = [];
const signum = Math.sign;
function init() {
  for (let i2 = 0; i2 < 16; i2++) {
    const row = [];
    rotationCayley.push(row);
    for (let j2 = 0; j2 < 16; j2++) {
      const _ux = signum(ux[i2] * ux[j2] + vx[i2] * uy[j2]);
      const _uy = signum(uy[i2] * ux[j2] + vy[i2] * uy[j2]);
      const _vx = signum(ux[i2] * vx[j2] + vx[i2] * vy[j2]);
      const _vy = signum(uy[i2] * vx[j2] + vy[i2] * vy[j2]);
      for (let k4 = 0; k4 < 16; k4++) {
        if (ux[k4] === _ux && uy[k4] === _uy && vx[k4] === _vx && vy[k4] === _vy) {
          row.push(k4);
          break;
        }
      }
    }
  }
  for (let i2 = 0; i2 < 16; i2++) {
    const mat = new Matrix();
    mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0);
    rotationMatrices.push(mat);
  }
}
init();
const groupD8 = {
  E: 0,
  SE: 1,
  S: 2,
  SW: 3,
  W: 4,
  NW: 5,
  N: 6,
  NE: 7,
  MIRROR_VERTICAL: 8,
  MAIN_DIAGONAL: 10,
  MIRROR_HORIZONTAL: 12,
  REVERSE_DIAGONAL: 14,
  uX: (ind) => ux[ind],
  uY: (ind) => uy[ind],
  vX: (ind) => vx[ind],
  vY: (ind) => vy[ind],
  inv: (rotation) => {
    if (rotation & 8) {
      return rotation & 15;
    }
    return -rotation & 7;
  },
  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
  rotate180: (rotation) => rotation ^ 4,
  isVertical: (rotation) => (rotation & 3) === 2,
  byDirection: (dx, dy) => {
    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
      if (dy >= 0) {
        return groupD8.S;
      }
      return groupD8.N;
    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
      if (dx > 0) {
        return groupD8.E;
      }
      return groupD8.W;
    } else if (dy > 0) {
      if (dx > 0) {
        return groupD8.SE;
      }
      return groupD8.SW;
    } else if (dx > 0) {
      return groupD8.NE;
    }
    return groupD8.NW;
  },
  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
    const mat = rotationMatrices[groupD8.inv(rotation)];
    mat.tx = tx;
    mat.ty = ty;
    matrix.append(mat);
  }
};
class ObservablePoint {
  constructor(cb, scope, x2 = 0, y2 = 0) {
    this._x = x2;
    this._y = y2;
    this.cb = cb;
    this.scope = scope;
  }
  clone(cb = this.cb, scope = this.scope) {
    return new ObservablePoint(cb, scope, this._x, this._y);
  }
  set(x2 = 0, y2 = x2) {
    if (this._x !== x2 || this._y !== y2) {
      this._x = x2;
      this._y = y2;
      this.cb.call(this.scope);
    }
    return this;
  }
  copyFrom(p2) {
    if (this._x !== p2.x || this._y !== p2.y) {
      this._x = p2.x;
      this._y = p2.y;
      this.cb.call(this.scope);
    }
    return this;
  }
  copyTo(p2) {
    p2.set(this._x, this._y);
    return p2;
  }
  equals(p2) {
    return p2.x === this._x && p2.y === this._y;
  }
  toString() {
    return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this.scope}]`;
  }
  get x() {
    return this._x;
  }
  set x(value2) {
    if (this._x !== value2) {
      this._x = value2;
      this.cb.call(this.scope);
    }
  }
  get y() {
    return this._y;
  }
  set y(value2) {
    if (this._y !== value2) {
      this._y = value2;
      this.cb.call(this.scope);
    }
  }
}
const _Transform = class {
  constructor() {
    this.worldTransform = new Matrix();
    this.localTransform = new Matrix();
    this.position = new ObservablePoint(this.onChange, this, 0, 0);
    this.scale = new ObservablePoint(this.onChange, this, 1, 1);
    this.pivot = new ObservablePoint(this.onChange, this, 0, 0);
    this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);
    this._rotation = 0;
    this._cx = 1;
    this._sx = 0;
    this._cy = 0;
    this._sy = 1;
    this._localID = 0;
    this._currentLocalID = 0;
    this._worldID = 0;
    this._parentID = 0;
  }
  onChange() {
    this._localID++;
  }
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y);
    this._sx = Math.sin(this._rotation + this.skew.y);
    this._cy = -Math.sin(this._rotation - this.skew.x);
    this._sy = Math.cos(this._rotation - this.skew.x);
    this._localID++;
  }
  toString() {
    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
  }
  updateLocalTransform() {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
  }
  updateTransform(parentTransform) {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
    if (this._parentID !== parentTransform._worldID) {
      const pt = parentTransform.worldTransform;
      const wt = this.worldTransform;
      wt.a = lt.a * pt.a + lt.b * pt.c;
      wt.b = lt.a * pt.b + lt.b * pt.d;
      wt.c = lt.c * pt.a + lt.d * pt.c;
      wt.d = lt.c * pt.b + lt.d * pt.d;
      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
      this._parentID = parentTransform._worldID;
      this._worldID++;
    }
  }
  setFromMatrix(matrix) {
    matrix.decompose(this);
    this._localID++;
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(value2) {
    if (this._rotation !== value2) {
      this._rotation = value2;
      this.updateSkew();
    }
  }
};
let Transform = _Transform;
Transform.IDENTITY = new _Transform();
var defaultFragment$2 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
var defaultVertex$3 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
function compileShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}
function booleanArray(size2) {
  const array2 = new Array(size2);
  for (let i2 = 0; i2 < array2.length; i2++) {
    array2[i2] = false;
  }
  return array2;
}
function defaultValue(type, size2) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size2);
    case "vec3":
      return new Float32Array(3 * size2);
    case "vec4":
      return new Float32Array(4 * size2);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size2);
    case "ivec3":
      return new Int32Array(3 * size2);
    case "ivec4":
      return new Int32Array(4 * size2);
    case "uvec2":
      return new Uint32Array(2 * size2);
    case "uvec3":
      return new Uint32Array(3 * size2);
    case "uvec4":
      return new Uint32Array(4 * size2);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size2);
    case "bvec3":
      return booleanArray(3 * size2);
    case "bvec4":
      return booleanArray(4 * size2);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
const uniformParsers = [
  {
    test: (data) => data.type === "float" && data.size === 1 && !data.isArray,
    code: (name) => `
            if(uv["${name}"] !== ud["${name}"].value)
            {
                ud["${name}"].value = uv["${name}"]
                gl.uniform1f(ud["${name}"].location, uv["${name}"])
            }
            `
  },
  {
    test: (data, uniform) => (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0),
    code: (name) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${name}"], t);

            if(ud["${name}"].value !== t)
            {
                ud["${name}"].value = t;
                gl.uniform1i(ud["${name}"].location, t);
; // eslint-disable-line max-len
            }`
  },
  {
    test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,
    code: (name) => `
            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));
            `,
    codeUbo: (name) => `
                var ${name}_matrix = uv.${name}.toArray(true);

                data[offset] = ${name}_matrix[0];
                data[offset+1] = ${name}_matrix[1];
                data[offset+2] = ${name}_matrix[2];
        
                data[offset + 4] = ${name}_matrix[3];
                data[offset + 5] = ${name}_matrix[4];
                data[offset + 6] = ${name}_matrix[5];
        
                data[offset + 8] = ${name}_matrix[6];
                data[offset + 9] = ${name}_matrix[7];
                data[offset + 10] = ${name}_matrix[8];
            `
  },
  {
    test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${name}"].location, v.x, v.y);
                }`,
    codeUbo: (name) => `
                v = uv.${name};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
  },
  {
    test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);
                }
            `
  },
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
  },
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${name}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `
  },
  {
    test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${name}"].location, v.red, v.green, v.blue)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `
  },
  {
    test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
                }`
  }
];
const GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
};
const GLSL_TO_ARRAY_SETTERS = {
  float: `gl.uniform1fv(location, v)`,
  vec2: `gl.uniform2fv(location, v)`,
  vec3: `gl.uniform3fv(location, v)`,
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(group, uniformData) {
  var _a;
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (const i2 in group.uniforms) {
    const data = uniformData[i2];
    if (!data) {
      if ((_a = group.uniforms[i2]) == null ? void 0 : _a.group) {
        if (group.uniforms[i2].ubo) {
          funcFragments.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i2}, '${i2}');
                    `);
        } else {
          funcFragments.push(`
                        renderer.shader.syncUniformGroup(uv.${i2}, syncData);
                    `);
        }
      }
      continue;
    }
    const uniform = group.uniforms[i2];
    let parsed = false;
    for (let j2 = 0; j2 < uniformParsers.length; j2++) {
      if (uniformParsers[j2].test(data, uniform)) {
        funcFragments.push(uniformParsers[j2].code(i2, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      const templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
      const template = templateType[data.type].replace("location", `ud["${i2}"].location`);
      funcFragments.push(`
            cu = ud["${i2}"];
            cv = cu.value;
            v = uv["${i2}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}
const unknownContext = {};
let context = unknownContext;
function getTestContext() {
  if (context === unknownContext || (context == null ? void 0 : context.isContextLost())) {
    const canvas = settings.ADAPTER.createCanvas();
    let gl;
    if (settings.PREFER_ENV >= ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", {});
    }
    if (!gl) {
      gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
      if (!gl) {
        gl = null;
      } else {
        gl.getExtension("WEBGL_draw_buffers");
      }
    }
    context = gl;
  }
  return context;
}
let maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = PRECISION.MEDIUM;
    const gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? PRECISION.HIGH : PRECISION.MEDIUM;
      }
    }
  }
  return maxFragmentPrecision;
}
function logPrettyShaderError(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index2) => `${index2}: ${line}`);
  const shaderLog = gl.getShaderInfoLog(shader);
  const splitShader = shaderLog.split("\n");
  const dedupe = {};
  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => {
    if (n2 && !dedupe[n2]) {
      dedupe[n2] = true;
      return true;
    }
    return false;
  });
  const logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn(...logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}
const GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(type) {
  return GLSL_TO_SIZE[type];
}
let GL_TABLE = null;
const GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(gl, type) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i2 = 0; i2 < typeNames.length; ++i2) {
      const tn = typeNames[i2];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}
function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    let precision = requestedPrecision;
    if (requestedPrecision === PRECISION.HIGH && maxSupportedPrecision !== PRECISION.HIGH) {
      precision = PRECISION.MEDIUM;
    }
    return `precision ${precision} float;
${src}`;
  } else if (maxSupportedPrecision !== PRECISION.HIGH && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
let unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (e3) {
    unsafeEval = false;
  }
  return unsafeEval;
}
let UID$2 = 0;
const nameCache = {};
const _Program = class {
  constructor(vertexSrc, fragmentSrc, name = "pixi-shader", extra = {}) {
    this.extra = {};
    this.id = UID$2++;
    this.vertexSrc = vertexSrc || _Program.defaultVertexSrc;
    this.fragmentSrc = fragmentSrc || _Program.defaultFragmentSrc;
    this.vertexSrc = this.vertexSrc.trim();
    this.fragmentSrc = this.fragmentSrc.trim();
    this.extra = extra;
    if (this.vertexSrc.substring(0, 8) !== "#version") {
      name = name.replace(/\s+/g, "-");
      if (nameCache[name]) {
        nameCache[name]++;
        name += `-${nameCache[name]}`;
      } else {
        nameCache[name] = 1;
      }
      this.vertexSrc = `#define SHADER_NAME ${name}
${this.vertexSrc}`;
      this.fragmentSrc = `#define SHADER_NAME ${name}
${this.fragmentSrc}`;
      this.vertexSrc = setPrecision(this.vertexSrc, _Program.defaultVertexPrecision, PRECISION.HIGH);
      this.fragmentSrc = setPrecision(this.fragmentSrc, _Program.defaultFragmentPrecision, getMaxFragmentPrecision());
    }
    this.glPrograms = {};
    this.syncUniforms = null;
  }
  static get defaultVertexSrc() {
    return defaultVertex$3;
  }
  static get defaultFragmentSrc() {
    return defaultFragment$2;
  }
  static from(vertexSrc, fragmentSrc, name) {
    const key = vertexSrc + fragmentSrc;
    let program = ProgramCache[key];
    if (!program) {
      ProgramCache[key] = program = new _Program(vertexSrc, fragmentSrc, name);
    }
    return program;
  }
};
let Program = _Program;
Program.defaultVertexPrecision = PRECISION.HIGH;
Program.defaultFragmentPrecision = isMobile.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM;
let UID$1 = 0;
class UniformGroup {
  constructor(uniforms, isStatic, isUbo) {
    this.group = true;
    this.syncUniforms = {};
    this.dirtyId = 0;
    this.id = UID$1++;
    this.static = !!isStatic;
    this.ubo = !!isUbo;
    if (uniforms instanceof Buffer$1) {
      this.buffer = uniforms;
      this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
      this.autoManage = false;
      this.ubo = true;
    } else {
      this.uniforms = uniforms;
      if (this.ubo) {
        this.buffer = new Buffer$1(new Float32Array(1));
        this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
        this.autoManage = true;
      }
    }
  }
  update() {
    this.dirtyId++;
    if (!this.autoManage && this.buffer) {
      this.buffer.update();
    }
  }
  add(name, uniforms, _static) {
    if (!this.ubo) {
      this.uniforms[name] = new UniformGroup(uniforms, _static);
    } else {
      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
    }
  }
  static from(uniforms, _static, _ubo) {
    return new UniformGroup(uniforms, _static, _ubo);
  }
  static uboFrom(uniforms, _static) {
    return new UniformGroup(uniforms, _static ?? true, true);
  }
}
class Shader {
  constructor(program, uniforms) {
    this.uniformBindCount = 0;
    this.program = program;
    if (uniforms) {
      if (uniforms instanceof UniformGroup) {
        this.uniformGroup = uniforms;
      } else {
        this.uniformGroup = new UniformGroup(uniforms);
      }
    } else {
      this.uniformGroup = new UniformGroup({});
    }
    this.disposeRunner = new Runner("disposeShader");
  }
  checkUniformExists(name, group) {
    if (group.uniforms[name]) {
      return true;
    }
    for (const i2 in group.uniforms) {
      const uniform = group.uniforms[i2];
      if (uniform.group) {
        if (this.checkUniformExists(name, uniform)) {
          return true;
        }
      }
    }
    return false;
  }
  destroy() {
    this.uniformGroup = null;
    this.disposeRunner.emit(this);
    this.disposeRunner.destroy();
  }
  get uniforms() {
    return this.uniformGroup.uniforms;
  }
  static from(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.from(vertexSrc, fragmentSrc);
    return new Shader(program, uniforms);
  }
}
class BatchShaderGenerator {
  constructor(vertexSrc, fragTemplate2) {
    this.vertexSrc = vertexSrc;
    this.fragTemplate = fragTemplate2;
    this.programCache = {};
    this.defaultGroupCache = {};
    if (!fragTemplate2.includes("%count%")) {
      throw new Error('Fragment template must contain "%count%".');
    }
    if (!fragTemplate2.includes("%forloop%")) {
      throw new Error('Fragment template must contain "%forloop%".');
    }
  }
  generateShader(maxTextures) {
    if (!this.programCache[maxTextures]) {
      const sampleValues = new Int32Array(maxTextures);
      for (let i2 = 0; i2 < maxTextures; i2++) {
        sampleValues[i2] = i2;
      }
      this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);
      let fragmentSrc = this.fragTemplate;
      fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`);
      fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
      this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
    }
    const uniforms = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new Matrix(),
      default: this.defaultGroupCache[maxTextures]
    };
    return new Shader(this.programCache[maxTextures], uniforms);
  }
  generateSampleSrc(maxTextures) {
    let src = "";
    src += "\n";
    src += "\n";
    for (let i2 = 0; i2 < maxTextures; i2++) {
      if (i2 > 0) {
        src += "\nelse ";
      }
      if (i2 < maxTextures - 1) {
        src += `if(vTextureId < ${i2}.5)`;
      }
      src += "\n{";
      src += `
	color = texture2D(uSamplers[${i2}], vTextureCoord);`;
      src += "\n}";
    }
    src += "\n";
    src += "\n";
    return src;
  }
}
class BatchTextureArray {
  constructor() {
    this.elements = [];
    this.ids = [];
    this.count = 0;
  }
  clear() {
    for (let i2 = 0; i2 < this.count; i2++) {
      this.elements[i2] = null;
    }
    this.count = 0;
  }
}
function canUploadSameBuffer() {
  return !isMobile.apple.device;
}
function maxRecommendedTextures(max) {
  let allowMax = true;
  const navigator2 = settings.ADAPTER.getNavigator();
  if (isMobile.tablet || isMobile.phone) {
    if (isMobile.apple.device) {
      const match = navigator2.userAgent.match(/OS (\d+)_(\d+)?/);
      if (match) {
        const majorVersion = parseInt(match[1], 10);
        if (majorVersion < 11) {
          allowMax = false;
        }
      }
    }
    if (isMobile.android.device) {
      const match = navigator2.userAgent.match(/Android\s([0-9.]*)/);
      if (match) {
        const majorVersion = parseInt(match[1], 10);
        if (majorVersion < 7) {
          allowMax = false;
        }
      }
    }
  }
  return allowMax ? max : 4;
}
class ObjectRenderer {
  constructor(renderer2) {
    this.renderer = renderer2;
  }
  flush() {
  }
  destroy() {
    this.renderer = null;
  }
  start() {
  }
  stop() {
    this.flush();
  }
  render(_object) {
  }
}
var defaultFragment$1 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
var defaultVertex$2 = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";
const _BatchRenderer = class extends ObjectRenderer {
  constructor(renderer2) {
    super(renderer2);
    this.setShaderGenerator();
    this.geometryClass = BatchGeometry;
    this.vertexSize = 6;
    this.state = State.for2d();
    this.size = _BatchRenderer.defaultBatchSize * 4;
    this._vertexCount = 0;
    this._indexCount = 0;
    this._bufferedElements = [];
    this._bufferedTextures = [];
    this._bufferSize = 0;
    this._shader = null;
    this._packedGeometries = [];
    this._packedGeometryPoolSize = 2;
    this._flushId = 0;
    this._aBuffers = {};
    this._iBuffers = {};
    this.maxTextures = 1;
    this.renderer.on("prerender", this.onPrerender, this);
    renderer2.runners.contextChange.add(this);
    this._dcIndex = 0;
    this._aIndex = 0;
    this._iIndex = 0;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    this._tempBoundTextures = [];
  }
  static get defaultMaxTextures() {
    this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures(32);
    return this._defaultMaxTextures;
  }
  static set defaultMaxTextures(value2) {
    this._defaultMaxTextures = value2;
  }
  static get canUploadSameBuffer() {
    this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer();
    return this._canUploadSameBuffer;
  }
  static set canUploadSameBuffer(value2) {
    this._canUploadSameBuffer = value2;
  }
  get MAX_TEXTURES() {
    deprecation("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures");
    return this.maxTextures;
  }
  static get defaultVertexSrc() {
    return defaultVertex$2;
  }
  static get defaultFragmentTemplate() {
    return defaultFragment$1;
  }
  setShaderGenerator({
    vertex: vertex2 = _BatchRenderer.defaultVertexSrc,
    fragment: fragment2 = _BatchRenderer.defaultFragmentTemplate
  } = {}) {
    this.shaderGenerator = new BatchShaderGenerator(vertex2, fragment2);
  }
  contextChange() {
    const gl = this.renderer.gl;
    if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
      this.maxTextures = 1;
    } else {
      this.maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _BatchRenderer.defaultMaxTextures);
      this.maxTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);
    }
    this._shader = this.shaderGenerator.generateShader(this.maxTextures);
    for (let i2 = 0; i2 < this._packedGeometryPoolSize; i2++) {
      this._packedGeometries[i2] = new this.geometryClass();
    }
    this.initFlushBuffers();
  }
  initFlushBuffers() {
    const {
      _drawCallPool,
      _textureArrayPool
    } = _BatchRenderer;
    const MAX_SPRITES = this.size / 4;
    const MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;
    while (_drawCallPool.length < MAX_SPRITES) {
      _drawCallPool.push(new BatchDrawCall());
    }
    while (_textureArrayPool.length < MAX_TA) {
      _textureArrayPool.push(new BatchTextureArray());
    }
    for (let i2 = 0; i2 < this.maxTextures; i2++) {
      this._tempBoundTextures[i2] = null;
    }
  }
  onPrerender() {
    this._flushId = 0;
  }
  render(element) {
    if (!element._texture.valid) {
      return;
    }
    if (this._vertexCount + element.vertexData.length / 2 > this.size) {
      this.flush();
    }
    this._vertexCount += element.vertexData.length / 2;
    this._indexCount += element.indices.length;
    this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
    this._bufferedElements[this._bufferSize++] = element;
  }
  buildTexturesAndDrawCalls() {
    const {
      _bufferedTextures: textures,
      maxTextures
    } = this;
    const textureArrays = _BatchRenderer._textureArrayPool;
    const batch = this.renderer.batch;
    const boundTextures = this._tempBoundTextures;
    const touch = this.renderer.textureGC.count;
    let TICK = ++BaseTexture._globalBatch;
    let countTexArrays = 0;
    let texArray = textureArrays[0];
    let start = 0;
    batch.copyBoundTextures(boundTextures, maxTextures);
    for (let i2 = 0; i2 < this._bufferSize; ++i2) {
      const tex = textures[i2];
      textures[i2] = null;
      if (tex._batchEnabled === TICK) {
        continue;
      }
      if (texArray.count >= maxTextures) {
        batch.boundArray(texArray, boundTextures, TICK, maxTextures);
        this.buildDrawCalls(texArray, start, i2);
        start = i2;
        texArray = textureArrays[++countTexArrays];
        ++TICK;
      }
      tex._batchEnabled = TICK;
      tex.touched = touch;
      texArray.elements[texArray.count++] = tex;
    }
    if (texArray.count > 0) {
      batch.boundArray(texArray, boundTextures, TICK, maxTextures);
      this.buildDrawCalls(texArray, start, this._bufferSize);
      ++countTexArrays;
      ++TICK;
    }
    for (let i2 = 0; i2 < boundTextures.length; i2++) {
      boundTextures[i2] = null;
    }
    BaseTexture._globalBatch = TICK;
  }
  buildDrawCalls(texArray, start, finish) {
    const {
      _bufferedElements: elements,
      _attributeBuffer,
      _indexBuffer,
      vertexSize
    } = this;
    const drawCalls = _BatchRenderer._drawCallPool;
    let dcIndex = this._dcIndex;
    let aIndex = this._aIndex;
    let iIndex = this._iIndex;
    let drawCall = drawCalls[dcIndex];
    drawCall.start = this._iIndex;
    drawCall.texArray = texArray;
    for (let i2 = start; i2 < finish; ++i2) {
      const sprite = elements[i2];
      const tex = sprite._texture.baseTexture;
      const spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
      elements[i2] = null;
      if (start < i2 && drawCall.blend !== spriteBlendMode) {
        drawCall.size = iIndex - drawCall.start;
        start = i2;
        drawCall = drawCalls[++dcIndex];
        drawCall.texArray = texArray;
        drawCall.start = iIndex;
      }
      this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
      aIndex += sprite.vertexData.length / 2 * vertexSize;
      iIndex += sprite.indices.length;
      drawCall.blend = spriteBlendMode;
    }
    if (start < finish) {
      drawCall.size = iIndex - drawCall.start;
      ++dcIndex;
    }
    this._dcIndex = dcIndex;
    this._aIndex = aIndex;
    this._iIndex = iIndex;
  }
  bindAndClearTexArray(texArray) {
    const textureSystem = this.renderer.texture;
    for (let j2 = 0; j2 < texArray.count; j2++) {
      textureSystem.bind(texArray.elements[j2], texArray.ids[j2]);
      texArray.elements[j2] = null;
    }
    texArray.count = 0;
  }
  updateGeometry() {
    const {
      _packedGeometries: packedGeometries,
      _attributeBuffer: attributeBuffer,
      _indexBuffer: indexBuffer
    } = this;
    if (!_BatchRenderer.canUploadSameBuffer) {
      if (this._packedGeometryPoolSize <= this._flushId) {
        this._packedGeometryPoolSize++;
        packedGeometries[this._flushId] = new this.geometryClass();
      }
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.bind(packedGeometries[this._flushId]);
      this.renderer.geometry.updateBuffers();
      this._flushId++;
    } else {
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.updateBuffers();
    }
  }
  drawBatches() {
    const dcCount = this._dcIndex;
    const { gl, state: stateSystem } = this.renderer;
    const drawCalls = _BatchRenderer._drawCallPool;
    let curTexArray = null;
    for (let i2 = 0; i2 < dcCount; i2++) {
      const { texArray, type, size: size2, start, blend } = drawCalls[i2];
      if (curTexArray !== texArray) {
        curTexArray = texArray;
        this.bindAndClearTexArray(texArray);
      }
      this.state.blendMode = blend;
      stateSystem.set(this.state);
      gl.drawElements(type, size2, gl.UNSIGNED_SHORT, start * 2);
    }
  }
  flush() {
    if (this._vertexCount === 0) {
      return;
    }
    this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
    this._indexBuffer = this.getIndexBuffer(this._indexCount);
    this._aIndex = 0;
    this._iIndex = 0;
    this._dcIndex = 0;
    this.buildTexturesAndDrawCalls();
    this.updateGeometry();
    this.drawBatches();
    this._bufferSize = 0;
    this._vertexCount = 0;
    this._indexCount = 0;
  }
  start() {
    this.renderer.state.set(this.state);
    this.renderer.texture.ensureSamplerType(this.maxTextures);
    this.renderer.shader.bind(this._shader);
    if (_BatchRenderer.canUploadSameBuffer) {
      this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }
  }
  stop() {
    this.flush();
  }
  destroy() {
    for (let i2 = 0; i2 < this._packedGeometryPoolSize; i2++) {
      if (this._packedGeometries[i2]) {
        this._packedGeometries[i2].destroy();
      }
    }
    this.renderer.off("prerender", this.onPrerender, this);
    this._aBuffers = null;
    this._iBuffers = null;
    this._packedGeometries = null;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    if (this._shader) {
      this._shader.destroy();
      this._shader = null;
    }
    super.destroy();
  }
  getAttributeBuffer(size2) {
    const roundedP2 = nextPow2(Math.ceil(size2 / 8));
    const roundedSizeIndex = log2(roundedP2);
    const roundedSize = roundedP2 * 8;
    if (this._aBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    let buffer2 = this._aBuffers[roundedSize];
    if (!buffer2) {
      this._aBuffers[roundedSize] = buffer2 = new ViewableBuffer(roundedSize * this.vertexSize * 4);
    }
    return buffer2;
  }
  getIndexBuffer(size2) {
    const roundedP2 = nextPow2(Math.ceil(size2 / 12));
    const roundedSizeIndex = log2(roundedP2);
    const roundedSize = roundedP2 * 12;
    if (this._iBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    let buffer2 = this._iBuffers[roundedSizeIndex];
    if (!buffer2) {
      this._iBuffers[roundedSizeIndex] = buffer2 = new Uint16Array(roundedSize);
    }
    return buffer2;
  }
  packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
    const {
      uint32View,
      float32View
    } = attributeBuffer;
    const packedVertices = aIndex / this.vertexSize;
    const uvs = element.uvs;
    const indicies = element.indices;
    const vertexData = element.vertexData;
    const textureId = element._texture.baseTexture._batchLocation;
    const alpha = Math.min(element.worldAlpha, 1);
    const argb = Color.shared.setValue(element._tintRGB).toPremultiplied(alpha, element._texture.baseTexture.alphaMode > 0);
    for (let i2 = 0; i2 < vertexData.length; i2 += 2) {
      float32View[aIndex++] = vertexData[i2];
      float32View[aIndex++] = vertexData[i2 + 1];
      float32View[aIndex++] = uvs[i2];
      float32View[aIndex++] = uvs[i2 + 1];
      uint32View[aIndex++] = argb;
      float32View[aIndex++] = textureId;
    }
    for (let i2 = 0; i2 < indicies.length; i2++) {
      indexBuffer[iIndex++] = packedVertices + indicies[i2];
    }
  }
};
let BatchRenderer = _BatchRenderer;
BatchRenderer.defaultBatchSize = 4096;
BatchRenderer.extension = {
  name: "batch",
  type: ExtensionType.RendererPlugin
};
BatchRenderer._drawCallPool = [];
BatchRenderer._textureArrayPool = [];
extensions$1.add(BatchRenderer);
var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
var defaultVertex$1 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
const _Filter = class extends Shader {
  constructor(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.from(vertexSrc || _Filter.defaultVertexSrc, fragmentSrc || _Filter.defaultFragmentSrc);
    super(program, uniforms);
    this.padding = 0;
    this.resolution = _Filter.defaultResolution;
    this.multisample = _Filter.defaultMultisample;
    this.enabled = true;
    this.autoFit = true;
    this.state = new State();
  }
  apply(filterManager, input, output, clearMode, _currentState) {
    filterManager.applyFilter(this, input, output, clearMode);
  }
  get blendMode() {
    return this.state.blendMode;
  }
  set blendMode(value2) {
    this.state.blendMode = value2;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value2) {
    this._resolution = value2;
  }
  static get defaultVertexSrc() {
    return defaultVertex$1;
  }
  static get defaultFragmentSrc() {
    return defaultFragment;
  }
};
let Filter = _Filter;
Filter.defaultResolution = 1;
Filter.defaultMultisample = MSAA_QUALITY.NONE;
class BackgroundSystem {
  constructor() {
    this.clearBeforeRender = true;
    this._backgroundColor = new Color(0);
    this.alpha = 1;
  }
  init(options) {
    this.clearBeforeRender = options.clearBeforeRender;
    const { backgroundColor, background, backgroundAlpha } = options;
    const color = background ?? backgroundColor;
    if (color !== void 0) {
      this.color = color;
    }
    this.alpha = backgroundAlpha;
  }
  get color() {
    return this._backgroundColor.value;
  }
  set color(value2) {
    this._backgroundColor.setValue(value2);
  }
  get alpha() {
    return this._backgroundColor.alpha;
  }
  set alpha(value2) {
    this._backgroundColor.setAlpha(value2);
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  destroy() {
  }
}
BackgroundSystem.defaultOptions = {
  backgroundAlpha: 1,
  backgroundColor: 0,
  clearBeforeRender: true
};
BackgroundSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "background"
};
extensions$1.add(BackgroundSystem);
class BatchSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.emptyRenderer = new ObjectRenderer(renderer2);
    this.currentRenderer = this.emptyRenderer;
  }
  setObjectRenderer(objectRenderer) {
    if (this.currentRenderer === objectRenderer) {
      return;
    }
    this.currentRenderer.stop();
    this.currentRenderer = objectRenderer;
    this.currentRenderer.start();
  }
  flush() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  reset() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  copyBoundTextures(arr, maxTextures) {
    const { boundTextures } = this.renderer.texture;
    for (let i2 = maxTextures - 1; i2 >= 0; --i2) {
      arr[i2] = boundTextures[i2] || null;
      if (arr[i2]) {
        arr[i2]._batchLocation = i2;
      }
    }
  }
  boundArray(texArray, boundTextures, batchId, maxTextures) {
    const { elements, ids, count } = texArray;
    let j2 = 0;
    for (let i2 = 0; i2 < count; i2++) {
      const tex = elements[i2];
      const loc = tex._batchLocation;
      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
        ids[i2] = loc;
        continue;
      }
      while (j2 < maxTextures) {
        const bound = boundTextures[j2];
        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j2) {
          j2++;
          continue;
        }
        ids[i2] = j2;
        tex._batchLocation = j2;
        boundTextures[j2] = tex;
        break;
      }
    }
  }
  destroy() {
    this.renderer = null;
  }
}
BatchSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "batch"
};
extensions$1.add(BatchSystem);
let CONTEXT_UID_COUNTER = 0;
class ContextSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.webGLVersion = 1;
    this.extensions = {};
    this.supports = {
      uint32Indices: false
    };
    this.handleContextLost = this.handleContextLost.bind(this);
    this.handleContextRestored = this.handleContextRestored.bind(this);
  }
  get isLost() {
    return !this.gl || this.gl.isContextLost();
  }
  contextChange(gl) {
    this.gl = gl;
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
  }
  init(options) {
    if (options.context) {
      this.initFromContext(options.context);
    } else {
      const alpha = this.renderer.background.alpha < 1;
      const premultipliedAlpha = options.premultipliedAlpha;
      this.preserveDrawingBuffer = options.preserveDrawingBuffer;
      this.useContextAlpha = options.useContextAlpha;
      this.powerPreference = options.powerPreference;
      this.initFromOptions({
        alpha,
        premultipliedAlpha,
        antialias: options.antialias,
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer,
        powerPreference: options.powerPreference
      });
    }
  }
  initFromContext(gl) {
    this.gl = gl;
    this.validateContext(gl);
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    this.renderer.runners.contextChange.emit(gl);
    const view = this.renderer.view;
    if (view.addEventListener !== void 0) {
      view.addEventListener("webglcontextlost", this.handleContextLost, false);
      view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
    }
  }
  initFromOptions(options) {
    const gl = this.createContext(this.renderer.view, options);
    this.initFromContext(gl);
  }
  createContext(canvas, options) {
    let gl;
    if (settings.PREFER_ENV >= ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", options);
    }
    if (gl) {
      this.webGLVersion = 2;
    } else {
      this.webGLVersion = 1;
      gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
      if (!gl) {
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      }
    }
    this.gl = gl;
    this.getExtensions();
    return this.gl;
  }
  getExtensions() {
    const { gl } = this;
    const common = {
      loseContext: gl.getExtension("WEBGL_lose_context"),
      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc")
    };
    if (this.webGLVersion === 1) {
      Object.assign(this.extensions, common, {
        drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
        depthTexture: gl.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
        floatTexture: gl.getExtension("OES_texture_float"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        textureHalfFloat: gl.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
      });
    } else if (this.webGLVersion === 2) {
      Object.assign(this.extensions, common, {
        colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
      });
    }
  }
  handleContextLost(event) {
    event.preventDefault();
    setTimeout(() => {
      if (this.gl.isContextLost() && this.extensions.loseContext) {
        this.extensions.loseContext.restoreContext();
      }
    }, 0);
  }
  handleContextRestored() {
    this.renderer.runners.contextChange.emit(this.gl);
  }
  destroy() {
    const view = this.renderer.view;
    this.renderer = null;
    if (view.removeEventListener !== void 0) {
      view.removeEventListener("webglcontextlost", this.handleContextLost);
      view.removeEventListener("webglcontextrestored", this.handleContextRestored);
    }
    this.gl.useProgram(null);
    if (this.extensions.loseContext) {
      this.extensions.loseContext.loseContext();
    }
  }
  postrender() {
    if (this.renderer.objectRenderer.renderingToScreen) {
      this.gl.flush();
    }
  }
  validateContext(gl) {
    const attributes = gl.getContextAttributes();
    const isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
    if (isWebGl2) {
      this.webGLVersion = 2;
    }
    if (attributes && !attributes.stencil) {
      console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    }
    const hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
    this.supports.uint32Indices = hasuint32;
    if (!hasuint32) {
      console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }
  }
}
ContextSystem.defaultOptions = {
  context: null,
  antialias: false,
  premultipliedAlpha: true,
  preserveDrawingBuffer: false,
  powerPreference: "default"
};
ContextSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "context"
};
extensions$1.add(ContextSystem);
class DepthResource extends BufferResource {
  upload(renderer2, baseTexture, glTexture) {
    const gl = renderer2.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  }
}
class Framebuffer {
  constructor(width, height) {
    this.width = Math.round(width || 100);
    this.height = Math.round(height || 100);
    this.stencil = false;
    this.depth = false;
    this.dirtyId = 0;
    this.dirtyFormat = 0;
    this.dirtySize = 0;
    this.depthTexture = null;
    this.colorTextures = [];
    this.glFramebuffers = {};
    this.disposeRunner = new Runner("disposeFramebuffer");
    this.multisample = MSAA_QUALITY.NONE;
  }
  get colorTexture() {
    return this.colorTextures[0];
  }
  addColorTexture(index2 = 0, texture) {
    this.colorTextures[index2] = texture || new BaseTexture(null, {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      mipmap: MIPMAP_MODES.OFF,
      width: this.width,
      height: this.height
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  addDepthTexture(texture) {
    this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      width: this.width,
      height: this.height,
      mipmap: MIPMAP_MODES.OFF,
      format: FORMATS.DEPTH_COMPONENT,
      type: TYPES.UNSIGNED_SHORT
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  enableDepth() {
    this.depth = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  enableStencil() {
    this.stencil = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  resize(width, height) {
    width = Math.round(width);
    height = Math.round(height);
    if (width === this.width && height === this.height)
      return;
    this.width = width;
    this.height = height;
    this.dirtyId++;
    this.dirtySize++;
    for (let i2 = 0; i2 < this.colorTextures.length; i2++) {
      const texture = this.colorTextures[i2];
      const resolution = texture.resolution;
      texture.setSize(width / resolution, height / resolution);
    }
    if (this.depthTexture) {
      const resolution = this.depthTexture.resolution;
      this.depthTexture.setSize(width / resolution, height / resolution);
    }
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroyDepthTexture() {
    if (this.depthTexture) {
      this.depthTexture.destroy();
      this.depthTexture = null;
      ++this.dirtyId;
      ++this.dirtyFormat;
    }
  }
}
class BaseRenderTexture extends BaseTexture {
  constructor(options = {}) {
    if (typeof options === "number") {
      const width = arguments[0];
      const height = arguments[1];
      const scaleMode = arguments[2];
      const resolution = arguments[3];
      options = { width, height, scaleMode, resolution };
    }
    options.width = options.width || 100;
    options.height = options.height || 100;
    options.multisample ?? (options.multisample = MSAA_QUALITY.NONE);
    super(null, options);
    this.mipmap = MIPMAP_MODES.OFF;
    this.valid = true;
    this._clear = new Color([0, 0, 0, 0]);
    this.framebuffer = new Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this);
    this.framebuffer.multisample = options.multisample;
    this.maskStack = [];
    this.filterStack = [{}];
  }
  set clearColor(value2) {
    this._clear.setValue(value2);
  }
  get clearColor() {
    return this._clear.value;
  }
  get clear() {
    return this._clear;
  }
  resize(desiredWidth, desiredHeight) {
    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);
    this.setRealSize(this.framebuffer.width, this.framebuffer.height);
  }
  dispose() {
    this.framebuffer.dispose();
    super.dispose();
  }
  destroy() {
    super.destroy();
    this.framebuffer.destroyDepthTexture();
    this.framebuffer = null;
  }
}
class BaseImageResource extends Resource {
  constructor(source) {
    const sourceAny = source;
    const width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
    const height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
    super(width, height);
    this.source = source;
    this.noSubImage = false;
  }
  static crossOrigin(element, url2, crossorigin) {
    if (crossorigin === void 0 && !url2.startsWith("data:")) {
      element.crossOrigin = determineCrossOrigin(url2);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  }
  upload(renderer2, baseTexture, glTexture, source) {
    const gl = renderer2.gl;
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    source = source || this.source;
    if (typeof HTMLImageElement !== "undefined" && source instanceof HTMLImageElement) {
      if (!source.complete || source.naturalWidth === 0) {
        return false;
      }
    } else if (typeof HTMLVideoElement !== "undefined" && source instanceof HTMLVideoElement) {
      if (source.readyState <= 1 && source.buffered.length === 0) {
        return false;
      }
    }
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);
    }
    return true;
  }
  update() {
    if (this.destroyed) {
      return;
    }
    const source = this.source;
    const width = source.naturalWidth || source.videoWidth || source.width;
    const height = source.naturalHeight || source.videoHeight || source.height;
    this.resize(width, height);
    super.update();
  }
  dispose() {
    this.source = null;
  }
}
class ImageResource extends BaseImageResource {
  constructor(source, options) {
    options = options || {};
    if (typeof source === "string") {
      const imageElement = new Image();
      BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
      imageElement.src = source;
      source = imageElement;
    }
    super(source);
    if (!source.complete && !!this._width && !!this._height) {
      this._width = 0;
      this._height = 0;
    }
    this.url = source.src;
    this._process = null;
    this.preserveBitmap = false;
    this.createBitmap = (options.createBitmap ?? settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;
    this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
    this.bitmap = null;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load(createBitmap) {
    if (this._load) {
      return this._load;
    }
    if (createBitmap !== void 0) {
      this.createBitmap = createBitmap;
    }
    this._load = new Promise((resolve2, reject) => {
      const source = this.source;
      this.url = source.src;
      const completed = () => {
        if (this.destroyed) {
          return;
        }
        source.onload = null;
        source.onerror = null;
        this.resize(source.width, source.height);
        this._load = null;
        if (this.createBitmap) {
          resolve2(this.process());
        } else {
          resolve2(this);
        }
      };
      if (source.complete && source.src) {
        completed();
      } else {
        source.onload = completed;
        source.onerror = (event) => {
          reject(event);
          this.onError.emit(event);
        };
      }
    });
    return this._load;
  }
  process() {
    const source = this.source;
    if (this._process !== null) {
      return this._process;
    }
    if (this.bitmap !== null || !globalThis.createImageBitmap) {
      return Promise.resolve(this);
    }
    const createImageBitmap2 = globalThis.createImageBitmap;
    const cors = !source.crossOrigin || source.crossOrigin === "anonymous";
    this._process = fetch(source.src, {
      mode: cors ? "cors" : "no-cors"
    }).then((r2) => r2.blob()).then((blob) => createImageBitmap2(blob, 0, 0, source.width, source.height, {
      premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
    })).then((bitmap) => {
      if (this.destroyed) {
        return Promise.reject();
      }
      this.bitmap = bitmap;
      this.update();
      this._process = null;
      return Promise.resolve(this);
    });
    return this._process;
  }
  upload(renderer2, baseTexture, glTexture) {
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    if (!this.createBitmap) {
      return super.upload(renderer2, baseTexture, glTexture);
    }
    if (!this.bitmap) {
      this.process();
      if (!this.bitmap) {
        return false;
      }
    }
    super.upload(renderer2, baseTexture, glTexture, this.bitmap);
    if (!this.preserveBitmap) {
      let flag = true;
      const glTextures = baseTexture._glTextures;
      for (const key in glTextures) {
        const otherTex = glTextures[key];
        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
          flag = false;
          break;
        }
      }
      if (flag) {
        if (this.bitmap.close) {
          this.bitmap.close();
        }
        this.bitmap = null;
      }
    }
    return true;
  }
  dispose() {
    this.source.onload = null;
    this.source.onerror = null;
    super.dispose();
    if (this.bitmap) {
      this.bitmap.close();
      this.bitmap = null;
    }
    this._process = null;
    this._load = null;
  }
  static test(source) {
    return typeof HTMLImageElement !== "undefined" && (typeof source === "string" || source instanceof HTMLImageElement);
  }
}
class TextureUvs {
  constructor() {
    this.x0 = 0;
    this.y0 = 0;
    this.x1 = 1;
    this.y1 = 0;
    this.x2 = 1;
    this.y2 = 1;
    this.x3 = 0;
    this.y3 = 1;
    this.uvsFloat32 = new Float32Array(8);
  }
  set(frame, baseFrame, rotate) {
    const tw = baseFrame.width;
    const th = baseFrame.height;
    if (rotate) {
      const w2 = frame.width / 2 / tw;
      const h2 = frame.height / 2 / th;
      const cX = frame.x / tw + w2;
      const cY = frame.y / th + h2;
      rotate = groupD8.add(rotate, groupD8.NW);
      this.x0 = cX + w2 * groupD8.uX(rotate);
      this.y0 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x1 = cX + w2 * groupD8.uX(rotate);
      this.y1 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x2 = cX + w2 * groupD8.uX(rotate);
      this.y2 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x3 = cX + w2 * groupD8.uX(rotate);
      this.y3 = cY + h2 * groupD8.uY(rotate);
    } else {
      this.x0 = frame.x / tw;
      this.y0 = frame.y / th;
      this.x1 = (frame.x + frame.width) / tw;
      this.y1 = frame.y / th;
      this.x2 = (frame.x + frame.width) / tw;
      this.y2 = (frame.y + frame.height) / th;
      this.x3 = frame.x / tw;
      this.y3 = (frame.y + frame.height) / th;
    }
    this.uvsFloat32[0] = this.x0;
    this.uvsFloat32[1] = this.y0;
    this.uvsFloat32[2] = this.x1;
    this.uvsFloat32[3] = this.y1;
    this.uvsFloat32[4] = this.x2;
    this.uvsFloat32[5] = this.y2;
    this.uvsFloat32[6] = this.x3;
    this.uvsFloat32[7] = this.y3;
  }
  toString() {
    return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
  }
}
const DEFAULT_UVS = new TextureUvs();
function removeAllHandlers(tex) {
  tex.destroy = function _emptyDestroy() {
  };
  tex.on = function _emptyOn() {
  };
  tex.once = function _emptyOnce() {
  };
  tex.emit = function _emptyEmit() {
  };
}
class Texture extends EventEmitter2 {
  constructor(baseTexture, frame, orig, trim, rotate, anchor, borders) {
    super();
    this.noFrame = false;
    if (!frame) {
      this.noFrame = true;
      frame = new Rectangle(0, 0, 1, 1);
    }
    if (baseTexture instanceof Texture) {
      baseTexture = baseTexture.baseTexture;
    }
    this.baseTexture = baseTexture;
    this._frame = frame;
    this.trim = trim;
    this.valid = false;
    this._uvs = DEFAULT_UVS;
    this.uvMatrix = null;
    this.orig = orig || frame;
    this._rotate = Number(rotate || 0);
    if (rotate === true) {
      this._rotate = 2;
    } else if (this._rotate % 2 !== 0) {
      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
    }
    this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);
    this.defaultBorders = borders;
    this._updateID = 0;
    this.textureCacheIds = [];
    if (!baseTexture.valid) {
      baseTexture.once("loaded", this.onBaseTextureUpdated, this);
    } else if (this.noFrame) {
      if (baseTexture.valid) {
        this.onBaseTextureUpdated(baseTexture);
      }
    } else {
      this.frame = frame;
    }
    if (this.noFrame) {
      baseTexture.on("update", this.onBaseTextureUpdated, this);
    }
  }
  update() {
    if (this.baseTexture.resource) {
      this.baseTexture.resource.update();
    }
  }
  onBaseTextureUpdated(baseTexture) {
    if (this.noFrame) {
      if (!this.baseTexture.valid) {
        return;
      }
      this._frame.width = baseTexture.width;
      this._frame.height = baseTexture.height;
      this.valid = true;
      this.updateUvs();
    } else {
      this.frame = this._frame;
    }
    this.emit("update", this);
  }
  destroy(destroyBase) {
    if (this.baseTexture) {
      if (destroyBase) {
        const { resource } = this.baseTexture;
        if ((resource == null ? void 0 : resource.url) && TextureCache[resource.url]) {
          Texture.removeFromCache(resource.url);
        }
        this.baseTexture.destroy();
      }
      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
      this.baseTexture.off("update", this.onBaseTextureUpdated, this);
      this.baseTexture = null;
    }
    this._frame = null;
    this._uvs = null;
    this.trim = null;
    this.orig = null;
    this.valid = false;
    Texture.removeFromCache(this);
    this.textureCacheIds = null;
  }
  clone() {
    var _a;
    const clonedFrame = this._frame.clone();
    const clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
    const clonedTexture = new Texture(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, (_a = this.trim) == null ? void 0 : _a.clone(), this.rotate, this.defaultAnchor, this.defaultBorders);
    if (this.noFrame) {
      clonedTexture._frame = clonedFrame;
    }
    return clonedTexture;
  }
  updateUvs() {
    if (this._uvs === DEFAULT_UVS) {
      this._uvs = new TextureUvs();
    }
    this._uvs.set(this._frame, this.baseTexture, this.rotate);
    this._updateID++;
  }
  static from(source, options = {}, strict = settings.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source === "string";
    let cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else if (source instanceof BaseTexture) {
      if (!source.cacheId) {
        const prefix = (options == null ? void 0 : options.pixiIdPrefix) || "pixiid";
        source.cacheId = `${prefix}-${uid$2()}`;
        BaseTexture.addToCache(source, source.cacheId);
      }
      cacheId = source.cacheId;
    } else {
      if (!source._pixiId) {
        const prefix = (options == null ? void 0 : options.pixiIdPrefix) || "pixiid";
        source._pixiId = `${prefix}_${uid$2()}`;
      }
      cacheId = source._pixiId;
    }
    let texture = TextureCache[cacheId];
    if (isFrame && strict && !texture) {
      throw new Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);
    }
    if (!texture && !(source instanceof BaseTexture)) {
      if (!options.resolution) {
        options.resolution = getResolutionOfUrl(source);
      }
      texture = new Texture(new BaseTexture(source, options));
      texture.baseTexture.cacheId = cacheId;
      BaseTexture.addToCache(texture.baseTexture, cacheId);
      Texture.addToCache(texture, cacheId);
    } else if (!texture && source instanceof BaseTexture) {
      texture = new Texture(source);
      Texture.addToCache(texture, cacheId);
    }
    return texture;
  }
  static fromURL(url2, options) {
    const resourceOptions = Object.assign({ autoLoad: false }, options == null ? void 0 : options.resourceOptions);
    const texture = Texture.from(url2, Object.assign({ resourceOptions }, options), false);
    const resource = texture.baseTexture.resource;
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return resource.load().then(() => Promise.resolve(texture));
  }
  static fromBuffer(buffer2, width, height, options) {
    return new Texture(BaseTexture.fromBuffer(buffer2, width, height, options));
  }
  static fromLoader(source, imageUrl, name, options) {
    const baseTexture = new BaseTexture(source, Object.assign({
      scaleMode: BaseTexture.defaultOptions.scaleMode,
      resolution: getResolutionOfUrl(imageUrl)
    }, options));
    const { resource } = baseTexture;
    if (resource instanceof ImageResource) {
      resource.url = imageUrl;
    }
    const texture = new Texture(baseTexture);
    if (!name) {
      name = imageUrl;
    }
    BaseTexture.addToCache(texture.baseTexture, name);
    Texture.addToCache(texture, name);
    if (name !== imageUrl) {
      BaseTexture.addToCache(texture.baseTexture, imageUrl);
      Texture.addToCache(texture, imageUrl);
    }
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return new Promise((resolve2) => {
      texture.baseTexture.once("loaded", () => resolve2(texture));
    });
  }
  static addToCache(texture, id) {
    if (id) {
      if (!texture.textureCacheIds.includes(id)) {
        texture.textureCacheIds.push(id);
      }
      if (TextureCache[id] && TextureCache[id] !== texture) {
        console.warn(`Texture added to the cache with an id [${id}] that already had an entry`);
      }
      TextureCache[id] = texture;
    }
  }
  static removeFromCache(texture) {
    if (typeof texture === "string") {
      const textureFromCache = TextureCache[texture];
      if (textureFromCache) {
        const index2 = textureFromCache.textureCacheIds.indexOf(texture);
        if (index2 > -1) {
          textureFromCache.textureCacheIds.splice(index2, 1);
        }
        delete TextureCache[texture];
        return textureFromCache;
      }
    } else if (texture == null ? void 0 : texture.textureCacheIds) {
      for (let i2 = 0; i2 < texture.textureCacheIds.length; ++i2) {
        if (TextureCache[texture.textureCacheIds[i2]] === texture) {
          delete TextureCache[texture.textureCacheIds[i2]];
        }
      }
      texture.textureCacheIds.length = 0;
      return texture;
    }
    return null;
  }
  get resolution() {
    return this.baseTexture.resolution;
  }
  get frame() {
    return this._frame;
  }
  set frame(frame) {
    this._frame = frame;
    this.noFrame = false;
    const { x: x2, y: y2, width, height } = frame;
    const xNotFit = x2 + width > this.baseTexture.width;
    const yNotFit = y2 + height > this.baseTexture.height;
    if (xNotFit || yNotFit) {
      const relationship = xNotFit && yNotFit ? "and" : "or";
      const errorX = `X: ${x2} + ${width} = ${x2 + width} > ${this.baseTexture.width}`;
      const errorY = `Y: ${y2} + ${height} = ${y2 + height} > ${this.baseTexture.height}`;
      throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);
    }
    this.valid = width && height && this.baseTexture.valid;
    if (!this.trim && !this.rotate) {
      this.orig = frame;
    }
    if (this.valid) {
      this.updateUvs();
    }
  }
  get rotate() {
    return this._rotate;
  }
  set rotate(rotate) {
    this._rotate = rotate;
    if (this.valid) {
      this.updateUvs();
    }
  }
  get width() {
    return this.orig.width;
  }
  get height() {
    return this.orig.height;
  }
  castToBaseTexture() {
    return this.baseTexture;
  }
  static get EMPTY() {
    if (!Texture._EMPTY) {
      Texture._EMPTY = new Texture(new BaseTexture());
      removeAllHandlers(Texture._EMPTY);
      removeAllHandlers(Texture._EMPTY.baseTexture);
    }
    return Texture._EMPTY;
  }
  static get WHITE() {
    if (!Texture._WHITE) {
      const canvas = settings.ADAPTER.createCanvas(16, 16);
      const context2 = canvas.getContext("2d");
      canvas.width = 16;
      canvas.height = 16;
      context2.fillStyle = "white";
      context2.fillRect(0, 0, 16, 16);
      Texture._WHITE = new Texture(BaseTexture.from(canvas));
      removeAllHandlers(Texture._WHITE);
      removeAllHandlers(Texture._WHITE.baseTexture);
    }
    return Texture._WHITE;
  }
}
class RenderTexture extends Texture {
  constructor(baseRenderTexture, frame) {
    super(baseRenderTexture, frame);
    this.valid = true;
    this.filterFrame = null;
    this.filterPoolKey = null;
    this.updateUvs();
  }
  get framebuffer() {
    return this.baseTexture.framebuffer;
  }
  get multisample() {
    return this.framebuffer.multisample;
  }
  set multisample(value2) {
    this.framebuffer.multisample = value2;
  }
  resize(desiredWidth, desiredHeight, resizeBaseTexture = true) {
    const resolution = this.baseTexture.resolution;
    const width = Math.round(desiredWidth * resolution) / resolution;
    const height = Math.round(desiredHeight * resolution) / resolution;
    this.valid = width > 0 && height > 0;
    this._frame.width = this.orig.width = width;
    this._frame.height = this.orig.height = height;
    if (resizeBaseTexture) {
      this.baseTexture.resize(width, height);
    }
    this.updateUvs();
  }
  setResolution(resolution) {
    const { baseTexture } = this;
    if (baseTexture.resolution === resolution) {
      return;
    }
    baseTexture.setResolution(resolution);
    this.resize(baseTexture.width, baseTexture.height, false);
  }
  static create(options) {
    return new RenderTexture(new BaseRenderTexture(options));
  }
}
class RenderTexturePool {
  constructor(textureOptions) {
    this.texturePool = {};
    this.textureOptions = textureOptions || {};
    this.enableFullScreen = false;
    this._pixelsWidth = 0;
    this._pixelsHeight = 0;
  }
  createTexture(realWidth, realHeight, multisample = MSAA_QUALITY.NONE) {
    const baseRenderTexture = new BaseRenderTexture(Object.assign({
      width: realWidth,
      height: realHeight,
      resolution: 1,
      multisample
    }, this.textureOptions));
    return new RenderTexture(baseRenderTexture);
  }
  getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
    let key;
    minWidth = Math.ceil(minWidth * resolution - 1e-6);
    minHeight = Math.ceil(minHeight * resolution - 1e-6);
    if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
      minWidth = nextPow2(minWidth);
      minHeight = nextPow2(minHeight);
      key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;
      if (multisample > 1) {
        key += multisample * 4294967296;
      }
    } else {
      key = multisample > 1 ? -multisample : -1;
    }
    if (!this.texturePool[key]) {
      this.texturePool[key] = [];
    }
    let renderTexture = this.texturePool[key].pop();
    if (!renderTexture) {
      renderTexture = this.createTexture(minWidth, minHeight, multisample);
    }
    renderTexture.filterPoolKey = key;
    renderTexture.setResolution(resolution);
    return renderTexture;
  }
  getFilterTexture(input, resolution, multisample) {
    const filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  }
  returnTexture(renderTexture) {
    const key = renderTexture.filterPoolKey;
    renderTexture.filterFrame = null;
    this.texturePool[key].push(renderTexture);
  }
  returnFilterTexture(renderTexture) {
    this.returnTexture(renderTexture);
  }
  clear(destroyTextures) {
    destroyTextures = destroyTextures !== false;
    if (destroyTextures) {
      for (const i2 in this.texturePool) {
        const textures = this.texturePool[i2];
        if (textures) {
          for (let j2 = 0; j2 < textures.length; j2++) {
            textures[j2].destroy(true);
          }
        }
      }
    }
    this.texturePool = {};
  }
  setScreenSize(size2) {
    if (size2.width === this._pixelsWidth && size2.height === this._pixelsHeight) {
      return;
    }
    this.enableFullScreen = size2.width > 0 && size2.height > 0;
    for (const i2 in this.texturePool) {
      if (!(Number(i2) < 0)) {
        continue;
      }
      const textures = this.texturePool[i2];
      if (textures) {
        for (let j2 = 0; j2 < textures.length; j2++) {
          textures[j2].destroy(true);
        }
      }
      this.texturePool[i2] = [];
    }
    this._pixelsWidth = size2.width;
    this._pixelsHeight = size2.height;
  }
}
RenderTexturePool.SCREEN_KEY = -1;
class Quad extends Geometry {
  constructor() {
    super();
    this.addAttribute("aVertexPosition", new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ])).addIndex([0, 1, 3, 2]);
  }
}
class QuadUv extends Geometry {
  constructor() {
    super();
    this.vertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1
    ]);
    this.uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]);
    this.vertexBuffer = new Buffer$1(this.vertices);
    this.uvBuffer = new Buffer$1(this.uvs);
    this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
  }
  map(targetTextureFrame, destinationFrame) {
    let x2 = 0;
    let y2 = 0;
    this.uvs[0] = x2;
    this.uvs[1] = y2;
    this.uvs[2] = x2 + destinationFrame.width / targetTextureFrame.width;
    this.uvs[3] = y2;
    this.uvs[4] = x2 + destinationFrame.width / targetTextureFrame.width;
    this.uvs[5] = y2 + destinationFrame.height / targetTextureFrame.height;
    this.uvs[6] = x2;
    this.uvs[7] = y2 + destinationFrame.height / targetTextureFrame.height;
    x2 = destinationFrame.x;
    y2 = destinationFrame.y;
    this.vertices[0] = x2;
    this.vertices[1] = y2;
    this.vertices[2] = x2 + destinationFrame.width;
    this.vertices[3] = y2;
    this.vertices[4] = x2 + destinationFrame.width;
    this.vertices[5] = y2 + destinationFrame.height;
    this.vertices[6] = x2;
    this.vertices[7] = y2 + destinationFrame.height;
    this.invalidate();
    return this;
  }
  invalidate() {
    this.vertexBuffer._updateID++;
    this.uvBuffer._updateID++;
    return this;
  }
}
class FilterState {
  constructor() {
    this.renderTexture = null;
    this.target = null;
    this.legacy = false;
    this.resolution = 1;
    this.multisample = MSAA_QUALITY.NONE;
    this.sourceFrame = new Rectangle();
    this.destinationFrame = new Rectangle();
    this.bindingSourceFrame = new Rectangle();
    this.bindingDestinationFrame = new Rectangle();
    this.filters = [];
    this.transform = null;
  }
  clear() {
    this.target = null;
    this.filters = null;
    this.renderTexture = null;
  }
}
const tempPoints = [new Point(), new Point(), new Point(), new Point()];
const tempMatrix$2 = new Matrix();
class FilterSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.defaultFilterStack = [{}];
    this.texturePool = new RenderTexturePool();
    this.statePool = [];
    this.quad = new Quad();
    this.quadUv = new QuadUv();
    this.tempRect = new Rectangle();
    this.activeState = {};
    this.globalUniforms = new UniformGroup({
      outputFrame: new Rectangle(),
      inputSize: new Float32Array(4),
      inputPixel: new Float32Array(4),
      inputClamp: new Float32Array(4),
      resolution: 1,
      filterArea: new Float32Array(4),
      filterClamp: new Float32Array(4)
    }, true);
    this.forceClear = false;
    this.useMaxPadding = false;
  }
  init() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  push(target, filters2) {
    const renderer2 = this.renderer;
    const filterStack = this.defaultFilterStack;
    const state = this.statePool.pop() || new FilterState();
    const renderTextureSystem = this.renderer.renderTexture;
    let resolution = filters2[0].resolution;
    let multisample = filters2[0].multisample;
    let padding = filters2[0].padding;
    let autoFit = filters2[0].autoFit;
    let legacy = filters2[0].legacy ?? true;
    for (let i2 = 1; i2 < filters2.length; i2++) {
      const filter2 = filters2[i2];
      resolution = Math.min(resolution, filter2.resolution);
      multisample = Math.min(multisample, filter2.multisample);
      padding = this.useMaxPadding ? Math.max(padding, filter2.padding) : padding + filter2.padding;
      autoFit = autoFit && filter2.autoFit;
      legacy = legacy || (filter2.legacy ?? true);
    }
    if (filterStack.length === 1) {
      this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
    }
    filterStack.push(state);
    state.resolution = resolution;
    state.multisample = multisample;
    state.legacy = legacy;
    state.target = target;
    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
    state.sourceFrame.pad(padding);
    const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
    if (renderer2.projection.transform) {
      this.transformAABB(tempMatrix$2.copyFrom(renderer2.projection.transform).invert(), sourceFrameProjected);
    }
    if (autoFit) {
      state.sourceFrame.fit(sourceFrameProjected);
      if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {
        state.sourceFrame.width = 0;
        state.sourceFrame.height = 0;
      }
    } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {
      state.sourceFrame.width = 0;
      state.sourceFrame.height = 0;
    }
    this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer2.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer2.projection.transform);
    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);
    state.filters = filters2;
    state.destinationFrame.width = state.renderTexture.width;
    state.destinationFrame.height = state.renderTexture.height;
    const destinationFrame = this.tempRect;
    destinationFrame.x = 0;
    destinationFrame.y = 0;
    destinationFrame.width = state.sourceFrame.width;
    destinationFrame.height = state.sourceFrame.height;
    state.renderTexture.filterFrame = state.sourceFrame;
    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
    state.transform = renderer2.projection.transform;
    renderer2.projection.transform = null;
    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
    renderer2.framebuffer.clear(0, 0, 0, 0);
  }
  pop() {
    const filterStack = this.defaultFilterStack;
    const state = filterStack.pop();
    const filters2 = state.filters;
    this.activeState = state;
    const globalUniforms = this.globalUniforms.uniforms;
    globalUniforms.outputFrame = state.sourceFrame;
    globalUniforms.resolution = state.resolution;
    const inputSize = globalUniforms.inputSize;
    const inputPixel = globalUniforms.inputPixel;
    const inputClamp = globalUniforms.inputClamp;
    inputSize[0] = state.destinationFrame.width;
    inputSize[1] = state.destinationFrame.height;
    inputSize[2] = 1 / inputSize[0];
    inputSize[3] = 1 / inputSize[1];
    inputPixel[0] = Math.round(inputSize[0] * state.resolution);
    inputPixel[1] = Math.round(inputSize[1] * state.resolution);
    inputPixel[2] = 1 / inputPixel[0];
    inputPixel[3] = 1 / inputPixel[1];
    inputClamp[0] = 0.5 * inputPixel[2];
    inputClamp[1] = 0.5 * inputPixel[3];
    inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
    inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
    if (state.legacy) {
      const filterArea = globalUniforms.filterArea;
      filterArea[0] = state.destinationFrame.width;
      filterArea[1] = state.destinationFrame.height;
      filterArea[2] = state.sourceFrame.x;
      filterArea[3] = state.sourceFrame.y;
      globalUniforms.filterClamp = globalUniforms.inputClamp;
    }
    this.globalUniforms.update();
    const lastState = filterStack[filterStack.length - 1];
    this.renderer.framebuffer.blit();
    if (filters2.length === 1) {
      filters2[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);
      this.returnFilterTexture(state.renderTexture);
    } else {
      let flip = state.renderTexture;
      let flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
      flop.filterFrame = flip.filterFrame;
      let i2 = 0;
      for (i2 = 0; i2 < filters2.length - 1; ++i2) {
        if (i2 === 1 && state.multisample > 1) {
          flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
          flop.filterFrame = flip.filterFrame;
        }
        filters2[i2].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);
        const t2 = flip;
        flip = flop;
        flop = t2;
      }
      filters2[i2].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);
      if (i2 > 1 && state.multisample > 1) {
        this.returnFilterTexture(state.renderTexture);
      }
      this.returnFilterTexture(flip);
      this.returnFilterTexture(flop);
    }
    state.clear();
    this.statePool.push(state);
  }
  bindAndClear(filterTexture, clearMode = CLEAR_MODES.CLEAR) {
    const {
      renderTexture: renderTextureSystem,
      state: stateSystem
    } = this.renderer;
    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      this.renderer.projection.transform = this.activeState.transform;
    } else {
      this.renderer.projection.transform = null;
    }
    if (filterTexture == null ? void 0 : filterTexture.filterFrame) {
      const destinationFrame = this.tempRect;
      destinationFrame.x = 0;
      destinationFrame.y = 0;
      destinationFrame.width = filterTexture.filterFrame.width;
      destinationFrame.height = filterTexture.filterFrame.height;
      renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
    } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      renderTextureSystem.bind(filterTexture);
    } else {
      this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
    }
    const autoClear = stateSystem.stateId & 1 || this.forceClear;
    if (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) {
      this.renderer.framebuffer.clear(0, 0, 0, 0);
    }
  }
  applyFilter(filter2, input, output, clearMode) {
    const renderer2 = this.renderer;
    renderer2.state.set(filter2.state);
    this.bindAndClear(output, clearMode);
    filter2.uniforms.uSampler = input;
    filter2.uniforms.filterGlobals = this.globalUniforms;
    renderer2.shader.bind(filter2);
    filter2.legacy = !!filter2.program.attributeData.aTextureCoord;
    if (filter2.legacy) {
      this.quadUv.map(input._frame, input.filterFrame);
      renderer2.geometry.bind(this.quadUv);
      renderer2.geometry.draw(DRAW_MODES.TRIANGLES);
    } else {
      renderer2.geometry.bind(this.quad);
      renderer2.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);
    }
  }
  calculateSpriteMatrix(outputMatrix, sprite) {
    const { sourceFrame, destinationFrame } = this.activeState;
    const { orig } = sprite._texture;
    const mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
    const worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);
    worldTransform.invert();
    mappedMatrix.prepend(worldTransform);
    mappedMatrix.scale(1 / orig.width, 1 / orig.height);
    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
    return mappedMatrix;
  }
  destroy() {
    this.renderer = null;
    this.texturePool.clear(false);
  }
  getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
  }
  getFilterTexture(input, resolution, multisample) {
    if (typeof input === "number") {
      const swap2 = input;
      input = resolution;
      resolution = swap2;
    }
    input = input || this.activeState.renderTexture;
    const filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  }
  returnFilterTexture(renderTexture) {
    this.texturePool.returnTexture(renderTexture);
  }
  emptyPool() {
    this.texturePool.clear(true);
  }
  resize() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  transformAABB(matrix, rect) {
    const lt = tempPoints[0];
    const lb = tempPoints[1];
    const rt = tempPoints[2];
    const rb = tempPoints[3];
    lt.set(rect.left, rect.top);
    lb.set(rect.left, rect.bottom);
    rt.set(rect.right, rect.top);
    rb.set(rect.right, rect.bottom);
    matrix.apply(lt, lt);
    matrix.apply(lb, lb);
    matrix.apply(rt, rt);
    matrix.apply(rb, rb);
    const x0 = Math.min(lt.x, lb.x, rt.x, rb.x);
    const y0 = Math.min(lt.y, lb.y, rt.y, rb.y);
    const x1 = Math.max(lt.x, lb.x, rt.x, rb.x);
    const y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
    rect.x = x0;
    rect.y = y0;
    rect.width = x1 - x0;
    rect.height = y1 - y0;
  }
  roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {
      return;
    }
    if (transform) {
      const { a: a8, b: b3, c: c3, d: d2 } = transform;
      if ((Math.abs(b3) > 1e-4 || Math.abs(c3) > 1e-4) && (Math.abs(a8) > 1e-4 || Math.abs(d2) > 1e-4)) {
        return;
      }
    }
    transform = transform ? tempMatrix$2.copyFrom(transform) : tempMatrix$2.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.transformAABB(transform, frame);
    frame.ceil(resolution);
    this.transformAABB(transform.invert(), frame);
  }
}
FilterSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "filter"
};
extensions$1.add(FilterSystem);
class GLFramebuffer {
  constructor(framebuffer) {
    this.framebuffer = framebuffer;
    this.stencil = null;
    this.dirtyId = -1;
    this.dirtyFormat = -1;
    this.dirtySize = -1;
    this.multisample = MSAA_QUALITY.NONE;
    this.msaaBuffer = null;
    this.blitFramebuffer = null;
    this.mipLevel = 0;
  }
}
const tempRectangle = new Rectangle();
class FramebufferSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.managedFramebuffers = [];
    this.unknownFramebuffer = new Framebuffer(10, 10);
    this.msaaSamples = null;
  }
  contextChange() {
    this.disposeAll(true);
    const gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.current = this.unknownFramebuffer;
    this.viewport = new Rectangle();
    this.hasMRT = true;
    this.writeDepthTexture = true;
    if (this.renderer.context.webGLVersion === 1) {
      let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers;
      let nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
        nativeDrawBuffersExtension = null;
        nativeDepthTextureExtension = null;
      }
      if (nativeDrawBuffersExtension) {
        gl.drawBuffers = (activeTextures) => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures);
      } else {
        this.hasMRT = false;
        gl.drawBuffers = () => {
        };
      }
      if (!nativeDepthTextureExtension) {
        this.writeDepthTexture = false;
      }
    } else {
      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
    }
  }
  bind(framebuffer, frame, mipLevel = 0) {
    const { gl } = this;
    if (framebuffer) {
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
      if (this.current !== framebuffer) {
        this.current = framebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
      }
      if (fbo.mipLevel !== mipLevel) {
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
        fbo.mipLevel = mipLevel;
      }
      if (fbo.dirtyId !== framebuffer.dirtyId) {
        fbo.dirtyId = framebuffer.dirtyId;
        if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
          fbo.dirtyFormat = framebuffer.dirtyFormat;
          fbo.dirtySize = framebuffer.dirtySize;
          this.updateFramebuffer(framebuffer, mipLevel);
        } else if (fbo.dirtySize !== framebuffer.dirtySize) {
          fbo.dirtySize = framebuffer.dirtySize;
          this.resizeFramebuffer(framebuffer);
        }
      }
      for (let i2 = 0; i2 < framebuffer.colorTextures.length; i2++) {
        const tex = framebuffer.colorTextures[i2];
        this.renderer.texture.unbind(tex.parentTextureArray || tex);
      }
      if (framebuffer.depthTexture) {
        this.renderer.texture.unbind(framebuffer.depthTexture);
      }
      if (frame) {
        const mipWidth = frame.width >> mipLevel;
        const mipHeight = frame.height >> mipLevel;
        const scale = mipWidth / frame.width;
        this.setViewport(frame.x * scale, frame.y * scale, mipWidth, mipHeight);
      } else {
        const mipWidth = framebuffer.width >> mipLevel;
        const mipHeight = framebuffer.height >> mipLevel;
        this.setViewport(0, 0, mipWidth, mipHeight);
      }
    } else {
      if (this.current) {
        this.current = null;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      if (frame) {
        this.setViewport(frame.x, frame.y, frame.width, frame.height);
      } else {
        this.setViewport(0, 0, this.renderer.width, this.renderer.height);
      }
    }
  }
  setViewport(x2, y2, width, height) {
    const v2 = this.viewport;
    x2 = Math.round(x2);
    y2 = Math.round(y2);
    width = Math.round(width);
    height = Math.round(height);
    if (v2.width !== width || v2.height !== height || v2.x !== x2 || v2.y !== y2) {
      v2.x = x2;
      v2.y = y2;
      v2.width = width;
      v2.height = height;
      this.gl.viewport(x2, y2, width, height);
    }
  }
  get size() {
    if (this.current) {
      return { x: 0, y: 0, width: this.current.width, height: this.current.height };
    }
    return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
  }
  clear(r2, g2, b3, a8, mask = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH) {
    const { gl } = this;
    gl.clearColor(r2, g2, b3, a8);
    gl.clear(mask);
  }
  initFramebuffer(framebuffer) {
    const { gl } = this;
    const fbo = new GLFramebuffer(gl.createFramebuffer());
    fbo.multisample = this.detectSamples(framebuffer.multisample);
    framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
    this.managedFramebuffers.push(framebuffer);
    framebuffer.disposeRunner.add(this);
    return fbo;
  }
  resizeFramebuffer(framebuffer) {
    const { gl } = this;
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (fbo.stencil) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
    }
    const colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    for (let i2 = 0; i2 < count; i2++) {
      const texture = colorTextures[i2];
      const parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
      if (i2 === 0 && fbo.msaaBuffer) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
      }
    }
    if (framebuffer.depthTexture && this.writeDepthTexture) {
      this.renderer.texture.bind(framebuffer.depthTexture, 0);
    }
  }
  updateFramebuffer(framebuffer, mipLevel) {
    const { gl } = this;
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    const colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {
      fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();
    } else if (fbo.msaaBuffer) {
      gl.deleteRenderbuffer(fbo.msaaBuffer);
      fbo.msaaBuffer = null;
      if (fbo.blitFramebuffer) {
        fbo.blitFramebuffer.dispose();
        fbo.blitFramebuffer = null;
      }
    }
    const activeTextures = [];
    for (let i2 = 0; i2 < count; i2++) {
      const texture = colorTextures[i2];
      const parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
      if (i2 === 0 && fbo.msaaBuffer) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
      } else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i2, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
        activeTextures.push(gl.COLOR_ATTACHMENT0 + i2);
      }
    }
    if (activeTextures.length > 1) {
      gl.drawBuffers(activeTextures);
    }
    if (framebuffer.depthTexture) {
      const writeDepthTexture = this.writeDepthTexture;
      if (writeDepthTexture) {
        const depthTexture = framebuffer.depthTexture;
        this.renderer.texture.bind(depthTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
      }
    }
    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
      fbo.stencil = fbo.stencil || gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
    } else if (fbo.stencil) {
      gl.deleteRenderbuffer(fbo.stencil);
      fbo.stencil = null;
    }
  }
  canMultisampleFramebuffer(framebuffer) {
    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
  }
  detectSamples(samples) {
    const { msaaSamples } = this;
    let res = MSAA_QUALITY.NONE;
    if (samples <= 1 || msaaSamples === null) {
      return res;
    }
    for (let i2 = 0; i2 < msaaSamples.length; i2++) {
      if (msaaSamples[i2] <= samples) {
        res = msaaSamples[i2];
        break;
      }
    }
    if (res === 1) {
      res = MSAA_QUALITY.NONE;
    }
    return res;
  }
  blit(framebuffer, sourcePixels, destPixels) {
    const { current, renderer: renderer2, gl, CONTEXT_UID } = this;
    if (renderer2.context.webGLVersion !== 2) {
      return;
    }
    if (!current) {
      return;
    }
    const fbo = current.glFramebuffers[CONTEXT_UID];
    if (!fbo) {
      return;
    }
    if (!framebuffer) {
      if (!fbo.msaaBuffer) {
        return;
      }
      const colorTexture = current.colorTextures[0];
      if (!colorTexture) {
        return;
      }
      if (!fbo.blitFramebuffer) {
        fbo.blitFramebuffer = new Framebuffer(current.width, current.height);
        fbo.blitFramebuffer.addColorTexture(0, colorTexture);
      }
      framebuffer = fbo.blitFramebuffer;
      if (framebuffer.colorTextures[0] !== colorTexture) {
        framebuffer.colorTextures[0] = colorTexture;
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
      }
      if (framebuffer.width !== current.width || framebuffer.height !== current.height) {
        framebuffer.width = current.width;
        framebuffer.height = current.height;
        framebuffer.dirtyId++;
        framebuffer.dirtySize++;
      }
    }
    if (!sourcePixels) {
      sourcePixels = tempRectangle;
      sourcePixels.width = current.width;
      sourcePixels.height = current.height;
    }
    if (!destPixels) {
      destPixels = sourcePixels;
    }
    const sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
    this.bind(framebuffer);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
    gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, framebuffer.glFramebuffers[this.CONTEXT_UID].framebuffer);
  }
  disposeFramebuffer(framebuffer, contextLost) {
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    const gl = this.gl;
    if (!fbo) {
      return;
    }
    delete framebuffer.glFramebuffers[this.CONTEXT_UID];
    const index2 = this.managedFramebuffers.indexOf(framebuffer);
    if (index2 >= 0) {
      this.managedFramebuffers.splice(index2, 1);
    }
    framebuffer.disposeRunner.remove(this);
    if (!contextLost) {
      gl.deleteFramebuffer(fbo.framebuffer);
      if (fbo.msaaBuffer) {
        gl.deleteRenderbuffer(fbo.msaaBuffer);
      }
      if (fbo.stencil) {
        gl.deleteRenderbuffer(fbo.stencil);
      }
    }
    if (fbo.blitFramebuffer) {
      this.disposeFramebuffer(fbo.blitFramebuffer, contextLost);
    }
  }
  disposeAll(contextLost) {
    const list = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (let i2 = 0; i2 < list.length; i2++) {
      this.disposeFramebuffer(list[i2], contextLost);
    }
  }
  forceStencil() {
    const framebuffer = this.current;
    if (!framebuffer) {
      return;
    }
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (!fbo || fbo.stencil) {
      return;
    }
    framebuffer.stencil = true;
    const w2 = framebuffer.width;
    const h2 = framebuffer.height;
    const gl = this.gl;
    const stencil = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
    if (fbo.msaaBuffer) {
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w2, h2);
    } else {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w2, h2);
    }
    fbo.stencil = stencil;
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
  }
  reset() {
    this.current = this.unknownFramebuffer;
    this.viewport = new Rectangle();
  }
  destroy() {
    this.renderer = null;
  }
}
FramebufferSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "framebuffer"
};
extensions$1.add(FramebufferSystem);
const byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
class GeometrySystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this._activeGeometry = null;
    this._activeVao = null;
    this.hasVao = true;
    this.hasInstance = true;
    this.canUseUInt32ElementIndex = false;
    this.managedGeometries = {};
  }
  contextChange() {
    this.disposeAll(true);
    const gl = this.gl = this.renderer.gl;
    const context2 = this.renderer.context;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    if (context2.webGLVersion !== 2) {
      let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
        nativeVaoExtension = null;
      }
      if (nativeVaoExtension) {
        gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
        gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
        gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
      } else {
        this.hasVao = false;
        gl.createVertexArray = () => null;
        gl.bindVertexArray = () => null;
        gl.deleteVertexArray = () => null;
      }
    }
    if (context2.webGLVersion !== 2) {
      const instanceExt = gl.getExtension("ANGLE_instanced_arrays");
      if (instanceExt) {
        gl.vertexAttribDivisor = (a8, b3) => instanceExt.vertexAttribDivisorANGLE(a8, b3);
        gl.drawElementsInstanced = (a8, b3, c3, d2, e3) => instanceExt.drawElementsInstancedANGLE(a8, b3, c3, d2, e3);
        gl.drawArraysInstanced = (a8, b3, c3, d2) => instanceExt.drawArraysInstancedANGLE(a8, b3, c3, d2);
      } else {
        this.hasInstance = false;
      }
    }
    this.canUseUInt32ElementIndex = context2.webGLVersion === 2 || !!context2.extensions.uint32ElementIndex;
  }
  bind(geometry, shader) {
    shader = shader || this.renderer.shader.shader;
    const { gl } = this;
    let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    let incRefCount = false;
    if (!vaos) {
      this.managedGeometries[geometry.id] = geometry;
      geometry.disposeRunner.add(this);
      geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
      incRefCount = true;
    }
    const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
    this._activeGeometry = geometry;
    if (this._activeVao !== vao) {
      this._activeVao = vao;
      if (this.hasVao) {
        gl.bindVertexArray(vao);
      } else {
        this.activateVao(geometry, shader.program);
      }
    }
    this.updateBuffers();
  }
  reset() {
    this.unbind();
  }
  updateBuffers() {
    const geometry = this._activeGeometry;
    const bufferSystem = this.renderer.buffer;
    for (let i2 = 0; i2 < geometry.buffers.length; i2++) {
      const buffer2 = geometry.buffers[i2];
      bufferSystem.update(buffer2);
    }
  }
  checkCompatibility(geometry, program) {
    const geometryAttributes = geometry.attributes;
    const shaderAttributes = program.attributeData;
    for (const j2 in shaderAttributes) {
      if (!geometryAttributes[j2]) {
        throw new Error(`shader and geometry incompatible, geometry missing the "${j2}" attribute`);
      }
    }
  }
  getSignature(geometry, program) {
    const attribs = geometry.attributes;
    const shaderAttributes = program.attributeData;
    const strings = ["g", geometry.id];
    for (const i2 in attribs) {
      if (shaderAttributes[i2]) {
        strings.push(i2, shaderAttributes[i2].location);
      }
    }
    return strings.join("-");
  }
  initGeometryVao(geometry, shader, incRefCount = true) {
    const gl = this.gl;
    const CONTEXT_UID = this.CONTEXT_UID;
    const bufferSystem = this.renderer.buffer;
    const program = shader.program;
    if (!program.glPrograms[CONTEXT_UID]) {
      this.renderer.shader.generateProgram(shader);
    }
    this.checkCompatibility(geometry, program);
    const signature = this.getSignature(geometry, program);
    const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    let vao = vaoObjectHash[signature];
    if (vao) {
      vaoObjectHash[program.id] = vao;
      return vao;
    }
    const buffers = geometry.buffers;
    const attributes = geometry.attributes;
    const tempStride = {};
    const tempStart = {};
    for (const j2 in buffers) {
      tempStride[j2] = 0;
      tempStart[j2] = 0;
    }
    for (const j2 in attributes) {
      if (!attributes[j2].size && program.attributeData[j2]) {
        attributes[j2].size = program.attributeData[j2].size;
      } else if (!attributes[j2].size) {
        console.warn(`PIXI Geometry attribute '${j2}' size cannot be determined (likely the bound shader does not have the attribute)`);
      }
      tempStride[attributes[j2].buffer] += attributes[j2].size * byteSizeMap[attributes[j2].type];
    }
    for (const j2 in attributes) {
      const attribute = attributes[j2];
      const attribSize = attribute.size;
      if (attribute.stride === void 0) {
        if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type]) {
          attribute.stride = 0;
        } else {
          attribute.stride = tempStride[attribute.buffer];
        }
      }
      if (attribute.start === void 0) {
        attribute.start = tempStart[attribute.buffer];
        tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];
      }
    }
    vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    for (let i2 = 0; i2 < buffers.length; i2++) {
      const buffer2 = buffers[i2];
      bufferSystem.bind(buffer2);
      if (incRefCount) {
        buffer2._glBuffers[CONTEXT_UID].refCount++;
      }
    }
    this.activateVao(geometry, program);
    vaoObjectHash[program.id] = vao;
    vaoObjectHash[signature] = vao;
    gl.bindVertexArray(null);
    bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER);
    return vao;
  }
  disposeGeometry(geometry, contextLost) {
    var _a;
    if (!this.managedGeometries[geometry.id]) {
      return;
    }
    delete this.managedGeometries[geometry.id];
    const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    const gl = this.gl;
    const buffers = geometry.buffers;
    const bufferSystem = (_a = this.renderer) == null ? void 0 : _a.buffer;
    geometry.disposeRunner.remove(this);
    if (!vaos) {
      return;
    }
    if (bufferSystem) {
      for (let i2 = 0; i2 < buffers.length; i2++) {
        const buf = buffers[i2]._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffers[i2], contextLost);
          }
        }
      }
    }
    if (!contextLost) {
      for (const vaoId in vaos) {
        if (vaoId[0] === "g") {
          const vao = vaos[vaoId];
          if (this._activeVao === vao) {
            this.unbind();
          }
          gl.deleteVertexArray(vao);
        }
      }
    }
    delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
  }
  disposeAll(contextLost) {
    const all = Object.keys(this.managedGeometries);
    for (let i2 = 0; i2 < all.length; i2++) {
      this.disposeGeometry(this.managedGeometries[all[i2]], contextLost);
    }
  }
  activateVao(geometry, program) {
    const gl = this.gl;
    const CONTEXT_UID = this.CONTEXT_UID;
    const bufferSystem = this.renderer.buffer;
    const buffers = geometry.buffers;
    const attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      bufferSystem.bind(geometry.indexBuffer);
    }
    let lastBuffer = null;
    for (const j2 in attributes) {
      const attribute = attributes[j2];
      const buffer2 = buffers[attribute.buffer];
      const glBuffer = buffer2._glBuffers[CONTEXT_UID];
      if (program.attributeData[j2]) {
        if (lastBuffer !== glBuffer) {
          bufferSystem.bind(buffer2);
          lastBuffer = glBuffer;
        }
        const location2 = program.attributeData[j2].location;
        gl.enableVertexAttribArray(location2);
        gl.vertexAttribPointer(location2, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
        if (attribute.instance) {
          if (this.hasInstance) {
            gl.vertexAttribDivisor(location2, attribute.divisor);
          } else {
            throw new Error("geometry error, GPU Instancing is not supported on this device");
          }
        }
      }
    }
  }
  draw(type, size2, start, instanceCount) {
    const { gl } = this;
    const geometry = this._activeGeometry;
    if (geometry.indexBuffer) {
      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
        if (geometry.instanced) {
          gl.drawElementsInstanced(type, size2 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
        } else {
          gl.drawElements(type, size2 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
        }
      } else {
        console.warn("unsupported index buffer type: uint32");
      }
    } else if (geometry.instanced) {
      gl.drawArraysInstanced(type, start, size2 || geometry.getSize(), instanceCount || 1);
    } else {
      gl.drawArrays(type, start, size2 || geometry.getSize());
    }
    return this;
  }
  unbind() {
    this.gl.bindVertexArray(null);
    this._activeVao = null;
    this._activeGeometry = null;
  }
  destroy() {
    this.renderer = null;
  }
}
GeometrySystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "geometry"
};
extensions$1.add(GeometrySystem);
const tempMat$1 = new Matrix();
class TextureMatrix {
  constructor(texture, clampMargin) {
    this._texture = texture;
    this.mapCoord = new Matrix();
    this.uClampFrame = new Float32Array(4);
    this.uClampOffset = new Float32Array(2);
    this._textureID = -1;
    this._updateID = 0;
    this.clampOffset = 0;
    this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
    this.isSimple = false;
  }
  get texture() {
    return this._texture;
  }
  set texture(value2) {
    this._texture = value2;
    this._textureID = -1;
  }
  multiplyUvs(uvs, out) {
    if (out === void 0) {
      out = uvs;
    }
    const mat = this.mapCoord;
    for (let i2 = 0; i2 < uvs.length; i2 += 2) {
      const x2 = uvs[i2];
      const y2 = uvs[i2 + 1];
      out[i2] = x2 * mat.a + y2 * mat.c + mat.tx;
      out[i2 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
    }
    return out;
  }
  update(forceUpdate) {
    const tex = this._texture;
    if (!tex || !tex.valid) {
      return false;
    }
    if (!forceUpdate && this._textureID === tex._updateID) {
      return false;
    }
    this._textureID = tex._updateID;
    this._updateID++;
    const uvs = tex._uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    const orig = tex.orig;
    const trim = tex.trim;
    if (trim) {
      tempMat$1.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
      this.mapCoord.append(tempMat$1);
    }
    const texBase = tex.baseTexture;
    const frame = this.uClampFrame;
    const margin = this.clampMargin / texBase.resolution;
    const offset = this.clampOffset;
    frame[0] = (tex._frame.x + margin + offset) / texBase.width;
    frame[1] = (tex._frame.y + margin + offset) / texBase.height;
    frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
    frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
    this.uClampOffset[0] = offset / texBase.realWidth;
    this.uClampOffset[1] = offset / texBase.realHeight;
    this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
    return true;
  }
}
var fragment$7 = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";
var vertex$4 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";
class SpriteMaskFilter extends Filter {
  constructor(vertexSrc, fragmentSrc, uniforms) {
    let sprite = null;
    if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {
      sprite = vertexSrc;
      vertexSrc = void 0;
      fragmentSrc = void 0;
      uniforms = void 0;
    }
    super(vertexSrc || vertex$4, fragmentSrc || fragment$7, uniforms);
    this.maskSprite = sprite;
    this.maskMatrix = new Matrix();
  }
  get maskSprite() {
    return this._maskSprite;
  }
  set maskSprite(value2) {
    this._maskSprite = value2;
    if (this._maskSprite) {
      this._maskSprite.renderable = false;
    }
  }
  apply(filterManager, input, output, clearMode) {
    const maskSprite = this._maskSprite;
    const tex = maskSprite._texture;
    if (!tex.valid) {
      return;
    }
    if (!tex.uvMatrix) {
      tex.uvMatrix = new TextureMatrix(tex, 0);
    }
    tex.uvMatrix.update();
    this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
    this.uniforms.mask = tex;
    this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
    this.uniforms.alpha = maskSprite.worldAlpha;
    this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
    filterManager.applyFilter(this, input, output, clearMode);
  }
}
class MaskData {
  constructor(maskObject = null) {
    this.type = MASK_TYPES.NONE;
    this.autoDetect = true;
    this.maskObject = maskObject || null;
    this.pooled = false;
    this.isMaskData = true;
    this.resolution = null;
    this.multisample = Filter.defaultMultisample;
    this.enabled = true;
    this.colorMask = 15;
    this._filters = null;
    this._stencilCounter = 0;
    this._scissorCounter = 0;
    this._scissorRect = null;
    this._scissorRectLocal = null;
    this._colorMask = 15;
    this._target = null;
  }
  get filter() {
    return this._filters ? this._filters[0] : null;
  }
  set filter(value2) {
    if (value2) {
      if (this._filters) {
        this._filters[0] = value2;
      } else {
        this._filters = [value2];
      }
    } else {
      this._filters = null;
    }
  }
  reset() {
    if (this.pooled) {
      this.maskObject = null;
      this.type = MASK_TYPES.NONE;
      this.autoDetect = true;
    }
    this._target = null;
    this._scissorRectLocal = null;
  }
  copyCountersOrReset(maskAbove) {
    if (maskAbove) {
      this._stencilCounter = maskAbove._stencilCounter;
      this._scissorCounter = maskAbove._scissorCounter;
      this._scissorRect = maskAbove._scissorRect;
    } else {
      this._stencilCounter = 0;
      this._scissorCounter = 0;
      this._scissorRect = null;
    }
  }
}
class MaskSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.enableScissor = true;
    this.alphaMaskPool = [];
    this.maskDataPool = [];
    this.maskStack = [];
    this.alphaMaskIndex = 0;
  }
  setMaskStack(maskStack) {
    this.maskStack = maskStack;
    this.renderer.scissor.setMaskStack(maskStack);
    this.renderer.stencil.setMaskStack(maskStack);
  }
  push(target, maskDataOrTarget) {
    let maskData = maskDataOrTarget;
    if (!maskData.isMaskData) {
      const d2 = this.maskDataPool.pop() || new MaskData();
      d2.pooled = true;
      d2.maskObject = maskDataOrTarget;
      maskData = d2;
    }
    const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
    maskData.copyCountersOrReset(maskAbove);
    maskData._colorMask = maskAbove ? maskAbove._colorMask : 15;
    if (maskData.autoDetect) {
      this.detect(maskData);
    }
    maskData._target = target;
    if (maskData.type !== MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case MASK_TYPES.SCISSOR:
          this.renderer.scissor.push(maskData);
          break;
        case MASK_TYPES.STENCIL:
          this.renderer.stencil.push(maskData);
          break;
        case MASK_TYPES.SPRITE:
          maskData.copyCountersOrReset(null);
          this.pushSpriteMask(maskData);
          break;
        case MASK_TYPES.COLOR:
          this.pushColorMask(maskData);
          break;
      }
    }
    if (maskData.type === MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
  }
  pop(target) {
    const maskData = this.maskStack.pop();
    if (!maskData || maskData._target !== target) {
      return;
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case MASK_TYPES.SCISSOR:
          this.renderer.scissor.pop(maskData);
          break;
        case MASK_TYPES.STENCIL:
          this.renderer.stencil.pop(maskData.maskObject);
          break;
        case MASK_TYPES.SPRITE:
          this.popSpriteMask(maskData);
          break;
        case MASK_TYPES.COLOR:
          this.popColorMask(maskData);
          break;
      }
    }
    maskData.reset();
    if (maskData.pooled) {
      this.maskDataPool.push(maskData);
    }
    if (this.maskStack.length !== 0) {
      const maskCurrent = this.maskStack[this.maskStack.length - 1];
      if (maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters) {
        maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;
      }
    }
  }
  detect(maskData) {
    const maskObject = maskData.maskObject;
    if (!maskObject) {
      maskData.type = MASK_TYPES.COLOR;
    } else if (maskObject.isSprite) {
      maskData.type = MASK_TYPES.SPRITE;
    } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {
      maskData.type = MASK_TYPES.SCISSOR;
    } else {
      maskData.type = MASK_TYPES.STENCIL;
    }
  }
  pushSpriteMask(maskData) {
    const { maskObject } = maskData;
    const target = maskData._target;
    let alphaMaskFilter = maskData._filters;
    if (!alphaMaskFilter) {
      alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
      if (!alphaMaskFilter) {
        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];
      }
    }
    const renderer2 = this.renderer;
    const renderTextureSystem = renderer2.renderTexture;
    let resolution;
    let multisample;
    if (renderTextureSystem.current) {
      const renderTexture = renderTextureSystem.current;
      resolution = maskData.resolution || renderTexture.resolution;
      multisample = maskData.multisample ?? renderTexture.multisample;
    } else {
      resolution = maskData.resolution || renderer2.resolution;
      multisample = maskData.multisample ?? renderer2.multisample;
    }
    alphaMaskFilter[0].resolution = resolution;
    alphaMaskFilter[0].multisample = multisample;
    alphaMaskFilter[0].maskSprite = maskObject;
    const stashFilterArea = target.filterArea;
    target.filterArea = maskObject.getBounds(true);
    renderer2.filter.push(target, alphaMaskFilter);
    target.filterArea = stashFilterArea;
    if (!maskData._filters) {
      this.alphaMaskIndex++;
    }
  }
  popSpriteMask(maskData) {
    this.renderer.filter.pop();
    if (maskData._filters) {
      maskData._filters[0].maskSprite = null;
    } else {
      this.alphaMaskIndex--;
      this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;
    }
  }
  pushColorMask(maskData) {
    const currColorMask = maskData._colorMask;
    const nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  }
  popColorMask(maskData) {
    const currColorMask = maskData._colorMask;
    const nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  }
  destroy() {
    this.renderer = null;
  }
}
MaskSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "mask"
};
extensions$1.add(MaskSystem);
class AbstractMaskSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.maskStack = [];
    this.glConst = 0;
  }
  getStackLength() {
    return this.maskStack.length;
  }
  setMaskStack(maskStack) {
    const { gl } = this.renderer;
    const curStackLen = this.getStackLength();
    this.maskStack = maskStack;
    const newStackLen = this.getStackLength();
    if (newStackLen !== curStackLen) {
      if (newStackLen === 0) {
        gl.disable(this.glConst);
      } else {
        gl.enable(this.glConst);
        this._useCurrent();
      }
    }
  }
  _useCurrent() {
  }
  destroy() {
    this.renderer = null;
    this.maskStack = null;
  }
}
const tempMatrix$1 = new Matrix();
const rectPool = [];
const _ScissorSystem = class extends AbstractMaskSystem {
  constructor(renderer2) {
    super(renderer2);
    this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._scissorCounter;
    }
    return 0;
  }
  calcScissorRect(maskData) {
    if (maskData._scissorRectLocal) {
      return;
    }
    const prevData = maskData._scissorRect;
    const { maskObject } = maskData;
    const { renderer: renderer2 } = this;
    const renderTextureSystem = renderer2.renderTexture;
    const rect = maskObject.getBounds(true, rectPool.pop() ?? new Rectangle());
    this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer2.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer2.projection.transform);
    if (prevData) {
      rect.fit(prevData);
    }
    maskData._scissorRectLocal = rect;
  }
  static isMatrixRotated(matrix) {
    if (!matrix) {
      return false;
    }
    const { a: a8, b: b3, c: c3, d: d2 } = matrix;
    return (Math.abs(b3) > 1e-4 || Math.abs(c3) > 1e-4) && (Math.abs(a8) > 1e-4 || Math.abs(d2) > 1e-4);
  }
  testScissor(maskData) {
    const { maskObject } = maskData;
    if (!maskObject.isFastRect || !maskObject.isFastRect()) {
      return false;
    }
    if (_ScissorSystem.isMatrixRotated(maskObject.worldTransform)) {
      return false;
    }
    if (_ScissorSystem.isMatrixRotated(this.renderer.projection.transform)) {
      return false;
    }
    this.calcScissorRect(maskData);
    const rect = maskData._scissorRectLocal;
    return rect.width > 0 && rect.height > 0;
  }
  roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (_ScissorSystem.isMatrixRotated(transform)) {
      return;
    }
    transform = transform ? tempMatrix$1.copyFrom(transform) : tempMatrix$1.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.renderer.filter.transformAABB(transform, frame);
    frame.fit(bindingDestinationFrame);
    frame.x = Math.round(frame.x * resolution);
    frame.y = Math.round(frame.y * resolution);
    frame.width = Math.round(frame.width * resolution);
    frame.height = Math.round(frame.height * resolution);
  }
  push(maskData) {
    if (!maskData._scissorRectLocal) {
      this.calcScissorRect(maskData);
    }
    const { gl } = this.renderer;
    if (!maskData._scissorRect) {
      gl.enable(gl.SCISSOR_TEST);
    }
    maskData._scissorCounter++;
    maskData._scissorRect = maskData._scissorRectLocal;
    this._useCurrent();
  }
  pop(maskData) {
    const { gl } = this.renderer;
    if (maskData) {
      rectPool.push(maskData._scissorRectLocal);
    }
    if (this.getStackLength() > 0) {
      this._useCurrent();
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }
  }
  _useCurrent() {
    const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
    let y2;
    if (this.renderer.renderTexture.current) {
      y2 = rect.y;
    } else {
      y2 = this.renderer.height - rect.height - rect.y;
    }
    this.renderer.gl.scissor(rect.x, y2, rect.width, rect.height);
  }
};
let ScissorSystem = _ScissorSystem;
ScissorSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "scissor"
};
extensions$1.add(ScissorSystem);
class StencilSystem extends AbstractMaskSystem {
  constructor(renderer2) {
    super(renderer2);
    this.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._stencilCounter;
    }
    return 0;
  }
  push(maskData) {
    const maskObject = maskData.maskObject;
    const { gl } = this.renderer;
    const prevMaskCount = maskData._stencilCounter;
    if (prevMaskCount === 0) {
      this.renderer.framebuffer.forceStencil();
      gl.clearStencil(0);
      gl.clear(gl.STENCIL_BUFFER_BIT);
      gl.enable(gl.STENCIL_TEST);
    }
    maskData._stencilCounter++;
    const colorMask = maskData._colorMask;
    if (colorMask !== 0) {
      maskData._colorMask = 0;
      gl.colorMask(false, false, false, false);
    }
    gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
    maskObject.renderable = true;
    maskObject.render(this.renderer);
    this.renderer.batch.flush();
    maskObject.renderable = false;
    if (colorMask !== 0) {
      maskData._colorMask = colorMask;
      gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
    }
    this._useCurrent();
  }
  pop(maskObject) {
    const gl = this.renderer.gl;
    if (this.getStackLength() === 0) {
      gl.disable(gl.STENCIL_TEST);
    } else {
      const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      const colorMask = maskData ? maskData._colorMask : 15;
      if (colorMask !== 0) {
        maskData._colorMask = 0;
        gl.colorMask(false, false, false, false);
      }
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
      maskObject.renderable = true;
      maskObject.render(this.renderer);
      this.renderer.batch.flush();
      maskObject.renderable = false;
      if (colorMask !== 0) {
        maskData._colorMask = colorMask;
        gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
      }
      this._useCurrent();
    }
  }
  _useCurrent() {
    const gl = this.renderer.gl;
    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
  }
}
StencilSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "stencil"
};
extensions$1.add(StencilSystem);
class PluginSystem2 {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.plugins = {};
    Object.defineProperties(this.plugins, {
      extract: {
        enumerable: false,
        get() {
          deprecation("7.0.0", "renderer.plugins.extract has moved to renderer.extract");
          return renderer2.extract;
        }
      },
      prepare: {
        enumerable: false,
        get() {
          deprecation("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare");
          return renderer2.prepare;
        }
      },
      interaction: {
        enumerable: false,
        get() {
          deprecation("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events");
          return renderer2.events;
        }
      }
    });
  }
  init() {
    const staticMap = this.rendererPlugins;
    for (const o2 in staticMap) {
      this.plugins[o2] = new staticMap[o2](this.renderer);
    }
  }
  destroy() {
    for (const o2 in this.plugins) {
      this.plugins[o2].destroy();
      this.plugins[o2] = null;
    }
  }
}
PluginSystem2.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "_plugin"
};
extensions$1.add(PluginSystem2);
class ProjectionSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.destinationFrame = null;
    this.sourceFrame = null;
    this.defaultFrame = null;
    this.projectionMatrix = new Matrix();
    this.transform = null;
  }
  update(destinationFrame, sourceFrame, resolution, root2) {
    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
    this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
    this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root2);
    if (this.transform) {
      this.projectionMatrix.append(this.transform);
    }
    const renderer2 = this.renderer;
    renderer2.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
    renderer2.globalUniforms.update();
    if (renderer2.shader.shader) {
      renderer2.shader.syncUniformGroup(renderer2.shader.shader.uniforms.globals);
    }
  }
  calculateProjection(_destinationFrame, sourceFrame, _resolution, root2) {
    const pm = this.projectionMatrix;
    const sign2 = !root2 ? 1 : -1;
    pm.identity();
    pm.a = 1 / sourceFrame.width * 2;
    pm.d = sign2 * (1 / sourceFrame.height * 2);
    pm.tx = -1 - sourceFrame.x * pm.a;
    pm.ty = -sign2 - sourceFrame.y * pm.d;
  }
  setTransform(_matrix) {
  }
  destroy() {
    this.renderer = null;
  }
}
ProjectionSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "projection"
};
extensions$1.add(ProjectionSystem);
const tempTransform = new Transform();
class GenerateTextureSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this._tempMatrix = new Matrix();
  }
  generateTexture(displayObject, options) {
    const { region: manualRegion, ...textureOptions } = options || {};
    const region = manualRegion || displayObject.getLocalBounds(null, true);
    if (region.width === 0)
      region.width = 1;
    if (region.height === 0)
      region.height = 1;
    const renderTexture = RenderTexture.create({
      width: region.width,
      height: region.height,
      ...textureOptions
    });
    this._tempMatrix.tx = -region.x;
    this._tempMatrix.ty = -region.y;
    const transform = displayObject.transform;
    displayObject.transform = tempTransform;
    this.renderer.render(displayObject, {
      renderTexture,
      transform: this._tempMatrix,
      skipUpdateTransform: !!displayObject.parent,
      blit: true
    });
    displayObject.transform = transform;
    return renderTexture;
  }
  destroy() {
  }
}
GenerateTextureSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "textureGenerator"
};
extensions$1.add(GenerateTextureSystem);
const tempRect = new Rectangle();
const tempRect2 = new Rectangle();
class RenderTextureSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.defaultMaskStack = [];
    this.current = null;
    this.sourceFrame = new Rectangle();
    this.destinationFrame = new Rectangle();
    this.viewportFrame = new Rectangle();
  }
  contextChange() {
    var _a;
    const attributes = (_a = this.renderer) == null ? void 0 : _a.gl.getContextAttributes();
    this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);
  }
  bind(renderTexture = null, sourceFrame, destinationFrame) {
    const renderer2 = this.renderer;
    this.current = renderTexture;
    let baseTexture;
    let framebuffer;
    let resolution;
    if (renderTexture) {
      baseTexture = renderTexture.baseTexture;
      resolution = baseTexture.resolution;
      if (!sourceFrame) {
        tempRect.width = renderTexture.frame.width;
        tempRect.height = renderTexture.frame.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        tempRect2.x = renderTexture.frame.x;
        tempRect2.y = renderTexture.frame.y;
        tempRect2.width = sourceFrame.width;
        tempRect2.height = sourceFrame.height;
        destinationFrame = tempRect2;
      }
      framebuffer = baseTexture.framebuffer;
    } else {
      resolution = renderer2.resolution;
      if (!sourceFrame) {
        tempRect.width = renderer2._view.screen.width;
        tempRect.height = renderer2._view.screen.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        destinationFrame = tempRect;
        destinationFrame.width = sourceFrame.width;
        destinationFrame.height = sourceFrame.height;
      }
    }
    const viewportFrame = this.viewportFrame;
    viewportFrame.x = destinationFrame.x * resolution;
    viewportFrame.y = destinationFrame.y * resolution;
    viewportFrame.width = destinationFrame.width * resolution;
    viewportFrame.height = destinationFrame.height * resolution;
    if (!renderTexture) {
      viewportFrame.y = renderer2.view.height - (viewportFrame.y + viewportFrame.height);
    }
    viewportFrame.ceil();
    this.renderer.framebuffer.bind(framebuffer, viewportFrame);
    this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
    if (renderTexture) {
      this.renderer.mask.setMaskStack(baseTexture.maskStack);
    } else {
      this.renderer.mask.setMaskStack(this.defaultMaskStack);
    }
    this.sourceFrame.copyFrom(sourceFrame);
    this.destinationFrame.copyFrom(destinationFrame);
  }
  clear(clearColor, mask) {
    const fallbackColor = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor;
    const color = Color.shared.setValue(clearColor ? clearColor : fallbackColor);
    if (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) {
      color.premultiply(color.alpha);
    }
    const destinationFrame = this.destinationFrame;
    const baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen;
    const clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
    if (clearMask) {
      let { x: x2, y: y2, width, height } = this.viewportFrame;
      x2 = Math.round(x2);
      y2 = Math.round(y2);
      width = Math.round(width);
      height = Math.round(height);
      this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
      this.renderer.gl.scissor(x2, y2, width, height);
    }
    this.renderer.framebuffer.clear(color.red, color.green, color.blue, color.alpha, mask);
    if (clearMask) {
      this.renderer.scissor.pop();
    }
  }
  resize() {
    this.bind(null);
  }
  reset() {
    this.bind(null);
  }
  destroy() {
    this.renderer = null;
  }
}
RenderTextureSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "renderTexture"
};
extensions$1.add(RenderTextureSystem);
class IGLUniformData {
}
class GLProgram {
  constructor(program, uniformData) {
    this.program = program;
    this.uniformData = uniformData;
    this.uniformGroups = {};
    this.uniformDirtyGroups = {};
    this.uniformBufferBindings = {};
  }
  destroy() {
    this.uniformData = null;
    this.uniformGroups = null;
    this.uniformDirtyGroups = null;
    this.uniformBufferBindings = null;
    this.program = null;
  }
}
function getAttributeData(program, gl) {
  const attributes = {};
  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i2 = 0; i2 < totalAttributes; i2++) {
    const attribData = gl.getActiveAttrib(program, i2);
    if (attribData.name.startsWith("gl_")) {
      continue;
    }
    const type = mapType(gl, attribData.type);
    const data = {
      type,
      name: attribData.name,
      size: mapSize(type),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
}
function getUniformData(program, gl) {
  const uniforms = {};
  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i2 = 0; i2 < totalUniforms; i2++) {
    const uniformData = gl.getActiveUniform(program, i2);
    const name = uniformData.name.replace(/\[.*?\]$/, "");
    const isArray2 = !!uniformData.name.match(/\[.*?\]$/);
    const type = mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i2,
      type,
      size: uniformData.size,
      isArray: isArray2,
      value: defaultValue(type, uniformData.size)
    };
  }
  return uniforms;
}
function generateProgram(gl, program) {
  var _a;
  const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);
  const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
  const webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = (_a = program.extra) == null ? void 0 : _a.transformFeedbackVaryings;
  if (transformFeedbackVaryings) {
    if (typeof gl.transformFeedbackVaryings !== "function") {
      console.warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
    } else {
      gl.transformFeedbackVaryings(webGLProgram, transformFeedbackVaryings.names, transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS);
    }
  }
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program.attributeData = getAttributeData(webGLProgram, gl);
  program.uniformData = getUniformData(webGLProgram, gl);
  if (!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
    const keys2 = Object.keys(program.attributeData);
    keys2.sort((a8, b3) => a8 > b3 ? 1 : -1);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      program.attributeData[keys2[i2]].location = i2;
      gl.bindAttribLocation(webGLProgram, i2, keys2[i2]);
    }
    gl.linkProgram(webGLProgram);
  }
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i2 in program.uniformData) {
    const data = program.uniformData[i2];
    uniformData[i2] = {
      location: gl.getUniformLocation(webGLProgram, i2),
      value: defaultValue(data.type, data.size)
    };
  }
  const glProgram = new GLProgram(webGLProgram, uniformData);
  return glProgram;
}
function uboUpdate(_ud, _uv, _renderer, _syncData, buffer2) {
  _renderer.buffer.update(buffer2);
}
const UBO_TO_SINGLE_SETTERS = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
};
const GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    dataLen: 0,
    dirty: 0
  }));
  let size2 = 0;
  let chunkSize = 0;
  let offset = 0;
  for (let i2 = 0; i2 < uboElements.length; i2++) {
    const uboElement = uboElements[i2];
    size2 = GLSL_TO_STD40_SIZE[uboElement.data.type];
    if (uboElement.data.size > 1) {
      size2 = Math.max(size2, 16) * uboElement.data.size;
    }
    uboElement.dataLen = size2;
    if (chunkSize % size2 !== 0 && chunkSize < 16) {
      const lineUpValue = chunkSize % size2 % 16;
      chunkSize += lineUpValue;
      offset += lineUpValue;
    }
    if (chunkSize + size2 > 16) {
      offset = Math.ceil(offset / 16) * 16;
      uboElement.offset = offset;
      offset += size2;
      chunkSize = size2;
    } else {
      uboElement.offset = offset;
      chunkSize += size2;
      offset += size2;
    }
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
function getUBOData(uniforms, uniformData) {
  const usedUniformDatas = [];
  for (const i2 in uniforms) {
    if (uniformData[i2]) {
      usedUniformDatas.push(uniformData[i2]);
    }
  }
  usedUniformDatas.sort((a8, b3) => a8.index - b3.index);
  return usedUniformDatas;
}
function generateUniformBufferSync(group, uniformData) {
  if (!group.autoManage) {
    return { size: 0, syncFunc: uboUpdate };
  }
  const usedUniformDatas = getUBOData(group.uniforms, uniformData);
  const { uboElements, size: size2 } = createUBOElements(usedUniformDatas);
  const funcFragments = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
  for (let i2 = 0; i2 < uboElements.length; i2++) {
    const uboElement = uboElements[i2];
    const uniform = group.uniforms[uboElement.data.name];
    const name = uboElement.data.name;
    let parsed = false;
    for (let j2 = 0; j2 < uniformParsers.length; j2++) {
      const uniformParser = uniformParsers[j2];
      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
        funcFragments.push(`offset = ${uboElement.offset / 4};`, uniformParsers[j2].codeUbo(uboElement.data.name, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        const size22 = mapSize(uboElement.data.type);
        const rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
        const elementSize = size22 / rowSize;
        const remainder = (4 - elementSize % 4) % 4;
        funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};

                t = 0;

                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
                {
                    for(var j = 0; j < ${elementSize}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${remainder};
                }

                `);
      } else {
        const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};
                ${template};
                `);
      }
    }
  }
  funcFragments.push(`
       renderer.buffer.update(buffer);
    `);
  return {
    size: size2,
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
  };
}
let UID = 0;
const defaultSyncData = { textureCount: 0, uboCount: 0 };
class ShaderSystem {
  constructor(renderer2) {
    this.destroyed = false;
    this.renderer = renderer2;
    this.systemCheck();
    this.gl = null;
    this.shader = null;
    this.program = null;
    this.cache = {};
    this._uboCache = {};
    this.id = UID++;
  }
  systemCheck() {
    if (!unsafeEvalSupported()) {
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }
  }
  contextChange(gl) {
    this.gl = gl;
    this.reset();
  }
  bind(shader, dontSync) {
    shader.disposeRunner.add(this);
    shader.uniforms.globals = this.renderer.globalUniforms;
    const program = shader.program;
    const glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
    this.shader = shader;
    if (this.program !== program) {
      this.program = program;
      this.gl.useProgram(glProgram.program);
    }
    if (!dontSync) {
      defaultSyncData.textureCount = 0;
      defaultSyncData.uboCount = 0;
      this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
    }
    return glProgram;
  }
  setUniforms(uniforms) {
    const shader = this.shader.program;
    const glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
  }
  syncUniformGroup(group, syncData) {
    const glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {
      glProgram.uniformDirtyGroups[group.id] = group.dirtyId;
      this.syncUniforms(group, glProgram, syncData);
    }
  }
  syncUniforms(group, glProgram, syncData) {
    const syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
    syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
  }
  createSyncGroups(group) {
    const id = this.getSignature(group, this.shader.program.uniformData, "u");
    if (!this.cache[id]) {
      this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData);
    }
    group.syncUniforms[this.shader.program.id] = this.cache[id];
    return group.syncUniforms[this.shader.program.id];
  }
  syncUniformBufferGroup(group, name) {
    const glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
      group.dirtyId = 0;
      const syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);
      group.buffer.update();
      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);
    }
    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);
  }
  createSyncBufferGroup(group, glProgram, name) {
    const { gl } = this.renderer;
    this.renderer.buffer.bind(group.buffer);
    const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);
    glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;
    gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
    this.shader.uniformBindCount++;
    const id = this.getSignature(group, this.shader.program.uniformData, "ubo");
    let uboData = this._uboCache[id];
    if (!uboData) {
      uboData = this._uboCache[id] = generateUniformBufferSync(group, this.shader.program.uniformData);
    }
    if (group.autoManage) {
      const data = new Float32Array(uboData.size / 4);
      group.buffer.update(data);
    }
    glProgram.uniformGroups[group.id] = uboData.syncFunc;
    return glProgram.uniformGroups[group.id];
  }
  getSignature(group, uniformData, preFix) {
    const uniforms = group.uniforms;
    const strings = [`${preFix}-`];
    for (const i2 in uniforms) {
      strings.push(i2);
      if (uniformData[i2]) {
        strings.push(uniformData[i2].type);
      }
    }
    return strings.join("-");
  }
  getGlProgram() {
    if (this.shader) {
      return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
    }
    return null;
  }
  generateProgram(shader) {
    const gl = this.gl;
    const program = shader.program;
    const glProgram = generateProgram(gl, program);
    program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
    return glProgram;
  }
  reset() {
    this.program = null;
    this.shader = null;
  }
  disposeShader(shader) {
    if (this.shader === shader) {
      this.shader = null;
    }
  }
  destroy() {
    this.renderer = null;
    this.destroyed = true;
  }
}
ShaderSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "shader"
};
extensions$1.add(ShaderSystem);
class StartupSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
  }
  run(options) {
    const { renderer: renderer2 } = this;
    renderer2.runners.init.emit(renderer2.options);
    if (options.hello) {
      console.log(`PixiJS ${"7.2.4"} - ${renderer2.rendererLogId} - https://pixijs.com`);
    }
    renderer2.resize(renderer2.screen.width, renderer2.screen.height);
  }
  destroy() {
  }
}
StartupSystem.defaultOptions = {
  hello: false
};
StartupSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "startup"
};
extensions$1.add(StartupSystem);
function mapWebGLBlendModesToPixi(gl, array2 = []) {
  array2[BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
  array2[BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.NONE] = [0, 0];
  array2[BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  array2[BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
  array2[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
  array2[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
  array2[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
  array2[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
  array2[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
  return array2;
}
const BLEND = 0;
const OFFSET = 1;
const CULLING = 2;
const DEPTH_TEST = 3;
const WINDING = 4;
const DEPTH_MASK = 5;
const _StateSystem = class {
  constructor() {
    this.gl = null;
    this.stateId = 0;
    this.polygonOffset = 0;
    this.blendMode = BLEND_MODES.NONE;
    this._blendEq = false;
    this.map = [];
    this.map[BLEND] = this.setBlend;
    this.map[OFFSET] = this.setOffset;
    this.map[CULLING] = this.setCullFace;
    this.map[DEPTH_TEST] = this.setDepthTest;
    this.map[WINDING] = this.setFrontFace;
    this.map[DEPTH_MASK] = this.setDepthMask;
    this.checks = [];
    this.defaultState = new State();
    this.defaultState.blend = true;
  }
  contextChange(gl) {
    this.gl = gl;
    this.blendModes = mapWebGLBlendModesToPixi(gl);
    this.set(this.defaultState);
    this.reset();
  }
  set(state) {
    state = state || this.defaultState;
    if (this.stateId !== state.data) {
      let diff = this.stateId ^ state.data;
      let i2 = 0;
      while (diff) {
        if (diff & 1) {
          this.map[i2].call(this, !!(state.data & 1 << i2));
        }
        diff = diff >> 1;
        i2++;
      }
      this.stateId = state.data;
    }
    for (let i2 = 0; i2 < this.checks.length; i2++) {
      this.checks[i2](this, state);
    }
  }
  forceState(state) {
    state = state || this.defaultState;
    for (let i2 = 0; i2 < this.map.length; i2++) {
      this.map[i2].call(this, !!(state.data & 1 << i2));
    }
    for (let i2 = 0; i2 < this.checks.length; i2++) {
      this.checks[i2](this, state);
    }
    this.stateId = state.data;
  }
  setBlend(value2) {
    this.updateCheck(_StateSystem.checkBlendMode, value2);
    this.gl[value2 ? "enable" : "disable"](this.gl.BLEND);
  }
  setOffset(value2) {
    this.updateCheck(_StateSystem.checkPolygonOffset, value2);
    this.gl[value2 ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  }
  setDepthTest(value2) {
    this.gl[value2 ? "enable" : "disable"](this.gl.DEPTH_TEST);
  }
  setDepthMask(value2) {
    this.gl.depthMask(value2);
  }
  setCullFace(value2) {
    this.gl[value2 ? "enable" : "disable"](this.gl.CULL_FACE);
  }
  setFrontFace(value2) {
    this.gl.frontFace(this.gl[value2 ? "CW" : "CCW"]);
  }
  setBlendMode(value2) {
    if (value2 === this.blendMode) {
      return;
    }
    this.blendMode = value2;
    const mode = this.blendModes[value2];
    const gl = this.gl;
    if (mode.length === 2) {
      gl.blendFunc(mode[0], mode[1]);
    } else {
      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
    }
    if (mode.length === 6) {
      this._blendEq = true;
      gl.blendEquationSeparate(mode[4], mode[5]);
    } else if (this._blendEq) {
      this._blendEq = false;
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    }
  }
  setPolygonOffset(value2, scale) {
    this.gl.polygonOffset(value2, scale);
  }
  reset() {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
    this.forceState(this.defaultState);
    this._blendEq = true;
    this.blendMode = -1;
    this.setBlendMode(0);
  }
  updateCheck(func, value2) {
    const index2 = this.checks.indexOf(func);
    if (value2 && index2 === -1) {
      this.checks.push(func);
    } else if (!value2 && index2 !== -1) {
      this.checks.splice(index2, 1);
    }
  }
  static checkBlendMode(system, state) {
    system.setBlendMode(state.blendMode);
  }
  static checkPolygonOffset(system, state) {
    system.setPolygonOffset(1, state.polygonOffset);
  }
  destroy() {
    this.gl = null;
  }
};
let StateSystem = _StateSystem;
StateSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "state"
};
extensions$1.add(StateSystem);
class SystemManager extends EventEmitter2 {
  constructor() {
    super(...arguments);
    this.runners = {};
    this._systemsHash = {};
  }
  setup(config2) {
    this.addRunners(...config2.runners);
    const priority = (config2.priority ?? []).filter((key) => config2.systems[key]);
    const orderByPriority = [
      ...priority,
      ...Object.keys(config2.systems).filter((key) => !priority.includes(key))
    ];
    for (const i2 of orderByPriority) {
      this.addSystem(config2.systems[i2], i2);
    }
  }
  addRunners(...runnerIds) {
    runnerIds.forEach((runnerId) => {
      this.runners[runnerId] = new Runner(runnerId);
    });
  }
  addSystem(ClassRef, name) {
    const system = new ClassRef(this);
    if (this[name]) {
      throw new Error(`Whoops! The name "${name}" is already in use`);
    }
    this[name] = system;
    this._systemsHash[name] = system;
    for (const i2 in this.runners) {
      this.runners[i2].add(system);
    }
    return this;
  }
  emitWithCustomOptions(runner, options) {
    const systemHashKeys = Object.keys(this._systemsHash);
    runner.items.forEach((system) => {
      const systemName = systemHashKeys.find((systemId) => this._systemsHash[systemId] === system);
      system[runner.name](options[systemName]);
    });
  }
  destroy() {
    Object.values(this.runners).forEach((runner) => {
      runner.destroy();
    });
    this._systemsHash = {};
  }
}
const _TextureGCSystem = class {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.count = 0;
    this.checkCount = 0;
    this.maxIdle = _TextureGCSystem.defaultMaxIdle;
    this.checkCountMax = _TextureGCSystem.defaultCheckCountMax;
    this.mode = _TextureGCSystem.defaultMode;
  }
  postrender() {
    if (!this.renderer.objectRenderer.renderingToScreen) {
      return;
    }
    this.count++;
    if (this.mode === GC_MODES.MANUAL) {
      return;
    }
    this.checkCount++;
    if (this.checkCount > this.checkCountMax) {
      this.checkCount = 0;
      this.run();
    }
  }
  run() {
    const tm = this.renderer.texture;
    const managedTextures = tm.managedTextures;
    let wasRemoved = false;
    for (let i2 = 0; i2 < managedTextures.length; i2++) {
      const texture = managedTextures[i2];
      if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
        tm.destroyTexture(texture, true);
        managedTextures[i2] = null;
        wasRemoved = true;
      }
    }
    if (wasRemoved) {
      let j2 = 0;
      for (let i2 = 0; i2 < managedTextures.length; i2++) {
        if (managedTextures[i2] !== null) {
          managedTextures[j2++] = managedTextures[i2];
        }
      }
      managedTextures.length = j2;
    }
  }
  unload(displayObject) {
    const tm = this.renderer.texture;
    const texture = displayObject._texture;
    if (texture && !texture.framebuffer) {
      tm.destroyTexture(texture);
    }
    for (let i2 = displayObject.children.length - 1; i2 >= 0; i2--) {
      this.unload(displayObject.children[i2]);
    }
  }
  destroy() {
    this.renderer = null;
  }
};
let TextureGCSystem = _TextureGCSystem;
TextureGCSystem.defaultMode = GC_MODES.AUTO;
TextureGCSystem.defaultMaxIdle = 60 * 60;
TextureGCSystem.defaultCheckCountMax = 60 * 10;
TextureGCSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "textureGC"
};
extensions$1.add(TextureGCSystem);
class GLTexture {
  constructor(texture) {
    this.texture = texture;
    this.width = -1;
    this.height = -1;
    this.dirtyId = -1;
    this.dirtyStyleId = -1;
    this.mipmap = false;
    this.wrapMode = 33071;
    this.type = TYPES.UNSIGNED_BYTE;
    this.internalFormat = FORMATS.RGBA;
    this.samplerType = 0;
  }
}
function mapTypeAndFormatToInternalFormat(gl) {
  let table;
  if ("WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {
    table = {
      [TYPES.UNSIGNED_BYTE]: {
        [FORMATS.RGBA]: gl.RGBA8,
        [FORMATS.RGB]: gl.RGB8,
        [FORMATS.RG]: gl.RG8,
        [FORMATS.RED]: gl.R8,
        [FORMATS.RGBA_INTEGER]: gl.RGBA8UI,
        [FORMATS.RGB_INTEGER]: gl.RGB8UI,
        [FORMATS.RG_INTEGER]: gl.RG8UI,
        [FORMATS.RED_INTEGER]: gl.R8UI,
        [FORMATS.ALPHA]: gl.ALPHA,
        [FORMATS.LUMINANCE]: gl.LUMINANCE,
        [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
      },
      [TYPES.BYTE]: {
        [FORMATS.RGBA]: gl.RGBA8_SNORM,
        [FORMATS.RGB]: gl.RGB8_SNORM,
        [FORMATS.RG]: gl.RG8_SNORM,
        [FORMATS.RED]: gl.R8_SNORM,
        [FORMATS.RGBA_INTEGER]: gl.RGBA8I,
        [FORMATS.RGB_INTEGER]: gl.RGB8I,
        [FORMATS.RG_INTEGER]: gl.RG8I,
        [FORMATS.RED_INTEGER]: gl.R8I
      },
      [TYPES.UNSIGNED_SHORT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA16UI,
        [FORMATS.RGB_INTEGER]: gl.RGB16UI,
        [FORMATS.RG_INTEGER]: gl.RG16UI,
        [FORMATS.RED_INTEGER]: gl.R16UI,
        [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT16
      },
      [TYPES.SHORT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA16I,
        [FORMATS.RGB_INTEGER]: gl.RGB16I,
        [FORMATS.RG_INTEGER]: gl.RG16I,
        [FORMATS.RED_INTEGER]: gl.R16I
      },
      [TYPES.UNSIGNED_INT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA32UI,
        [FORMATS.RGB_INTEGER]: gl.RGB32UI,
        [FORMATS.RG_INTEGER]: gl.RG32UI,
        [FORMATS.RED_INTEGER]: gl.R32UI,
        [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT24
      },
      [TYPES.INT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA32I,
        [FORMATS.RGB_INTEGER]: gl.RGB32I,
        [FORMATS.RG_INTEGER]: gl.RG32I,
        [FORMATS.RED_INTEGER]: gl.R32I
      },
      [TYPES.FLOAT]: {
        [FORMATS.RGBA]: gl.RGBA32F,
        [FORMATS.RGB]: gl.RGB32F,
        [FORMATS.RG]: gl.RG32F,
        [FORMATS.RED]: gl.R32F,
        [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT32F
      },
      [TYPES.HALF_FLOAT]: {
        [FORMATS.RGBA]: gl.RGBA16F,
        [FORMATS.RGB]: gl.RGB16F,
        [FORMATS.RG]: gl.RG16F,
        [FORMATS.RED]: gl.R16F
      },
      [TYPES.UNSIGNED_SHORT_5_6_5]: {
        [FORMATS.RGB]: gl.RGB565
      },
      [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
        [FORMATS.RGBA]: gl.RGBA4
      },
      [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
        [FORMATS.RGBA]: gl.RGB5_A1
      },
      [TYPES.UNSIGNED_INT_2_10_10_10_REV]: {
        [FORMATS.RGBA]: gl.RGB10_A2,
        [FORMATS.RGBA_INTEGER]: gl.RGB10_A2UI
      },
      [TYPES.UNSIGNED_INT_10F_11F_11F_REV]: {
        [FORMATS.RGB]: gl.R11F_G11F_B10F
      },
      [TYPES.UNSIGNED_INT_5_9_9_9_REV]: {
        [FORMATS.RGB]: gl.RGB9_E5
      },
      [TYPES.UNSIGNED_INT_24_8]: {
        [FORMATS.DEPTH_STENCIL]: gl.DEPTH24_STENCIL8
      },
      [TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
        [FORMATS.DEPTH_STENCIL]: gl.DEPTH32F_STENCIL8
      }
    };
  } else {
    table = {
      [TYPES.UNSIGNED_BYTE]: {
        [FORMATS.RGBA]: gl.RGBA,
        [FORMATS.RGB]: gl.RGB,
        [FORMATS.ALPHA]: gl.ALPHA,
        [FORMATS.LUMINANCE]: gl.LUMINANCE,
        [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
      },
      [TYPES.UNSIGNED_SHORT_5_6_5]: {
        [FORMATS.RGB]: gl.RGB
      },
      [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
        [FORMATS.RGBA]: gl.RGBA
      },
      [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
        [FORMATS.RGBA]: gl.RGBA
      }
    };
  }
  return table;
}
class TextureSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.boundTextures = [];
    this.currentLocation = -1;
    this.managedTextures = [];
    this._unknownBoundTextures = false;
    this.unknownTexture = new BaseTexture();
    this.hasIntegerTextures = false;
  }
  contextChange() {
    const gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.webGLVersion = this.renderer.context.webGLVersion;
    this.internalFormats = mapTypeAndFormatToInternalFormat(gl);
    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = maxTextures;
    for (let i2 = 0; i2 < maxTextures; i2++) {
      this.boundTextures[i2] = null;
    }
    this.emptyTextures = {};
    const emptyTexture2D = new GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
    this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
    this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
    for (let i2 = 0; i2 < 6; i2++) {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    for (let i2 = 0; i2 < this.boundTextures.length; i2++) {
      this.bind(null, i2);
    }
  }
  bind(texture, location2 = 0) {
    const { gl } = this;
    texture = texture == null ? void 0 : texture.castToBaseTexture();
    if ((texture == null ? void 0 : texture.valid) && !texture.parentTextureArray) {
      texture.touched = this.renderer.textureGC.count;
      const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
      if (this.boundTextures[location2] !== texture) {
        if (this.currentLocation !== location2) {
          this.currentLocation = location2;
          gl.activeTexture(gl.TEXTURE0 + location2);
        }
        gl.bindTexture(texture.target, glTexture.texture);
      }
      if (glTexture.dirtyId !== texture.dirtyId) {
        if (this.currentLocation !== location2) {
          this.currentLocation = location2;
          gl.activeTexture(gl.TEXTURE0 + location2);
        }
        this.updateTexture(texture);
      } else if (glTexture.dirtyStyleId !== texture.dirtyStyleId) {
        this.updateTextureStyle(texture);
      }
      this.boundTextures[location2] = texture;
    } else {
      if (this.currentLocation !== location2) {
        this.currentLocation = location2;
        gl.activeTexture(gl.TEXTURE0 + location2);
      }
      gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
      this.boundTextures[location2] = null;
    }
  }
  reset() {
    this._unknownBoundTextures = true;
    this.hasIntegerTextures = false;
    this.currentLocation = -1;
    for (let i2 = 0; i2 < this.boundTextures.length; i2++) {
      this.boundTextures[i2] = this.unknownTexture;
    }
  }
  unbind(texture) {
    const { gl, boundTextures } = this;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = false;
      for (let i2 = 0; i2 < boundTextures.length; i2++) {
        if (boundTextures[i2] === this.unknownTexture) {
          this.bind(null, i2);
        }
      }
    }
    for (let i2 = 0; i2 < boundTextures.length; i2++) {
      if (boundTextures[i2] === texture) {
        if (this.currentLocation !== i2) {
          gl.activeTexture(gl.TEXTURE0 + i2);
          this.currentLocation = i2;
        }
        gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
        boundTextures[i2] = null;
      }
    }
  }
  ensureSamplerType(maxTextures) {
    const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;
    if (!hasIntegerTextures) {
      return;
    }
    for (let i2 = maxTextures - 1; i2 >= 0; --i2) {
      const tex = boundTextures[i2];
      if (tex) {
        const glTexture = tex._glTextures[CONTEXT_UID];
        if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
          this.renderer.texture.unbind(tex);
        }
      }
    }
  }
  initTexture(texture) {
    const glTexture = new GLTexture(this.gl.createTexture());
    glTexture.dirtyId = -1;
    texture._glTextures[this.CONTEXT_UID] = glTexture;
    this.managedTextures.push(texture);
    texture.on("dispose", this.destroyTexture, this);
    return glTexture;
  }
  initTextureType(texture, glTexture) {
    var _a;
    glTexture.internalFormat = ((_a = this.internalFormats[texture.type]) == null ? void 0 : _a[texture.format]) ?? texture.format;
    if (this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT) {
      glTexture.type = this.gl.HALF_FLOAT;
    } else {
      glTexture.type = texture.type;
    }
  }
  updateTexture(texture) {
    var _a;
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    const renderer2 = this.renderer;
    this.initTextureType(texture, glTexture);
    if ((_a = texture.resource) == null ? void 0 : _a.upload(renderer2, texture, glTexture)) {
      if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
        this.hasIntegerTextures = true;
      }
    } else {
      const width = texture.realWidth;
      const height = texture.realHeight;
      const gl = renderer2.gl;
      if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
      }
    }
    if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
      this.updateTextureStyle(texture);
    }
    glTexture.dirtyId = texture.dirtyId;
  }
  destroyTexture(texture, skipRemove) {
    const { gl } = this;
    texture = texture.castToBaseTexture();
    if (texture._glTextures[this.CONTEXT_UID]) {
      this.unbind(texture);
      gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
      texture.off("dispose", this.destroyTexture, this);
      delete texture._glTextures[this.CONTEXT_UID];
      if (!skipRemove) {
        const i2 = this.managedTextures.indexOf(texture);
        if (i2 !== -1) {
          removeItems(this.managedTextures, i2, 1);
        }
      }
    }
  }
  updateTextureStyle(texture) {
    var _a;
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
      glTexture.mipmap = false;
    } else {
      glTexture.mipmap = texture.mipmap >= 1;
    }
    if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
      glTexture.wrapMode = WRAP_MODES.CLAMP;
    } else {
      glTexture.wrapMode = texture.wrapMode;
    }
    if ((_a = texture.resource) == null ? void 0 : _a.style(this.renderer, texture, glTexture))
      ;
    else {
      this.setStyle(texture, glTexture);
    }
    glTexture.dirtyStyleId = texture.dirtyStyleId;
  }
  setStyle(texture, glTexture) {
    const gl = this.gl;
    if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL) {
      gl.generateMipmap(texture.target);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
    if (glTexture.mipmap) {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
      const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {
        const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
      }
    } else {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
  }
  destroy() {
    this.renderer = null;
  }
}
TextureSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "texture"
};
extensions$1.add(TextureSystem);
class TransformFeedbackSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
  }
  contextChange() {
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  bind(transformFeedback) {
    const { gl, CONTEXT_UID } = this;
    const glTransformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
  }
  unbind() {
    const { gl } = this;
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
  }
  beginTransformFeedback(drawMode, shader) {
    const { gl, renderer: renderer2 } = this;
    if (shader) {
      renderer2.shader.bind(shader);
    }
    gl.beginTransformFeedback(drawMode);
  }
  endTransformFeedback() {
    const { gl } = this;
    gl.endTransformFeedback();
  }
  createGLTransformFeedback(tf) {
    const { gl, renderer: renderer2, CONTEXT_UID } = this;
    const glTransformFeedback = gl.createTransformFeedback();
    tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback;
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
    for (let i2 = 0; i2 < tf.buffers.length; i2++) {
      const buffer2 = tf.buffers[i2];
      if (!buffer2)
        continue;
      renderer2.buffer.update(buffer2);
      buffer2._glBuffers[CONTEXT_UID].refCount++;
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i2, buffer2._glBuffers[CONTEXT_UID].buffer || null);
    }
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    tf.disposeRunner.add(this);
    return glTransformFeedback;
  }
  disposeTransformFeedback(tf, contextLost) {
    const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID];
    const gl = this.gl;
    tf.disposeRunner.remove(this);
    const bufferSystem = this.renderer.buffer;
    if (bufferSystem) {
      for (let i2 = 0; i2 < tf.buffers.length; i2++) {
        const buffer2 = tf.buffers[i2];
        if (!buffer2)
          continue;
        const buf = buffer2._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffer2, contextLost);
          }
        }
      }
    }
    if (!glTF) {
      return;
    }
    if (!contextLost) {
      gl.deleteTransformFeedback(glTF);
    }
    delete tf._glTransformFeedbacks[this.CONTEXT_UID];
  }
  destroy() {
    this.renderer = null;
  }
}
TransformFeedbackSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "transformFeedback"
};
extensions$1.add(TransformFeedbackSystem);
class ViewSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
  }
  init(options) {
    this.screen = new Rectangle(0, 0, options.width, options.height);
    this.element = options.view || settings.ADAPTER.createCanvas();
    this.resolution = options.resolution || settings.RESOLUTION;
    this.autoDensity = !!options.autoDensity;
  }
  resizeView(desiredScreenWidth, desiredScreenHeight) {
    this.element.width = Math.round(desiredScreenWidth * this.resolution);
    this.element.height = Math.round(desiredScreenHeight * this.resolution);
    const screenWidth = this.element.width / this.resolution;
    const screenHeight = this.element.height / this.resolution;
    this.screen.width = screenWidth;
    this.screen.height = screenHeight;
    if (this.autoDensity) {
      this.element.style.width = `${screenWidth}px`;
      this.element.style.height = `${screenHeight}px`;
    }
    this.renderer.emit("resize", screenWidth, screenHeight);
    this.renderer.runners.resize.emit(this.screen.width, this.screen.height);
  }
  destroy(removeView) {
    var _a;
    if (removeView) {
      (_a = this.element.parentNode) == null ? void 0 : _a.removeChild(this.element);
    }
    this.renderer = null;
    this.element = null;
    this.screen = null;
  }
}
ViewSystem.defaultOptions = {
  width: 800,
  height: 600,
  resolution: settings.RESOLUTION,
  autoDensity: false
};
ViewSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "_view"
};
extensions$1.add(ViewSystem);
settings.PREFER_ENV = ENV.WEBGL2;
settings.STRICT_TEXTURE_CACHE = false;
settings.RENDER_OPTIONS = {
  ...ContextSystem.defaultOptions,
  ...BackgroundSystem.defaultOptions,
  ...ViewSystem.defaultOptions,
  ...StartupSystem.defaultOptions
};
Object.defineProperties(settings, {
  WRAP_MODE: {
    get() {
      return BaseTexture.defaultOptions.wrapMode;
    },
    set(value2) {
      deprecation("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode");
      BaseTexture.defaultOptions.wrapMode = value2;
    }
  },
  SCALE_MODE: {
    get() {
      return BaseTexture.defaultOptions.scaleMode;
    },
    set(value2) {
      deprecation("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode");
      BaseTexture.defaultOptions.scaleMode = value2;
    }
  },
  MIPMAP_TEXTURES: {
    get() {
      return BaseTexture.defaultOptions.mipmap;
    },
    set(value2) {
      deprecation("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap");
      BaseTexture.defaultOptions.mipmap = value2;
    }
  },
  ANISOTROPIC_LEVEL: {
    get() {
      return BaseTexture.defaultOptions.anisotropicLevel;
    },
    set(value2) {
      deprecation("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel");
      BaseTexture.defaultOptions.anisotropicLevel = value2;
    }
  },
  FILTER_RESOLUTION: {
    get() {
      deprecation("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution");
      return Filter.defaultResolution;
    },
    set(value2) {
      Filter.defaultResolution = value2;
    }
  },
  FILTER_MULTISAMPLE: {
    get() {
      deprecation("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample");
      return Filter.defaultMultisample;
    },
    set(value2) {
      Filter.defaultMultisample = value2;
    }
  },
  SPRITE_MAX_TEXTURES: {
    get() {
      return BatchRenderer.defaultMaxTextures;
    },
    set(value2) {
      deprecation("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures");
      BatchRenderer.defaultMaxTextures = value2;
    }
  },
  SPRITE_BATCH_SIZE: {
    get() {
      return BatchRenderer.defaultBatchSize;
    },
    set(value2) {
      deprecation("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize");
      BatchRenderer.defaultBatchSize = value2;
    }
  },
  CAN_UPLOAD_SAME_BUFFER: {
    get() {
      return BatchRenderer.canUploadSameBuffer;
    },
    set(value2) {
      deprecation("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer");
      BatchRenderer.canUploadSameBuffer = value2;
    }
  },
  GC_MODE: {
    get() {
      return TextureGCSystem.defaultMode;
    },
    set(value2) {
      deprecation("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode");
      TextureGCSystem.defaultMode = value2;
    }
  },
  GC_MAX_IDLE: {
    get() {
      return TextureGCSystem.defaultMaxIdle;
    },
    set(value2) {
      deprecation("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle");
      TextureGCSystem.defaultMaxIdle = value2;
    }
  },
  GC_MAX_CHECK_COUNT: {
    get() {
      return TextureGCSystem.defaultCheckCountMax;
    },
    set(value2) {
      deprecation("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax");
      TextureGCSystem.defaultCheckCountMax = value2;
    }
  },
  PRECISION_VERTEX: {
    get() {
      return Program.defaultVertexPrecision;
    },
    set(value2) {
      deprecation("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision");
      Program.defaultVertexPrecision = value2;
    }
  },
  PRECISION_FRAGMENT: {
    get() {
      return Program.defaultFragmentPrecision;
    },
    set(value2) {
      deprecation("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision");
      Program.defaultFragmentPrecision = value2;
    }
  }
});
var UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
  return UPDATE_PRIORITY2;
})(UPDATE_PRIORITY || {});
class TickerListener {
  constructor(fn, context2 = null, priority = 0, once3 = false) {
    this.next = null;
    this.previous = null;
    this._destroyed = false;
    this.fn = fn;
    this.context = context2;
    this.priority = priority;
    this.once = once3;
  }
  match(fn, context2 = null) {
    return this.fn === fn && this.context === context2;
  }
  emit(deltaTime) {
    if (this.fn) {
      if (this.context) {
        this.fn.call(this.context, deltaTime);
      } else {
        this.fn(deltaTime);
      }
    }
    const redirect = this.next;
    if (this.once) {
      this.destroy(true);
    }
    if (this._destroyed) {
      this.next = null;
    }
    return redirect;
  }
  connect(previous) {
    this.previous = previous;
    if (previous.next) {
      previous.next.previous = this;
    }
    this.next = previous.next;
    previous.next = this;
  }
  destroy(hard = false) {
    this._destroyed = true;
    this.fn = null;
    this.context = null;
    if (this.previous) {
      this.previous.next = this.next;
    }
    if (this.next) {
      this.next.previous = this.previous;
    }
    const redirect = this.next;
    this.next = hard ? null : redirect;
    this.previous = null;
    return redirect;
  }
}
const _Ticker = class {
  constructor() {
    this.autoStart = false;
    this.deltaTime = 1;
    this.lastTime = -1;
    this.speed = 1;
    this.started = false;
    this._requestId = null;
    this._maxElapsedMS = 100;
    this._minElapsedMS = 0;
    this._protected = false;
    this._lastFrame = -1;
    this._head = new TickerListener(null, null, Infinity);
    this.deltaMS = 1 / _Ticker.targetFPMS;
    this.elapsedMS = 1 / _Ticker.targetFPMS;
    this._tick = (time) => {
      this._requestId = null;
      if (this.started) {
        this.update(time);
        if (this.started && this._requestId === null && this._head.next) {
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
    };
  }
  _requestIfNeeded() {
    if (this._requestId === null && this._head.next) {
      this.lastTime = performance.now();
      this._lastFrame = this.lastTime;
      this._requestId = requestAnimationFrame(this._tick);
    }
  }
  _cancelIfNeeded() {
    if (this._requestId !== null) {
      cancelAnimationFrame(this._requestId);
      this._requestId = null;
    }
  }
  _startIfPossible() {
    if (this.started) {
      this._requestIfNeeded();
    } else if (this.autoStart) {
      this.start();
    }
  }
  add(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener(fn, context2, priority));
  }
  addOnce(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener(fn, context2, priority, true));
  }
  _addListener(listener) {
    let current = this._head.next;
    let previous = this._head;
    if (!current) {
      listener.connect(previous);
    } else {
      while (current) {
        if (listener.priority > current.priority) {
          listener.connect(previous);
          break;
        }
        previous = current;
        current = current.next;
      }
      if (!listener.previous) {
        listener.connect(previous);
      }
    }
    this._startIfPossible();
    return this;
  }
  remove(fn, context2) {
    let listener = this._head.next;
    while (listener) {
      if (listener.match(fn, context2)) {
        listener = listener.destroy();
      } else {
        listener = listener.next;
      }
    }
    if (!this._head.next) {
      this._cancelIfNeeded();
    }
    return this;
  }
  get count() {
    if (!this._head) {
      return 0;
    }
    let count = 0;
    let current = this._head;
    while (current = current.next) {
      count++;
    }
    return count;
  }
  start() {
    if (!this.started) {
      this.started = true;
      this._requestIfNeeded();
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this._cancelIfNeeded();
    }
  }
  destroy() {
    if (!this._protected) {
      this.stop();
      let listener = this._head.next;
      while (listener) {
        listener = listener.destroy(true);
      }
      this._head.destroy();
      this._head = null;
    }
  }
  update(currentTime = performance.now()) {
    let elapsedMS;
    if (currentTime > this.lastTime) {
      elapsedMS = this.elapsedMS = currentTime - this.lastTime;
      if (elapsedMS > this._maxElapsedMS) {
        elapsedMS = this._maxElapsedMS;
      }
      elapsedMS *= this.speed;
      if (this._minElapsedMS) {
        const delta = currentTime - this._lastFrame | 0;
        if (delta < this._minElapsedMS) {
          return;
        }
        this._lastFrame = currentTime - delta % this._minElapsedMS;
      }
      this.deltaMS = elapsedMS;
      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;
      const head = this._head;
      let listener = head.next;
      while (listener) {
        listener = listener.emit(this.deltaTime);
      }
      if (!head.next) {
        this._cancelIfNeeded();
      }
    } else {
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    }
    this.lastTime = currentTime;
  }
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(fps) {
    const minFPS = Math.min(this.maxFPS, fps);
    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);
    this._maxElapsedMS = 1 / minFPMS;
  }
  get maxFPS() {
    if (this._minElapsedMS) {
      return Math.round(1e3 / this._minElapsedMS);
    }
    return 0;
  }
  set maxFPS(fps) {
    if (fps === 0) {
      this._minElapsedMS = 0;
    } else {
      const maxFPS = Math.max(this.minFPS, fps);
      this._minElapsedMS = 1 / (maxFPS / 1e3);
    }
  }
  static get shared() {
    if (!_Ticker._shared) {
      const shared = _Ticker._shared = new _Ticker();
      shared.autoStart = true;
      shared._protected = true;
    }
    return _Ticker._shared;
  }
  static get system() {
    if (!_Ticker._system) {
      const system = _Ticker._system = new _Ticker();
      system.autoStart = true;
      system._protected = true;
    }
    return _Ticker._system;
  }
};
let Ticker = _Ticker;
Ticker.targetFPMS = 0.06;
Object.defineProperties(settings, {
  TARGET_FPMS: {
    get() {
      return Ticker.targetFPMS;
    },
    set(value2) {
      deprecation("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS");
      Ticker.targetFPMS = value2;
    }
  }
});
class TickerPlugin {
  static init(options) {
    options = Object.assign({
      autoStart: true,
      sharedTicker: false
    }, options);
    Object.defineProperty(this, "ticker", {
      set(ticker) {
        if (this._ticker) {
          this._ticker.remove(this.render, this);
        }
        this._ticker = ticker;
        if (ticker) {
          ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
        }
      },
      get() {
        return this._ticker;
      }
    });
    this.stop = () => {
      this._ticker.stop();
    };
    this.start = () => {
      this._ticker.start();
    };
    this._ticker = null;
    this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
    if (options.autoStart) {
      this.start();
    }
  }
  static destroy() {
    if (this._ticker) {
      const oldTicker = this._ticker;
      this.ticker = null;
      oldTicker.destroy();
    }
  }
}
TickerPlugin.extension = ExtensionType.Application;
extensions$1.add(TickerPlugin);
const renderers = [];
extensions$1.handleByList(ExtensionType.Renderer, renderers);
function autoDetectRenderer(options) {
  for (const RendererType of renderers) {
    if (RendererType.test(options)) {
      return new RendererType(options);
    }
  }
  throw new Error("Unable to auto-detect a suitable renderer.");
}
var $defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var $defaultFilterVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
const defaultVertex = $defaultVertex;
const defaultFilterVertex = $defaultFilterVertex;
class MultisampleSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
  }
  contextChange(gl) {
    let samples;
    if (this.renderer.context.webGLVersion === 1) {
      const framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    } else {
      const framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
    }
    if (samples >= MSAA_QUALITY.HIGH) {
      this.multisample = MSAA_QUALITY.HIGH;
    } else if (samples >= MSAA_QUALITY.MEDIUM) {
      this.multisample = MSAA_QUALITY.MEDIUM;
    } else if (samples >= MSAA_QUALITY.LOW) {
      this.multisample = MSAA_QUALITY.LOW;
    } else {
      this.multisample = MSAA_QUALITY.NONE;
    }
  }
  destroy() {
  }
}
MultisampleSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "_multisample"
};
extensions$1.add(MultisampleSystem);
class GLBuffer {
  constructor(buffer2) {
    this.buffer = buffer2 || null;
    this.updateID = -1;
    this.byteLength = -1;
    this.refCount = 0;
  }
}
class BufferSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.managedBuffers = {};
    this.boundBufferBases = {};
  }
  destroy() {
    this.renderer = null;
  }
  contextChange() {
    this.disposeAll(true);
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  bind(buffer2) {
    const { gl, CONTEXT_UID } = this;
    const glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
    gl.bindBuffer(buffer2.type, glBuffer.buffer);
  }
  unbind(type) {
    const { gl } = this;
    gl.bindBuffer(type, null);
  }
  bindBufferBase(buffer2, index2) {
    const { gl, CONTEXT_UID } = this;
    if (this.boundBufferBases[index2] !== buffer2) {
      const glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
      this.boundBufferBases[index2] = buffer2;
      gl.bindBufferBase(gl.UNIFORM_BUFFER, index2, glBuffer.buffer);
    }
  }
  bindBufferRange(buffer2, index2, offset) {
    const { gl, CONTEXT_UID } = this;
    offset = offset || 0;
    const glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
    gl.bindBufferRange(gl.UNIFORM_BUFFER, index2 || 0, glBuffer.buffer, offset * 256, 256);
  }
  update(buffer2) {
    const { gl, CONTEXT_UID } = this;
    const glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
    if (buffer2._updateID === glBuffer.updateID) {
      return;
    }
    glBuffer.updateID = buffer2._updateID;
    gl.bindBuffer(buffer2.type, glBuffer.buffer);
    if (glBuffer.byteLength >= buffer2.data.byteLength) {
      gl.bufferSubData(buffer2.type, 0, buffer2.data);
    } else {
      const drawType = buffer2.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
      glBuffer.byteLength = buffer2.data.byteLength;
      gl.bufferData(buffer2.type, buffer2.data, drawType);
    }
  }
  dispose(buffer2, contextLost) {
    if (!this.managedBuffers[buffer2.id]) {
      return;
    }
    delete this.managedBuffers[buffer2.id];
    const glBuffer = buffer2._glBuffers[this.CONTEXT_UID];
    const gl = this.gl;
    buffer2.disposeRunner.remove(this);
    if (!glBuffer) {
      return;
    }
    if (!contextLost) {
      gl.deleteBuffer(glBuffer.buffer);
    }
    delete buffer2._glBuffers[this.CONTEXT_UID];
  }
  disposeAll(contextLost) {
    const all = Object.keys(this.managedBuffers);
    for (let i2 = 0; i2 < all.length; i2++) {
      this.dispose(this.managedBuffers[all[i2]], contextLost);
    }
  }
  createGLBuffer(buffer2) {
    const { CONTEXT_UID, gl } = this;
    buffer2._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
    this.managedBuffers[buffer2.id] = buffer2;
    buffer2.disposeRunner.add(this);
    return buffer2._glBuffers[CONTEXT_UID];
  }
}
BufferSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "buffer"
};
extensions$1.add(BufferSystem);
class ObjectRendererSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
  }
  render(displayObject, options) {
    const renderer2 = this.renderer;
    let renderTexture;
    let clear2;
    let transform;
    let skipUpdateTransform;
    if (options) {
      renderTexture = options.renderTexture;
      clear2 = options.clear;
      transform = options.transform;
      skipUpdateTransform = options.skipUpdateTransform;
    }
    this.renderingToScreen = !renderTexture;
    renderer2.runners.prerender.emit();
    renderer2.emit("prerender");
    renderer2.projection.transform = transform;
    if (renderer2.context.isLost) {
      return;
    }
    if (!renderTexture) {
      this.lastObjectRendered = displayObject;
    }
    if (!skipUpdateTransform) {
      const cacheParent = displayObject.enableTempParent();
      displayObject.updateTransform();
      displayObject.disableTempParent(cacheParent);
    }
    renderer2.renderTexture.bind(renderTexture);
    renderer2.batch.currentRenderer.start();
    if (clear2 ?? renderer2.background.clearBeforeRender) {
      renderer2.renderTexture.clear();
    }
    displayObject.render(renderer2);
    renderer2.batch.currentRenderer.flush();
    if (renderTexture) {
      if (options.blit) {
        renderer2.framebuffer.blit();
      }
      renderTexture.baseTexture.update();
    }
    renderer2.runners.postrender.emit();
    renderer2.projection.transform = null;
    renderer2.emit("postrender");
  }
  destroy() {
    this.renderer = null;
    this.lastObjectRendered = null;
  }
}
ObjectRendererSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "objectRenderer"
};
extensions$1.add(ObjectRendererSystem);
const _Renderer = class extends SystemManager {
  constructor(options) {
    super();
    this.type = RENDERER_TYPE.WEBGL;
    options = Object.assign({}, settings.RENDER_OPTIONS, options);
    this.gl = null;
    this.CONTEXT_UID = 0;
    this.globalUniforms = new UniformGroup({
      projectionMatrix: new Matrix()
    }, true);
    const systemConfig = {
      runners: [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "reset",
        "update",
        "postrender",
        "prerender",
        "resize"
      ],
      systems: _Renderer.__systems,
      priority: [
        "_view",
        "textureGenerator",
        "background",
        "_plugin",
        "startup",
        "context",
        "state",
        "texture",
        "buffer",
        "geometry",
        "framebuffer",
        "transformFeedback",
        "mask",
        "scissor",
        "stencil",
        "projection",
        "textureGC",
        "filter",
        "renderTexture",
        "batch",
        "objectRenderer",
        "_multisample"
      ]
    };
    this.setup(systemConfig);
    if ("useContextAlpha" in options) {
      deprecation("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead");
      options.premultipliedAlpha = options.useContextAlpha && options.useContextAlpha !== "notMultiplied";
      options.backgroundAlpha = options.useContextAlpha === false ? 1 : options.backgroundAlpha;
    }
    this._plugin.rendererPlugins = _Renderer.__plugins;
    this.options = options;
    this.startup.run(this.options);
  }
  static test(options) {
    if (options == null ? void 0 : options.forceCanvas) {
      return false;
    }
    return isWebGLSupported();
  }
  render(displayObject, options) {
    this.objectRenderer.render(displayObject, options);
  }
  resize(desiredScreenWidth, desiredScreenHeight) {
    this._view.resizeView(desiredScreenWidth, desiredScreenHeight);
  }
  reset() {
    this.runners.reset.emit();
    return this;
  }
  clear() {
    this.renderTexture.bind();
    this.renderTexture.clear();
  }
  destroy(removeView = false) {
    this.runners.destroy.items.reverse();
    this.emitWithCustomOptions(this.runners.destroy, {
      _view: removeView
    });
    super.destroy();
  }
  get plugins() {
    return this._plugin.plugins;
  }
  get multisample() {
    return this._multisample.multisample;
  }
  get width() {
    return this._view.element.width;
  }
  get height() {
    return this._view.element.height;
  }
  get resolution() {
    return this._view.resolution;
  }
  set resolution(value2) {
    this._view.resolution = value2;
    this.runners.resolutionChange.emit(value2);
  }
  get autoDensity() {
    return this._view.autoDensity;
  }
  get view() {
    return this._view.element;
  }
  get screen() {
    return this._view.screen;
  }
  get lastObjectRendered() {
    return this.objectRenderer.lastObjectRendered;
  }
  get renderingToScreen() {
    return this.objectRenderer.renderingToScreen;
  }
  get rendererLogId() {
    return `WebGL ${this.context.webGLVersion}`;
  }
  get clearBeforeRender() {
    deprecation("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead.");
    return this.background.clearBeforeRender;
  }
  get useContextAlpha() {
    deprecation("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead.");
    return this.context.useContextAlpha;
  }
  get preserveDrawingBuffer() {
    deprecation("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context");
    return this.context.preserveDrawingBuffer;
  }
  get backgroundColor() {
    deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
    return this.background.color;
  }
  set backgroundColor(value2) {
    deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
    this.background.color = value2;
  }
  get backgroundAlpha() {
    deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
    return this.background.alpha;
  }
  set backgroundAlpha(value2) {
    deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
    this.background.alpha = value2;
  }
  get powerPreference() {
    deprecation("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context");
    return this.context.powerPreference;
  }
  generateTexture(displayObject, options) {
    return this.textureGenerator.generateTexture(displayObject, options);
  }
};
let Renderer = _Renderer;
Renderer.extension = {
  type: ExtensionType.Renderer,
  priority: 1
};
Renderer.__plugins = {};
Renderer.__systems = {};
extensions$1.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);
extensions$1.handleByMap(ExtensionType.RendererSystem, Renderer.__systems);
extensions$1.add(Renderer);
class AbstractMultiResource extends Resource {
  constructor(length2, options) {
    const { width, height } = options || {};
    super(width, height);
    this.items = [];
    this.itemDirtyIds = [];
    for (let i2 = 0; i2 < length2; i2++) {
      const partTexture = new BaseTexture();
      this.items.push(partTexture);
      this.itemDirtyIds.push(-2);
    }
    this.length = length2;
    this._load = null;
    this.baseTexture = null;
  }
  initFromArray(resources, options) {
    for (let i2 = 0; i2 < this.length; i2++) {
      if (!resources[i2]) {
        continue;
      }
      if (resources[i2].castToBaseTexture) {
        this.addBaseTextureAt(resources[i2].castToBaseTexture(), i2);
      } else if (resources[i2] instanceof Resource) {
        this.addResourceAt(resources[i2], i2);
      } else {
        this.addResourceAt(autoDetectResource(resources[i2], options), i2);
      }
    }
  }
  dispose() {
    for (let i2 = 0, len = this.length; i2 < len; i2++) {
      this.items[i2].destroy();
    }
    this.items = null;
    this.itemDirtyIds = null;
    this._load = null;
  }
  addResourceAt(resource, index2) {
    if (!this.items[index2]) {
      throw new Error(`Index ${index2} is out of bounds`);
    }
    if (resource.valid && !this.valid) {
      this.resize(resource.width, resource.height);
    }
    this.items[index2].setResource(resource);
    return this;
  }
  bind(baseTexture) {
    if (this.baseTexture !== null) {
      throw new Error("Only one base texture per TextureArray is allowed");
    }
    super.bind(baseTexture);
    for (let i2 = 0; i2 < this.length; i2++) {
      this.items[i2].parentTextureArray = baseTexture;
      this.items[i2].on("update", baseTexture.update, baseTexture);
    }
  }
  unbind(baseTexture) {
    super.unbind(baseTexture);
    for (let i2 = 0; i2 < this.length; i2++) {
      this.items[i2].parentTextureArray = null;
      this.items[i2].off("update", baseTexture.update, baseTexture);
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    const resources = this.items.map((item) => item.resource).filter((item) => item);
    const promises = resources.map((item) => item.load());
    this._load = Promise.all(promises).then(() => {
      const { realWidth, realHeight } = this.items[0];
      this.resize(realWidth, realHeight);
      return Promise.resolve(this);
    });
    return this._load;
  }
}
class ArrayResource extends AbstractMultiResource {
  constructor(source, options) {
    const { width, height } = options || {};
    let urls;
    let length2;
    if (Array.isArray(source)) {
      urls = source;
      length2 = source.length;
    } else {
      length2 = source;
    }
    super(length2, { width, height });
    if (urls) {
      this.initFromArray(urls, options);
    }
  }
  addBaseTextureAt(baseTexture, index2) {
    if (baseTexture.resource) {
      this.addResourceAt(baseTexture.resource, index2);
    } else {
      throw new Error("ArrayResource does not support RenderTexture");
    }
    return this;
  }
  bind(baseTexture) {
    super.bind(baseTexture);
    baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;
  }
  upload(renderer2, texture, glTexture) {
    const { length: length2, itemDirtyIds, items } = this;
    const { gl } = renderer2;
    if (glTexture.dirtyId < 0) {
      gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length2, 0, texture.format, glTexture.type, null);
    }
    for (let i2 = 0; i2 < length2; i2++) {
      const item = items[i2];
      if (itemDirtyIds[i2] < item.dirtyId) {
        itemDirtyIds[i2] = item.dirtyId;
        if (item.valid) {
          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i2, item.resource.width, item.resource.height, 1, texture.format, glTexture.type, item.resource.source);
        }
      }
    }
    return true;
  }
}
class CanvasResource extends BaseImageResource {
  constructor(source) {
    super(source);
  }
  static test(source) {
    const { OffscreenCanvas: OffscreenCanvas2 } = globalThis;
    if (OffscreenCanvas2 && source instanceof OffscreenCanvas2) {
      return true;
    }
    return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
  }
}
const _CubeResource = class extends AbstractMultiResource {
  constructor(source, options) {
    const { width, height, autoLoad, linkBaseTexture } = options || {};
    if (source && source.length !== _CubeResource.SIDES) {
      throw new Error(`Invalid length. Got ${source.length}, expected 6`);
    }
    super(6, { width, height });
    for (let i2 = 0; i2 < _CubeResource.SIDES; i2++) {
      this.items[i2].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i2;
    }
    this.linkBaseTexture = linkBaseTexture !== false;
    if (source) {
      this.initFromArray(source, options);
    }
    if (autoLoad !== false) {
      this.load();
    }
  }
  bind(baseTexture) {
    super.bind(baseTexture);
    baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;
  }
  addBaseTextureAt(baseTexture, index2, linkBaseTexture) {
    if (linkBaseTexture === void 0) {
      linkBaseTexture = this.linkBaseTexture;
    }
    if (!this.items[index2]) {
      throw new Error(`Index ${index2} is out of bounds`);
    }
    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index2);
      } else {
        throw new Error(`CubeResource does not support copying of renderTexture.`);
      }
    } else {
      baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index2;
      baseTexture.parentTextureArray = this.baseTexture;
      this.items[index2] = baseTexture;
    }
    if (baseTexture.valid && !this.valid) {
      this.resize(baseTexture.realWidth, baseTexture.realHeight);
    }
    this.items[index2] = baseTexture;
    return this;
  }
  upload(renderer2, _baseTexture, glTexture) {
    const dirty = this.itemDirtyIds;
    for (let i2 = 0; i2 < _CubeResource.SIDES; i2++) {
      const side = this.items[i2];
      if (dirty[i2] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) {
        if (side.valid && side.resource) {
          side.resource.upload(renderer2, side, glTexture);
          dirty[i2] = side.dirtyId;
        } else if (dirty[i2] < -1) {
          renderer2.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
          dirty[i2] = -1;
        }
      }
    }
    return true;
  }
  static test(source) {
    return Array.isArray(source) && source.length === _CubeResource.SIDES;
  }
};
let CubeResource = _CubeResource;
CubeResource.SIDES = 6;
class ImageBitmapResource extends BaseImageResource {
  constructor(source, options) {
    options = options || {};
    let baseSource;
    let url2;
    if (typeof source === "string") {
      baseSource = ImageBitmapResource.EMPTY;
      url2 = source;
    } else {
      baseSource = source;
      url2 = null;
    }
    super(baseSource);
    this.url = url2;
    this.crossOrigin = options.crossOrigin ?? true;
    this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = new Promise(async (resolve2, reject) => {
      if (this.url === null) {
        resolve2(this);
        return;
      }
      try {
        const response = await settings.ADAPTER.fetch(this.url, {
          mode: this.crossOrigin ? "cors" : "no-cors"
        });
        if (this.destroyed)
          return;
        const imageBlob = await response.blob();
        if (this.destroyed)
          return;
        const imageBitmap = await createImageBitmap(imageBlob, {
          premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
        });
        if (this.destroyed)
          return;
        this.source = imageBitmap;
        this.update();
        resolve2(this);
      } catch (e3) {
        if (this.destroyed)
          return;
        reject(e3);
        this.onError.emit(e3);
      }
    });
    return this._load;
  }
  upload(renderer2, baseTexture, glTexture) {
    if (!(this.source instanceof ImageBitmap)) {
      this.load();
      return false;
    }
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    return super.upload(renderer2, baseTexture, glTexture);
  }
  dispose() {
    if (this.source instanceof ImageBitmap) {
      this.source.close();
    }
    super.dispose();
    this._load = null;
  }
  static test(source) {
    return !!globalThis.createImageBitmap && typeof ImageBitmap !== "undefined" && (typeof source === "string" || source instanceof ImageBitmap);
  }
  static get EMPTY() {
    ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings.ADAPTER.createCanvas(0, 0);
    return ImageBitmapResource._EMPTY;
  }
}
const _SVGResource = class extends BaseImageResource {
  constructor(sourceBase64, options) {
    options = options || {};
    super(settings.ADAPTER.createCanvas());
    this._width = 0;
    this._height = 0;
    this.svg = sourceBase64;
    this.scale = options.scale || 1;
    this._overrideWidth = options.width;
    this._overrideHeight = options.height;
    this._resolve = null;
    this._crossorigin = options.crossorigin;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = new Promise((resolve2) => {
      this._resolve = () => {
        this.resize(this.source.width, this.source.height);
        resolve2(this);
      };
      if (_SVGResource.SVG_XML.test(this.svg.trim())) {
        if (!btoa) {
          throw new Error("Your browser doesn't support base64 conversions.");
        }
        this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;
      }
      this._loadSvg();
    });
    return this._load;
  }
  _loadSvg() {
    const tempImage = new Image();
    BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
    tempImage.src = this.svg;
    tempImage.onerror = (event) => {
      if (!this._resolve) {
        return;
      }
      tempImage.onerror = null;
      this.onError.emit(event);
    };
    tempImage.onload = () => {
      if (!this._resolve) {
        return;
      }
      const svgWidth = tempImage.width;
      const svgHeight = tempImage.height;
      if (!svgWidth || !svgHeight) {
        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
      }
      let width = svgWidth * this.scale;
      let height = svgHeight * this.scale;
      if (this._overrideWidth || this._overrideHeight) {
        width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth;
        height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight;
      }
      width = Math.round(width);
      height = Math.round(height);
      const canvas = this.source;
      canvas.width = width;
      canvas.height = height;
      canvas._pixiId = `canvas_${uid$2()}`;
      canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
      this._resolve();
      this._resolve = null;
    };
  }
  static getSize(svgString) {
    const sizeMatch = _SVGResource.SVG_SIZE.exec(svgString);
    const size2 = {};
    if (sizeMatch) {
      size2[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
      size2[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
    }
    return size2;
  }
  dispose() {
    super.dispose();
    this._resolve = null;
    this._crossorigin = null;
  }
  static test(source, extension) {
    return extension === "svg" || typeof source === "string" && source.startsWith("data:image/svg+xml") || typeof source === "string" && _SVGResource.SVG_XML.test(source);
  }
};
let SVGResource = _SVGResource;
SVGResource.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
const _VideoResource = class extends BaseImageResource {
  constructor(source, options) {
    options = options || {};
    if (!(source instanceof HTMLVideoElement)) {
      const videoElement = document.createElement("video");
      videoElement.setAttribute("preload", "auto");
      videoElement.setAttribute("webkit-playsinline", "");
      videoElement.setAttribute("playsinline", "");
      if (typeof source === "string") {
        source = [source];
      }
      const firstSrc = source[0].src || source[0];
      BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
      for (let i2 = 0; i2 < source.length; ++i2) {
        const sourceElement = document.createElement("source");
        let { src, mime } = source[i2];
        src = src || source[i2];
        const baseSrc = src.split("?").shift().toLowerCase();
        const ext2 = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
        mime = mime || _VideoResource.MIME_TYPES[ext2] || `video/${ext2}`;
        sourceElement.src = src;
        sourceElement.type = mime;
        videoElement.appendChild(sourceElement);
      }
      source = videoElement;
    }
    super(source);
    this.noSubImage = true;
    this._autoUpdate = true;
    this._isConnectedToTicker = false;
    this._updateFPS = options.updateFPS || 0;
    this._msToNextUpdate = 0;
    this.autoPlay = options.autoPlay !== false;
    this._load = null;
    this._resolve = null;
    this._onCanPlay = this._onCanPlay.bind(this);
    this._onError = this._onError.bind(this);
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  update(_deltaTime = 0) {
    if (!this.destroyed) {
      const elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
      if (!this._updateFPS || this._msToNextUpdate <= 0) {
        super.update();
        this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
      }
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    const source = this.source;
    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
      source.complete = true;
    }
    source.addEventListener("play", this._onPlayStart.bind(this));
    source.addEventListener("pause", this._onPlayStop.bind(this));
    if (!this._isSourceReady()) {
      source.addEventListener("canplay", this._onCanPlay);
      source.addEventListener("canplaythrough", this._onCanPlay);
      source.addEventListener("error", this._onError, true);
    } else {
      this._onCanPlay();
    }
    this._load = new Promise((resolve2) => {
      if (this.valid) {
        resolve2(this);
      } else {
        this._resolve = resolve2;
        source.load();
      }
    });
    return this._load;
  }
  _onError(event) {
    this.source.removeEventListener("error", this._onError, true);
    this.onError.emit(event);
  }
  _isSourcePlaying() {
    const source = this.source;
    return !source.paused && !source.ended && this._isSourceReady();
  }
  _isSourceReady() {
    const source = this.source;
    return source.readyState > 2;
  }
  _onPlayStart() {
    if (!this.valid) {
      this._onCanPlay();
    }
    if (this.autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this);
      this._isConnectedToTicker = true;
    }
  }
  _onPlayStop() {
    if (this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  _onCanPlay() {
    const source = this.source;
    source.removeEventListener("canplay", this._onCanPlay);
    source.removeEventListener("canplaythrough", this._onCanPlay);
    const valid = this.valid;
    this.resize(source.videoWidth, source.videoHeight);
    if (!valid && this._resolve) {
      this._resolve(this);
      this._resolve = null;
    }
    if (this._isSourcePlaying()) {
      this._onPlayStart();
    } else if (this.autoPlay) {
      source.play();
    }
  }
  dispose() {
    if (this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
    const source = this.source;
    if (source) {
      source.removeEventListener("error", this._onError, true);
      source.pause();
      source.src = "";
      source.load();
    }
    super.dispose();
  }
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value2) {
    if (value2 !== this._autoUpdate) {
      this._autoUpdate = value2;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
        Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(value2) {
    if (value2 !== this._updateFPS) {
      this._updateFPS = value2;
    }
  }
  static test(source, extension) {
    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource.TYPES.includes(extension);
  }
};
let VideoResource = _VideoResource;
VideoResource.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
VideoResource.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};
INSTALLED.push(ImageBitmapResource, ImageResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
class TransformFeedback {
  constructor() {
    this._glTransformFeedbacks = {};
    this.buffers = [];
    this.disposeRunner = new Runner("disposeTransformFeedback");
  }
  bindBuffer(index2, buffer2) {
    this.buffers[index2] = buffer2;
  }
  destroy() {
    this.disposeRunner.emit(this, false);
  }
}
const VERSION = "7.2.4";
class Bounds {
  constructor() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
    this.rect = null;
    this.updateID = -1;
  }
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  clear() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
  }
  getRectangle(rect) {
    if (this.minX > this.maxX || this.minY > this.maxY) {
      return Rectangle.EMPTY;
    }
    rect = rect || new Rectangle(0, 0, 1, 1);
    rect.x = this.minX;
    rect.y = this.minY;
    rect.width = this.maxX - this.minX;
    rect.height = this.maxY - this.minY;
    return rect;
  }
  addPoint(point) {
    this.minX = Math.min(this.minX, point.x);
    this.maxX = Math.max(this.maxX, point.x);
    this.minY = Math.min(this.minY, point.y);
    this.maxY = Math.max(this.maxY, point.y);
  }
  addPointMatrix(matrix, point) {
    const { a: a8, b: b3, c: c3, d: d2, tx, ty } = matrix;
    const x2 = a8 * point.x + c3 * point.y + tx;
    const y2 = b3 * point.x + d2 * point.y + ty;
    this.minX = Math.min(this.minX, x2);
    this.maxX = Math.max(this.maxX, x2);
    this.minY = Math.min(this.minY, y2);
    this.maxY = Math.max(this.maxY, y2);
  }
  addQuad(vertices) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x2 = vertices[0];
    let y2 = vertices[1];
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = vertices[2];
    y2 = vertices[3];
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = vertices[4];
    y2 = vertices[5];
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = vertices[6];
    y2 = vertices[7];
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addFrame(transform, x0, y0, x1, y1) {
    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
  }
  addFrameMatrix(matrix, x0, y0, x1, y1) {
    const a8 = matrix.a;
    const b3 = matrix.b;
    const c3 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x2 = a8 * x0 + c3 * y0 + tx;
    let y2 = b3 * x0 + d2 * y0 + ty;
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = a8 * x1 + c3 * y0 + tx;
    y2 = b3 * x1 + d2 * y0 + ty;
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = a8 * x0 + c3 * y1 + tx;
    y2 = b3 * x0 + d2 * y1 + ty;
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = a8 * x1 + c3 * y1 + tx;
    y2 = b3 * x1 + d2 * y1 + ty;
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addVertexData(vertexData, beginOffset, endOffset) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    for (let i2 = beginOffset; i2 < endOffset; i2 += 2) {
      const x2 = vertexData[i2];
      const y2 = vertexData[i2 + 1];
      minX = x2 < minX ? x2 : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x2 > maxX ? x2 : maxX;
      maxY = y2 > maxY ? y2 : maxY;
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addVertices(transform, vertices, beginOffset, endOffset) {
    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
  }
  addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX = 0, padY = padX) {
    const a8 = matrix.a;
    const b3 = matrix.b;
    const c3 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    for (let i2 = beginOffset; i2 < endOffset; i2 += 2) {
      const rawX = vertices[i2];
      const rawY = vertices[i2 + 1];
      const x2 = a8 * rawX + c3 * rawY + tx;
      const y2 = d2 * rawY + b3 * rawX + ty;
      minX = Math.min(minX, x2 - padX);
      maxX = Math.max(maxX, x2 + padX);
      minY = Math.min(minY, y2 - padY);
      maxY = Math.max(maxY, y2 + padY);
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addBounds(bounds) {
    const minX = this.minX;
    const minY = this.minY;
    const maxX = this.maxX;
    const maxY = this.maxY;
    this.minX = bounds.minX < minX ? bounds.minX : minX;
    this.minY = bounds.minY < minY ? bounds.minY : minY;
    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
  }
  addBoundsMask(bounds, mask) {
    const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
    const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
    const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
    const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  addBoundsMatrix(bounds, matrix) {
    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
  }
  addBoundsArea(bounds, area2) {
    const _minX = bounds.minX > area2.x ? bounds.minX : area2.x;
    const _minY = bounds.minY > area2.y ? bounds.minY : area2.y;
    const _maxX = bounds.maxX < area2.x + area2.width ? bounds.maxX : area2.x + area2.width;
    const _maxY = bounds.maxY < area2.y + area2.height ? bounds.maxY : area2.y + area2.height;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  pad(paddingX = 0, paddingY = paddingX) {
    if (!this.isEmpty()) {
      this.minX -= paddingX;
      this.maxX += paddingX;
      this.minY -= paddingY;
      this.maxY += paddingY;
    }
  }
  addFramePad(x0, y0, x1, y1, padX, padY) {
    x0 -= padX;
    y0 -= padY;
    x1 += padX;
    y1 += padY;
    this.minX = this.minX < x0 ? this.minX : x0;
    this.maxX = this.maxX > x1 ? this.maxX : x1;
    this.minY = this.minY < y0 ? this.minY : y0;
    this.maxY = this.maxY > y1 ? this.maxY : y1;
  }
}
class DisplayObject extends EventEmitter2 {
  constructor() {
    super();
    this.tempDisplayObjectParent = null;
    this.transform = new Transform();
    this.alpha = 1;
    this.visible = true;
    this.renderable = true;
    this.cullable = false;
    this.cullArea = null;
    this.parent = null;
    this.worldAlpha = 1;
    this._lastSortedIndex = 0;
    this._zIndex = 0;
    this.filterArea = null;
    this.filters = null;
    this._enabledFilters = null;
    this._bounds = new Bounds();
    this._localBounds = null;
    this._boundsID = 0;
    this._boundsRect = null;
    this._localBoundsRect = null;
    this._mask = null;
    this._maskRefCount = 0;
    this._destroyed = false;
    this.isSprite = false;
    this.isMask = false;
  }
  static mixin(source) {
    const keys2 = Object.keys(source);
    for (let i2 = 0; i2 < keys2.length; ++i2) {
      const propertyName = keys2[i2];
      Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
  }
  get destroyed() {
    return this._destroyed;
  }
  _recursivePostUpdateTransform() {
    if (this.parent) {
      this.parent._recursivePostUpdateTransform();
      this.transform.updateTransform(this.parent.transform);
    } else {
      this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }
  }
  updateTransform() {
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
  }
  getBounds(skipUpdate, rect) {
    if (!skipUpdate) {
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.updateTransform();
        this.parent = null;
      } else {
        this._recursivePostUpdateTransform();
        this.updateTransform();
      }
    }
    if (this._bounds.updateID !== this._boundsID) {
      this.calculateBounds();
      this._bounds.updateID = this._boundsID;
    }
    if (!rect) {
      if (!this._boundsRect) {
        this._boundsRect = new Rectangle();
      }
      rect = this._boundsRect;
    }
    return this._bounds.getRectangle(rect);
  }
  getLocalBounds(rect) {
    if (!rect) {
      if (!this._localBoundsRect) {
        this._localBoundsRect = new Rectangle();
      }
      rect = this._localBoundsRect;
    }
    if (!this._localBounds) {
      this._localBounds = new Bounds();
    }
    const transformRef = this.transform;
    const parentRef = this.parent;
    this.parent = null;
    this.transform = this._tempDisplayObjectParent.transform;
    const worldBounds = this._bounds;
    const worldBoundsID = this._boundsID;
    this._bounds = this._localBounds;
    const bounds = this.getBounds(false, rect);
    this.parent = parentRef;
    this.transform = transformRef;
    this._bounds = worldBounds;
    this._bounds.updateID += this._boundsID - worldBoundsID;
    return bounds;
  }
  toGlobal(position, point, skipUpdate = false) {
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.apply(position, point);
  }
  toLocal(position, from2, point, skipUpdate) {
    if (from2) {
      position = from2.toGlobal(position, point, skipUpdate);
    }
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.applyInverse(position, point);
  }
  setParent(container) {
    if (!container || !container.addChild) {
      throw new Error("setParent: Argument must be a Container");
    }
    container.addChild(this);
    return container;
  }
  removeFromParent() {
    var _a;
    (_a = this.parent) == null ? void 0 : _a.removeChild(this);
  }
  setTransform(x2 = 0, y2 = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0) {
    this.position.x = x2;
    this.position.y = y2;
    this.scale.x = !scaleX ? 1 : scaleX;
    this.scale.y = !scaleY ? 1 : scaleY;
    this.rotation = rotation;
    this.skew.x = skewX;
    this.skew.y = skewY;
    this.pivot.x = pivotX;
    this.pivot.y = pivotY;
    return this;
  }
  destroy(_options) {
    this.removeFromParent();
    this._destroyed = true;
    this.transform = null;
    this.parent = null;
    this._bounds = null;
    this.mask = null;
    this.cullArea = null;
    this.filters = null;
    this.filterArea = null;
    this.hitArea = null;
    this.eventMode = "auto";
    this.interactiveChildren = false;
    this.emit("destroyed");
    this.removeAllListeners();
  }
  get _tempDisplayObjectParent() {
    if (this.tempDisplayObjectParent === null) {
      this.tempDisplayObjectParent = new TemporaryDisplayObject();
    }
    return this.tempDisplayObjectParent;
  }
  enableTempParent() {
    const myParent = this.parent;
    this.parent = this._tempDisplayObjectParent;
    return myParent;
  }
  disableTempParent(cacheParent) {
    this.parent = cacheParent;
  }
  get x() {
    return this.position.x;
  }
  set x(value2) {
    this.transform.position.x = value2;
  }
  get y() {
    return this.position.y;
  }
  set y(value2) {
    this.transform.position.y = value2;
  }
  get worldTransform() {
    return this.transform.worldTransform;
  }
  get localTransform() {
    return this.transform.localTransform;
  }
  get position() {
    return this.transform.position;
  }
  set position(value2) {
    this.transform.position.copyFrom(value2);
  }
  get scale() {
    return this.transform.scale;
  }
  set scale(value2) {
    this.transform.scale.copyFrom(value2);
  }
  get pivot() {
    return this.transform.pivot;
  }
  set pivot(value2) {
    this.transform.pivot.copyFrom(value2);
  }
  get skew() {
    return this.transform.skew;
  }
  set skew(value2) {
    this.transform.skew.copyFrom(value2);
  }
  get rotation() {
    return this.transform.rotation;
  }
  set rotation(value2) {
    this.transform.rotation = value2;
  }
  get angle() {
    return this.transform.rotation * RAD_TO_DEG;
  }
  set angle(value2) {
    this.transform.rotation = value2 * DEG_TO_RAD;
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value2) {
    this._zIndex = value2;
    if (this.parent) {
      this.parent.sortDirty = true;
    }
  }
  get worldVisible() {
    let item = this;
    do {
      if (!item.visible) {
        return false;
      }
      item = item.parent;
    } while (item);
    return true;
  }
  get mask() {
    return this._mask;
  }
  set mask(value2) {
    if (this._mask === value2) {
      return;
    }
    if (this._mask) {
      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
      if (maskObject) {
        maskObject._maskRefCount--;
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = true;
          maskObject.isMask = false;
        }
      }
    }
    this._mask = value2;
    if (this._mask) {
      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
      if (maskObject) {
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = false;
          maskObject.isMask = true;
        }
        maskObject._maskRefCount++;
      }
    }
  }
}
class TemporaryDisplayObject extends DisplayObject {
  constructor() {
    super(...arguments);
    this.sortDirty = null;
  }
}
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
const tempMatrix = new Matrix();
function sortChildren(a8, b3) {
  if (a8.zIndex === b3.zIndex) {
    return a8._lastSortedIndex - b3._lastSortedIndex;
  }
  return a8.zIndex - b3.zIndex;
}
const _Container = class extends DisplayObject {
  constructor() {
    super();
    this.children = [];
    this.sortableChildren = _Container.defaultSortableChildren;
    this.sortDirty = false;
  }
  onChildrenChange(_length) {
  }
  addChild(...children) {
    if (children.length > 1) {
      for (let i2 = 0; i2 < children.length; i2++) {
        this.addChild(children[i2]);
      }
    } else {
      const child = children[0];
      if (child.parent) {
        child.parent.removeChild(child);
      }
      child.parent = this;
      this.sortDirty = true;
      child.transform._parentID = -1;
      this.children.push(child);
      this._boundsID++;
      this.onChildrenChange(this.children.length - 1);
      this.emit("childAdded", child, this, this.children.length - 1);
      child.emit("added", this);
    }
    return children[0];
  }
  addChildAt(child, index2) {
    if (index2 < 0 || index2 > this.children.length) {
      throw new Error(`${child}addChildAt: The index ${index2} supplied is out of bounds ${this.children.length}`);
    }
    if (child.parent) {
      child.parent.removeChild(child);
    }
    child.parent = this;
    this.sortDirty = true;
    child.transform._parentID = -1;
    this.children.splice(index2, 0, child);
    this._boundsID++;
    this.onChildrenChange(index2);
    child.emit("added", this);
    this.emit("childAdded", child, this, index2);
    return child;
  }
  swapChildren(child, child2) {
    if (child === child2) {
      return;
    }
    const index1 = this.getChildIndex(child);
    const index2 = this.getChildIndex(child2);
    this.children[index1] = child2;
    this.children[index2] = child;
    this.onChildrenChange(index1 < index2 ? index1 : index2);
  }
  getChildIndex(child) {
    const index2 = this.children.indexOf(child);
    if (index2 === -1) {
      throw new Error("The supplied DisplayObject must be a child of the caller");
    }
    return index2;
  }
  setChildIndex(child, index$1) {
    if (index$1 < 0 || index$1 >= this.children.length) {
      throw new Error(`The index ${index$1} supplied is out of bounds ${this.children.length}`);
    }
    const currentIndex = this.getChildIndex(child);
    removeItems(this.children, currentIndex, 1);
    this.children.splice(index$1, 0, child);
    this.onChildrenChange(index$1);
  }
  getChildAt(index2) {
    if (index2 < 0 || index2 >= this.children.length) {
      throw new Error(`getChildAt: Index (${index2}) does not exist.`);
    }
    return this.children[index2];
  }
  removeChild(...children) {
    if (children.length > 1) {
      for (let i2 = 0; i2 < children.length; i2++) {
        this.removeChild(children[i2]);
      }
    } else {
      const child = children[0];
      const index$1 = this.children.indexOf(child);
      if (index$1 === -1)
        return null;
      child.parent = null;
      child.transform._parentID = -1;
      removeItems(this.children, index$1, 1);
      this._boundsID++;
      this.onChildrenChange(index$1);
      child.emit("removed", this);
      this.emit("childRemoved", child, this, index$1);
    }
    return children[0];
  }
  removeChildAt(index$1) {
    const child = this.getChildAt(index$1);
    child.parent = null;
    child.transform._parentID = -1;
    removeItems(this.children, index$1, 1);
    this._boundsID++;
    this.onChildrenChange(index$1);
    child.emit("removed", this);
    this.emit("childRemoved", child, this, index$1);
    return child;
  }
  removeChildren(beginIndex = 0, endIndex = this.children.length) {
    const begin = beginIndex;
    const end = endIndex;
    const range = end - begin;
    let removed;
    if (range > 0 && range <= end) {
      removed = this.children.splice(begin, range);
      for (let i2 = 0; i2 < removed.length; ++i2) {
        removed[i2].parent = null;
        if (removed[i2].transform) {
          removed[i2].transform._parentID = -1;
        }
      }
      this._boundsID++;
      this.onChildrenChange(beginIndex);
      for (let i2 = 0; i2 < removed.length; ++i2) {
        removed[i2].emit("removed", this);
        this.emit("childRemoved", removed[i2], this, i2);
      }
      return removed;
    } else if (range === 0 && this.children.length === 0) {
      return [];
    }
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  }
  sortChildren() {
    let sortRequired = false;
    for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
      const child = this.children[i2];
      child._lastSortedIndex = i2;
      if (!sortRequired && child.zIndex !== 0) {
        sortRequired = true;
      }
    }
    if (sortRequired && this.children.length > 1) {
      this.children.sort(sortChildren);
    }
    this.sortDirty = false;
  }
  updateTransform() {
    if (this.sortableChildren && this.sortDirty) {
      this.sortChildren();
    }
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
    for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
      const child = this.children[i2];
      if (child.visible) {
        child.updateTransform();
      }
    }
  }
  calculateBounds() {
    this._bounds.clear();
    this._calculateBounds();
    for (let i2 = 0; i2 < this.children.length; i2++) {
      const child = this.children[i2];
      if (!child.visible || !child.renderable) {
        continue;
      }
      child.calculateBounds();
      if (child._mask) {
        const maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;
        if (maskObject) {
          maskObject.calculateBounds();
          this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
        } else {
          this._bounds.addBounds(child._bounds);
        }
      } else if (child.filterArea) {
        this._bounds.addBoundsArea(child._bounds, child.filterArea);
      } else {
        this._bounds.addBounds(child._bounds);
      }
    }
    this._bounds.updateID = this._boundsID;
  }
  getLocalBounds(rect, skipChildrenUpdate = false) {
    const result = super.getLocalBounds(rect);
    if (!skipChildrenUpdate) {
      for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
        const child = this.children[i2];
        if (child.visible) {
          child.updateTransform();
        }
      }
    }
    return result;
  }
  _calculateBounds() {
  }
  _renderWithCulling(renderer2) {
    const sourceFrame = renderer2.renderTexture.sourceFrame;
    if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {
      return;
    }
    let bounds;
    let transform;
    if (this.cullArea) {
      bounds = this.cullArea;
      transform = this.worldTransform;
    } else if (this._render !== _Container.prototype._render) {
      bounds = this.getBounds(true);
    }
    const projectionTransform = renderer2.projection.transform;
    if (projectionTransform) {
      if (transform) {
        transform = tempMatrix.copyFrom(transform);
        transform.prepend(projectionTransform);
      } else {
        transform = projectionTransform;
      }
    }
    if (bounds && sourceFrame.intersects(bounds, transform)) {
      this._render(renderer2);
    } else if (this.cullArea) {
      return;
    }
    for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
      const child = this.children[i2];
      const childCullable = child.cullable;
      child.cullable = childCullable || !this.cullArea;
      child.render(renderer2);
      child.cullable = childCullable;
    }
  }
  render(renderer2) {
    var _a;
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    if (this._mask || ((_a = this.filters) == null ? void 0 : _a.length)) {
      this.renderAdvanced(renderer2);
    } else if (this.cullable) {
      this._renderWithCulling(renderer2);
    } else {
      this._render(renderer2);
      for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
        this.children[i2].render(renderer2);
      }
    }
  }
  renderAdvanced(renderer2) {
    var _a, _b, _c;
    const filters2 = this.filters;
    const mask = this._mask;
    if (filters2) {
      if (!this._enabledFilters) {
        this._enabledFilters = [];
      }
      this._enabledFilters.length = 0;
      for (let i2 = 0; i2 < filters2.length; i2++) {
        if (filters2[i2].enabled) {
          this._enabledFilters.push(filters2[i2]);
        }
      }
    }
    const flush = filters2 && ((_a = this._enabledFilters) == null ? void 0 : _a.length) || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES.NONE));
    if (flush) {
      renderer2.batch.flush();
    }
    if (filters2 && ((_b = this._enabledFilters) == null ? void 0 : _b.length)) {
      renderer2.filter.push(this, this._enabledFilters);
    }
    if (mask) {
      renderer2.mask.push(this, this._mask);
    }
    if (this.cullable) {
      this._renderWithCulling(renderer2);
    } else {
      this._render(renderer2);
      for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
        this.children[i2].render(renderer2);
      }
    }
    if (flush) {
      renderer2.batch.flush();
    }
    if (mask) {
      renderer2.mask.pop(this);
    }
    if (filters2 && ((_c = this._enabledFilters) == null ? void 0 : _c.length)) {
      renderer2.filter.pop();
    }
  }
  _render(_renderer) {
  }
  destroy(options) {
    super.destroy();
    this.sortDirty = false;
    const destroyChildren = typeof options === "boolean" ? options : options == null ? void 0 : options.children;
    const oldChildren = this.removeChildren(0, this.children.length);
    if (destroyChildren) {
      for (let i2 = 0; i2 < oldChildren.length; ++i2) {
        oldChildren[i2].destroy(options);
      }
    }
  }
  get width() {
    return this.scale.x * this.getLocalBounds().width;
  }
  set width(value2) {
    const width = this.getLocalBounds().width;
    if (width !== 0) {
      this.scale.x = value2 / width;
    } else {
      this.scale.x = 1;
    }
    this._width = value2;
  }
  get height() {
    return this.scale.y * this.getLocalBounds().height;
  }
  set height(value2) {
    const height = this.getLocalBounds().height;
    if (height !== 0) {
      this.scale.y = value2 / height;
    } else {
      this.scale.y = 1;
    }
    this._height = value2;
  }
};
let Container = _Container;
Container.defaultSortableChildren = false;
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
Object.defineProperties(settings, {
  SORTABLE_CHILDREN: {
    get() {
      return Container.defaultSortableChildren;
    },
    set(value2) {
      deprecation("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren");
      Container.defaultSortableChildren = value2;
    }
  }
});
const tempPoint$2 = new Point();
const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
class Sprite extends Container {
  constructor(texture) {
    super();
    this._anchor = new ObservablePoint(this._onAnchorUpdate, this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
    this._texture = null;
    this._width = 0;
    this._height = 0;
    this._tintColor = new Color(16777215);
    this._tintRGB = null;
    this.tint = 16777215;
    this.blendMode = BLEND_MODES.NORMAL;
    this._cachedTint = 16777215;
    this.uvs = null;
    this.texture = texture || Texture.EMPTY;
    this.vertexData = new Float32Array(8);
    this.vertexTrimmedData = null;
    this._transformID = -1;
    this._textureID = -1;
    this._transformTrimmedID = -1;
    this._textureTrimmedID = -1;
    this.indices = indices;
    this.pluginName = "batch";
    this.isSprite = true;
    this._roundPixels = settings.ROUND_PIXELS;
  }
  _onTextureUpdate() {
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    if (this._width) {
      this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width;
    }
    if (this._height) {
      this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height;
    }
  }
  _onAnchorUpdate() {
    this._transformID = -1;
    this._transformTrimmedID = -1;
  }
  calculateVertices() {
    const texture = this._texture;
    if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
      return;
    }
    if (this._textureID !== texture._updateID) {
      this.uvs = this._texture._uvs.uvsFloat32;
    }
    this._transformID = this.transform._worldID;
    this._textureID = texture._updateID;
    const wt = this.transform.worldTransform;
    const a8 = wt.a;
    const b3 = wt.b;
    const c3 = wt.c;
    const d2 = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const vertexData = this.vertexData;
    const trim = texture.trim;
    const orig = texture.orig;
    const anchor = this._anchor;
    let w0 = 0;
    let w1 = 0;
    let h0 = 0;
    let h1 = 0;
    if (trim) {
      w1 = trim.x - anchor._x * orig.width;
      w0 = w1 + trim.width;
      h1 = trim.y - anchor._y * orig.height;
      h0 = h1 + trim.height;
    } else {
      w1 = -anchor._x * orig.width;
      w0 = w1 + orig.width;
      h1 = -anchor._y * orig.height;
      h0 = h1 + orig.height;
    }
    vertexData[0] = a8 * w1 + c3 * h1 + tx;
    vertexData[1] = d2 * h1 + b3 * w1 + ty;
    vertexData[2] = a8 * w0 + c3 * h1 + tx;
    vertexData[3] = d2 * h1 + b3 * w0 + ty;
    vertexData[4] = a8 * w0 + c3 * h0 + tx;
    vertexData[5] = d2 * h0 + b3 * w0 + ty;
    vertexData[6] = a8 * w1 + c3 * h0 + tx;
    vertexData[7] = d2 * h0 + b3 * w1 + ty;
    if (this._roundPixels) {
      const resolution = settings.RESOLUTION;
      for (let i2 = 0; i2 < vertexData.length; ++i2) {
        vertexData[i2] = Math.round(vertexData[i2] * resolution) / resolution;
      }
    }
  }
  calculateTrimmedVertices() {
    if (!this.vertexTrimmedData) {
      this.vertexTrimmedData = new Float32Array(8);
    } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
      return;
    }
    this._transformTrimmedID = this.transform._worldID;
    this._textureTrimmedID = this._texture._updateID;
    const texture = this._texture;
    const vertexData = this.vertexTrimmedData;
    const orig = texture.orig;
    const anchor = this._anchor;
    const wt = this.transform.worldTransform;
    const a8 = wt.a;
    const b3 = wt.b;
    const c3 = wt.c;
    const d2 = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const w1 = -anchor._x * orig.width;
    const w0 = w1 + orig.width;
    const h1 = -anchor._y * orig.height;
    const h0 = h1 + orig.height;
    vertexData[0] = a8 * w1 + c3 * h1 + tx;
    vertexData[1] = d2 * h1 + b3 * w1 + ty;
    vertexData[2] = a8 * w0 + c3 * h1 + tx;
    vertexData[3] = d2 * h1 + b3 * w0 + ty;
    vertexData[4] = a8 * w0 + c3 * h0 + tx;
    vertexData[5] = d2 * h0 + b3 * w0 + ty;
    vertexData[6] = a8 * w1 + c3 * h0 + tx;
    vertexData[7] = d2 * h0 + b3 * w1 + ty;
  }
  _render(renderer2) {
    this.calculateVertices();
    renderer2.batch.setObjectRenderer(renderer2.plugins[this.pluginName]);
    renderer2.plugins[this.pluginName].render(this);
  }
  _calculateBounds() {
    const trim = this._texture.trim;
    const orig = this._texture.orig;
    if (!trim || trim.width === orig.width && trim.height === orig.height) {
      this.calculateVertices();
      this._bounds.addQuad(this.vertexData);
    } else {
      this.calculateTrimmedVertices();
      this._bounds.addQuad(this.vertexTrimmedData);
    }
  }
  getLocalBounds(rect) {
    if (this.children.length === 0) {
      if (!this._localBounds) {
        this._localBounds = new Bounds();
      }
      this._localBounds.minX = this._texture.orig.width * -this._anchor._x;
      this._localBounds.minY = this._texture.orig.height * -this._anchor._y;
      this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
      this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._localBounds.getRectangle(rect);
    }
    return super.getLocalBounds.call(this, rect);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, tempPoint$2);
    const width = this._texture.orig.width;
    const height = this._texture.orig.height;
    const x1 = -width * this.anchor.x;
    let y1 = 0;
    if (tempPoint$2.x >= x1 && tempPoint$2.x < x1 + width) {
      y1 = -height * this.anchor.y;
      if (tempPoint$2.y >= y1 && tempPoint$2.y < y1 + height) {
        return true;
      }
    }
    return false;
  }
  destroy(options) {
    super.destroy(options);
    this._texture.off("update", this._onTextureUpdate, this);
    this._anchor = null;
    const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
    if (destroyTexture) {
      const destroyBaseTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.baseTexture;
      this._texture.destroy(!!destroyBaseTexture);
    }
    this._texture = null;
  }
  static from(source, options) {
    const texture = source instanceof Texture ? source : Texture.from(source, options);
    return new Sprite(texture);
  }
  set roundPixels(value2) {
    if (this._roundPixels !== value2) {
      this._transformID = -1;
    }
    this._roundPixels = value2;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value2) {
    const s2 = sign(this.scale.x) || 1;
    this.scale.x = s2 * value2 / this._texture.orig.width;
    this._width = value2;
  }
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value2) {
    const s2 = sign(this.scale.y) || 1;
    this.scale.y = s2 * value2 / this._texture.orig.height;
    this._height = value2;
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(value2) {
    this._anchor.copyFrom(value2);
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value2) {
    this._tintColor.setValue(value2);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
  }
  get tintValue() {
    return this._tintColor.toNumber();
  }
  get texture() {
    return this._texture;
  }
  set texture(value2) {
    if (this._texture === value2) {
      return;
    }
    if (this._texture) {
      this._texture.off("update", this._onTextureUpdate, this);
    }
    this._texture = value2 || Texture.EMPTY;
    this._cachedTint = 16777215;
    this._textureID = -1;
    this._textureTrimmedID = -1;
    if (value2) {
      if (value2.baseTexture.valid) {
        this._onTextureUpdate();
      } else {
        value2.once("update", this._onTextureUpdate, this);
      }
    }
  }
}
const _tempMatrix = new Matrix();
DisplayObject.prototype._cacheAsBitmap = false;
DisplayObject.prototype._cacheData = null;
DisplayObject.prototype._cacheAsBitmapResolution = null;
DisplayObject.prototype._cacheAsBitmapMultisample = null;
class CacheData {
  constructor() {
    this.textureCacheId = null;
    this.originalRender = null;
    this.originalRenderCanvas = null;
    this.originalCalculateBounds = null;
    this.originalGetLocalBounds = null;
    this.originalUpdateTransform = null;
    this.originalDestroy = null;
    this.originalMask = null;
    this.originalFilterArea = null;
    this.originalContainsPoint = null;
    this.sprite = null;
  }
}
Object.defineProperties(DisplayObject.prototype, {
  cacheAsBitmapResolution: {
    get() {
      return this._cacheAsBitmapResolution;
    },
    set(resolution) {
      if (resolution === this._cacheAsBitmapResolution) {
        return;
      }
      this._cacheAsBitmapResolution = resolution;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmapMultisample: {
    get() {
      return this._cacheAsBitmapMultisample;
    },
    set(multisample) {
      if (multisample === this._cacheAsBitmapMultisample) {
        return;
      }
      this._cacheAsBitmapMultisample = multisample;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmap: {
    get() {
      return this._cacheAsBitmap;
    },
    set(value2) {
      if (this._cacheAsBitmap === value2) {
        return;
      }
      this._cacheAsBitmap = value2;
      let data;
      if (value2) {
        if (!this._cacheData) {
          this._cacheData = new CacheData();
        }
        data = this._cacheData;
        data.originalRender = this.render;
        data.originalRenderCanvas = this.renderCanvas;
        data.originalUpdateTransform = this.updateTransform;
        data.originalCalculateBounds = this.calculateBounds;
        data.originalGetLocalBounds = this.getLocalBounds;
        data.originalDestroy = this.destroy;
        data.originalContainsPoint = this.containsPoint;
        data.originalMask = this._mask;
        data.originalFilterArea = this.filterArea;
        this.render = this._renderCached;
        this.renderCanvas = this._renderCachedCanvas;
        this.destroy = this._cacheAsBitmapDestroy;
      } else {
        data = this._cacheData;
        if (data.sprite) {
          this._destroyCachedDisplayObject();
        }
        this.render = data.originalRender;
        this.renderCanvas = data.originalRenderCanvas;
        this.calculateBounds = data.originalCalculateBounds;
        this.getLocalBounds = data.originalGetLocalBounds;
        this.destroy = data.originalDestroy;
        this.updateTransform = data.originalUpdateTransform;
        this.containsPoint = data.originalContainsPoint;
        this._mask = data.originalMask;
        this.filterArea = data.originalFilterArea;
      }
    }
  }
});
DisplayObject.prototype._renderCached = function _renderCached(renderer2) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObject(renderer2);
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._render(renderer2);
};
DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer2) {
  var _a, _b;
  if ((_a = this._cacheData) == null ? void 0 : _a.sprite) {
    return;
  }
  const cacheAlpha = this.alpha;
  this.alpha = 1;
  renderer2.batch.flush();
  const bounds = this.getLocalBounds(null, true).clone();
  if ((_b = this.filters) == null ? void 0 : _b.length) {
    const padding = this.filters[0].padding;
    bounds.pad(padding);
  }
  bounds.ceil(settings.RESOLUTION);
  const cachedRenderTexture = renderer2.renderTexture.current;
  const cachedSourceFrame = renderer2.renderTexture.sourceFrame.clone();
  const cachedDestinationFrame = renderer2.renderTexture.destinationFrame.clone();
  const cachedProjectionTransform = renderer2.projection.transform;
  const renderTexture = RenderTexture.create({
    width: bounds.width,
    height: bounds.height,
    resolution: this.cacheAsBitmapResolution || renderer2.resolution,
    multisample: this.cacheAsBitmapMultisample ?? renderer2.multisample
  });
  const textureCacheId = `cacheAsBitmap_${uid$2()}`;
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  const m2 = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
  this.render = this._cacheData.originalRender;
  renderer2.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false });
  renderer2.framebuffer.blit();
  renderer2.projection.transform = cachedProjectionTransform;
  renderer2.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
  this.render = this._renderCached;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  const cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.enableTempParent();
    this.updateTransform();
    this.disableTempParent(null);
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer2) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObjectCanvas(renderer2);
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._renderCanvas(renderer2);
};
DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer2) {
  var _a;
  if ((_a = this._cacheData) == null ? void 0 : _a.sprite) {
    return;
  }
  const bounds = this.getLocalBounds(null, true);
  const cacheAlpha = this.alpha;
  this.alpha = 1;
  const cachedRenderTarget = renderer2.canvasContext.activeContext;
  const cachedProjectionTransform = renderer2._projTransform;
  bounds.ceil(settings.RESOLUTION);
  const renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });
  const textureCacheId = `cacheAsBitmap_${uid$2()}`;
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  const m2 = _tempMatrix;
  this.transform.localTransform.copyTo(m2);
  m2.invert();
  m2.tx -= bounds.x;
  m2.ty -= bounds.y;
  this.renderCanvas = this._cacheData.originalRenderCanvas;
  renderer2.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false });
  renderer2.canvasContext.activeContext = cachedRenderTarget;
  renderer2._projTransform = cachedProjectionTransform;
  this.renderCanvas = this._renderCachedCanvas;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  const cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.parent = renderer2._tempDisplayObjectParent;
    this.updateTransform();
    this.parent = null;
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
  this._bounds.clear();
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite._calculateBounds();
  this._bounds.updateID = this._boundsID;
};
DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
  return this._cacheData.sprite.getLocalBounds(null);
};
DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
  this._cacheData.sprite._texture.destroy(true);
  this._cacheData.sprite = null;
  BaseTexture.removeFromCache(this._cacheData.textureCacheId);
  Texture.removeFromCache(this._cacheData.textureCacheId);
  this._cacheData.textureCacheId = null;
};
DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
  this.cacheAsBitmap = false;
  this.destroy(options);
};
DisplayObject.prototype.name = null;
Container.prototype.getChildByName = function getChildByName(name, deep) {
  for (let i2 = 0, j2 = this.children.length; i2 < j2; i2++) {
    if (this.children[i2].name === name) {
      return this.children[i2];
    }
  }
  if (deep) {
    for (let i2 = 0, j2 = this.children.length; i2 < j2; i2++) {
      const child = this.children[i2];
      if (!child.getChildByName) {
        continue;
      }
      const target = child.getChildByName(name, true);
      if (target) {
        return target;
      }
    }
  }
  return null;
};
DisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point = new Point(), skipUpdate = false) {
  if (this.parent) {
    this.parent.toGlobal(this.position, point, skipUpdate);
  } else {
    point.x = this.position.x;
    point.y = this.position.y;
  }
  return point;
};
var fragment$6 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";
class AlphaFilter extends Filter {
  constructor(alpha = 1) {
    super(defaultVertex, fragment$6, { uAlpha: 1 });
    this.alpha = alpha;
  }
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value2) {
    this.uniforms.uAlpha = value2;
  }
}
const GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
};
const fragTemplate = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join("\n");
function generateBlurFragSource(kernelSize) {
  const kernel = GAUSSIAN_VALUES[kernelSize];
  const halfLength = kernel.length;
  let fragSource = fragTemplate;
  let blurLoop = "";
  const template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
  let value2;
  for (let i2 = 0; i2 < kernelSize; i2++) {
    let blur = template.replace("%index%", i2.toString());
    value2 = i2;
    if (i2 >= halfLength) {
      value2 = kernelSize - i2 - 1;
    }
    blur = blur.replace("%value%", kernel[value2].toString());
    blurLoop += blur;
    blurLoop += "\n";
  }
  fragSource = fragSource.replace("%blur%", blurLoop);
  fragSource = fragSource.replace("%size%", kernelSize.toString());
  return fragSource;
}
const vertTemplate = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function generateBlurVertSource(kernelSize, x2) {
  const halfLength = Math.ceil(kernelSize / 2);
  let vertSource = vertTemplate;
  let blurLoop = "";
  let template;
  if (x2) {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";
  } else {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  }
  for (let i2 = 0; i2 < kernelSize; i2++) {
    let blur = template.replace("%index%", i2.toString());
    blur = blur.replace("%sampleIndex%", `${i2 - (halfLength - 1)}.0`);
    blurLoop += blur;
    blurLoop += "\n";
  }
  vertSource = vertSource.replace("%blur%", blurLoop);
  vertSource = vertSource.replace("%size%", kernelSize.toString());
  return vertSource;
}
class BlurFilterPass extends Filter {
  constructor(horizontal, strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {
    const vertSrc = generateBlurVertSource(kernelSize, horizontal);
    const fragSrc = generateBlurFragSource(kernelSize);
    super(vertSrc, fragSrc);
    this.horizontal = horizontal;
    this.resolution = resolution;
    this._quality = 0;
    this.quality = quality;
    this.blur = strength;
  }
  apply(filterManager, input, output, clearMode) {
    if (output) {
      if (this.horizontal) {
        this.uniforms.strength = 1 / output.width * (output.width / input.width);
      } else {
        this.uniforms.strength = 1 / output.height * (output.height / input.height);
      }
    } else {
      if (this.horizontal) {
        this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);
      } else {
        this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);
      }
    }
    this.uniforms.strength *= this.strength;
    this.uniforms.strength /= this.passes;
    if (this.passes === 1) {
      filterManager.applyFilter(this, input, output, clearMode);
    } else {
      const renderTarget = filterManager.getFilterTexture();
      const renderer2 = filterManager.renderer;
      let flip = input;
      let flop = renderTarget;
      this.state.blend = false;
      filterManager.applyFilter(this, flip, flop, CLEAR_MODES.CLEAR);
      for (let i2 = 1; i2 < this.passes - 1; i2++) {
        filterManager.bindAndClear(flip, CLEAR_MODES.BLIT);
        this.uniforms.uSampler = flop;
        const temp = flop;
        flop = flip;
        flip = temp;
        renderer2.shader.bind(this);
        renderer2.geometry.draw(5);
      }
      this.state.blend = true;
      filterManager.applyFilter(this, flop, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    }
  }
  get blur() {
    return this.strength;
  }
  set blur(value2) {
    this.padding = 1 + Math.abs(value2) * 2;
    this.strength = value2;
  }
  get quality() {
    return this._quality;
  }
  set quality(value2) {
    this._quality = value2;
    this.passes = value2;
  }
}
class BlurFilter extends Filter {
  constructor(strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {
    super();
    this._repeatEdgePixels = false;
    this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);
    this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);
    this.resolution = resolution;
    this.quality = quality;
    this.blur = strength;
    this.repeatEdgePixels = false;
  }
  apply(filterManager, input, output, clearMode) {
    const xStrength = Math.abs(this.blurXFilter.strength);
    const yStrength = Math.abs(this.blurYFilter.strength);
    if (xStrength && yStrength) {
      const renderTarget = filterManager.getFilterTexture();
      this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES.CLEAR);
      this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    } else if (yStrength) {
      this.blurYFilter.apply(filterManager, input, output, clearMode);
    } else {
      this.blurXFilter.apply(filterManager, input, output, clearMode);
    }
  }
  updatePadding() {
    if (this._repeatEdgePixels) {
      this.padding = 0;
    } else {
      this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
    }
  }
  get blur() {
    return this.blurXFilter.blur;
  }
  set blur(value2) {
    this.blurXFilter.blur = this.blurYFilter.blur = value2;
    this.updatePadding();
  }
  get quality() {
    return this.blurXFilter.quality;
  }
  set quality(value2) {
    this.blurXFilter.quality = this.blurYFilter.quality = value2;
  }
  get blurX() {
    return this.blurXFilter.blur;
  }
  set blurX(value2) {
    this.blurXFilter.blur = value2;
    this.updatePadding();
  }
  get blurY() {
    return this.blurYFilter.blur;
  }
  set blurY(value2) {
    this.blurYFilter.blur = value2;
    this.updatePadding();
  }
  get blendMode() {
    return this.blurYFilter.blendMode;
  }
  set blendMode(value2) {
    this.blurYFilter.blendMode = value2;
  }
  get repeatEdgePixels() {
    return this._repeatEdgePixels;
  }
  set repeatEdgePixels(value2) {
    this._repeatEdgePixels = value2;
    this.updatePadding();
  }
}
var fragment$5 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";
class ColorMatrixFilter extends Filter {
  constructor() {
    const uniforms = {
      m: new Float32Array([
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]),
      uAlpha: 1
    };
    super(defaultFilterVertex, fragment$5, uniforms);
    this.alpha = 1;
  }
  _loadMatrix(matrix, multiply = false) {
    let newMatrix = matrix;
    if (multiply) {
      this._multiply(newMatrix, this.uniforms.m, matrix);
      newMatrix = this._colorMatrix(newMatrix);
    }
    this.uniforms.m = newMatrix;
  }
  _multiply(out, a8, b3) {
    out[0] = a8[0] * b3[0] + a8[1] * b3[5] + a8[2] * b3[10] + a8[3] * b3[15];
    out[1] = a8[0] * b3[1] + a8[1] * b3[6] + a8[2] * b3[11] + a8[3] * b3[16];
    out[2] = a8[0] * b3[2] + a8[1] * b3[7] + a8[2] * b3[12] + a8[3] * b3[17];
    out[3] = a8[0] * b3[3] + a8[1] * b3[8] + a8[2] * b3[13] + a8[3] * b3[18];
    out[4] = a8[0] * b3[4] + a8[1] * b3[9] + a8[2] * b3[14] + a8[3] * b3[19] + a8[4];
    out[5] = a8[5] * b3[0] + a8[6] * b3[5] + a8[7] * b3[10] + a8[8] * b3[15];
    out[6] = a8[5] * b3[1] + a8[6] * b3[6] + a8[7] * b3[11] + a8[8] * b3[16];
    out[7] = a8[5] * b3[2] + a8[6] * b3[7] + a8[7] * b3[12] + a8[8] * b3[17];
    out[8] = a8[5] * b3[3] + a8[6] * b3[8] + a8[7] * b3[13] + a8[8] * b3[18];
    out[9] = a8[5] * b3[4] + a8[6] * b3[9] + a8[7] * b3[14] + a8[8] * b3[19] + a8[9];
    out[10] = a8[10] * b3[0] + a8[11] * b3[5] + a8[12] * b3[10] + a8[13] * b3[15];
    out[11] = a8[10] * b3[1] + a8[11] * b3[6] + a8[12] * b3[11] + a8[13] * b3[16];
    out[12] = a8[10] * b3[2] + a8[11] * b3[7] + a8[12] * b3[12] + a8[13] * b3[17];
    out[13] = a8[10] * b3[3] + a8[11] * b3[8] + a8[12] * b3[13] + a8[13] * b3[18];
    out[14] = a8[10] * b3[4] + a8[11] * b3[9] + a8[12] * b3[14] + a8[13] * b3[19] + a8[14];
    out[15] = a8[15] * b3[0] + a8[16] * b3[5] + a8[17] * b3[10] + a8[18] * b3[15];
    out[16] = a8[15] * b3[1] + a8[16] * b3[6] + a8[17] * b3[11] + a8[18] * b3[16];
    out[17] = a8[15] * b3[2] + a8[16] * b3[7] + a8[17] * b3[12] + a8[18] * b3[17];
    out[18] = a8[15] * b3[3] + a8[16] * b3[8] + a8[17] * b3[13] + a8[18] * b3[18];
    out[19] = a8[15] * b3[4] + a8[16] * b3[9] + a8[17] * b3[14] + a8[18] * b3[19] + a8[19];
    return out;
  }
  _colorMatrix(matrix) {
    const m2 = new Float32Array(matrix);
    m2[4] /= 255;
    m2[9] /= 255;
    m2[14] /= 255;
    m2[19] /= 255;
    return m2;
  }
  brightness(b3, multiply) {
    const matrix = [
      b3,
      0,
      0,
      0,
      0,
      0,
      b3,
      0,
      0,
      0,
      0,
      0,
      b3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  tint(color, multiply) {
    const [r2, g2, b3] = Color.shared.setValue(color).toArray();
    const matrix = [
      r2,
      0,
      0,
      0,
      0,
      0,
      g2,
      0,
      0,
      0,
      0,
      0,
      b3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  greyscale(scale, multiply) {
    const matrix = [
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  blackAndWhite(multiply) {
    const matrix = [
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  hue(rotation, multiply) {
    rotation = (rotation || 0) / 180 * Math.PI;
    const cosR = Math.cos(rotation);
    const sinR = Math.sin(rotation);
    const sqrt = Math.sqrt;
    const w2 = 1 / 3;
    const sqrW = sqrt(w2);
    const a00 = cosR + (1 - cosR) * w2;
    const a01 = w2 * (1 - cosR) - sqrW * sinR;
    const a02 = w2 * (1 - cosR) + sqrW * sinR;
    const a10 = w2 * (1 - cosR) + sqrW * sinR;
    const a11 = cosR + w2 * (1 - cosR);
    const a12 = w2 * (1 - cosR) - sqrW * sinR;
    const a20 = w2 * (1 - cosR) - sqrW * sinR;
    const a21 = w2 * (1 - cosR) + sqrW * sinR;
    const a222 = cosR + w2 * (1 - cosR);
    const matrix = [
      a00,
      a01,
      a02,
      0,
      0,
      a10,
      a11,
      a12,
      0,
      0,
      a20,
      a21,
      a222,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  contrast(amount, multiply) {
    const v2 = (amount || 0) + 1;
    const o2 = -0.5 * (v2 - 1);
    const matrix = [
      v2,
      0,
      0,
      0,
      o2,
      0,
      v2,
      0,
      0,
      o2,
      0,
      0,
      v2,
      0,
      o2,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  saturate(amount = 0, multiply) {
    const x2 = amount * 2 / 3 + 1;
    const y2 = (x2 - 1) * -0.5;
    const matrix = [
      x2,
      y2,
      y2,
      0,
      0,
      y2,
      x2,
      y2,
      0,
      0,
      y2,
      y2,
      x2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  desaturate() {
    this.saturate(-1);
  }
  negative(multiply) {
    const matrix = [
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  sepia(multiply) {
    const matrix = [
      0.393,
      0.7689999,
      0.18899999,
      0,
      0,
      0.349,
      0.6859999,
      0.16799999,
      0,
      0,
      0.272,
      0.5339999,
      0.13099999,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  technicolor(multiply) {
    const matrix = [
      1.9125277891456083,
      -0.8545344976951645,
      -0.09155508482755585,
      0,
      11.793603434377337,
      -0.3087833385928097,
      1.7658908555458428,
      -0.10601743074722245,
      0,
      -70.35205161461398,
      -0.231103377548616,
      -0.7501899197440212,
      1.847597816108189,
      0,
      30.950940869491138,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  polaroid(multiply) {
    const matrix = [
      1.438,
      -0.062,
      -0.062,
      0,
      0,
      -0.122,
      1.378,
      -0.122,
      0,
      0,
      -0.016,
      -0.016,
      1.483,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  toBGR(multiply) {
    const matrix = [
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  kodachrome(multiply) {
    const matrix = [
      1.1285582396593525,
      -0.3967382283601348,
      -0.03992559172921793,
      0,
      63.72958762196502,
      -0.16404339962244616,
      1.0835251566291304,
      -0.05498805115633132,
      0,
      24.732407896706203,
      -0.16786010706155763,
      -0.5603416277695248,
      1.6014850761964943,
      0,
      35.62982807460946,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  browni(multiply) {
    const matrix = [
      0.5997023498159715,
      0.34553243048391263,
      -0.2708298674538042,
      0,
      47.43192855600873,
      -0.037703249837783157,
      0.8609577587992641,
      0.15059552388459913,
      0,
      -36.96841498319127,
      0.24113635128153335,
      -0.07441037908422492,
      0.44972182064877153,
      0,
      -7.562075277591283,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  vintage(multiply) {
    const matrix = [
      0.6279345635605994,
      0.3202183420819367,
      -0.03965408211312453,
      0,
      9.651285835294123,
      0.02578397704808868,
      0.6441188644374771,
      0.03259127616149294,
      0,
      7.462829176470591,
      0.0466055556782719,
      -0.0851232987247891,
      0.5241648018700465,
      0,
      5.159190588235296,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  colorTone(desaturation, toned, lightColor, darkColor, multiply) {
    desaturation = desaturation || 0.2;
    toned = toned || 0.15;
    lightColor = lightColor || 16770432;
    darkColor = darkColor || 3375104;
    const temp = Color.shared;
    const [lR, lG, lB] = temp.setValue(lightColor).toArray();
    const [dR, dG, dB] = temp.setValue(darkColor).toArray();
    const matrix = [
      0.3,
      0.59,
      0.11,
      0,
      0,
      lR,
      lG,
      lB,
      desaturation,
      0,
      dR,
      dG,
      dB,
      toned,
      0,
      lR - dR,
      lG - dG,
      lB - dB,
      0,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  night(intensity, multiply) {
    intensity = intensity || 0.1;
    const matrix = [
      intensity * -2,
      -intensity,
      0,
      0,
      0,
      -intensity,
      0,
      intensity,
      0,
      0,
      0,
      intensity,
      intensity * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  predator(amount, multiply) {
    const matrix = [
      11.224130630493164 * amount,
      -4.794486999511719 * amount,
      -2.8746118545532227 * amount,
      0 * amount,
      0.40342438220977783 * amount,
      -3.6330697536468506 * amount,
      9.193157196044922 * amount,
      -2.951810836791992 * amount,
      0 * amount,
      -1.316135048866272 * amount,
      -3.2184197902679443 * amount,
      -4.2375030517578125 * amount,
      7.476448059082031 * amount,
      0 * amount,
      0.8044459223747253 * amount,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  lsd(multiply) {
    const matrix = [
      2,
      -0.4,
      0.5,
      0,
      0,
      -0.5,
      2,
      -0.4,
      0,
      0,
      -0.4,
      -0.5,
      3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  reset() {
    const matrix = [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, false);
  }
  get matrix() {
    return this.uniforms.m;
  }
  set matrix(value2) {
    this.uniforms.m = value2;
  }
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value2) {
    this.uniforms.uAlpha = value2;
  }
}
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
var fragment$4 = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";
var vertex$3 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";
class DisplacementFilter extends Filter {
  constructor(sprite, scale) {
    const maskMatrix = new Matrix();
    sprite.renderable = false;
    super(vertex$3, fragment$4, {
      mapSampler: sprite._texture,
      filterMatrix: maskMatrix,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    });
    this.maskSprite = sprite;
    this.maskMatrix = maskMatrix;
    if (scale === null || scale === void 0) {
      scale = 20;
    }
    this.scale = new Point(scale, scale);
  }
  apply(filterManager, input, output, clearMode) {
    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
    this.uniforms.scale.x = this.scale.x;
    this.uniforms.scale.y = this.scale.y;
    const wt = this.maskSprite.worldTransform;
    const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
    const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
    if (lenX !== 0 && lenY !== 0) {
      this.uniforms.rotation[0] = wt.a / lenX;
      this.uniforms.rotation[1] = wt.b / lenX;
      this.uniforms.rotation[2] = wt.c / lenY;
      this.uniforms.rotation[3] = wt.d / lenY;
    }
    filterManager.applyFilter(this, input, output, clearMode);
  }
  get map() {
    return this.uniforms.mapSampler;
  }
  set map(value2) {
    this.uniforms.mapSampler = value2;
  }
}
var fragment$3 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
var vertex$2 = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";
class FXAAFilter extends Filter {
  constructor() {
    super(vertex$2, fragment$3);
  }
}
var fragment$2 = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";
class NoiseFilter extends Filter {
  constructor(noise = 0.5, seed2 = Math.random()) {
    super(defaultFilterVertex, fragment$2, {
      uNoise: 0,
      uSeed: 0
    });
    this.noise = noise;
    this.seed = seed2;
  }
  get noise() {
    return this.uniforms.uNoise;
  }
  set noise(value2) {
    this.uniforms.uNoise = value2;
  }
  get seed() {
    return this.uniforms.uSeed;
  }
  set seed(value2) {
    this.uniforms.uSeed = value2;
  }
}
const filters = {
  AlphaFilter,
  BlurFilter,
  BlurFilterPass,
  ColorMatrixFilter,
  DisplacementFilter,
  FXAAFilter,
  NoiseFilter
};
Object.entries(filters).forEach(([key, FilterClass]) => {
  Object.defineProperty(filters, key, {
    get() {
      deprecation("7.1.0", `filters.${key} has moved to ${key}`);
      return FilterClass;
    }
  });
});
class EventsTickerClass {
  constructor() {
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this.tickerAdded = false;
    this._pauseUpdate = true;
  }
  init(events2) {
    this.removeTickerListener();
    this.events = events2;
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this.tickerAdded = false;
    this._pauseUpdate = true;
  }
  get pauseUpdate() {
    return this._pauseUpdate;
  }
  set pauseUpdate(paused) {
    this._pauseUpdate = paused;
  }
  addTickerListener() {
    if (this.tickerAdded || !this.domElement) {
      return;
    }
    Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
    this.tickerAdded = true;
  }
  removeTickerListener() {
    if (!this.tickerAdded) {
      return;
    }
    Ticker.system.remove(this.tickerUpdate, this);
    this.tickerAdded = false;
  }
  pointerMoved() {
    this._didMove = true;
  }
  update() {
    if (!this.domElement || this._pauseUpdate) {
      return;
    }
    if (this._didMove) {
      this._didMove = false;
      return;
    }
    const rootPointerEvent = this.events["rootPointerEvent"];
    if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
      return;
    }
    globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
      clientX: rootPointerEvent.clientX,
      clientY: rootPointerEvent.clientY
    }));
  }
  tickerUpdate(deltaTime) {
    this._deltaTime += deltaTime;
    if (this._deltaTime < this.interactionFrequency) {
      return;
    }
    this._deltaTime = 0;
    this.update();
  }
}
const EventsTicker = new EventsTickerClass();
class FederatedEvent {
  constructor(manager) {
    this.bubbles = true;
    this.cancelBubble = true;
    this.cancelable = false;
    this.composed = false;
    this.defaultPrevented = false;
    this.eventPhase = FederatedEvent.prototype.NONE;
    this.propagationStopped = false;
    this.propagationImmediatelyStopped = false;
    this.layer = new Point();
    this.page = new Point();
    this.NONE = 0;
    this.CAPTURING_PHASE = 1;
    this.AT_TARGET = 2;
    this.BUBBLING_PHASE = 3;
    this.manager = manager;
  }
  get layerX() {
    return this.layer.x;
  }
  get layerY() {
    return this.layer.y;
  }
  get pageX() {
    return this.page.x;
  }
  get pageY() {
    return this.page.y;
  }
  get data() {
    return this;
  }
  composedPath() {
    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
      this.path = this.target ? this.manager.propagationPath(this.target) : [];
    }
    return this.path;
  }
  initEvent(_type, _bubbles, _cancelable) {
    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  preventDefault() {
    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
      this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = true;
  }
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  }
  stopPropagation() {
    this.propagationStopped = true;
  }
}
class FederatedMouseEvent extends FederatedEvent {
  constructor() {
    super(...arguments);
    this.client = new Point();
    this.movement = new Point();
    this.offset = new Point();
    this.global = new Point();
    this.screen = new Point();
  }
  get clientX() {
    return this.client.x;
  }
  get clientY() {
    return this.client.y;
  }
  get x() {
    return this.clientX;
  }
  get y() {
    return this.clientY;
  }
  get movementX() {
    return this.movement.x;
  }
  get movementY() {
    return this.movement.y;
  }
  get offsetX() {
    return this.offset.x;
  }
  get offsetY() {
    return this.offset.y;
  }
  get globalX() {
    return this.global.x;
  }
  get globalY() {
    return this.global.y;
  }
  get screenX() {
    return this.screen.x;
  }
  get screenY() {
    return this.screen.y;
  }
  getLocalPosition(displayObject, point, globalPos) {
    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
  }
  getModifierState(key) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
  }
  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
    throw new Error("Method not implemented.");
  }
}
class FederatedPointerEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments);
    this.width = 0;
    this.height = 0;
    this.isPrimary = false;
  }
  getCoalescedEvents() {
    if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
      return [this];
    }
    return [];
  }
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
}
class FederatedWheelEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments);
    this.DOM_DELTA_PIXEL = 0;
    this.DOM_DELTA_LINE = 1;
    this.DOM_DELTA_PAGE = 2;
  }
}
FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
FederatedWheelEvent.DOM_DELTA_LINE = 1;
FederatedWheelEvent.DOM_DELTA_PAGE = 2;
const PROPAGATION_LIMIT = 2048;
const tempHitLocation = new Point();
const tempLocalMapping = new Point();
class EventBoundary {
  constructor(rootTarget) {
    this.dispatch = new EventEmitter2();
    this.moveOnAll = false;
    this.enableGlobalMoveEvents = true;
    this.mappingState = {
      trackingData: {}
    };
    this.eventPool = /* @__PURE__ */ new Map();
    this._allInteractiveElements = [];
    this._hitElements = [];
    this._isPointerMoveEvent = false;
    this.rootTarget = rootTarget;
    this.hitPruneFn = this.hitPruneFn.bind(this);
    this.hitTestFn = this.hitTestFn.bind(this);
    this.mapPointerDown = this.mapPointerDown.bind(this);
    this.mapPointerMove = this.mapPointerMove.bind(this);
    this.mapPointerOut = this.mapPointerOut.bind(this);
    this.mapPointerOver = this.mapPointerOver.bind(this);
    this.mapPointerUp = this.mapPointerUp.bind(this);
    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
    this.mapWheel = this.mapWheel.bind(this);
    this.mappingTable = {};
    this.addEventMapping("pointerdown", this.mapPointerDown);
    this.addEventMapping("pointermove", this.mapPointerMove);
    this.addEventMapping("pointerout", this.mapPointerOut);
    this.addEventMapping("pointerleave", this.mapPointerOut);
    this.addEventMapping("pointerover", this.mapPointerOver);
    this.addEventMapping("pointerup", this.mapPointerUp);
    this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
    this.addEventMapping("wheel", this.mapWheel);
  }
  addEventMapping(type, fn) {
    if (!this.mappingTable[type]) {
      this.mappingTable[type] = [];
    }
    this.mappingTable[type].push({
      fn,
      priority: 0
    });
    this.mappingTable[type].sort((a8, b3) => a8.priority - b3.priority);
  }
  dispatchEvent(e3, type) {
    e3.propagationStopped = false;
    e3.propagationImmediatelyStopped = false;
    this.propagate(e3, type);
    this.dispatch.emit(type || e3.type, e3);
  }
  mapEvent(e3) {
    if (!this.rootTarget) {
      return;
    }
    const mappers = this.mappingTable[e3.type];
    if (mappers) {
      for (let i2 = 0, j2 = mappers.length; i2 < j2; i2++) {
        mappers[i2].fn(e3);
      }
    } else {
      console.warn(`[EventBoundary]: Event mapping not defined for ${e3.type}`);
    }
  }
  hitTest(x2, y2) {
    EventsTicker.pauseUpdate = true;
    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
    const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
    const invertedPath = this[fn](this.rootTarget, this.rootTarget.eventMode, tempHitLocation.set(x2, y2), this.hitTestFn, this.hitPruneFn);
    return invertedPath && invertedPath[0];
  }
  propagate(e3, type) {
    if (!e3.target) {
      return;
    }
    const composedPath = e3.composedPath();
    e3.eventPhase = e3.CAPTURING_PHASE;
    for (let i2 = 0, j2 = composedPath.length - 1; i2 < j2; i2++) {
      e3.currentTarget = composedPath[i2];
      this.notifyTarget(e3, type);
      if (e3.propagationStopped || e3.propagationImmediatelyStopped)
        return;
    }
    e3.eventPhase = e3.AT_TARGET;
    e3.currentTarget = e3.target;
    this.notifyTarget(e3, type);
    if (e3.propagationStopped || e3.propagationImmediatelyStopped)
      return;
    e3.eventPhase = e3.BUBBLING_PHASE;
    for (let i2 = composedPath.length - 2; i2 >= 0; i2--) {
      e3.currentTarget = composedPath[i2];
      this.notifyTarget(e3, type);
      if (e3.propagationStopped || e3.propagationImmediatelyStopped)
        return;
    }
  }
  all(e3, type, targets = this._allInteractiveElements) {
    if (targets.length === 0)
      return;
    e3.eventPhase = e3.BUBBLING_PHASE;
    const events2 = Array.isArray(type) ? type : [type];
    for (let i2 = targets.length - 1; i2 >= 0; i2--) {
      events2.forEach((event) => {
        e3.currentTarget = targets[i2];
        this.notifyTarget(e3, event);
      });
    }
  }
  propagationPath(target) {
    const propagationPath = [target];
    for (let i2 = 0; i2 < PROPAGATION_LIMIT && target !== this.rootTarget; i2++) {
      if (!target.parent) {
        throw new Error("Cannot find propagation path to disconnected target");
      }
      propagationPath.push(target.parent);
      target = target.parent;
    }
    propagationPath.reverse();
    return propagationPath;
  }
  hitTestMoveRecursive(currentTarget, eventMode, location2, testFn, pruneFn, ignore = false) {
    let shouldReturn = false;
    if (this._interactivePrune(currentTarget))
      return null;
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i2 = children.length - 1; i2 >= 0; i2--) {
        const child = children[i2];
        const nestedHit = this.hitTestMoveRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location2, testFn, pruneFn, ignore || pruneFn(currentTarget, location2));
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive) {
            if (isInteractive)
              this._allInteractiveElements.push(currentTarget);
            nestedHit.push(currentTarget);
          }
          if (this._hitElements.length === 0)
            this._hitElements = nestedHit;
          shouldReturn = true;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveTarget && isInteractiveTarget)
      this._allInteractiveElements.push(currentTarget);
    if (ignore || this._hitElements.length > 0)
      return null;
    if (shouldReturn)
      return this._hitElements;
    if (isInteractiveMode && (!pruneFn(currentTarget, location2) && testFn(currentTarget, location2))) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  hitTestRecursive(currentTarget, eventMode, location2, testFn, pruneFn) {
    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location2)) {
      return null;
    }
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i2 = children.length - 1; i2 >= 0; i2--) {
        const child = children[i2];
        const nestedHit = this.hitTestRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location2, testFn, pruneFn);
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive)
            nestedHit.push(currentTarget);
          return nestedHit;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveMode && testFn(currentTarget, location2)) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  _isInteractive(int) {
    return int === "static" || int === "dynamic";
  }
  _interactivePrune(displayObject) {
    if (!displayObject || displayObject.isMask || !displayObject.visible || !displayObject.renderable) {
      return true;
    }
    if (displayObject.eventMode === "none") {
      return true;
    }
    if (displayObject.eventMode === "passive" && !displayObject.interactiveChildren) {
      return true;
    }
    if (displayObject.isMask) {
      return true;
    }
    return false;
  }
  hitPruneFn(displayObject, location2) {
    var _a;
    if (displayObject.hitArea) {
      displayObject.worldTransform.applyInverse(location2, tempLocalMapping);
      if (!displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
        return true;
      }
    }
    if (displayObject._mask) {
      const maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;
      if (maskObject && !((_a = maskObject.containsPoint) == null ? void 0 : _a.call(maskObject, location2))) {
        return true;
      }
    }
    return false;
  }
  hitTestFn(displayObject, location2) {
    if (displayObject.eventMode === "passive") {
      return false;
    }
    if (displayObject.hitArea) {
      return true;
    }
    if (displayObject.containsPoint) {
      return displayObject.containsPoint(location2);
    }
    return false;
  }
  notifyTarget(e3, type) {
    var _a, _b;
    type = type ?? e3.type;
    const handlerKey = `on${type}`;
    (_b = (_a = e3.currentTarget)[handlerKey]) == null ? void 0 : _b.call(_a, e3);
    const key = e3.eventPhase === e3.CAPTURING_PHASE || e3.eventPhase === e3.AT_TARGET ? `${type}capture` : type;
    this.notifyListeners(e3, key);
    if (e3.eventPhase === e3.AT_TARGET) {
      this.notifyListeners(e3, type);
    }
  }
  mapPointerDown(from2) {
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const e3 = this.createPointerEvent(from2);
    this.dispatchEvent(e3, "pointerdown");
    if (e3.pointerType === "touch") {
      this.dispatchEvent(e3, "touchstart");
    } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
      const isRightButton = e3.button === 2;
      this.dispatchEvent(e3, isRightButton ? "rightdown" : "mousedown");
    }
    const trackingData = this.trackingData(from2.pointerId);
    trackingData.pressTargetsByButton[from2.button] = e3.composedPath();
    this.freeEvent(e3);
  }
  mapPointerMove(from2) {
    var _a, _b;
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    this._isPointerMoveEvent = true;
    const e3 = this.createPointerEvent(from2);
    this._isPointerMoveEvent = false;
    const isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
    const trackingData = this.trackingData(from2.pointerId);
    const outTarget = this.findMountedTarget(trackingData.overTargets);
    if (((_a = trackingData.overTargets) == null ? void 0 : _a.length) > 0 && outTarget !== e3.target) {
      const outType = from2.type === "mousemove" ? "mouseout" : "pointerout";
      const outEvent = this.createPointerEvent(from2, outType, outTarget);
      this.dispatchEvent(outEvent, "pointerout");
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      if (!e3.composedPath().includes(outTarget)) {
        const leaveEvent = this.createPointerEvent(from2, "pointerleave", outTarget);
        leaveEvent.eventPhase = leaveEvent.AT_TARGET;
        while (leaveEvent.target && !e3.composedPath().includes(leaveEvent.target)) {
          leaveEvent.currentTarget = leaveEvent.target;
          this.notifyTarget(leaveEvent);
          if (isMouse)
            this.notifyTarget(leaveEvent, "mouseleave");
          leaveEvent.target = leaveEvent.target.parent;
        }
        this.freeEvent(leaveEvent);
      }
      this.freeEvent(outEvent);
    }
    if (outTarget !== e3.target) {
      const overType = from2.type === "mousemove" ? "mouseover" : "pointerover";
      const overEvent = this.clonePointerEvent(e3, overType);
      this.dispatchEvent(overEvent, "pointerover");
      if (isMouse)
        this.dispatchEvent(overEvent, "mouseover");
      let overTargetAncestor = outTarget == null ? void 0 : outTarget.parent;
      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
        if (overTargetAncestor === e3.target)
          break;
        overTargetAncestor = overTargetAncestor.parent;
      }
      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
      if (didPointerEnter) {
        const enterEvent = this.clonePointerEvent(e3, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
          enterEvent.currentTarget = enterEvent.target;
          this.notifyTarget(enterEvent);
          if (isMouse)
            this.notifyTarget(enterEvent, "mouseenter");
          enterEvent.target = enterEvent.target.parent;
        }
        this.freeEvent(enterEvent);
      }
      this.freeEvent(overEvent);
    }
    const allMethods = [];
    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
    this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e3, "pointermove");
    allowGlobalPointerEvents && allMethods.push("globalpointermove");
    if (e3.pointerType === "touch") {
      this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e3, "touchmove");
      allowGlobalPointerEvents && allMethods.push("globaltouchmove");
    }
    if (isMouse) {
      this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e3, "mousemove");
      allowGlobalPointerEvents && allMethods.push("globalmousemove");
      this.cursor = (_b = e3.target) == null ? void 0 : _b.cursor;
    }
    if (allMethods.length > 0) {
      this.all(e3, allMethods);
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    trackingData.overTargets = e3.composedPath();
    this.freeEvent(e3);
  }
  mapPointerOver(from2) {
    var _a;
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from2.pointerId);
    const e3 = this.createPointerEvent(from2);
    const isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
    this.dispatchEvent(e3, "pointerover");
    if (isMouse)
      this.dispatchEvent(e3, "mouseover");
    if (e3.pointerType === "mouse")
      this.cursor = (_a = e3.target) == null ? void 0 : _a.cursor;
    const enterEvent = this.clonePointerEvent(e3, "pointerenter");
    enterEvent.eventPhase = enterEvent.AT_TARGET;
    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
      enterEvent.currentTarget = enterEvent.target;
      this.notifyTarget(enterEvent);
      if (isMouse)
        this.notifyTarget(enterEvent, "mouseenter");
      enterEvent.target = enterEvent.target.parent;
    }
    trackingData.overTargets = e3.composedPath();
    this.freeEvent(e3);
    this.freeEvent(enterEvent);
  }
  mapPointerOut(from2) {
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from2.pointerId);
    if (trackingData.overTargets) {
      const isMouse = from2.pointerType === "mouse" || from2.pointerType === "pen";
      const outTarget = this.findMountedTarget(trackingData.overTargets);
      const outEvent = this.createPointerEvent(from2, "pointerout", outTarget);
      this.dispatchEvent(outEvent);
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      const leaveEvent = this.createPointerEvent(from2, "pointerleave", outTarget);
      leaveEvent.eventPhase = leaveEvent.AT_TARGET;
      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
        leaveEvent.currentTarget = leaveEvent.target;
        this.notifyTarget(leaveEvent);
        if (isMouse)
          this.notifyTarget(leaveEvent, "mouseleave");
        leaveEvent.target = leaveEvent.target.parent;
      }
      trackingData.overTargets = null;
      this.freeEvent(outEvent);
      this.freeEvent(leaveEvent);
    }
    this.cursor = null;
  }
  mapPointerUp(from2) {
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const now = performance.now();
    const e3 = this.createPointerEvent(from2);
    this.dispatchEvent(e3, "pointerup");
    if (e3.pointerType === "touch") {
      this.dispatchEvent(e3, "touchend");
    } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
      const isRightButton = e3.button === 2;
      this.dispatchEvent(e3, isRightButton ? "rightup" : "mouseup");
    }
    const trackingData = this.trackingData(from2.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from2.button]);
    let clickTarget = pressTarget;
    if (pressTarget && !e3.composedPath().includes(pressTarget)) {
      let currentTarget = pressTarget;
      while (currentTarget && !e3.composedPath().includes(currentTarget)) {
        e3.currentTarget = currentTarget;
        this.notifyTarget(e3, "pointerupoutside");
        if (e3.pointerType === "touch") {
          this.notifyTarget(e3, "touchendoutside");
        } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
          const isRightButton = e3.button === 2;
          this.notifyTarget(e3, isRightButton ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from2.button];
      clickTarget = currentTarget;
    }
    if (clickTarget) {
      const clickEvent = this.clonePointerEvent(e3, "click");
      clickEvent.target = clickTarget;
      clickEvent.path = null;
      if (!trackingData.clicksByButton[from2.button]) {
        trackingData.clicksByButton[from2.button] = {
          clickCount: 0,
          target: clickEvent.target,
          timeStamp: now
        };
      }
      const clickHistory = trackingData.clicksByButton[from2.button];
      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
        ++clickHistory.clickCount;
      } else {
        clickHistory.clickCount = 1;
      }
      clickHistory.target = clickEvent.target;
      clickHistory.timeStamp = now;
      clickEvent.detail = clickHistory.clickCount;
      if (clickEvent.pointerType === "mouse") {
        const isRightButton = clickEvent.button === 2;
        this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
      } else if (clickEvent.pointerType === "touch") {
        this.dispatchEvent(clickEvent, "tap");
      }
      this.dispatchEvent(clickEvent, "pointertap");
      this.freeEvent(clickEvent);
    }
    this.freeEvent(e3);
  }
  mapPointerUpOutside(from2) {
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from2.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from2.button]);
    const e3 = this.createPointerEvent(from2);
    if (pressTarget) {
      let currentTarget = pressTarget;
      while (currentTarget) {
        e3.currentTarget = currentTarget;
        this.notifyTarget(e3, "pointerupoutside");
        if (e3.pointerType === "touch") {
          this.notifyTarget(e3, "touchendoutside");
        } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
          this.notifyTarget(e3, e3.button === 2 ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from2.button];
    }
    this.freeEvent(e3);
  }
  mapWheel(from2) {
    if (!(from2 instanceof FederatedWheelEvent)) {
      console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
      return;
    }
    const wheelEvent = this.createWheelEvent(from2);
    this.dispatchEvent(wheelEvent);
    this.freeEvent(wheelEvent);
  }
  findMountedTarget(propagationPath) {
    if (!propagationPath) {
      return null;
    }
    let currentTarget = propagationPath[0];
    for (let i2 = 1; i2 < propagationPath.length; i2++) {
      if (propagationPath[i2].parent === currentTarget) {
        currentTarget = propagationPath[i2];
      } else {
        break;
      }
    }
    return currentTarget;
  }
  createPointerEvent(from2, type, target) {
    const event = this.allocateEvent(FederatedPointerEvent);
    this.copyPointerData(from2, event);
    this.copyMouseData(from2, event);
    this.copyData(from2, event);
    event.nativeEvent = from2.nativeEvent;
    event.originalEvent = from2;
    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
    if (typeof type === "string") {
      event.type = type;
    }
    return event;
  }
  createWheelEvent(from2) {
    const event = this.allocateEvent(FederatedWheelEvent);
    this.copyWheelData(from2, event);
    this.copyMouseData(from2, event);
    this.copyData(from2, event);
    event.nativeEvent = from2.nativeEvent;
    event.originalEvent = from2;
    event.target = this.hitTest(event.global.x, event.global.y);
    return event;
  }
  clonePointerEvent(from2, type) {
    const event = this.allocateEvent(FederatedPointerEvent);
    event.nativeEvent = from2.nativeEvent;
    event.originalEvent = from2.originalEvent;
    this.copyPointerData(from2, event);
    this.copyMouseData(from2, event);
    this.copyData(from2, event);
    event.target = from2.target;
    event.path = from2.composedPath().slice();
    event.type = type ?? event.type;
    return event;
  }
  copyWheelData(from2, to) {
    to.deltaMode = from2.deltaMode;
    to.deltaX = from2.deltaX;
    to.deltaY = from2.deltaY;
    to.deltaZ = from2.deltaZ;
  }
  copyPointerData(from2, to) {
    if (!(from2 instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))
      return;
    to.pointerId = from2.pointerId;
    to.width = from2.width;
    to.height = from2.height;
    to.isPrimary = from2.isPrimary;
    to.pointerType = from2.pointerType;
    to.pressure = from2.pressure;
    to.tangentialPressure = from2.tangentialPressure;
    to.tiltX = from2.tiltX;
    to.tiltY = from2.tiltY;
    to.twist = from2.twist;
  }
  copyMouseData(from2, to) {
    if (!(from2 instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))
      return;
    to.altKey = from2.altKey;
    to.button = from2.button;
    to.buttons = from2.buttons;
    to.client.copyFrom(from2.client);
    to.ctrlKey = from2.ctrlKey;
    to.metaKey = from2.metaKey;
    to.movement.copyFrom(from2.movement);
    to.screen.copyFrom(from2.screen);
    to.shiftKey = from2.shiftKey;
    to.global.copyFrom(from2.global);
  }
  copyData(from2, to) {
    to.isTrusted = from2.isTrusted;
    to.srcElement = from2.srcElement;
    to.timeStamp = performance.now();
    to.type = from2.type;
    to.detail = from2.detail;
    to.view = from2.view;
    to.which = from2.which;
    to.layer.copyFrom(from2.layer);
    to.page.copyFrom(from2.page);
  }
  trackingData(id) {
    if (!this.mappingState.trackingData[id]) {
      this.mappingState.trackingData[id] = {
        pressTargetsByButton: {},
        clicksByButton: {},
        overTarget: null
      };
    }
    return this.mappingState.trackingData[id];
  }
  allocateEvent(constructor) {
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    const event = this.eventPool.get(constructor).pop() || new constructor(this);
    event.eventPhase = event.NONE;
    event.currentTarget = null;
    event.path = null;
    event.target = null;
    return event;
  }
  freeEvent(event) {
    if (event.manager !== this)
      throw new Error("It is illegal to free an event not managed by this EventBoundary!");
    const constructor = event.constructor;
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    this.eventPool.get(constructor).push(event);
  }
  notifyListeners(e3, type) {
    const listeners2 = e3.currentTarget._events[type];
    if (!listeners2)
      return;
    if (!e3.currentTarget.isInteractive())
      return;
    if ("fn" in listeners2) {
      if (listeners2.once)
        e3.currentTarget.removeListener(type, listeners2.fn, void 0, true);
      listeners2.fn.call(listeners2.context, e3);
    } else {
      for (let i2 = 0, j2 = listeners2.length; i2 < j2 && !e3.propagationImmediatelyStopped; i2++) {
        if (listeners2[i2].once)
          e3.currentTarget.removeListener(type, listeners2[i2].fn, void 0, true);
        listeners2[i2].fn.call(listeners2[i2].context, e3);
      }
    }
  }
}
const MOUSE_POINTER_ID = 1;
const TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
const _EventSystem = class {
  constructor(renderer2) {
    this.supportsTouchEvents = "ontouchstart" in globalThis;
    this.supportsPointerEvents = !!globalThis.PointerEvent;
    this.domElement = null;
    this.resolution = 1;
    this.renderer = renderer2;
    this.rootBoundary = new EventBoundary(null);
    EventsTicker.init(this);
    this.autoPreventDefault = true;
    this.eventsAdded = false;
    this.rootPointerEvent = new FederatedPointerEvent(null);
    this.rootWheelEvent = new FederatedWheelEvent(null);
    this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    };
    this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {
      set: (target, key, value2) => {
        if (key === "globalMove") {
          this.rootBoundary.enableGlobalMoveEvents = value2;
        }
        target[key] = value2;
        return true;
      }
    });
    this.onPointerDown = this.onPointerDown.bind(this);
    this.onPointerMove = this.onPointerMove.bind(this);
    this.onPointerUp = this.onPointerUp.bind(this);
    this.onPointerOverOut = this.onPointerOverOut.bind(this);
    this.onWheel = this.onWheel.bind(this);
  }
  static get defaultEventMode() {
    return this._defaultEventMode;
  }
  init(options) {
    const { view, resolution } = this.renderer;
    this.setTargetElement(view);
    this.resolution = resolution;
    _EventSystem._defaultEventMode = options.eventMode ?? "auto";
    Object.assign(this.features, options.eventFeatures ?? {});
    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
  }
  resolutionChange(resolution) {
    this.resolution = resolution;
  }
  destroy() {
    this.setTargetElement(null);
    this.renderer = null;
  }
  setCursor(mode) {
    mode = mode || "default";
    let applyStyles = true;
    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
      applyStyles = false;
    }
    if (this.currentCursor === mode) {
      return;
    }
    this.currentCursor = mode;
    const style = this.cursorStyles[mode];
    if (style) {
      switch (typeof style) {
        case "string":
          if (applyStyles) {
            this.domElement.style.cursor = style;
          }
          break;
        case "function":
          style(mode);
          break;
        case "object":
          if (applyStyles) {
            Object.assign(this.domElement.style, style);
          }
          break;
      }
    } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
      this.domElement.style.cursor = mode;
    }
  }
  get pointer() {
    return this.rootPointerEvent;
  }
  onPointerDown(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    const events2 = this.normalizeToPointerData(nativeEvent);
    if (this.autoPreventDefault && events2[0].isNormalized) {
      const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
      if (cancelable) {
        nativeEvent.preventDefault();
      }
    }
    for (let i2 = 0, j2 = events2.length; i2 < j2; i2++) {
      const nativeEvent2 = events2[i2];
      const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);
      this.rootBoundary.mapEvent(federatedEvent);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerMove(nativeEvent) {
    if (!this.features.move)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    EventsTicker.pointerMoved();
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i2]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerUp(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    let target = nativeEvent.target;
    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
      target = nativeEvent.composedPath()[0];
    }
    const outside = target !== this.domElement ? "outside" : "";
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i2]);
      event.type += outside;
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerOverOut(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i2]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onWheel(nativeEvent) {
    if (!this.features.wheel)
      return;
    const wheelEvent = this.normalizeWheelEvent(nativeEvent);
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    this.rootBoundary.mapEvent(wheelEvent);
  }
  setTargetElement(element) {
    this.removeEvents();
    this.domElement = element;
    EventsTicker.domElement = element;
    this.addEvents();
  }
  addEvents() {
    if (this.eventsAdded || !this.domElement) {
      return;
    }
    EventsTicker.addTickerListener();
    const style = this.domElement.style;
    if (style) {
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "none";
        style.msTouchAction = "none";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "none";
      }
    }
    if (this.supportsPointerEvents) {
      globalThis.document.addEventListener("pointermove", this.onPointerMove, true);
      this.domElement.addEventListener("pointerdown", this.onPointerDown, true);
      this.domElement.addEventListener("pointerleave", this.onPointerOverOut, true);
      this.domElement.addEventListener("pointerover", this.onPointerOverOut, true);
      globalThis.addEventListener("pointerup", this.onPointerUp, true);
    } else {
      globalThis.document.addEventListener("mousemove", this.onPointerMove, true);
      this.domElement.addEventListener("mousedown", this.onPointerDown, true);
      this.domElement.addEventListener("mouseout", this.onPointerOverOut, true);
      this.domElement.addEventListener("mouseover", this.onPointerOverOut, true);
      globalThis.addEventListener("mouseup", this.onPointerUp, true);
    }
    if (this.supportsTouchEvents) {
      this.domElement.addEventListener("touchstart", this.onPointerDown, true);
      this.domElement.addEventListener("touchend", this.onPointerUp, true);
      this.domElement.addEventListener("touchmove", this.onPointerMove, true);
    }
    this.domElement.addEventListener("wheel", this.onWheel, {
      passive: true,
      capture: true
    });
    this.eventsAdded = true;
  }
  removeEvents() {
    if (!this.eventsAdded || !this.domElement) {
      return;
    }
    EventsTicker.removeTickerListener();
    const style = this.domElement.style;
    if (globalThis.navigator.msPointerEnabled) {
      style.msContentZooming = "";
      style.msTouchAction = "";
    } else if (this.supportsPointerEvents) {
      style.touchAction = "";
    }
    if (this.supportsPointerEvents) {
      globalThis.document.removeEventListener("pointermove", this.onPointerMove, true);
      this.domElement.removeEventListener("pointerdown", this.onPointerDown, true);
      this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, true);
      this.domElement.removeEventListener("pointerover", this.onPointerOverOut, true);
      globalThis.removeEventListener("pointerup", this.onPointerUp, true);
    } else {
      globalThis.document.removeEventListener("mousemove", this.onPointerMove, true);
      this.domElement.removeEventListener("mousedown", this.onPointerDown, true);
      this.domElement.removeEventListener("mouseout", this.onPointerOverOut, true);
      this.domElement.removeEventListener("mouseover", this.onPointerOverOut, true);
      globalThis.removeEventListener("mouseup", this.onPointerUp, true);
    }
    if (this.supportsTouchEvents) {
      this.domElement.removeEventListener("touchstart", this.onPointerDown, true);
      this.domElement.removeEventListener("touchend", this.onPointerUp, true);
      this.domElement.removeEventListener("touchmove", this.onPointerMove, true);
    }
    this.domElement.removeEventListener("wheel", this.onWheel, true);
    this.domElement = null;
    this.eventsAdded = false;
  }
  mapPositionToPoint(point, x2, y2) {
    let rect;
    if (!this.domElement.parentElement) {
      rect = {
        x: 0,
        y: 0,
        width: this.domElement.width,
        height: this.domElement.height,
        left: 0,
        top: 0
      };
    } else {
      rect = this.domElement.getBoundingClientRect();
    }
    const resolutionMultiplier = 1 / this.resolution;
    point.x = (x2 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
    point.y = (y2 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
  }
  normalizeToPointerData(event) {
    const normalizedEvents = [];
    if (this.supportsTouchEvents && event instanceof TouchEvent) {
      for (let i2 = 0, li = event.changedTouches.length; i2 < li; i2++) {
        const touch = event.changedTouches[i2];
        if (typeof touch.button === "undefined")
          touch.button = 0;
        if (typeof touch.buttons === "undefined")
          touch.buttons = 1;
        if (typeof touch.isPrimary === "undefined") {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (typeof touch.width === "undefined")
          touch.width = touch.radiusX || 1;
        if (typeof touch.height === "undefined")
          touch.height = touch.radiusY || 1;
        if (typeof touch.tiltX === "undefined")
          touch.tiltX = 0;
        if (typeof touch.tiltY === "undefined")
          touch.tiltY = 0;
        if (typeof touch.pointerType === "undefined")
          touch.pointerType = "touch";
        if (typeof touch.pointerId === "undefined")
          touch.pointerId = touch.identifier || 0;
        if (typeof touch.pressure === "undefined")
          touch.pressure = touch.force || 0.5;
        if (typeof touch.twist === "undefined")
          touch.twist = 0;
        if (typeof touch.tangentialPressure === "undefined")
          touch.tangentialPressure = 0;
        if (typeof touch.layerX === "undefined")
          touch.layerX = touch.offsetX = touch.clientX;
        if (typeof touch.layerY === "undefined")
          touch.layerY = touch.offsetY = touch.clientY;
        touch.isNormalized = true;
        touch.type = event.type;
        normalizedEvents.push(touch);
      }
    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
      const tempEvent = event;
      if (typeof tempEvent.isPrimary === "undefined")
        tempEvent.isPrimary = true;
      if (typeof tempEvent.width === "undefined")
        tempEvent.width = 1;
      if (typeof tempEvent.height === "undefined")
        tempEvent.height = 1;
      if (typeof tempEvent.tiltX === "undefined")
        tempEvent.tiltX = 0;
      if (typeof tempEvent.tiltY === "undefined")
        tempEvent.tiltY = 0;
      if (typeof tempEvent.pointerType === "undefined")
        tempEvent.pointerType = "mouse";
      if (typeof tempEvent.pointerId === "undefined")
        tempEvent.pointerId = MOUSE_POINTER_ID;
      if (typeof tempEvent.pressure === "undefined")
        tempEvent.pressure = 0.5;
      if (typeof tempEvent.twist === "undefined")
        tempEvent.twist = 0;
      if (typeof tempEvent.tangentialPressure === "undefined")
        tempEvent.tangentialPressure = 0;
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  }
  normalizeWheelEvent(nativeEvent) {
    const event = this.rootWheelEvent;
    this.transferMouseData(event, nativeEvent);
    event.deltaX = nativeEvent.deltaX;
    event.deltaY = nativeEvent.deltaY;
    event.deltaZ = nativeEvent.deltaZ;
    event.deltaMode = nativeEvent.deltaMode;
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.nativeEvent = nativeEvent;
    event.type = nativeEvent.type;
    return event;
  }
  bootstrapEvent(event, nativeEvent) {
    event.originalEvent = null;
    event.nativeEvent = nativeEvent;
    event.pointerId = nativeEvent.pointerId;
    event.width = nativeEvent.width;
    event.height = nativeEvent.height;
    event.isPrimary = nativeEvent.isPrimary;
    event.pointerType = nativeEvent.pointerType;
    event.pressure = nativeEvent.pressure;
    event.tangentialPressure = nativeEvent.tangentialPressure;
    event.tiltX = nativeEvent.tiltX;
    event.tiltY = nativeEvent.tiltY;
    event.twist = nativeEvent.twist;
    this.transferMouseData(event, nativeEvent);
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.isTrusted = nativeEvent.isTrusted;
    if (event.type === "pointerleave") {
      event.type = "pointerout";
    }
    if (event.type.startsWith("mouse")) {
      event.type = event.type.replace("mouse", "pointer");
    }
    if (event.type.startsWith("touch")) {
      event.type = TOUCH_TO_POINTER[event.type] || event.type;
    }
    return event;
  }
  transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted;
    event.srcElement = nativeEvent.srcElement;
    event.timeStamp = performance.now();
    event.type = nativeEvent.type;
    event.altKey = nativeEvent.altKey;
    event.button = nativeEvent.button;
    event.buttons = nativeEvent.buttons;
    event.client.x = nativeEvent.clientX;
    event.client.y = nativeEvent.clientY;
    event.ctrlKey = nativeEvent.ctrlKey;
    event.metaKey = nativeEvent.metaKey;
    event.movement.x = nativeEvent.movementX;
    event.movement.y = nativeEvent.movementY;
    event.page.x = nativeEvent.pageX;
    event.page.y = nativeEvent.pageY;
    event.relatedTarget = null;
    event.shiftKey = nativeEvent.shiftKey;
  }
};
let EventSystem = _EventSystem;
EventSystem.extension = {
  name: "events",
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ]
};
EventSystem.defaultEventFeatures = {
  move: true,
  globalMove: true,
  click: true,
  wheel: true
};
extensions$1.add(EventSystem);
function convertEventModeToInteractiveMode(mode) {
  return mode === "dynamic" || mode === "static";
}
const FederatedDisplayObject = {
  onclick: null,
  onmousedown: null,
  onmouseenter: null,
  onmouseleave: null,
  onmousemove: null,
  onglobalmousemove: null,
  onmouseout: null,
  onmouseover: null,
  onmouseup: null,
  onmouseupoutside: null,
  onpointercancel: null,
  onpointerdown: null,
  onpointerenter: null,
  onpointerleave: null,
  onpointermove: null,
  onglobalpointermove: null,
  onpointerout: null,
  onpointerover: null,
  onpointertap: null,
  onpointerup: null,
  onpointerupoutside: null,
  onrightclick: null,
  onrightdown: null,
  onrightup: null,
  onrightupoutside: null,
  ontap: null,
  ontouchcancel: null,
  ontouchend: null,
  ontouchendoutside: null,
  ontouchmove: null,
  onglobaltouchmove: null,
  ontouchstart: null,
  onwheel: null,
  _internalInteractive: void 0,
  get interactive() {
    return this._internalInteractive ?? convertEventModeToInteractiveMode(EventSystem.defaultEventMode);
  },
  set interactive(value2) {
    deprecation("7.2.0", `Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead.`);
    this._internalInteractive = value2;
    this.eventMode = value2 ? "static" : "auto";
  },
  _internalEventMode: void 0,
  get eventMode() {
    return this._internalEventMode ?? EventSystem.defaultEventMode;
  },
  set eventMode(value2) {
    this._internalInteractive = convertEventModeToInteractiveMode(value2);
    this._internalEventMode = value2;
  },
  isInteractive() {
    return this.eventMode === "static" || this.eventMode === "dynamic";
  },
  interactiveChildren: true,
  hitArea: null,
  addEventListener(type, listener, options) {
    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
    const context2 = typeof listener === "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type;
    listener = typeof listener === "function" ? listener : listener.handleEvent;
    this.on(type, listener, context2);
  },
  removeEventListener(type, listener, options) {
    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
    const context2 = typeof listener === "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type;
    listener = typeof listener === "function" ? listener : listener.handleEvent;
    this.off(type, listener, context2);
  },
  dispatchEvent(e3) {
    if (!(e3 instanceof FederatedEvent)) {
      throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
    }
    e3.defaultPrevented = false;
    e3.path = null;
    e3.target = this;
    e3.manager.dispatchEvent(e3);
    return !e3.defaultPrevented;
  }
};
DisplayObject.mixin(FederatedDisplayObject);
const accessibleTarget = {
  accessible: false,
  accessibleTitle: null,
  accessibleHint: null,
  tabIndex: 0,
  _accessibleActive: false,
  _accessibleDiv: null,
  accessibleType: "button",
  accessiblePointerEvents: "auto",
  accessibleChildren: true,
  renderId: -1
};
DisplayObject.mixin(accessibleTarget);
const KEY_CODE_TAB = 9;
const DIV_TOUCH_SIZE = 100;
const DIV_TOUCH_POS_X = 0;
const DIV_TOUCH_POS_Y = 0;
const DIV_TOUCH_ZINDEX = 2;
const DIV_HOOK_SIZE = 1;
const DIV_HOOK_POS_X = -1e3;
const DIV_HOOK_POS_Y = -1e3;
const DIV_HOOK_ZINDEX = 2;
class AccessibilityManager {
  constructor(renderer2) {
    this.debug = false;
    this._isActive = false;
    this._isMobileAccessibility = false;
    this.pool = [];
    this.renderId = 0;
    this.children = [];
    this.androidUpdateCount = 0;
    this.androidUpdateFrequency = 500;
    this._hookDiv = null;
    if (isMobile.tablet || isMobile.phone) {
      this.createTouchHook();
    }
    const div = document.createElement("div");
    div.style.width = `${DIV_TOUCH_SIZE}px`;
    div.style.height = `${DIV_TOUCH_SIZE}px`;
    div.style.position = "absolute";
    div.style.top = `${DIV_TOUCH_POS_X}px`;
    div.style.left = `${DIV_TOUCH_POS_Y}px`;
    div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
    this.div = div;
    this.renderer = renderer2;
    this._onKeyDown = this._onKeyDown.bind(this);
    this._onMouseMove = this._onMouseMove.bind(this);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
  }
  get isActive() {
    return this._isActive;
  }
  get isMobileAccessibility() {
    return this._isMobileAccessibility;
  }
  createTouchHook() {
    const hookDiv = document.createElement("button");
    hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.position = "absolute";
    hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
    hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
    hookDiv.style.backgroundColor = "#FF0000";
    hookDiv.title = "select to enable accessibility for this content";
    hookDiv.addEventListener("focus", () => {
      this._isMobileAccessibility = true;
      this.activate();
      this.destroyTouchHook();
    });
    document.body.appendChild(hookDiv);
    this._hookDiv = hookDiv;
  }
  destroyTouchHook() {
    if (!this._hookDiv) {
      return;
    }
    document.body.removeChild(this._hookDiv);
    this._hookDiv = null;
  }
  activate() {
    var _a;
    if (this._isActive) {
      return;
    }
    this._isActive = true;
    globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown, false);
    this.renderer.on("postrender", this.update, this);
    (_a = this.renderer.view.parentNode) == null ? void 0 : _a.appendChild(this.div);
  }
  deactivate() {
    var _a;
    if (!this._isActive || this._isMobileAccessibility) {
      return;
    }
    this._isActive = false;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
    this.renderer.off("postrender", this.update);
    (_a = this.div.parentNode) == null ? void 0 : _a.removeChild(this.div);
  }
  updateAccessibleObjects(displayObject) {
    if (!displayObject.visible || !displayObject.accessibleChildren) {
      return;
    }
    if (displayObject.accessible && displayObject.isInteractive()) {
      if (!displayObject._accessibleActive) {
        this.addChild(displayObject);
      }
      displayObject.renderId = this.renderId;
    }
    const children = displayObject.children;
    if (children) {
      for (let i2 = 0; i2 < children.length; i2++) {
        this.updateAccessibleObjects(children[i2]);
      }
    }
  }
  update() {
    const now = performance.now();
    if (isMobile.android.device && now < this.androidUpdateCount) {
      return;
    }
    this.androidUpdateCount = now + this.androidUpdateFrequency;
    if (!this.renderer.renderingToScreen) {
      return;
    }
    if (this.renderer.lastObjectRendered) {
      this.updateAccessibleObjects(this.renderer.lastObjectRendered);
    }
    const { x: x2, y: y2, width, height } = this.renderer.view.getBoundingClientRect();
    const { width: viewWidth, height: viewHeight, resolution } = this.renderer;
    const sx = width / viewWidth * resolution;
    const sy = height / viewHeight * resolution;
    let div = this.div;
    div.style.left = `${x2}px`;
    div.style.top = `${y2}px`;
    div.style.width = `${viewWidth}px`;
    div.style.height = `${viewHeight}px`;
    for (let i2 = 0; i2 < this.children.length; i2++) {
      const child = this.children[i2];
      if (child.renderId !== this.renderId) {
        child._accessibleActive = false;
        removeItems(this.children, i2, 1);
        this.div.removeChild(child._accessibleDiv);
        this.pool.push(child._accessibleDiv);
        child._accessibleDiv = null;
        i2--;
      } else {
        div = child._accessibleDiv;
        let hitArea = child.hitArea;
        const wt = child.worldTransform;
        if (child.hitArea) {
          div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
          div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
          div.style.width = `${hitArea.width * wt.a * sx}px`;
          div.style.height = `${hitArea.height * wt.d * sy}px`;
        } else {
          hitArea = child.getBounds();
          this.capHitArea(hitArea);
          div.style.left = `${hitArea.x * sx}px`;
          div.style.top = `${hitArea.y * sy}px`;
          div.style.width = `${hitArea.width * sx}px`;
          div.style.height = `${hitArea.height * sy}px`;
          if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
            div.title = child.accessibleTitle;
          }
          if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
            div.setAttribute("aria-label", child.accessibleHint);
          }
        }
        if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
          div.title = child.accessibleTitle;
          div.tabIndex = child.tabIndex;
          if (this.debug)
            this.updateDebugHTML(div);
        }
      }
    }
    this.renderId++;
  }
  updateDebugHTML(div) {
    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
  }
  capHitArea(hitArea) {
    if (hitArea.x < 0) {
      hitArea.width += hitArea.x;
      hitArea.x = 0;
    }
    if (hitArea.y < 0) {
      hitArea.height += hitArea.y;
      hitArea.y = 0;
    }
    const { width: viewWidth, height: viewHeight } = this.renderer;
    if (hitArea.x + hitArea.width > viewWidth) {
      hitArea.width = viewWidth - hitArea.x;
    }
    if (hitArea.y + hitArea.height > viewHeight) {
      hitArea.height = viewHeight - hitArea.y;
    }
  }
  addChild(displayObject) {
    let div = this.pool.pop();
    if (!div) {
      div = document.createElement("button");
      div.style.width = `${DIV_TOUCH_SIZE}px`;
      div.style.height = `${DIV_TOUCH_SIZE}px`;
      div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
      div.style.position = "absolute";
      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      div.style.borderStyle = "none";
      if (navigator.userAgent.toLowerCase().includes("chrome")) {
        div.setAttribute("aria-live", "off");
      } else {
        div.setAttribute("aria-live", "polite");
      }
      if (navigator.userAgent.match(/rv:.*Gecko\//)) {
        div.setAttribute("aria-relevant", "additions");
      } else {
        div.setAttribute("aria-relevant", "text");
      }
      div.addEventListener("click", this._onClick.bind(this));
      div.addEventListener("focus", this._onFocus.bind(this));
      div.addEventListener("focusout", this._onFocusOut.bind(this));
    }
    div.style.pointerEvents = displayObject.accessiblePointerEvents;
    div.type = displayObject.accessibleType;
    if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
      div.title = displayObject.accessibleTitle;
    } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
      div.title = `displayObject ${displayObject.tabIndex}`;
    }
    if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
      div.setAttribute("aria-label", displayObject.accessibleHint);
    }
    if (this.debug)
      this.updateDebugHTML(div);
    displayObject._accessibleActive = true;
    displayObject._accessibleDiv = div;
    div.displayObject = displayObject;
    this.children.push(displayObject);
    this.div.appendChild(displayObject._accessibleDiv);
    displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
  }
  _dispatchEvent(e3, type) {
    const { displayObject: target } = e3.target;
    const boundry = this.renderer.events.rootBoundary;
    const event = Object.assign(new FederatedEvent(boundry), { target });
    boundry.rootTarget = this.renderer.lastObjectRendered;
    type.forEach((type2) => boundry.dispatchEvent(event, type2));
  }
  _onClick(e3) {
    this._dispatchEvent(e3, ["click", "pointertap", "tap"]);
  }
  _onFocus(e3) {
    if (!e3.target.getAttribute("aria-live")) {
      e3.target.setAttribute("aria-live", "assertive");
    }
    this._dispatchEvent(e3, ["mouseover"]);
  }
  _onFocusOut(e3) {
    if (!e3.target.getAttribute("aria-live")) {
      e3.target.setAttribute("aria-live", "polite");
    }
    this._dispatchEvent(e3, ["mouseout"]);
  }
  _onKeyDown(e3) {
    if (e3.keyCode !== KEY_CODE_TAB) {
      return;
    }
    this.activate();
  }
  _onMouseMove(e3) {
    if (e3.movementX === 0 && e3.movementY === 0) {
      return;
    }
    this.deactivate();
  }
  destroy() {
    this.destroyTouchHook();
    this.div = null;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown);
    this.pool = null;
    this.children = null;
    this.renderer = null;
  }
}
AccessibilityManager.extension = {
  name: "accessibility",
  type: [
    ExtensionType.RendererPlugin,
    ExtensionType.CanvasRendererPlugin
  ]
};
extensions$1.add(AccessibilityManager);
const _Application = class {
  constructor(options) {
    this.stage = new Container();
    options = Object.assign({
      forceCanvas: false
    }, options);
    this.renderer = autoDetectRenderer(options);
    _Application._plugins.forEach((plugin) => {
      plugin.init.call(this, options);
    });
  }
  render() {
    this.renderer.render(this.stage);
  }
  get view() {
    return this.renderer.view;
  }
  get screen() {
    return this.renderer.screen;
  }
  destroy(removeView, stageOptions) {
    const plugins = _Application._plugins.slice(0);
    plugins.reverse();
    plugins.forEach((plugin) => {
      plugin.destroy.call(this);
    });
    this.stage.destroy(stageOptions);
    this.stage = null;
    this.renderer.destroy(removeView);
    this.renderer = null;
  }
};
let Application = _Application;
Application._plugins = [];
extensions$1.handleByList(ExtensionType.Application, Application._plugins);
class ResizePlugin {
  static init(options) {
    Object.defineProperty(this, "resizeTo", {
      set(dom) {
        globalThis.removeEventListener("resize", this.queueResize);
        this._resizeTo = dom;
        if (dom) {
          globalThis.addEventListener("resize", this.queueResize);
          this.resize();
        }
      },
      get() {
        return this._resizeTo;
      }
    });
    this.queueResize = () => {
      if (!this._resizeTo) {
        return;
      }
      this.cancelResize();
      this._resizeId = requestAnimationFrame(() => this.resize());
    };
    this.cancelResize = () => {
      if (this._resizeId) {
        cancelAnimationFrame(this._resizeId);
        this._resizeId = null;
      }
    };
    this.resize = () => {
      if (!this._resizeTo) {
        return;
      }
      this.cancelResize();
      let width;
      let height;
      if (this._resizeTo === globalThis.window) {
        width = globalThis.innerWidth;
        height = globalThis.innerHeight;
      } else {
        const { clientWidth, clientHeight } = this._resizeTo;
        width = clientWidth;
        height = clientHeight;
      }
      this.renderer.resize(width, height);
      this.render();
    };
    this._resizeId = null;
    this._resizeTo = null;
    this.resizeTo = options.resizeTo || null;
  }
  static destroy() {
    globalThis.removeEventListener("resize", this.queueResize);
    this.cancelResize();
    this.cancelResize = null;
    this.queueResize = null;
    this.resizeTo = null;
    this.resize = null;
  }
}
ResizePlugin.extension = ExtensionType.Application;
extensions$1.add(ResizePlugin);
const assetKeyMap = {
  loader: ExtensionType.LoadParser,
  resolver: ExtensionType.ResolveParser,
  cache: ExtensionType.CacheParser,
  detection: ExtensionType.DetectionParser
};
extensions$1.handle(ExtensionType.Asset, (extension) => {
  const ref = extension.ref;
  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions$1.add(Object.assign(ref[key], { extension: ref[key].extension ?? type })));
}, (extension) => {
  const ref = extension.ref;
  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions$1.remove(ref[key]));
});
class BackgroundLoader {
  constructor(loader, verbose = false) {
    this._loader = loader;
    this._assetList = [];
    this._isLoading = false;
    this._maxConcurrent = 1;
    this.verbose = verbose;
  }
  add(assetUrls) {
    assetUrls.forEach((a8) => {
      this._assetList.push(a8);
    });
    if (this.verbose)
      console.log("[BackgroundLoader] assets: ", this._assetList);
    if (this._isActive && !this._isLoading) {
      this._next();
    }
  }
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = true;
      const toLoad = [];
      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
      for (let i2 = 0; i2 < toLoadAmount; i2++) {
        toLoad.push(this._assetList.pop());
      }
      await this._loader.load(toLoad);
      this._isLoading = false;
      this._next();
    }
  }
  get active() {
    return this._isActive;
  }
  set active(value2) {
    if (this._isActive === value2)
      return;
    this._isActive = value2;
    if (value2 && !this._isLoading) {
      this._next();
    }
  }
}
function checkDataUrl(url2, mimes) {
  if (Array.isArray(mimes)) {
    for (const mime of mimes) {
      if (url2.startsWith(`data:${mime}`))
        return true;
    }
    return false;
  }
  return url2.startsWith(`data:${mimes}`);
}
function checkExtension(url2, extension) {
  const tempURL = url2.split("?")[0];
  const ext2 = path.extname(tempURL).toLowerCase();
  if (Array.isArray(extension)) {
    return extension.includes(ext2);
  }
  return ext2 === extension;
}
const convertToList = (input, transform) => {
  if (!Array.isArray(input)) {
    input = [input];
  }
  if (!transform) {
    return input;
  }
  return input.map((item) => {
    if (typeof item === "string") {
      return transform(item);
    }
    return item;
  });
};
const copySearchParams = (targetUrl, sourceUrl) => {
  const searchParams = sourceUrl.split("?")[1];
  if (searchParams) {
    targetUrl += `?${searchParams}`;
  }
  return targetUrl;
};
function processX(base2, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i2 = 0; i2 < id.length; i2++) {
    const value2 = id[i2];
    if (depth < ids.length - 1) {
      processX(base2.replace(result[depth], value2), ids, depth + 1, result, tags);
    } else {
      tags.push(base2.replace(result[depth], value2));
    }
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
}
const isSingleItem = (item) => !Array.isArray(item);
class CacheClass {
  constructor() {
    this._parsers = [];
    this._cache = /* @__PURE__ */ new Map();
    this._cacheMap = /* @__PURE__ */ new Map();
  }
  reset() {
    this._cacheMap.clear();
    this._cache.clear();
  }
  has(key) {
    return this._cache.has(key);
  }
  get(key) {
    const result = this._cache.get(key);
    if (!result) {
      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
    }
    return result;
  }
  set(key, value2) {
    const keys2 = convertToList(key);
    let cacheableAssets;
    for (let i2 = 0; i2 < this.parsers.length; i2++) {
      const parser2 = this.parsers[i2];
      if (parser2.test(value2)) {
        cacheableAssets = parser2.getCacheableAssets(keys2, value2);
        break;
      }
    }
    if (!cacheableAssets) {
      cacheableAssets = {};
      keys2.forEach((key2) => {
        cacheableAssets[key2] = value2;
      });
    }
    const cacheKeys = Object.keys(cacheableAssets);
    const cachedAssets = {
      cacheKeys,
      keys: keys2
    };
    keys2.forEach((key2) => {
      this._cacheMap.set(key2, cachedAssets);
    });
    cacheKeys.forEach((key2) => {
      if (this._cache.has(key2) && this._cache.get(key2) !== value2) {
        console.warn("[Cache] already has key:", key2);
      }
      this._cache.set(key2, cacheableAssets[key2]);
    });
    if (value2 instanceof Texture) {
      const texture = value2;
      keys2.forEach((key2) => {
        if (texture.baseTexture !== Texture.EMPTY.baseTexture) {
          BaseTexture.addToCache(texture.baseTexture, key2);
        }
        Texture.addToCache(texture, key2);
      });
    }
  }
  remove(key) {
    this._cacheMap.get(key);
    if (!this._cacheMap.has(key)) {
      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
      return;
    }
    const cacheMap = this._cacheMap.get(key);
    const cacheKeys = cacheMap.cacheKeys;
    cacheKeys.forEach((key2) => {
      this._cache.delete(key2);
    });
    cacheMap.keys.forEach((key2) => {
      this._cacheMap.delete(key2);
    });
  }
  get parsers() {
    return this._parsers;
  }
}
const Cache = new CacheClass();
class Loader {
  constructor() {
    this._parsers = [];
    this._parsersValidated = false;
    this.parsers = new Proxy(this._parsers, {
      set: (target, key, value2) => {
        this._parsersValidated = false;
        target[key] = value2;
        return true;
      }
    });
    this.promiseCache = {};
  }
  reset() {
    this._parsersValidated = false;
    this.promiseCache = {};
  }
  _getLoadPromiseAndParser(url2, data) {
    const result = {
      promise: null,
      parser: null
    };
    result.promise = (async () => {
      var _a, _b;
      let asset = null;
      let parser2 = null;
      if (data.loadParser) {
        parser2 = this._parserHash[data.loadParser];
        if (!parser2) {
          console.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url2}`);
        }
      }
      if (!parser2) {
        for (let i2 = 0; i2 < this.parsers.length; i2++) {
          const parserX = this.parsers[i2];
          if (parserX.load && ((_a = parserX.test) == null ? void 0 : _a.call(parserX, url2, data, this))) {
            parser2 = parserX;
            break;
          }
        }
        if (!parser2) {
          console.warn(`[Assets] ${url2} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
          return null;
        }
      }
      asset = await parser2.load(url2, data, this);
      result.parser = parser2;
      for (let i2 = 0; i2 < this.parsers.length; i2++) {
        const parser22 = this.parsers[i2];
        if (parser22.parse) {
          if (parser22.parse && await ((_b = parser22.testParse) == null ? void 0 : _b.call(parser22, asset, data, this))) {
            asset = await parser22.parse(asset, data, this) || asset;
            result.parser = parser22;
          }
        }
      }
      return asset;
    })();
    return result;
  }
  async load(assetsToLoadIn, onProgress) {
    if (!this._parsersValidated) {
      this._validateParsers();
    }
    let count = 0;
    const assets = {};
    const singleAsset = isSingleItem(assetsToLoadIn);
    const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
      src: item
    }));
    const total = assetsToLoad.length;
    const promises = assetsToLoad.map(async (asset) => {
      const url2 = path.toAbsolute(asset.src);
      if (!assets[asset.src]) {
        try {
          if (!this.promiseCache[url2]) {
            this.promiseCache[url2] = this._getLoadPromiseAndParser(url2, asset);
          }
          assets[asset.src] = await this.promiseCache[url2].promise;
          if (onProgress)
            onProgress(++count / total);
        } catch (e3) {
          delete this.promiseCache[url2];
          delete assets[asset.src];
          throw new Error(`[Loader.load] Failed to load ${url2}.
${e3}`);
        }
      }
    });
    await Promise.all(promises);
    return singleAsset ? assets[assetsToLoad[0].src] : assets;
  }
  async unload(assetsToUnloadIn) {
    const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({
      src: item
    }));
    const promises = assetsToUnload.map(async (asset) => {
      var _a, _b;
      const url2 = path.toAbsolute(asset.src);
      const loadPromise = this.promiseCache[url2];
      if (loadPromise) {
        const loadedAsset = await loadPromise.promise;
        (_b = (_a = loadPromise.parser) == null ? void 0 : _a.unload) == null ? void 0 : _b.call(_a, loadedAsset, asset, this);
        delete this.promiseCache[url2];
      }
    });
    await Promise.all(promises);
  }
  _validateParsers() {
    this._parsersValidated = true;
    this._parserHash = this._parsers.filter((parser2) => parser2.name).reduce((hash, parser2) => {
      if (hash[parser2.name]) {
        console.warn(`[Assets] loadParser name conflict "${parser2.name}"`);
      }
      return { ...hash, [parser2.name]: parser2 };
    }, {});
  }
}
var LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
  LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
  LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
  LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
  return LoaderParserPriority2;
})(LoaderParserPriority || {});
const validJSONExtension = ".json";
const validJSONMIME = "application/json";
const loadJson = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low
  },
  name: "loadJson",
  test(url2) {
    return checkDataUrl(url2, validJSONMIME) || checkExtension(url2, validJSONExtension);
  },
  async load(url2) {
    const response = await settings.ADAPTER.fetch(url2);
    const json = await response.json();
    return json;
  }
};
extensions$1.add(loadJson);
const validTXTExtension = ".txt";
const validTXTMIME = "text/plain";
const loadTxt = {
  name: "loadTxt",
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low
  },
  test(url2) {
    return checkDataUrl(url2, validTXTMIME) || checkExtension(url2, validTXTExtension);
  },
  async load(url2) {
    const response = await settings.ADAPTER.fetch(url2);
    const txt = await response.text();
    return txt;
  }
};
extensions$1.add(loadTxt);
const validWeights = [
  "normal",
  "bold",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900"
];
const validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
const validFontMIMEs = [
  "font/ttf",
  "font/otf",
  "font/woff",
  "font/woff2"
];
const CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function getFontFamilyName(url2) {
  const ext2 = path.extname(url2);
  const name = path.basename(url2, ext2);
  const nameWithSpaces = name.replace(/(-|_)/g, " ");
  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let valid = nameTokens.length > 0;
  for (const token of nameTokens) {
    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
      valid = false;
      break;
    }
  }
  let fontFamilyName = nameTokens.join(" ");
  if (!valid) {
    fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
  }
  return fontFamilyName;
}
const loadWebFont = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low
  },
  name: "loadWebFont",
  test(url2) {
    return checkDataUrl(url2, validFontMIMEs) || checkExtension(url2, validFontExtensions);
  },
  async load(url2, options) {
    var _a, _b, _c;
    const fonts = settings.ADAPTER.getFontFaceSet();
    if (fonts) {
      const fontFaces = [];
      const name = ((_a = options.data) == null ? void 0 : _a.family) ?? getFontFamilyName(url2);
      const weights = ((_c = (_b = options.data) == null ? void 0 : _b.weights) == null ? void 0 : _c.filter((weight) => validWeights.includes(weight))) ?? ["normal"];
      const data = options.data ?? {};
      for (let i2 = 0; i2 < weights.length; i2++) {
        const weight = weights[i2];
        const font = new FontFace(name, `url(${encodeURI(url2)})`, {
          ...data,
          weight
        });
        await font.load();
        fonts.add(font);
        fontFaces.push(font);
      }
      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
    }
    console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
    return null;
  },
  unload(font) {
    (Array.isArray(font) ? font : [font]).forEach((t2) => settings.ADAPTER.getFontFaceSet().delete(t2));
  }
};
extensions$1.add(loadWebFont);
let UUID = 0;
let MAX_WORKERS;
const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
const checkImageBitmapCode = {
  id: "checkImageBitmap",
  code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${WHITE_PNG}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
};
const workerCode = {
  id: "loadImageBitmap",
  code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
};
let workerURL;
class WorkerManagerClass {
  constructor() {
    this._initialized = false;
    this._createdWorkers = 0;
    this.workerPool = [];
    this.queue = [];
    this.resolveHash = {};
  }
  isImageBitmapSupported() {
    if (this._isImageBitmapSupported !== void 0)
      return this._isImageBitmapSupported;
    this._isImageBitmapSupported = new Promise((resolve2) => {
      const workerURL2 = URL.createObjectURL(new Blob([checkImageBitmapCode.code], { type: "application/javascript" }));
      const worker = new Worker(workerURL2);
      worker.addEventListener("message", (event) => {
        worker.terminate();
        URL.revokeObjectURL(workerURL2);
        resolve2(event.data);
      });
    });
    return this._isImageBitmapSupported;
  }
  loadImageBitmap(src) {
    return this._run("loadImageBitmap", [src]);
  }
  async _initWorkers() {
    if (this._initialized)
      return;
    this._initialized = true;
  }
  getWorker() {
    if (MAX_WORKERS === void 0) {
      MAX_WORKERS = navigator.hardwareConcurrency || 4;
    }
    let worker = this.workerPool.pop();
    if (!worker && this._createdWorkers < MAX_WORKERS) {
      if (!workerURL) {
        workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }));
      }
      this._createdWorkers++;
      worker = new Worker(workerURL);
      worker.addEventListener("message", (event) => {
        this.complete(event.data);
        this.returnWorker(event.target);
        this.next();
      });
    }
    return worker;
  }
  returnWorker(worker) {
    this.workerPool.push(worker);
  }
  complete(data) {
    if (data.error !== void 0) {
      this.resolveHash[data.uuid].reject(data.error);
    } else {
      this.resolveHash[data.uuid].resolve(data.data);
    }
    this.resolveHash[data.uuid] = null;
  }
  async _run(id, args) {
    await this._initWorkers();
    const promise = new Promise((resolve2, reject) => {
      this.queue.push({ id, arguments: args, resolve: resolve2, reject });
    });
    this.next();
    return promise;
  }
  next() {
    if (!this.queue.length)
      return;
    const worker = this.getWorker();
    if (!worker) {
      return;
    }
    const toDo = this.queue.pop();
    const id = toDo.id;
    this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
    worker.postMessage({
      data: toDo.arguments,
      uuid: UUID++,
      id
    });
  }
}
const WorkerManager = new WorkerManagerClass();
function createTexture(base2, loader, url2) {
  const texture = new Texture(base2);
  texture.baseTexture.on("dispose", () => {
    delete loader.promiseCache[url2];
  });
  return texture;
}
const validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
const validImageMIMEs = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/avif"
];
async function loadImageBitmap(url2) {
  const response = await settings.ADAPTER.fetch(url2);
  if (!response.ok) {
    throw new Error(`[loadImageBitmap] Failed to fetch ${url2}: ${response.status} ${response.statusText}`);
  }
  const imageBlob = await response.blob();
  const imageBitmap = await createImageBitmap(imageBlob);
  return imageBitmap;
}
const loadTextures = {
  name: "loadTextures",
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  config: {
    preferWorkers: true,
    preferCreateImageBitmap: true,
    crossOrigin: "anonymous"
  },
  test(url2) {
    return checkDataUrl(url2, validImageMIMEs) || checkExtension(url2, validImageExtensions);
  },
  async load(url2, asset, loader) {
    let src = null;
    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
      if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {
        src = await WorkerManager.loadImageBitmap(url2);
      } else {
        src = await loadImageBitmap(url2);
      }
    } else {
      src = await new Promise((resolve2) => {
        src = new Image();
        src.crossOrigin = this.config.crossOrigin;
        src.src = url2;
        if (src.complete) {
          resolve2(src);
        } else {
          src.onload = () => {
            resolve2(src);
          };
        }
      });
    }
    const base2 = new BaseTexture(src, {
      resolution: getResolutionOfUrl(url2),
      ...asset.data
    });
    base2.resource.src = url2;
    return createTexture(base2, loader, url2);
  },
  unload(texture) {
    texture.destroy(true);
  }
};
extensions$1.add(loadTextures);
const validSVGExtension = ".svg";
const validSVGMIME = "image/svg+xml";
const loadSVG = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  name: "loadSVG",
  test(url2) {
    return checkDataUrl(url2, validSVGMIME) || checkExtension(url2, validSVGExtension);
  },
  async testParse(data) {
    return SVGResource.test(data);
  },
  async parse(asset, data, loader) {
    var _a;
    const src = new SVGResource(asset, (_a = data == null ? void 0 : data.data) == null ? void 0 : _a.resourceOptions);
    await src.load();
    const base2 = new BaseTexture(src, {
      resolution: getResolutionOfUrl(asset),
      ...data == null ? void 0 : data.data
    });
    base2.resource.src = asset;
    const texture = createTexture(base2, loader, asset);
    return texture;
  },
  async load(url2, _options) {
    const response = await settings.ADAPTER.fetch(url2);
    return response.text();
  },
  unload: loadTextures.unload
};
extensions$1.add(loadSVG);
class Resolver {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
    };
    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
    this._assetMap = {};
    this._preferredOrder = [];
    this._parsers = [];
    this._resolverHash = {};
    this._bundles = {};
  }
  setBundleIdentifier(bundleIdentifier) {
    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
    if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
  }
  prefer(...preferOrders) {
    preferOrders.forEach((prefer) => {
      this._preferredOrder.push(prefer);
      if (!prefer.priority) {
        prefer.priority = Object.keys(prefer.params);
      }
    });
    this._resolverHash = {};
  }
  set basePath(basePath) {
    this._basePath = basePath;
  }
  get basePath() {
    return this._basePath;
  }
  set rootPath(rootPath) {
    this._rootPath = rootPath;
  }
  get rootPath() {
    return this._rootPath;
  }
  get parsers() {
    return this._parsers;
  }
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
    this._assetMap = {};
    this._preferredOrder = [];
    this._resolverHash = {};
    this._rootPath = null;
    this._basePath = null;
    this._manifest = null;
    this._bundles = {};
    this._defaultSearchParams = null;
  }
  setDefaultSearchParams(searchParams) {
    if (typeof searchParams === "string") {
      this._defaultSearchParams = searchParams;
    } else {
      const queryValues = searchParams;
      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
    }
  }
  addManifest(manifest) {
    if (this._manifest) {
      console.warn("[Resolver] Manifest already exists, this will be overwritten");
    }
    this._manifest = manifest;
    manifest.bundles.forEach((bundle) => {
      this.addBundle(bundle.name, bundle.assets);
    });
  }
  addBundle(bundleId, assets) {
    const assetNames = [];
    if (Array.isArray(assets)) {
      assets.forEach((asset) => {
        if (typeof asset.name === "string") {
          const bundleAssetId = this._createBundleAssetId(bundleId, asset.name);
          assetNames.push(bundleAssetId);
          this.add([asset.name, bundleAssetId], asset.srcs, asset.data);
        } else {
          const bundleIds = asset.name.map((name) => this._createBundleAssetId(bundleId, name));
          bundleIds.forEach((bundleId2) => {
            assetNames.push(bundleId2);
          });
          this.add([...asset.name, ...bundleIds], asset.srcs);
        }
      });
    } else {
      Object.keys(assets).forEach((key) => {
        assetNames.push(this._createBundleAssetId(bundleId, key));
        this.add([key, this._createBundleAssetId(bundleId, key)], assets[key]);
      });
    }
    this._bundles[bundleId] = assetNames;
  }
  add(keysIn, assetsIn, data) {
    const keys2 = convertToList(keysIn);
    keys2.forEach((key) => {
      if (this.hasKey(key)) {
        console.warn(`[Resolver] already has key: ${key} overwriting`);
      }
    });
    if (!Array.isArray(assetsIn)) {
      if (typeof assetsIn === "string") {
        assetsIn = createStringVariations(assetsIn);
      } else {
        assetsIn = [assetsIn];
      }
    }
    const assetMap = assetsIn.map((asset) => {
      let formattedAsset = asset;
      if (typeof asset === "string") {
        let parsed = false;
        for (let i2 = 0; i2 < this._parsers.length; i2++) {
          const parser2 = this._parsers[i2];
          if (parser2.test(asset)) {
            formattedAsset = parser2.parse(asset);
            parsed = true;
            break;
          }
        }
        if (!parsed) {
          formattedAsset = {
            src: asset
          };
        }
      }
      if (!formattedAsset.format) {
        formattedAsset.format = formattedAsset.src.split(".").pop();
      }
      if (!formattedAsset.alias) {
        formattedAsset.alias = keys2;
      }
      if (this._basePath || this._rootPath) {
        formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
      }
      formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
      formattedAsset.data = formattedAsset.data ?? data;
      return formattedAsset;
    });
    keys2.forEach((key) => {
      this._assetMap[key] = assetMap;
    });
  }
  resolveBundle(bundleIds) {
    const singleAsset = isSingleItem(bundleIds);
    bundleIds = convertToList(bundleIds);
    const out = {};
    bundleIds.forEach((bundleId) => {
      const assetNames = this._bundles[bundleId];
      if (assetNames) {
        const results = this.resolve(assetNames);
        const assets = {};
        for (const key in results) {
          const asset = results[key];
          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
        }
        out[bundleId] = assets;
      }
    });
    return singleAsset ? out[bundleIds[0]] : out;
  }
  resolveUrl(key) {
    const result = this.resolve(key);
    if (typeof key !== "string") {
      const out = {};
      for (const i2 in result) {
        out[i2] = result[i2].src;
      }
      return out;
    }
    return result.src;
  }
  resolve(keys2) {
    const singleAsset = isSingleItem(keys2);
    keys2 = convertToList(keys2);
    const result = {};
    keys2.forEach((key) => {
      if (!this._resolverHash[key]) {
        if (this._assetMap[key]) {
          let assets = this._assetMap[key];
          const preferredOrder = this._getPreferredOrder(assets);
          const bestAsset = assets[0];
          preferredOrder == null ? void 0 : preferredOrder.priority.forEach((priorityKey) => {
            preferredOrder.params[priorityKey].forEach((value2) => {
              const filteredAssets = assets.filter((asset) => {
                if (asset[priorityKey]) {
                  return asset[priorityKey] === value2;
                }
                return false;
              });
              if (filteredAssets.length) {
                assets = filteredAssets;
              }
            });
          });
          this._resolverHash[key] = assets[0] ?? bestAsset;
        } else {
          let src = key;
          if (this._basePath || this._rootPath) {
            src = path.toAbsolute(src, this._basePath, this._rootPath);
          }
          src = this._appendDefaultSearchParams(src);
          this._resolverHash[key] = {
            src
          };
        }
      }
      result[key] = this._resolverHash[key];
    });
    return singleAsset ? result[keys2[0]] : result;
  }
  hasKey(key) {
    return !!this._assetMap[key];
  }
  hasBundle(key) {
    return !!this._bundles[key];
  }
  _getPreferredOrder(assets) {
    for (let i2 = 0; i2 < assets.length; i2++) {
      const asset = assets[0];
      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
      if (preferred) {
        return preferred;
      }
    }
    return this._preferredOrder[0];
  }
  _appendDefaultSearchParams(url2) {
    if (!this._defaultSearchParams)
      return url2;
    const paramConnector = /\?/.test(url2) ? "&" : "?";
    return `${url2}${paramConnector}${this._defaultSearchParams}`;
  }
}
class AssetsClass {
  constructor() {
    this._detections = [];
    this._initialized = false;
    this.resolver = new Resolver();
    this.loader = new Loader();
    this.cache = Cache;
    this._backgroundLoader = new BackgroundLoader(this.loader);
    this._backgroundLoader.active = true;
    this.reset();
  }
  async init(options = {}) {
    var _a, _b, _c;
    if (this._initialized) {
      console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
      return;
    }
    this._initialized = true;
    if (options.defaultSearchParams) {
      this.resolver.setDefaultSearchParams(options.defaultSearchParams);
    }
    if (options.basePath) {
      this.resolver.basePath = options.basePath;
    }
    if (options.bundleIdentifier) {
      this.resolver.setBundleIdentifier(options.bundleIdentifier);
    }
    if (options.manifest) {
      let manifest = options.manifest;
      if (typeof manifest === "string") {
        manifest = await this.load(manifest);
      }
      this.resolver.addManifest(manifest);
    }
    const resolutionPref = ((_a = options.texturePreference) == null ? void 0 : _a.resolution) ?? 1;
    const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
    let formats2 = [];
    if ((_b = options.texturePreference) == null ? void 0 : _b.format) {
      const formatPref = (_c = options.texturePreference) == null ? void 0 : _c.format;
      formats2 = typeof formatPref === "string" ? [formatPref] : formatPref;
      for (const detection of this._detections) {
        if (!await detection.test()) {
          formats2 = await detection.remove(formats2);
        }
      }
    } else {
      for (const detection of this._detections) {
        if (await detection.test()) {
          formats2 = await detection.add(formats2);
        }
      }
    }
    this.resolver.prefer({
      params: {
        format: formats2,
        resolution
      }
    });
    if (options.preferences) {
      this.setPreferences(options.preferences);
    }
  }
  add(keysIn, assetsIn, data) {
    this.resolver.add(keysIn, assetsIn, data);
  }
  async load(urls, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    const singleAsset = isSingleItem(urls);
    const urlArray = convertToList(urls).map((url2) => {
      if (typeof url2 !== "string") {
        this.resolver.add(url2.src, url2);
        return url2.src;
      }
      if (!this.resolver.hasKey(url2)) {
        this.resolver.add(url2, url2);
      }
      return url2;
    });
    const resolveResults = this.resolver.resolve(urlArray);
    const out = await this._mapLoadToResolve(resolveResults, onProgress);
    return singleAsset ? out[urlArray[0]] : out;
  }
  addBundle(bundleId, assets) {
    this.resolver.addBundle(bundleId, assets);
  }
  async loadBundle(bundleIds, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    let singleAsset = false;
    if (typeof bundleIds === "string") {
      singleAsset = true;
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const out = {};
    const keys2 = Object.keys(resolveResults);
    let count = 0;
    let total = 0;
    const _onProgress = () => {
      onProgress == null ? void 0 : onProgress(++count / total);
    };
    const promises = keys2.map((bundleId) => {
      const resolveResult = resolveResults[bundleId];
      total += Object.keys(resolveResult).length;
      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
        out[bundleId] = resolveResult2;
      });
    });
    await Promise.all(promises);
    return singleAsset ? out[bundleIds[0]] : out;
  }
  async backgroundLoad(urls) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof urls === "string") {
      urls = [urls];
    }
    const resolveResults = this.resolver.resolve(urls);
    this._backgroundLoader.add(Object.values(resolveResults));
  }
  async backgroundLoadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof bundleIds === "string") {
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    Object.values(resolveResults).forEach((resolveResult) => {
      this._backgroundLoader.add(Object.values(resolveResult));
    });
  }
  reset() {
    this.resolver.reset();
    this.loader.reset();
    this.cache.reset();
    this._initialized = false;
  }
  get(keys2) {
    if (typeof keys2 === "string") {
      return Cache.get(keys2);
    }
    const assets = {};
    for (let i2 = 0; i2 < keys2.length; i2++) {
      assets[i2] = Cache.get(keys2[i2]);
    }
    return assets;
  }
  async _mapLoadToResolve(resolveResults, onProgress) {
    const resolveArray = Object.values(resolveResults);
    const resolveKeys = Object.keys(resolveResults);
    this._backgroundLoader.active = false;
    const loadedAssets = await this.loader.load(resolveArray, onProgress);
    this._backgroundLoader.active = true;
    const out = {};
    resolveArray.forEach((resolveResult, i2) => {
      const asset = loadedAssets[resolveResult.src];
      const keys2 = [resolveResult.src];
      if (resolveResult.alias) {
        keys2.push(...resolveResult.alias);
      }
      out[resolveKeys[i2]] = asset;
      Cache.set(keys2, asset);
    });
    return out;
  }
  async unload(urls) {
    if (!this._initialized) {
      await this.init();
    }
    const urlArray = convertToList(urls).map((url2) => typeof url2 !== "string" ? url2.src : url2);
    const resolveResults = this.resolver.resolve(urlArray);
    await this._unloadFromResolved(resolveResults);
  }
  async unloadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    bundleIds = convertToList(bundleIds);
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
    await Promise.all(promises);
  }
  async _unloadFromResolved(resolveResult) {
    const resolveArray = Object.values(resolveResult);
    resolveArray.forEach((resolveResult2) => {
      Cache.remove(resolveResult2.src);
    });
    await this.loader.unload(resolveArray);
  }
  get detections() {
    return this._detections;
  }
  get preferWorkers() {
    return loadTextures.config.preferWorkers;
  }
  set preferWorkers(value2) {
    deprecation("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead.");
    this.setPreferences({ preferWorkers: value2 });
  }
  setPreferences(preferences) {
    this.loader.parsers.forEach((parser2) => {
      if (!parser2.config)
        return;
      Object.keys(parser2.config).filter((key) => key in preferences).forEach((key) => {
        parser2.config[key] = preferences[key];
      });
    });
  }
}
const Assets = new AssetsClass();
extensions$1.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);
const cacheTextureArray = {
  extension: ExtensionType.CacheParser,
  test: (asset) => Array.isArray(asset) && asset.every((t2) => t2 instanceof Texture),
  getCacheableAssets: (keys2, asset) => {
    const out = {};
    keys2.forEach((key) => {
      asset.forEach((item, i2) => {
        out[key + (i2 === 0 ? "" : i2 + 1)] = item;
      });
    });
    return out;
  }
};
extensions$1.add(cacheTextureArray);
const detectAvif = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 1
  },
  test: async () => {
    if (!globalThis.createImageBitmap)
      return false;
    const avifData = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
    const blob = await settings.ADAPTER.fetch(avifData).then((r2) => r2.blob());
    return createImageBitmap(blob).then(() => true, () => false);
  },
  add: async (formats2) => [...formats2, "avif"],
  remove: async (formats2) => formats2.filter((f3) => f3 !== "avif")
};
extensions$1.add(detectAvif);
const detectWebp = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => {
    if (!globalThis.createImageBitmap)
      return false;
    const webpData = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=";
    const blob = await settings.ADAPTER.fetch(webpData).then((r2) => r2.blob());
    return createImageBitmap(blob).then(() => true, () => false);
  },
  add: async (formats2) => [...formats2, "webp"],
  remove: async (formats2) => formats2.filter((f3) => f3 !== "webp")
};
extensions$1.add(detectWebp);
const imageFormats = ["png", "jpg", "jpeg"];
const detectDefaults = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: -1
  },
  test: () => Promise.resolve(true),
  add: async (formats2) => [...formats2, ...imageFormats],
  remove: async (formats2) => formats2.filter((f3) => !imageFormats.includes(f3))
};
extensions$1.add(detectDefaults);
const resolveTextureUrl = {
  extension: ExtensionType.ResolveParser,
  test: loadTextures.test,
  parse: (value2) => {
    var _a;
    return {
      resolution: parseFloat(((_a = settings.RETINA_PREFIX.exec(value2)) == null ? void 0 : _a[1]) ?? "1"),
      format: value2.split(".").pop(),
      src: value2
    };
  }
};
extensions$1.add(resolveTextureUrl);
var INTERNAL_FORMATS = /* @__PURE__ */ ((INTERNAL_FORMATS2) => {
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
  return INTERNAL_FORMATS2;
})(INTERNAL_FORMATS || {});
const INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
  [
    33776
    /* COMPRESSED_RGB_S3TC_DXT1_EXT */
  ]: 0.5,
  [
    33777
    /* COMPRESSED_RGBA_S3TC_DXT1_EXT */
  ]: 0.5,
  [
    33778
    /* COMPRESSED_RGBA_S3TC_DXT3_EXT */
  ]: 1,
  [
    33779
    /* COMPRESSED_RGBA_S3TC_DXT5_EXT */
  ]: 1,
  [
    35916
    /* COMPRESSED_SRGB_S3TC_DXT1_EXT */
  ]: 0.5,
  [
    35917
    /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */
  ]: 0.5,
  [
    35918
    /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */
  ]: 1,
  [
    35919
    /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */
  ]: 1,
  [
    37488
    /* COMPRESSED_R11_EAC */
  ]: 0.5,
  [
    37489
    /* COMPRESSED_SIGNED_R11_EAC */
  ]: 0.5,
  [
    37490
    /* COMPRESSED_RG11_EAC */
  ]: 1,
  [
    37491
    /* COMPRESSED_SIGNED_RG11_EAC */
  ]: 1,
  [
    37492
    /* COMPRESSED_RGB8_ETC2 */
  ]: 0.5,
  [
    37496
    /* COMPRESSED_RGBA8_ETC2_EAC */
  ]: 1,
  [
    37493
    /* COMPRESSED_SRGB8_ETC2 */
  ]: 0.5,
  [
    37497
    /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */
  ]: 1,
  [
    37494
    /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
  ]: 0.5,
  [
    37495
    /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
  ]: 0.5,
  [
    35840
    /* COMPRESSED_RGB_PVRTC_4BPPV1_IMG */
  ]: 0.5,
  [
    35842
    /* COMPRESSED_RGBA_PVRTC_4BPPV1_IMG */
  ]: 0.5,
  [
    35841
    /* COMPRESSED_RGB_PVRTC_2BPPV1_IMG */
  ]: 0.25,
  [
    35843
    /* COMPRESSED_RGBA_PVRTC_2BPPV1_IMG */
  ]: 0.25,
  [
    36196
    /* COMPRESSED_RGB_ETC1_WEBGL */
  ]: 0.5,
  [
    35986
    /* COMPRESSED_RGB_ATC_WEBGL */
  ]: 0.5,
  [
    35986
    /* COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL */
  ]: 1,
  [
    34798
    /* COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL */
  ]: 1,
  [
    37808
    /* COMPRESSED_RGBA_ASTC_4x4_KHR */
  ]: 1
};
let storedGl;
let extensions;
function getCompressedTextureExtensions() {
  extensions = {
    s3tc: storedGl.getExtension("WEBGL_compressed_texture_s3tc"),
    s3tc_sRGB: storedGl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
    etc: storedGl.getExtension("WEBGL_compressed_texture_etc"),
    etc1: storedGl.getExtension("WEBGL_compressed_texture_etc1"),
    pvrtc: storedGl.getExtension("WEBGL_compressed_texture_pvrtc") || storedGl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
    atc: storedGl.getExtension("WEBGL_compressed_texture_atc"),
    astc: storedGl.getExtension("WEBGL_compressed_texture_astc")
  };
}
const detectCompressedTextures = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 2
  },
  test: async () => {
    const canvas = settings.ADAPTER.createCanvas();
    const gl = canvas.getContext("webgl");
    if (!gl) {
      console.warn("WebGL not available for compressed textures.");
      return false;
    }
    storedGl = gl;
    return true;
  },
  add: async (formats2) => {
    if (!extensions)
      getCompressedTextureExtensions();
    const textureFormats = [];
    for (const extensionName in extensions) {
      const extension = extensions[extensionName];
      if (!extension) {
        continue;
      }
      textureFormats.push(extensionName);
    }
    return [...textureFormats, ...formats2];
  },
  remove: async (formats2) => {
    if (!extensions)
      getCompressedTextureExtensions();
    return formats2.filter((f3) => !(f3 in extensions));
  }
};
extensions$1.add(detectCompressedTextures);
class BlobResource extends BufferResource {
  constructor(source, options = { width: 1, height: 1, autoLoad: true }) {
    let origin;
    let data;
    if (typeof source === "string") {
      origin = source;
      data = new Uint8Array();
    } else {
      origin = null;
      data = source;
    }
    super(data, options);
    this.origin = origin;
    this.buffer = data ? new ViewableBuffer(data) : null;
    this._load = null;
    this.loaded = false;
    if (this.origin !== null && options.autoLoad !== false) {
      this.load();
    }
    if (this.origin === null && this.buffer) {
      this._load = Promise.resolve(this);
      this.loaded = true;
      this.onBlobLoaded(this.buffer.rawBinaryData);
    }
  }
  onBlobLoaded(_data) {
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = fetch(this.origin).then((response) => response.blob()).then((blob) => blob.arrayBuffer()).then((arrayBuffer) => {
      this.data = new Uint32Array(arrayBuffer);
      this.buffer = new ViewableBuffer(arrayBuffer);
      this.loaded = true;
      this.onBlobLoaded(arrayBuffer);
      this.update();
      return this;
    });
    return this._load;
  }
}
class CompressedTextureResource extends BlobResource {
  constructor(source, options) {
    super(source, options);
    this.format = options.format;
    this.levels = options.levels || 1;
    this._width = options.width;
    this._height = options.height;
    this._extension = CompressedTextureResource._formatToExtension(this.format);
    if (options.levelBuffers || this.buffer) {
      this._levelBuffers = options.levelBuffers || CompressedTextureResource._createLevelBuffers(source instanceof Uint8Array ? source : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
    }
  }
  upload(renderer2, _texture, _glTexture) {
    const gl = renderer2.gl;
    const extension = renderer2.context.extensions[this._extension];
    if (!extension) {
      throw new Error(`${this._extension} textures are not supported on the current machine`);
    }
    if (!this._levelBuffers) {
      return false;
    }
    for (let i2 = 0, j2 = this.levels; i2 < j2; i2++) {
      const { levelID, levelWidth, levelHeight, levelBuffer } = this._levelBuffers[i2];
      gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
    }
    return true;
  }
  onBlobLoaded() {
    this._levelBuffers = CompressedTextureResource._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
  }
  static _formatToExtension(format2) {
    if (format2 >= 33776 && format2 <= 33779) {
      return "s3tc";
    } else if (format2 >= 37488 && format2 <= 37497) {
      return "etc";
    } else if (format2 >= 35840 && format2 <= 35843) {
      return "pvrtc";
    } else if (format2 >= 36196) {
      return "etc1";
    } else if (format2 >= 35986 && format2 <= 34798) {
      return "atc";
    }
    throw new Error("Invalid (compressed) texture format given!");
  }
  static _createLevelBuffers(buffer2, format2, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
    const buffers = new Array(levels);
    let offset = buffer2.byteOffset;
    let levelWidth = imageWidth;
    let levelHeight = imageHeight;
    let alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
    let alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
    let levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
    for (let i2 = 0; i2 < levels; i2++) {
      buffers[i2] = {
        levelID: i2,
        levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
        levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
        levelBuffer: new Uint8Array(buffer2.buffer, offset, levelSize)
      };
      offset += levelSize;
      levelWidth = levelWidth >> 1 || 1;
      levelHeight = levelHeight >> 1 || 1;
      alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
      alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
      levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
    }
    return buffers;
  }
}
const DDS_MAGIC_SIZE = 4;
const DDS_HEADER_SIZE = 124;
const DDS_HEADER_PF_SIZE = 32;
const DDS_HEADER_DX10_SIZE = 20;
const DDS_MAGIC = 542327876;
const DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
};
const DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
};
const DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
};
const PF_FLAGS = 1;
const DDPF_ALPHA = 2;
const DDPF_FOURCC = 4;
const DDPF_RGB = 64;
const DDPF_YUV = 512;
const DDPF_LUMINANCE = 131072;
const FOURCC_DXT1 = 827611204;
const FOURCC_DXT3 = 861165636;
const FOURCC_DXT5 = 894720068;
const FOURCC_DX10 = 808540228;
const DDS_RESOURCE_MISC_TEXTURECUBE = 4;
const FOURCC_TO_FORMAT = {
  [FOURCC_DXT1]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [FOURCC_DXT3]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [FOURCC_DXT5]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT
};
const DXGI_TO_FORMAT = {
  [
    70
    /* DXGI_FORMAT_BC1_TYPELESS */
  ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [
    71
    /* DXGI_FORMAT_BC1_UNORM */
  ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [
    73
    /* DXGI_FORMAT_BC2_TYPELESS */
  ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [
    74
    /* DXGI_FORMAT_BC2_UNORM */
  ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [
    76
    /* DXGI_FORMAT_BC3_TYPELESS */
  ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  [
    77
    /* DXGI_FORMAT_BC3_UNORM */
  ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  [
    72
    /* DXGI_FORMAT_BC1_UNORM_SRGB */
  ]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
  [
    75
    /* DXGI_FORMAT_BC2_UNORM_SRGB */
  ]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
  [
    78
    /* DXGI_FORMAT_BC3_UNORM_SRGB */
  ]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
};
function parseDDS(arrayBuffer) {
  const data = new Uint32Array(arrayBuffer);
  const magicWord = data[0];
  if (magicWord !== DDS_MAGIC) {
    throw new Error("Invalid DDS file magic word");
  }
  const header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  const height = header[DDS_FIELDS.HEIGHT];
  const width = header[DDS_FIELDS.WIDTH];
  const mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];
  const pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  const formatFlags = pixelFormat[PF_FLAGS];
  if (formatFlags & DDPF_FOURCC) {
    const fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
    if (fourCC !== FOURCC_DX10) {
      const internalFormat2 = FOURCC_TO_FORMAT[fourCC];
      const dataOffset2 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
      const texData = new Uint8Array(arrayBuffer, dataOffset2);
      const resource = new CompressedTextureResource(texData, {
        format: internalFormat2,
        width,
        height,
        levels: mipmapCount
      });
      return [resource];
    }
    const dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
    const dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    const dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];
    const resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];
    const miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];
    const arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];
    const internalFormat = DXGI_TO_FORMAT[dxgiFormat];
    if (internalFormat === void 0) {
      throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);
    }
    if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {
      throw new Error("DDSParser does not support cubemap textures");
    }
    if (resourceDimension === 6) {
      throw new Error("DDSParser does not supported 3D texture data");
    }
    const imageBuffers = new Array();
    const dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
    if (arraySize === 1) {
      imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
    } else {
      const pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat];
      let imageSize = 0;
      let levelWidth = width;
      let levelHeight = height;
      for (let i2 = 0; i2 < mipmapCount; i2++) {
        const alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);
        const alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);
        const levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
        imageSize += levelSize;
        levelWidth = levelWidth >>> 1;
        levelHeight = levelHeight >>> 1;
      }
      let imageOffset = dataOffset;
      for (let i2 = 0; i2 < arraySize; i2++) {
        imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));
        imageOffset += imageSize;
      }
    }
    return imageBuffers.map((buffer2) => new CompressedTextureResource(buffer2, {
      format: internalFormat,
      width,
      height,
      levels: mipmapCount
    }));
  }
  if (formatFlags & DDPF_RGB) {
    throw new Error("DDSParser does not support uncompressed texture data.");
  }
  if (formatFlags & DDPF_YUV) {
    throw new Error("DDSParser does not supported YUV uncompressed texture data.");
  }
  if (formatFlags & DDPF_LUMINANCE) {
    throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
  }
  if (formatFlags & DDPF_ALPHA) {
    throw new Error("DDSParser does not support single-channel (alpha) texture data!");
  }
  throw new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
const FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
const ENDIANNESS = 67305985;
const KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
};
const FILE_HEADER_SIZE = 64;
const TYPES_TO_BYTES_PER_COMPONENT = {
  [TYPES.UNSIGNED_BYTE]: 1,
  [TYPES.UNSIGNED_SHORT]: 2,
  [TYPES.INT]: 4,
  [TYPES.UNSIGNED_INT]: 4,
  [TYPES.FLOAT]: 4,
  [TYPES.HALF_FLOAT]: 8
};
const FORMATS_TO_COMPONENTS = {
  [FORMATS.RGBA]: 4,
  [FORMATS.RGB]: 3,
  [FORMATS.RG]: 2,
  [FORMATS.RED]: 1,
  [FORMATS.LUMINANCE]: 1,
  [FORMATS.LUMINANCE_ALPHA]: 2,
  [FORMATS.ALPHA]: 1
};
const TYPES_TO_BYTES_PER_PIXEL = {
  [TYPES.UNSIGNED_SHORT_4_4_4_4]: 2,
  [TYPES.UNSIGNED_SHORT_5_5_5_1]: 2,
  [TYPES.UNSIGNED_SHORT_5_6_5]: 2
};
function parseKTX(url2, arrayBuffer, loadKeyValueData = false) {
  const dataView = new DataView(arrayBuffer);
  if (!validate(url2, dataView)) {
    return null;
  }
  const littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;
  const glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);
  const glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);
  const glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);
  const pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);
  const pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
  const pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;
  const numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
  const numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);
  const numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
  const bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
  if (pixelHeight === 0 || pixelDepth !== 1) {
    throw new Error("Only 2D textures are supported");
  }
  if (numberOfFaces !== 1) {
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  }
  if (numberOfArrayElements !== 1) {
    throw new Error("WebGL does not support array textures");
  }
  const blockWidth = 4;
  const blockHeight = 4;
  const alignedWidth = pixelWidth + 3 & ~3;
  const alignedHeight = pixelHeight + 3 & ~3;
  const imageBuffers = new Array(numberOfArrayElements);
  let imagePixels = pixelWidth * pixelHeight;
  if (glType === 0) {
    imagePixels = alignedWidth * alignedHeight;
  }
  let imagePixelByteSize;
  if (glType !== 0) {
    if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {
      imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];
    } else {
      imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];
    }
  } else {
    imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
  }
  if (imagePixelByteSize === void 0) {
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  }
  const kvData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;
  const imageByteSize = imagePixels * imagePixelByteSize;
  let mipByteSize = imageByteSize;
  let mipWidth = pixelWidth;
  let mipHeight = pixelHeight;
  let alignedMipWidth = alignedWidth;
  let alignedMipHeight = alignedHeight;
  let imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
  for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
    const imageSize = dataView.getUint32(imageOffset, littleEndian);
    let elementOffset = imageOffset + 4;
    for (let arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
      let mips = imageBuffers[arrayElement];
      if (!mips) {
        mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);
      }
      mips[mipmapLevel] = {
        levelID: mipmapLevel,
        levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,
        levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,
        levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
      };
      elementOffset += mipByteSize;
    }
    imageOffset += imageSize + 4;
    imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
    mipWidth = mipWidth >> 1 || 1;
    mipHeight = mipHeight >> 1 || 1;
    alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);
    alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);
    mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
  }
  if (glType !== 0) {
    return {
      uncompressed: imageBuffers.map((levelBuffers) => {
        let buffer2 = levelBuffers[0].levelBuffer;
        let convertToInt = false;
        if (glType === TYPES.FLOAT) {
          buffer2 = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === TYPES.UNSIGNED_INT) {
          convertToInt = true;
          buffer2 = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === TYPES.INT) {
          convertToInt = true;
          buffer2 = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        }
        return {
          resource: new BufferResource(buffer2, {
            width: levelBuffers[0].levelWidth,
            height: levelBuffers[0].levelHeight
          }),
          type: glType,
          format: convertToInt ? convertFormatToInteger(glFormat) : glFormat
        };
      }),
      kvData
    };
  }
  return {
    compressed: imageBuffers.map((levelBuffers) => new CompressedTextureResource(null, {
      format: glInternalFormat,
      width: pixelWidth,
      height: pixelHeight,
      levels: numberOfMipmapLevels,
      levelBuffers
    })),
    kvData
  };
}
function validate(url2, dataView) {
  for (let i2 = 0; i2 < FILE_IDENTIFIER.length; i2++) {
    if (dataView.getUint8(i2) !== FILE_IDENTIFIER[i2]) {
      console.error(`${url2} is not a valid *.ktx file!`);
      return false;
    }
  }
  return true;
}
function convertFormatToInteger(format2) {
  switch (format2) {
    case FORMATS.RGBA:
      return FORMATS.RGBA_INTEGER;
    case FORMATS.RGB:
      return FORMATS.RGB_INTEGER;
    case FORMATS.RG:
      return FORMATS.RG_INTEGER;
    case FORMATS.RED:
      return FORMATS.RED_INTEGER;
    default:
      return format2;
  }
}
function parseKvData(dataView, bytesOfKeyValueData, littleEndian) {
  const kvData = /* @__PURE__ */ new Map();
  let bytesIntoKeyValueData = 0;
  while (bytesIntoKeyValueData < bytesOfKeyValueData) {
    const keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian);
    const keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4;
    const valuePadding = 3 - (keyAndValueByteSize + 3) % 4;
    if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    let keyNulByte = 0;
    for (; keyNulByte < keyAndValueByteSize; keyNulByte++) {
      if (dataView.getUint8(keyAndValueByteOffset + keyNulByte) === 0) {
        break;
      }
    }
    if (keyNulByte === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    const key = new TextDecoder().decode(new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte));
    const value2 = new DataView(dataView.buffer, keyAndValueByteOffset + keyNulByte + 1, keyAndValueByteSize - keyNulByte - 1);
    kvData.set(key, value2);
    bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;
  }
  return kvData;
}
const loadDDS = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  name: "loadDDS",
  test(url2) {
    return checkExtension(url2, ".dds");
  },
  async load(url2, asset, loader) {
    const response = await settings.ADAPTER.fetch(url2);
    const arrayBuffer = await response.arrayBuffer();
    const resources = parseDDS(arrayBuffer);
    const textures = resources.map((resource) => {
      const base2 = new BaseTexture(resource, {
        mipmap: MIPMAP_MODES.OFF,
        alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
        resolution: getResolutionOfUrl(url2),
        ...asset.data
      });
      return createTexture(base2, loader, url2);
    });
    return textures.length === 1 ? textures[0] : textures;
  },
  unload(texture) {
    if (Array.isArray(texture)) {
      texture.forEach((t2) => t2.destroy(true));
    } else {
      texture.destroy(true);
    }
  }
};
extensions$1.add(loadDDS);
const loadKTX = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  name: "loadKTX",
  test(url2) {
    return checkExtension(url2, ".ktx");
  },
  async load(url2, asset, loader) {
    const response = await settings.ADAPTER.fetch(url2);
    const arrayBuffer = await response.arrayBuffer();
    const { compressed, uncompressed, kvData } = parseKTX(url2, arrayBuffer);
    const resources = compressed ?? uncompressed;
    const options = {
      mipmap: MIPMAP_MODES.OFF,
      alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
      resolution: getResolutionOfUrl(url2),
      ...asset.data
    };
    const textures = resources.map((resource) => {
      if (resources === uncompressed) {
        Object.assign(options, {
          type: resource.type,
          format: resource.format
        });
      }
      const base2 = new BaseTexture(resource, options);
      base2.ktxKeyValueData = kvData;
      return createTexture(base2, loader, url2);
    });
    return textures.length === 1 ? textures[0] : textures;
  },
  unload(texture) {
    if (Array.isArray(texture)) {
      texture.forEach((t2) => t2.destroy(true));
    } else {
      texture.destroy(true);
    }
  }
};
extensions$1.add(loadKTX);
const resolveCompressedTextureUrl = {
  extension: ExtensionType.ResolveParser,
  test: (value2) => {
    const temp = value2.split("?")[0];
    const extension = temp.split(".").pop();
    return ["basis", "ktx", "dds"].includes(extension);
  },
  parse: (value2) => {
    var _a, _b;
    const temp = value2.split("?")[0];
    const extension = temp.split(".").pop();
    if (extension === "ktx") {
      const extensions2 = [
        ".s3tc.ktx",
        ".s3tc_sRGB.ktx",
        ".etc.ktx",
        ".etc1.ktx",
        ".pvrt.ktx",
        ".atc.ktx",
        ".astc.ktx"
      ];
      if (extensions2.some((ext2) => value2.endsWith(ext2))) {
        return {
          resolution: parseFloat(((_a = settings.RETINA_PREFIX.exec(value2)) == null ? void 0 : _a[1]) ?? "1"),
          format: extensions2.find((ext2) => value2.endsWith(ext2)),
          src: value2
        };
      }
    }
    return {
      resolution: parseFloat(((_b = settings.RETINA_PREFIX.exec(value2)) == null ? void 0 : _b[1]) ?? "1"),
      format: value2.split(".").pop(),
      src: value2
    };
  }
};
extensions$1.add(resolveCompressedTextureUrl);
const TEMP_RECT = new Rectangle();
const BYTES_PER_PIXEL = 4;
const _Extract = class {
  constructor(renderer2) {
    this.renderer = renderer2;
  }
  async image(target, format2, quality) {
    const image = new Image();
    image.src = await this.base64(target, format2, quality);
    return image;
  }
  async base64(target, format2, quality) {
    const canvas = this.canvas(target);
    if (canvas.toBlob !== void 0) {
      return new Promise((resolve2, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) {
            reject(new Error("ICanvas.toBlob failed!"));
            return;
          }
          const reader = new FileReader();
          reader.onload = () => resolve2(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        }, format2, quality);
      });
    }
    if (canvas.toDataURL !== void 0) {
      return canvas.toDataURL(format2, quality);
    }
    if (canvas.convertToBlob !== void 0) {
      const blob = await canvas.convertToBlob({ type: format2, quality });
      return new Promise((resolve2, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve2(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }
    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
  }
  canvas(target, frame) {
    const { pixels, width, height, flipY } = this._rawPixels(target, frame);
    if (flipY) {
      _Extract._flipY(pixels, width, height);
    }
    _Extract._unpremultiplyAlpha(pixels);
    const canvasBuffer = new CanvasRenderTarget(width, height, 1);
    const imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);
    canvasBuffer.context.putImageData(imageData, 0, 0);
    return canvasBuffer.canvas;
  }
  pixels(target, frame) {
    const { pixels, width, height, flipY } = this._rawPixels(target, frame);
    if (flipY) {
      _Extract._flipY(pixels, width, height);
    }
    _Extract._unpremultiplyAlpha(pixels);
    return pixels;
  }
  _rawPixels(target, frame) {
    const renderer2 = this.renderer;
    if (!renderer2) {
      throw new Error("The Extract has already been destroyed");
    }
    let resolution;
    let flipY = false;
    let renderTexture;
    let generated = false;
    if (target) {
      if (target instanceof RenderTexture) {
        renderTexture = target;
      } else {
        renderTexture = renderer2.generateTexture(target, {
          resolution: renderer2.resolution,
          multisample: renderer2.multisample
        });
        generated = true;
      }
    }
    if (renderTexture) {
      resolution = renderTexture.baseTexture.resolution;
      frame = frame ?? renderTexture.frame;
      flipY = false;
      if (!generated) {
        renderer2.renderTexture.bind(renderTexture);
        const fbo = renderTexture.framebuffer.glFramebuffers[renderer2.CONTEXT_UID];
        if (fbo.blitFramebuffer) {
          renderer2.framebuffer.bind(fbo.blitFramebuffer);
        }
      }
    } else {
      resolution = renderer2.resolution;
      if (!frame) {
        frame = TEMP_RECT;
        frame.width = renderer2.width / resolution;
        frame.height = renderer2.height / resolution;
      }
      flipY = true;
      renderer2.renderTexture.bind();
    }
    const width = Math.round(frame.width * resolution);
    const height = Math.round(frame.height * resolution);
    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    const gl = renderer2.gl;
    gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    if (generated) {
      renderTexture == null ? void 0 : renderTexture.destroy(true);
    }
    return { pixels, width, height, flipY };
  }
  destroy() {
    this.renderer = null;
  }
  static _flipY(pixels, width, height) {
    const w2 = width << 2;
    const h2 = height >> 1;
    const temp = new Uint8Array(w2);
    for (let y2 = 0; y2 < h2; y2++) {
      const t2 = y2 * w2;
      const b3 = (height - y2 - 1) * w2;
      temp.set(pixels.subarray(t2, t2 + w2));
      pixels.copyWithin(t2, b3, b3 + w2);
      pixels.set(temp, b3);
    }
  }
  static _unpremultiplyAlpha(pixels) {
    if (pixels instanceof Uint8ClampedArray) {
      pixels = new Uint8Array(pixels.buffer);
    }
    const n2 = pixels.length;
    for (let i2 = 0; i2 < n2; i2 += 4) {
      const alpha = pixels[i2 + 3];
      if (alpha !== 0) {
        const a8 = 255.001 / alpha;
        pixels[i2] = pixels[i2] * a8 + 0.5;
        pixels[i2 + 1] = pixels[i2 + 1] * a8 + 0.5;
        pixels[i2 + 2] = pixels[i2 + 2] * a8 + 0.5;
      }
    }
  }
};
let Extract = _Extract;
Extract.extension = {
  name: "extract",
  type: ExtensionType.RendererSystem
};
extensions$1.add(Extract);
const buildCircle = {
  build(graphicsData) {
    const points = graphicsData.points;
    let x2;
    let y2;
    let dx;
    let dy;
    let rx;
    let ry;
    if (graphicsData.type === SHAPES.CIRC) {
      const circle = graphicsData.shape;
      x2 = circle.x;
      y2 = circle.y;
      rx = ry = circle.radius;
      dx = dy = 0;
    } else if (graphicsData.type === SHAPES.ELIP) {
      const ellipse = graphicsData.shape;
      x2 = ellipse.x;
      y2 = ellipse.y;
      rx = ellipse.width;
      ry = ellipse.height;
      dx = dy = 0;
    } else {
      const roundedRect = graphicsData.shape;
      const halfWidth = roundedRect.width / 2;
      const halfHeight = roundedRect.height / 2;
      x2 = roundedRect.x + halfWidth;
      y2 = roundedRect.y + halfHeight;
      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
      dx = halfWidth - rx;
      dy = halfHeight - ry;
    }
    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
      points.length = 0;
      return;
    }
    const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
    const m2 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
    points.length = m2;
    if (m2 === 0) {
      return;
    }
    if (n2 === 0) {
      points.length = 8;
      points[0] = points[6] = x2 + dx;
      points[1] = points[3] = y2 + dy;
      points[2] = points[4] = x2 - dx;
      points[5] = points[7] = y2 - dy;
      return;
    }
    let j1 = 0;
    let j2 = n2 * 4 + (dx ? 2 : 0) + 2;
    let j3 = j2;
    let j4 = m2;
    {
      const x0 = dx + rx;
      const y0 = dy;
      const x1 = x2 + x0;
      const x22 = x2 - x0;
      const y1 = y2 + y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x22;
      if (dy) {
        const y22 = y2 - y0;
        points[j3++] = x22;
        points[j3++] = y22;
        points[--j4] = y22;
        points[--j4] = x1;
      }
    }
    for (let i2 = 1; i2 < n2; i2++) {
      const a8 = Math.PI / 2 * (i2 / n2);
      const x0 = dx + Math.cos(a8) * rx;
      const y0 = dy + Math.sin(a8) * ry;
      const x1 = x2 + x0;
      const x22 = x2 - x0;
      const y1 = y2 + y0;
      const y22 = y2 - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x22;
      points[j3++] = x22;
      points[j3++] = y22;
      points[--j4] = y22;
      points[--j4] = x1;
    }
    {
      const x0 = dx;
      const y0 = dy + ry;
      const x1 = x2 + x0;
      const x22 = x2 - x0;
      const y1 = y2 + y0;
      const y22 = y2 - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j4] = y22;
      points[--j4] = x1;
      if (dx) {
        points[j1++] = x22;
        points[j1++] = y1;
        points[--j4] = y22;
        points[--j4] = x22;
      }
    }
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points = graphicsData.points;
    const verts = graphicsGeometry.points;
    const indices2 = graphicsGeometry.indices;
    if (points.length === 0) {
      return;
    }
    let vertPos = verts.length / 2;
    const center = vertPos;
    let x2;
    let y2;
    if (graphicsData.type !== SHAPES.RREC) {
      const circle = graphicsData.shape;
      x2 = circle.x;
      y2 = circle.y;
    } else {
      const roundedRect = graphicsData.shape;
      x2 = roundedRect.x + roundedRect.width / 2;
      y2 = roundedRect.y + roundedRect.height / 2;
    }
    const matrix = graphicsData.matrix;
    verts.push(graphicsData.matrix ? matrix.a * x2 + matrix.c * y2 + matrix.tx : x2, graphicsData.matrix ? matrix.b * x2 + matrix.d * y2 + matrix.ty : y2);
    vertPos++;
    verts.push(points[0], points[1]);
    for (let i2 = 2; i2 < points.length; i2 += 2) {
      verts.push(points[i2], points[i2 + 1]);
      indices2.push(vertPos++, center, vertPos);
    }
    indices2.push(center + 1, center, vertPos);
  }
};
function fixOrientation(points, hole = false) {
  const m2 = points.length;
  if (m2 < 6) {
    return;
  }
  let area2 = 0;
  for (let i2 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i2 < m2; i2 += 2) {
    const x2 = points[i2];
    const y2 = points[i2 + 1];
    area2 += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (!hole && area2 > 0 || hole && area2 <= 0) {
    const n2 = m2 / 2;
    for (let i2 = n2 + n2 % 2; i2 < m2; i2 += 2) {
      const i1 = m2 - i2 - 2;
      const i22 = m2 - i2 - 1;
      const i3 = i2;
      const i4 = i2 + 1;
      [points[i1], points[i3]] = [points[i3], points[i1]];
      [points[i22], points[i4]] = [points[i4], points[i22]];
    }
  }
}
const buildPoly = {
  build(graphicsData) {
    graphicsData.points = graphicsData.shape.points.slice();
  },
  triangulate(graphicsData, graphicsGeometry) {
    let points = graphicsData.points;
    const holes = graphicsData.holes;
    const verts = graphicsGeometry.points;
    const indices2 = graphicsGeometry.indices;
    if (points.length >= 6) {
      fixOrientation(points, false);
      const holeArray = [];
      for (let i2 = 0; i2 < holes.length; i2++) {
        const hole = holes[i2];
        fixOrientation(hole.points, true);
        holeArray.push(points.length / 2);
        points = points.concat(hole.points);
      }
      const triangles = earcut$1(points, holeArray, 2);
      if (!triangles) {
        return;
      }
      const vertPos = verts.length / 2;
      for (let i2 = 0; i2 < triangles.length; i2 += 3) {
        indices2.push(triangles[i2] + vertPos);
        indices2.push(triangles[i2 + 1] + vertPos);
        indices2.push(triangles[i2 + 2] + vertPos);
      }
      for (let i2 = 0; i2 < points.length; i2++) {
        verts.push(points[i2]);
      }
    }
  }
};
const buildRectangle = {
  build(graphicsData) {
    const rectData = graphicsData.shape;
    const x2 = rectData.x;
    const y2 = rectData.y;
    const width = rectData.width;
    const height = rectData.height;
    const points = graphicsData.points;
    points.length = 0;
    if (!(width >= 0 && height >= 0)) {
      return;
    }
    points.push(x2, y2, x2 + width, y2, x2 + width, y2 + height, x2, y2 + height);
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points = graphicsData.points;
    const verts = graphicsGeometry.points;
    if (points.length === 0) {
      return;
    }
    const vertPos = verts.length / 2;
    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
  }
};
const buildRoundedRectangle = {
  build(graphicsData) {
    buildCircle.build(graphicsData);
  },
  triangulate(graphicsData, graphicsGeometry) {
    buildCircle.triangulate(graphicsData, graphicsGeometry);
  }
};
var LINE_JOIN = /* @__PURE__ */ ((LINE_JOIN2) => {
  LINE_JOIN2["MITER"] = "miter";
  LINE_JOIN2["BEVEL"] = "bevel";
  LINE_JOIN2["ROUND"] = "round";
  return LINE_JOIN2;
})(LINE_JOIN || {});
var LINE_CAP = /* @__PURE__ */ ((LINE_CAP2) => {
  LINE_CAP2["BUTT"] = "butt";
  LINE_CAP2["ROUND"] = "round";
  LINE_CAP2["SQUARE"] = "square";
  return LINE_CAP2;
})(LINE_CAP || {});
const curves = {
  adaptive: true,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount(length2, defaultSegments = 20) {
    if (!this.adaptive || !length2 || isNaN(length2)) {
      return defaultSegments;
    }
    let result = Math.ceil(length2 / this.maxLength);
    if (result < this.minSegments) {
      result = this.minSegments;
    } else if (result > this.maxSegments) {
      result = this.maxSegments;
    }
    return result;
  }
};
const GRAPHICS_CURVES = curves;
class ArcUtils {
  static curveTo(x1, y1, x2, y2, radius, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const a12 = fromY - y1;
    const b12 = fromX - x1;
    const a23 = y2 - y1;
    const b22 = x2 - x1;
    const mm = Math.abs(a12 * b22 - b12 * a23);
    if (mm < 1e-8 || radius === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return null;
    }
    const dd = a12 * a12 + b12 * b12;
    const cc = a23 * a23 + b22 * b22;
    const tt2 = a12 * a23 + b12 * b22;
    const k1 = radius * Math.sqrt(dd) / mm;
    const k22 = radius * Math.sqrt(cc) / mm;
    const j1 = k1 * tt2 / dd;
    const j2 = k22 * tt2 / cc;
    const cx = k1 * b22 + k22 * b12;
    const cy = k1 * a23 + k22 * a12;
    const px = b12 * (k22 + j1);
    const py = a12 * (k22 + j1);
    const qx = b22 * (k1 + j2);
    const qy = a23 * (k1 + j2);
    const startAngle = Math.atan2(py - cy, px - cx);
    const endAngle = Math.atan2(qy - cy, qx - cx);
    return {
      cx: cx + x1,
      cy: cy + y1,
      radius,
      startAngle,
      endAngle,
      anticlockwise: b12 * a23 > b22 * a12
    };
  }
  static arc(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
    const sweep = endAngle - startAngle;
    const n2 = curves._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);
    const theta = sweep / (n2 * 2);
    const theta2 = theta * 2;
    const cTheta = Math.cos(theta);
    const sTheta = Math.sin(theta);
    const segMinus = n2 - 1;
    const remainder = segMinus % 1 / segMinus;
    for (let i2 = 0; i2 <= segMinus; ++i2) {
      const real = i2 + remainder * i2;
      const angle2 = theta + startAngle + theta2 * real;
      const c3 = Math.cos(angle2);
      const s2 = -Math.sin(angle2);
      points.push((cTheta * c3 + sTheta * s2) * radius + cx, (cTheta * -s2 + sTheta * c3) * radius + cy);
    }
  }
}
class BatchPart {
  constructor() {
    this.reset();
  }
  begin(style, startIndex, attribStart) {
    this.reset();
    this.style = style;
    this.start = startIndex;
    this.attribStart = attribStart;
  }
  end(endIndex, endAttrib) {
    this.attribSize = endAttrib - this.attribStart;
    this.size = endIndex - this.start;
  }
  reset() {
    this.style = null;
    this.size = 0;
    this.start = 0;
    this.attribStart = 0;
    this.attribSize = 0;
  }
}
class BezierUtils {
  static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
    const n2 = 10;
    let result = 0;
    let t2 = 0;
    let t22 = 0;
    let t3 = 0;
    let nt = 0;
    let nt2 = 0;
    let nt3 = 0;
    let x2 = 0;
    let y2 = 0;
    let dx = 0;
    let dy = 0;
    let prevX = fromX;
    let prevY = fromY;
    for (let i2 = 1; i2 <= n2; ++i2) {
      t2 = i2 / n2;
      t22 = t2 * t2;
      t3 = t22 * t2;
      nt = 1 - t2;
      nt2 = nt * nt;
      nt3 = nt2 * nt;
      x2 = nt3 * fromX + 3 * nt2 * t2 * cpX + 3 * nt * t22 * cpX2 + t3 * toX;
      y2 = nt3 * fromY + 3 * nt2 * t2 * cpY + 3 * nt * t22 * cpY2 + t3 * toY;
      dx = prevX - x2;
      dy = prevY - y2;
      prevX = x2;
      prevY = y2;
      result += Math.sqrt(dx * dx + dy * dy);
    }
    return result;
  }
  static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    points.length -= 2;
    const n2 = curves._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
    let dt = 0;
    let dt2 = 0;
    let dt3 = 0;
    let t2 = 0;
    let t3 = 0;
    points.push(fromX, fromY);
    for (let i2 = 1, j2 = 0; i2 <= n2; ++i2) {
      j2 = i2 / n2;
      dt = 1 - j2;
      dt2 = dt * dt;
      dt3 = dt2 * dt;
      t2 = j2 * j2;
      t3 = t2 * j2;
      points.push(dt3 * fromX + 3 * dt2 * j2 * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j2 * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }
  }
}
function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x2 - nx * innerWeight;
  const iy = y2 - ny * innerWeight;
  const ox = x2 + nx * outerWeight;
  const oy = y2 + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy, eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy, sx, sy);
    for (let i2 = 1, angle2 = startAngle; i2 < segCount; i2++, angle2 += angleInc) {
      verts.push(cx, cy, cx + Math.sin(angle2) * radius, cy + Math.cos(angle2) * radius);
    }
    verts.push(cx, cy, ex, ey);
  } else {
    verts.push(sx, sy, cx, cy);
    for (let i2 = 1, angle2 = startAngle; i2 < segCount; i2++, angle2 += angleInc) {
      verts.push(cx + Math.sin(angle2) * radius, cy + Math.cos(angle2) * radius, cx, cy);
    }
    verts.push(ex, ey, cx, cy);
  }
  return segCount * 2;
}
function buildNonNativeLine(graphicsData, graphicsGeometry) {
  const shape = graphicsData.shape;
  let points = graphicsData.points || shape.points.slice();
  const eps = graphicsGeometry.closePointEps;
  if (points.length === 0) {
    return;
  }
  const style = graphicsData.lineStyle;
  const firstPoint = new Point(points[0], points[1]);
  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  const verts = graphicsGeometry.points;
  const length2 = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0];
  let y0 = points[1];
  let x1 = points[2];
  let y1 = points[3];
  let x2 = 0;
  let y2 = 0;
  let perpx = -(y0 - y1);
  let perpy = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  const ratio = style.alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight);
  for (let i2 = 1; i2 < length2 - 1; ++i2) {
    x0 = points[(i2 - 1) * 2];
    y0 = points[(i2 - 1) * 2 + 1];
    x1 = points[i2 * 2];
    y1 = points[i2 * 2 + 1];
    x2 = points[(i2 + 1) * 2];
    y2 = points[(i2 + 1) * 2 + 1];
    perpx = -(y0 - y1);
    perpy = x0 - x1;
    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x2;
    const dy1 = y2 - y1;
    const dot = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (dot >= 0) {
        if (style.join === LINE_JOIN.ROUND) {
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight, x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);
      }
      continue;
    }
    const c12 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
    const c22 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    const px = (dx0 * c22 - dx1 * c12) / cross;
    const py = (dy1 * c12 - dy0 * c22) / cross;
    const pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pdist <= smallerInsideDiagonalSq;
    let join2 = style.join;
    if (join2 === LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared) {
      join2 = LINE_JOIN.BEVEL;
    }
    if (insideMiterOk) {
      switch (join2) {
        case LINE_JOIN.MITER: {
          verts.push(imx, imy, omx, omy);
          break;
        }
        case LINE_JOIN.BEVEL: {
          if (clockwise) {
            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight, imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);
          }
          indexCount += 2;
          break;
        }
        case LINE_JOIN.ROUND: {
          if (clockwise) {
            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
            verts.push(imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy);
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);
          }
          break;
        }
      }
    } else {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      switch (join2) {
        case LINE_JOIN.MITER: {
          if (clockwise) {
            verts.push(omx, omy, omx, omy);
          } else {
            verts.push(imx, imy, imx, imy);
          }
          indexCount += 2;
          break;
        }
        case LINE_JOIN.ROUND: {
          if (clockwise) {
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
          } else {
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
          }
          break;
        }
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length2 - 2) * 2];
  y0 = points[(length2 - 2) * 2 + 1];
  x1 = points[(length2 - 1) * 2];
  y1 = points[(length2 - 1) * 2 + 1];
  perpx = -(y0 - y1);
  perpy = x0 - x1;
  dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
    }
  }
  const indices2 = graphicsGeometry.indices;
  const eps2 = curves.epsilon * curves.epsilon;
  for (let i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2) {
    x0 = verts[i2 * 2];
    y0 = verts[i2 * 2 + 1];
    x1 = verts[(i2 + 1) * 2];
    y1 = verts[(i2 + 1) * 2 + 1];
    x2 = verts[(i2 + 2) * 2];
    y2 = verts[(i2 + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices2.push(i2, i2 + 1, i2 + 2);
  }
}
function buildNativeLine(graphicsData, graphicsGeometry) {
  let i2 = 0;
  const shape = graphicsData.shape;
  const points = graphicsData.points || shape.points;
  const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  if (points.length === 0)
    return;
  const verts = graphicsGeometry.points;
  const indices2 = graphicsGeometry.indices;
  const length2 = points.length / 2;
  const startIndex = verts.length / 2;
  let currentIndex = startIndex;
  verts.push(points[0], points[1]);
  for (i2 = 1; i2 < length2; i2++) {
    verts.push(points[i2 * 2], points[i2 * 2 + 1]);
    indices2.push(currentIndex, currentIndex + 1);
    currentIndex++;
  }
  if (closedShape) {
    indices2.push(currentIndex, startIndex);
  }
}
function buildLine(graphicsData, graphicsGeometry) {
  if (graphicsData.lineStyle.native) {
    buildNativeLine(graphicsData, graphicsGeometry);
  } else {
    buildNonNativeLine(graphicsData, graphicsGeometry);
  }
}
class QuadraticUtils {
  static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
    const ax = fromX - 2 * cpX + toX;
    const ay = fromY - 2 * cpY + toY;
    const bx = 2 * cpX - 2 * fromX;
    const by = 2 * cpY - 2 * fromY;
    const a8 = 4 * (ax * ax + ay * ay);
    const b3 = 4 * (ax * bx + ay * by);
    const c3 = bx * bx + by * by;
    const s2 = 2 * Math.sqrt(a8 + b3 + c3);
    const a23 = Math.sqrt(a8);
    const a32 = 2 * a8 * a23;
    const c22 = 2 * Math.sqrt(c3);
    const ba = b3 / a23;
    return (a32 * s2 + a23 * b3 * (s2 - c22) + (4 * c3 * a8 - b3 * b3) * Math.log((2 * a23 + ba + s2) / (ba + c22))) / (4 * a32);
  }
  static curveTo(cpX, cpY, toX, toY, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const n2 = curves._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));
    let xa = 0;
    let ya = 0;
    for (let i2 = 1; i2 <= n2; ++i2) {
      const j2 = i2 / n2;
      xa = fromX + (cpX - fromX) * j2;
      ya = fromY + (cpY - fromY) * j2;
      points.push(xa + (cpX + (toX - cpX) * j2 - xa) * j2, ya + (cpY + (toY - cpY) * j2 - ya) * j2);
    }
  }
}
const FILL_COMMANDS = {
  [SHAPES.POLY]: buildPoly,
  [SHAPES.CIRC]: buildCircle,
  [SHAPES.ELIP]: buildCircle,
  [SHAPES.RECT]: buildRectangle,
  [SHAPES.RREC]: buildRoundedRectangle
};
const BATCH_POOL = [];
const DRAW_CALL_POOL = [];
class GraphicsData {
  constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
    this.points = [];
    this.holes = [];
    this.shape = shape;
    this.lineStyle = lineStyle;
    this.fillStyle = fillStyle;
    this.matrix = matrix;
    this.type = shape.type;
  }
  clone() {
    return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);
  }
  destroy() {
    this.shape = null;
    this.holes.length = 0;
    this.holes = null;
    this.points.length = 0;
    this.points = null;
    this.lineStyle = null;
    this.fillStyle = null;
  }
}
const tmpPoint = new Point();
const _GraphicsGeometry = class extends BatchGeometry {
  constructor() {
    super();
    this.closePointEps = 1e-4;
    this.boundsPadding = 0;
    this.uvsFloat32 = null;
    this.indicesUint16 = null;
    this.batchable = false;
    this.points = [];
    this.colors = [];
    this.uvs = [];
    this.indices = [];
    this.textureIds = [];
    this.graphicsData = [];
    this.drawCalls = [];
    this.batchDirty = -1;
    this.batches = [];
    this.dirty = 0;
    this.cacheDirty = -1;
    this.clearDirty = 0;
    this.shapeIndex = 0;
    this._bounds = new Bounds();
    this.boundsDirty = -1;
  }
  get bounds() {
    this.updateBatches();
    if (this.boundsDirty !== this.dirty) {
      this.boundsDirty = this.dirty;
      this.calculateBounds();
    }
    return this._bounds;
  }
  invalidate() {
    this.boundsDirty = -1;
    this.dirty++;
    this.batchDirty++;
    this.shapeIndex = 0;
    this.points.length = 0;
    this.colors.length = 0;
    this.uvs.length = 0;
    this.indices.length = 0;
    this.textureIds.length = 0;
    for (let i2 = 0; i2 < this.drawCalls.length; i2++) {
      this.drawCalls[i2].texArray.clear();
      DRAW_CALL_POOL.push(this.drawCalls[i2]);
    }
    this.drawCalls.length = 0;
    for (let i2 = 0; i2 < this.batches.length; i2++) {
      const batchPart = this.batches[i2];
      batchPart.reset();
      BATCH_POOL.push(batchPart);
    }
    this.batches.length = 0;
  }
  clear() {
    if (this.graphicsData.length > 0) {
      this.invalidate();
      this.clearDirty++;
      this.graphicsData.length = 0;
    }
    return this;
  }
  drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {
    const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);
    this.graphicsData.push(data);
    this.dirty++;
    return this;
  }
  drawHole(shape, matrix = null) {
    if (!this.graphicsData.length) {
      return null;
    }
    const data = new GraphicsData(shape, null, null, matrix);
    const lastShape = this.graphicsData[this.graphicsData.length - 1];
    data.lineStyle = lastShape.lineStyle;
    lastShape.holes.push(data);
    this.dirty++;
    return this;
  }
  destroy() {
    super.destroy();
    for (let i2 = 0; i2 < this.graphicsData.length; ++i2) {
      this.graphicsData[i2].destroy();
    }
    this.points.length = 0;
    this.points = null;
    this.colors.length = 0;
    this.colors = null;
    this.uvs.length = 0;
    this.uvs = null;
    this.indices.length = 0;
    this.indices = null;
    this.indexBuffer.destroy();
    this.indexBuffer = null;
    this.graphicsData.length = 0;
    this.graphicsData = null;
    this.drawCalls.length = 0;
    this.drawCalls = null;
    this.batches.length = 0;
    this.batches = null;
    this._bounds = null;
  }
  containsPoint(point) {
    const graphicsData = this.graphicsData;
    for (let i2 = 0; i2 < graphicsData.length; ++i2) {
      const data = graphicsData[i2];
      if (!data.fillStyle.visible) {
        continue;
      }
      if (data.shape) {
        if (data.matrix) {
          data.matrix.applyInverse(point, tmpPoint);
        } else {
          tmpPoint.copyFrom(point);
        }
        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
          let hitHole = false;
          if (data.holes) {
            for (let i22 = 0; i22 < data.holes.length; i22++) {
              const hole = data.holes[i22];
              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                hitHole = true;
                break;
              }
            }
          }
          if (!hitHole) {
            return true;
          }
        }
      }
    }
    return false;
  }
  updateBatches() {
    if (!this.graphicsData.length) {
      this.batchable = true;
      return;
    }
    if (!this.validateBatching()) {
      return;
    }
    this.cacheDirty = this.dirty;
    const uvs = this.uvs;
    const graphicsData = this.graphicsData;
    let batchPart = null;
    let currentStyle = null;
    if (this.batches.length > 0) {
      batchPart = this.batches[this.batches.length - 1];
      currentStyle = batchPart.style;
    }
    for (let i2 = this.shapeIndex; i2 < graphicsData.length; i2++) {
      this.shapeIndex++;
      const data = graphicsData[i2];
      const fillStyle = data.fillStyle;
      const lineStyle = data.lineStyle;
      const command = FILL_COMMANDS[data.type];
      command.build(data);
      if (data.matrix) {
        this.transformPoints(data.points, data.matrix);
      }
      if (fillStyle.visible || lineStyle.visible) {
        this.processHoles(data.holes);
      }
      for (let j2 = 0; j2 < 2; j2++) {
        const style = j2 === 0 ? fillStyle : lineStyle;
        if (!style.visible)
          continue;
        const nextTexture = style.texture.baseTexture;
        const index22 = this.indices.length;
        const attribIndex = this.points.length / 2;
        nextTexture.wrapMode = WRAP_MODES.REPEAT;
        if (j2 === 0) {
          this.processFill(data);
        } else {
          this.processLine(data);
        }
        const size2 = this.points.length / 2 - attribIndex;
        if (size2 === 0)
          continue;
        if (batchPart && !this._compareStyles(currentStyle, style)) {
          batchPart.end(index22, attribIndex);
          batchPart = null;
        }
        if (!batchPart) {
          batchPart = BATCH_POOL.pop() || new BatchPart();
          batchPart.begin(style, index22, attribIndex);
          this.batches.push(batchPart);
          currentStyle = style;
        }
        this.addUvs(this.points, uvs, style.texture, attribIndex, size2, style.matrix);
      }
    }
    const index2 = this.indices.length;
    const attrib = this.points.length / 2;
    if (batchPart) {
      batchPart.end(index2, attrib);
    }
    if (this.batches.length === 0) {
      this.batchable = true;
      return;
    }
    const need32 = attrib > 65535;
    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {
      this.indicesUint16.set(this.indices);
    } else {
      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
    }
    this.batchable = this.isBatchable();
    if (this.batchable) {
      this.packBatches();
    } else {
      this.buildDrawCalls();
    }
  }
  _compareStyles(styleA, styleB) {
    if (!styleA || !styleB) {
      return false;
    }
    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
      return false;
    }
    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
      return false;
    }
    if (!!styleA.native !== !!styleB.native) {
      return false;
    }
    return true;
  }
  validateBatching() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
      return false;
    }
    for (let i2 = 0, l2 = this.graphicsData.length; i2 < l2; i2++) {
      const data = this.graphicsData[i2];
      const fill2 = data.fillStyle;
      const line = data.lineStyle;
      if (fill2 && !fill2.texture.baseTexture.valid)
        return false;
      if (line && !line.texture.baseTexture.valid)
        return false;
    }
    return true;
  }
  packBatches() {
    this.batchDirty++;
    this.uvsFloat32 = new Float32Array(this.uvs);
    const batches = this.batches;
    for (let i2 = 0, l2 = batches.length; i2 < l2; i2++) {
      const batch = batches[i2];
      for (let j2 = 0; j2 < batch.size; j2++) {
        const index2 = batch.start + j2;
        this.indicesUint16[index2] = this.indicesUint16[index2] - batch.attribStart;
      }
    }
  }
  isBatchable() {
    if (this.points.length > 65535 * 2) {
      return false;
    }
    const batches = this.batches;
    for (let i2 = 0; i2 < batches.length; i2++) {
      if (batches[i2].style.native) {
        return false;
      }
    }
    return this.points.length < _GraphicsGeometry.BATCHABLE_SIZE * 2;
  }
  buildDrawCalls() {
    let TICK = ++BaseTexture._globalBatch;
    for (let i2 = 0; i2 < this.drawCalls.length; i2++) {
      this.drawCalls[i2].texArray.clear();
      DRAW_CALL_POOL.push(this.drawCalls[i2]);
    }
    this.drawCalls.length = 0;
    const colors = this.colors;
    const textureIds = this.textureIds;
    let currentGroup = DRAW_CALL_POOL.pop();
    if (!currentGroup) {
      currentGroup = new BatchDrawCall();
      currentGroup.texArray = new BatchTextureArray();
    }
    currentGroup.texArray.count = 0;
    currentGroup.start = 0;
    currentGroup.size = 0;
    currentGroup.type = DRAW_MODES.TRIANGLES;
    let textureCount = 0;
    let currentTexture = null;
    let textureId = 0;
    let native = false;
    let drawMode = DRAW_MODES.TRIANGLES;
    let index2 = 0;
    this.drawCalls.push(currentGroup);
    for (let i2 = 0; i2 < this.batches.length; i2++) {
      const data = this.batches[i2];
      const maxTextures = 8;
      const style = data.style;
      const nextTexture = style.texture.baseTexture;
      if (native !== !!style.native) {
        native = !!style.native;
        drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;
        currentTexture = null;
        textureCount = maxTextures;
        TICK++;
      }
      if (currentTexture !== nextTexture) {
        currentTexture = nextTexture;
        if (nextTexture._batchEnabled !== TICK) {
          if (textureCount === maxTextures) {
            TICK++;
            textureCount = 0;
            if (currentGroup.size > 0) {
              currentGroup = DRAW_CALL_POOL.pop();
              if (!currentGroup) {
                currentGroup = new BatchDrawCall();
                currentGroup.texArray = new BatchTextureArray();
              }
              this.drawCalls.push(currentGroup);
            }
            currentGroup.start = index2;
            currentGroup.size = 0;
            currentGroup.texArray.count = 0;
            currentGroup.type = drawMode;
          }
          nextTexture.touched = 1;
          nextTexture._batchEnabled = TICK;
          nextTexture._batchLocation = textureCount;
          nextTexture.wrapMode = WRAP_MODES.REPEAT;
          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
          textureCount++;
        }
      }
      currentGroup.size += data.size;
      index2 += data.size;
      textureId = nextTexture._batchLocation;
      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);
      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
    }
    BaseTexture._globalBatch = TICK;
    this.packAttributes();
  }
  packAttributes() {
    const verts = this.points;
    const uvs = this.uvs;
    const colors = this.colors;
    const textureIds = this.textureIds;
    const glPoints = new ArrayBuffer(verts.length * 3 * 4);
    const f32 = new Float32Array(glPoints);
    const u32 = new Uint32Array(glPoints);
    let p2 = 0;
    for (let i2 = 0; i2 < verts.length / 2; i2++) {
      f32[p2++] = verts[i2 * 2];
      f32[p2++] = verts[i2 * 2 + 1];
      f32[p2++] = uvs[i2 * 2];
      f32[p2++] = uvs[i2 * 2 + 1];
      u32[p2++] = colors[i2];
      f32[p2++] = textureIds[i2];
    }
    this._buffer.update(glPoints);
    this._indexBuffer.update(this.indicesUint16);
  }
  processFill(data) {
    if (data.holes.length) {
      buildPoly.triangulate(data, this);
    } else {
      const command = FILL_COMMANDS[data.type];
      command.triangulate(data, this);
    }
  }
  processLine(data) {
    buildLine(data, this);
    for (let i2 = 0; i2 < data.holes.length; i2++) {
      buildLine(data.holes[i2], this);
    }
  }
  processHoles(holes) {
    for (let i2 = 0; i2 < holes.length; i2++) {
      const hole = holes[i2];
      const command = FILL_COMMANDS[hole.type];
      command.build(hole);
      if (hole.matrix) {
        this.transformPoints(hole.points, hole.matrix);
      }
    }
  }
  calculateBounds() {
    const bounds = this._bounds;
    bounds.clear();
    bounds.addVertexData(this.points, 0, this.points.length);
    bounds.pad(this.boundsPadding, this.boundsPadding);
  }
  transformPoints(points, matrix) {
    for (let i2 = 0; i2 < points.length / 2; i2++) {
      const x2 = points[i2 * 2];
      const y2 = points[i2 * 2 + 1];
      points[i2 * 2] = matrix.a * x2 + matrix.c * y2 + matrix.tx;
      points[i2 * 2 + 1] = matrix.b * x2 + matrix.d * y2 + matrix.ty;
    }
  }
  addColors(colors, color, alpha, size2, offset = 0) {
    const bgr = Color.shared.setValue(color).toLittleEndianNumber();
    const result = Color.shared.setValue(bgr).toPremultiplied(alpha);
    colors.length = Math.max(colors.length, offset + size2);
    for (let i2 = 0; i2 < size2; i2++) {
      colors[offset + i2] = result;
    }
  }
  addTextureIds(textureIds, id, size2, offset = 0) {
    textureIds.length = Math.max(textureIds.length, offset + size2);
    for (let i2 = 0; i2 < size2; i2++) {
      textureIds[offset + i2] = id;
    }
  }
  addUvs(verts, uvs, texture, start, size2, matrix = null) {
    let index2 = 0;
    const uvsStart = uvs.length;
    const frame = texture.frame;
    while (index2 < size2) {
      let x2 = verts[(start + index2) * 2];
      let y2 = verts[(start + index2) * 2 + 1];
      if (matrix) {
        const nx = matrix.a * x2 + matrix.c * y2 + matrix.tx;
        y2 = matrix.b * x2 + matrix.d * y2 + matrix.ty;
        x2 = nx;
      }
      index2++;
      uvs.push(x2 / frame.width, y2 / frame.height);
    }
    const baseTexture = texture.baseTexture;
    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {
      this.adjustUvs(uvs, texture, uvsStart, size2);
    }
  }
  adjustUvs(uvs, texture, start, size2) {
    const baseTexture = texture.baseTexture;
    const eps = 1e-6;
    const finish = start + size2 * 2;
    const frame = texture.frame;
    const scaleX = frame.width / baseTexture.width;
    const scaleY = frame.height / baseTexture.height;
    let offsetX = frame.x / frame.width;
    let offsetY = frame.y / frame.height;
    let minX = Math.floor(uvs[start] + eps);
    let minY = Math.floor(uvs[start + 1] + eps);
    for (let i2 = start + 2; i2 < finish; i2 += 2) {
      minX = Math.min(minX, Math.floor(uvs[i2] + eps));
      minY = Math.min(minY, Math.floor(uvs[i2 + 1] + eps));
    }
    offsetX -= minX;
    offsetY -= minY;
    for (let i2 = start; i2 < finish; i2 += 2) {
      uvs[i2] = (uvs[i2] + offsetX) * scaleX;
      uvs[i2 + 1] = (uvs[i2 + 1] + offsetY) * scaleY;
    }
  }
};
let GraphicsGeometry = _GraphicsGeometry;
GraphicsGeometry.BATCHABLE_SIZE = 100;
class FillStyle {
  constructor() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.visible = false;
    this.reset();
  }
  clone() {
    const obj = new FillStyle();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    return obj;
  }
  reset() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.visible = false;
  }
  destroy() {
    this.texture = null;
    this.matrix = null;
  }
}
class LineStyle extends FillStyle {
  constructor() {
    super(...arguments);
    this.width = 0;
    this.alignment = 0.5;
    this.native = false;
    this.cap = LINE_CAP.BUTT;
    this.join = LINE_JOIN.MITER;
    this.miterLimit = 10;
  }
  clone() {
    const obj = new LineStyle();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    obj.width = this.width;
    obj.alignment = this.alignment;
    obj.native = this.native;
    obj.cap = this.cap;
    obj.join = this.join;
    obj.miterLimit = this.miterLimit;
    return obj;
  }
  reset() {
    super.reset();
    this.color = 0;
    this.alignment = 0.5;
    this.width = 0;
    this.native = false;
  }
}
const DEFAULT_SHADERS = {};
const _Graphics = class extends Container {
  constructor(geometry = null) {
    super();
    this.shader = null;
    this.pluginName = "batch";
    this.currentPath = null;
    this.batches = [];
    this.batchTint = -1;
    this.batchDirty = -1;
    this.vertexData = null;
    this._fillStyle = new FillStyle();
    this._lineStyle = new LineStyle();
    this._matrix = null;
    this._holeMode = false;
    this.state = State.for2d();
    this._geometry = geometry || new GraphicsGeometry();
    this._geometry.refCount++;
    this._transformID = -1;
    this._tintColor = new Color(16777215);
    this.blendMode = BLEND_MODES.NORMAL;
  }
  get geometry() {
    return this._geometry;
  }
  clone() {
    this.finishPoly();
    return new _Graphics(this._geometry);
  }
  set blendMode(value2) {
    this.state.blendMode = value2;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value2) {
    this._tintColor.setValue(value2);
  }
  get fill() {
    return this._fillStyle;
  }
  get line() {
    return this._lineStyle;
  }
  lineStyle(options = null, color = 0, alpha, alignment = 0.5, native = false) {
    if (typeof options === "number") {
      options = { width: options, color, alpha, alignment, native };
    }
    return this.lineTextureStyle(options);
  }
  lineTextureStyle(options) {
    const defaultLineStyleOptions = {
      width: 0,
      texture: Texture.WHITE,
      color: (options == null ? void 0 : options.texture) ? 16777215 : 0,
      matrix: null,
      alignment: 0.5,
      native: false,
      cap: LINE_CAP.BUTT,
      join: LINE_JOIN.MITER,
      miterLimit: 10
    };
    options = Object.assign(defaultLineStyleOptions, options);
    this.normalizeColor(options);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options.width > 0 && options.alpha > 0;
    if (!visible) {
      this._lineStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._lineStyle, { visible }, options);
    }
    return this;
  }
  startPoly() {
    if (this.currentPath) {
      const points = this.currentPath.points;
      const len = this.currentPath.points.length;
      if (len > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = new Polygon();
        this.currentPath.closeStroke = false;
        this.currentPath.points.push(points[len - 2], points[len - 1]);
      }
    } else {
      this.currentPath = new Polygon();
      this.currentPath.closeStroke = false;
    }
  }
  finishPoly() {
    if (this.currentPath) {
      if (this.currentPath.points.length > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = null;
      } else {
        this.currentPath.points.length = 0;
      }
    }
  }
  moveTo(x2, y2) {
    this.startPoly();
    this.currentPath.points[0] = x2;
    this.currentPath.points[1] = y2;
    return this;
  }
  lineTo(x2, y2) {
    if (!this.currentPath) {
      this.moveTo(0, 0);
    }
    const points = this.currentPath.points;
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    if (fromX !== x2 || fromY !== y2) {
      points.push(x2, y2);
    }
    return this;
  }
  _initCurve(x2 = 0, y2 = 0) {
    if (this.currentPath) {
      if (this.currentPath.points.length === 0) {
        this.currentPath.points = [x2, y2];
      }
    } else {
      this.moveTo(x2, y2);
    }
  }
  quadraticCurveTo(cpX, cpY, toX, toY) {
    this._initCurve();
    const points = this.currentPath.points;
    if (points.length === 0) {
      this.moveTo(0, 0);
    }
    QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
    return this;
  }
  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
    this._initCurve();
    BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
    return this;
  }
  arcTo(x1, y1, x2, y2, radius) {
    this._initCurve(x1, y1);
    const points = this.currentPath.points;
    const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
    if (result) {
      const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;
      this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);
    }
    return this;
  }
  arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
    if (startAngle === endAngle) {
      return this;
    }
    if (!anticlockwise && endAngle <= startAngle) {
      endAngle += PI_2;
    } else if (anticlockwise && startAngle <= endAngle) {
      startAngle += PI_2;
    }
    const sweep = endAngle - startAngle;
    if (sweep === 0) {
      return this;
    }
    const startX = cx + Math.cos(startAngle) * radius;
    const startY = cy + Math.sin(startAngle) * radius;
    const eps = this._geometry.closePointEps;
    let points = this.currentPath ? this.currentPath.points : null;
    if (points) {
      const xDiff = Math.abs(points[points.length - 2] - startX);
      const yDiff = Math.abs(points[points.length - 1] - startY);
      if (xDiff < eps && yDiff < eps)
        ;
      else {
        points.push(startX, startY);
      }
    } else {
      this.moveTo(startX, startY);
      points = this.currentPath.points;
    }
    ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
    return this;
  }
  beginFill(color = 0, alpha) {
    return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });
  }
  normalizeColor(options) {
    const temp = Color.shared.setValue(options.color ?? 0);
    options.color = temp.toNumber();
    options.alpha ?? (options.alpha = temp.alpha);
  }
  beginTextureFill(options) {
    const defaultOptions = {
      texture: Texture.WHITE,
      color: 16777215,
      matrix: null
    };
    options = Object.assign(defaultOptions, options);
    this.normalizeColor(options);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options.alpha > 0;
    if (!visible) {
      this._fillStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._fillStyle, { visible }, options);
    }
    return this;
  }
  endFill() {
    this.finishPoly();
    this._fillStyle.reset();
    return this;
  }
  drawRect(x2, y2, width, height) {
    return this.drawShape(new Rectangle(x2, y2, width, height));
  }
  drawRoundedRect(x2, y2, width, height, radius) {
    return this.drawShape(new RoundedRectangle(x2, y2, width, height, radius));
  }
  drawCircle(x2, y2, radius) {
    return this.drawShape(new Circle(x2, y2, radius));
  }
  drawEllipse(x2, y2, width, height) {
    return this.drawShape(new Ellipse(x2, y2, width, height));
  }
  drawPolygon(...path2) {
    let points;
    let closeStroke = true;
    const poly = path2[0];
    if (poly.points) {
      closeStroke = poly.closeStroke;
      points = poly.points;
    } else if (Array.isArray(path2[0])) {
      points = path2[0];
    } else {
      points = path2;
    }
    const shape = new Polygon(points);
    shape.closeStroke = closeStroke;
    this.drawShape(shape);
    return this;
  }
  drawShape(shape) {
    if (!this._holeMode) {
      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
    } else {
      this._geometry.drawHole(shape, this._matrix);
    }
    return this;
  }
  clear() {
    this._geometry.clear();
    this._lineStyle.reset();
    this._fillStyle.reset();
    this._boundsID++;
    this._matrix = null;
    this._holeMode = false;
    this.currentPath = null;
    return this;
  }
  isFastRect() {
    const data = this._geometry.graphicsData;
    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
  }
  _render(renderer2) {
    this.finishPoly();
    const geometry = this._geometry;
    geometry.updateBatches();
    if (geometry.batchable) {
      if (this.batchDirty !== geometry.batchDirty) {
        this._populateBatches();
      }
      this._renderBatched(renderer2);
    } else {
      renderer2.batch.flush();
      this._renderDirect(renderer2);
    }
  }
  _populateBatches() {
    const geometry = this._geometry;
    const blendMode = this.blendMode;
    const len = geometry.batches.length;
    this.batchTint = -1;
    this._transformID = -1;
    this.batchDirty = geometry.batchDirty;
    this.batches.length = len;
    this.vertexData = new Float32Array(geometry.points);
    for (let i2 = 0; i2 < len; i2++) {
      const gI = geometry.batches[i2];
      const color = gI.style.color;
      const vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      const uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      const indices2 = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
      const batch = {
        vertexData,
        blendMode,
        indices: indices2,
        uvs,
        _batchRGB: Color.shared.setValue(color).toRgbArray(),
        _tintRGB: color,
        _texture: gI.style.texture,
        alpha: gI.style.alpha,
        worldAlpha: 1
      };
      this.batches[i2] = batch;
    }
  }
  _renderBatched(renderer2) {
    if (!this.batches.length) {
      return;
    }
    renderer2.batch.setObjectRenderer(renderer2.plugins[this.pluginName]);
    this.calculateVertices();
    this.calculateTints();
    for (let i2 = 0, l2 = this.batches.length; i2 < l2; i2++) {
      const batch = this.batches[i2];
      batch.worldAlpha = this.worldAlpha * batch.alpha;
      renderer2.plugins[this.pluginName].render(batch);
    }
  }
  _renderDirect(renderer2) {
    const shader = this._resolveDirectShader(renderer2);
    const geometry = this._geometry;
    const worldAlpha = this.worldAlpha;
    const uniforms = shader.uniforms;
    const drawCalls = geometry.drawCalls;
    uniforms.translationMatrix = this.transform.worldTransform;
    Color.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint);
    renderer2.shader.bind(shader);
    renderer2.geometry.bind(geometry, shader);
    renderer2.state.set(this.state);
    for (let i2 = 0, l2 = drawCalls.length; i2 < l2; i2++) {
      this._renderDrawCallDirect(renderer2, geometry.drawCalls[i2]);
    }
  }
  _renderDrawCallDirect(renderer2, drawCall) {
    const { texArray, type, size: size2, start } = drawCall;
    const groupTextureCount = texArray.count;
    for (let j2 = 0; j2 < groupTextureCount; j2++) {
      renderer2.texture.bind(texArray.elements[j2], j2);
    }
    renderer2.geometry.draw(type, size2, start);
  }
  _resolveDirectShader(renderer2) {
    let shader = this.shader;
    const pluginName = this.pluginName;
    if (!shader) {
      if (!DEFAULT_SHADERS[pluginName]) {
        const { maxTextures } = renderer2.plugins[pluginName];
        const sampleValues = new Int32Array(maxTextures);
        for (let i2 = 0; i2 < maxTextures; i2++) {
          sampleValues[i2] = i2;
        }
        const uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new Matrix(),
          default: UniformGroup.from({ uSamplers: sampleValues }, true)
        };
        const program = renderer2.plugins[pluginName]._shader.program;
        DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
      }
      shader = DEFAULT_SHADERS[pluginName];
    }
    return shader;
  }
  _calculateBounds() {
    this.finishPoly();
    const geometry = this._geometry;
    if (!geometry.graphicsData.length) {
      return;
    }
    const { minX, minY, maxX, maxY } = geometry.bounds;
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, _Graphics._TEMP_POINT);
    return this._geometry.containsPoint(_Graphics._TEMP_POINT);
  }
  calculateTints() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this._tintColor.toNumber();
      for (let i2 = 0; i2 < this.batches.length; i2++) {
        const batch = this.batches[i2];
        batch._tintRGB = Color.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber();
      }
    }
  }
  calculateVertices() {
    const wtID = this.transform._worldID;
    if (this._transformID === wtID) {
      return;
    }
    this._transformID = wtID;
    const wt = this.transform.worldTransform;
    const a8 = wt.a;
    const b3 = wt.b;
    const c3 = wt.c;
    const d2 = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const data = this._geometry.points;
    const vertexData = this.vertexData;
    let count = 0;
    for (let i2 = 0; i2 < data.length; i2 += 2) {
      const x2 = data[i2];
      const y2 = data[i2 + 1];
      vertexData[count++] = a8 * x2 + c3 * y2 + tx;
      vertexData[count++] = d2 * y2 + b3 * x2 + ty;
    }
  }
  closePath() {
    const currentPath = this.currentPath;
    if (currentPath) {
      currentPath.closeStroke = true;
      this.finishPoly();
    }
    return this;
  }
  setMatrix(matrix) {
    this._matrix = matrix;
    return this;
  }
  beginHole() {
    this.finishPoly();
    this._holeMode = true;
    return this;
  }
  endHole() {
    this.finishPoly();
    this._holeMode = false;
    return this;
  }
  destroy(options) {
    this._geometry.refCount--;
    if (this._geometry.refCount === 0) {
      this._geometry.dispose();
    }
    this._matrix = null;
    this.currentPath = null;
    this._lineStyle.destroy();
    this._lineStyle = null;
    this._fillStyle.destroy();
    this._fillStyle = null;
    this._geometry = null;
    this.shader = null;
    this.vertexData = null;
    this.batches.length = 0;
    this.batches = null;
    super.destroy(options);
  }
};
let Graphics = _Graphics;
Graphics.curves = curves;
Graphics._TEMP_POINT = new Point();
const graphicsUtils = {
  buildPoly,
  buildCircle,
  buildRectangle,
  buildRoundedRectangle,
  buildLine,
  ArcUtils,
  BezierUtils,
  QuadraticUtils,
  BatchPart,
  FILL_COMMANDS,
  BATCH_POOL,
  DRAW_CALL_POOL
};
class MeshBatchUvs {
  constructor(uvBuffer, uvMatrix) {
    this.uvBuffer = uvBuffer;
    this.uvMatrix = uvMatrix;
    this.data = null;
    this._bufferUpdateId = -1;
    this._textureUpdateId = -1;
    this._updateID = 0;
  }
  update(forceUpdate) {
    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
      return;
    }
    this._bufferUpdateId = this.uvBuffer._updateID;
    this._textureUpdateId = this.uvMatrix._updateID;
    const data = this.uvBuffer.data;
    if (!this.data || this.data.length !== data.length) {
      this.data = new Float32Array(data.length);
    }
    this.uvMatrix.multiplyUvs(data, this.data);
    this._updateID++;
  }
}
const tempPoint$1 = new Point();
const tempPolygon = new Polygon();
const _Mesh = class extends Container {
  constructor(geometry, shader, state, drawMode = DRAW_MODES.TRIANGLES) {
    super();
    this.geometry = geometry;
    this.shader = shader;
    this.state = state || State.for2d();
    this.drawMode = drawMode;
    this.start = 0;
    this.size = 0;
    this.uvs = null;
    this.indices = null;
    this.vertexData = new Float32Array(1);
    this.vertexDirty = -1;
    this._transformID = -1;
    this._roundPixels = settings.ROUND_PIXELS;
    this.batchUvs = null;
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(value2) {
    if (this._geometry === value2) {
      return;
    }
    if (this._geometry) {
      this._geometry.refCount--;
      if (this._geometry.refCount === 0) {
        this._geometry.dispose();
      }
    }
    this._geometry = value2;
    if (this._geometry) {
      this._geometry.refCount++;
    }
    this.vertexDirty = -1;
  }
  get uvBuffer() {
    return this.geometry.buffers[1];
  }
  get verticesBuffer() {
    return this.geometry.buffers[0];
  }
  set material(value2) {
    this.shader = value2;
  }
  get material() {
    return this.shader;
  }
  set blendMode(value2) {
    this.state.blendMode = value2;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  set roundPixels(value2) {
    if (this._roundPixels !== value2) {
      this._transformID = -1;
    }
    this._roundPixels = value2;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  get tint() {
    return "tint" in this.shader ? this.shader.tint : null;
  }
  set tint(value2) {
    this.shader.tint = value2;
  }
  get tintValue() {
    return this.shader.tintValue;
  }
  get texture() {
    return "texture" in this.shader ? this.shader.texture : null;
  }
  set texture(value2) {
    this.shader.texture = value2;
  }
  _render(renderer2) {
    const vertices = this.geometry.buffers[0].data;
    const shader = this.shader;
    if (shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < _Mesh.BATCHABLE_SIZE * 2) {
      this._renderToBatch(renderer2);
    } else {
      this._renderDefault(renderer2);
    }
  }
  _renderDefault(renderer2) {
    const shader = this.shader;
    shader.alpha = this.worldAlpha;
    if (shader.update) {
      shader.update();
    }
    renderer2.batch.flush();
    shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
    renderer2.shader.bind(shader);
    renderer2.state.set(this.state);
    renderer2.geometry.bind(this.geometry, shader);
    renderer2.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  }
  _renderToBatch(renderer2) {
    const geometry = this.geometry;
    const shader = this.shader;
    if (shader.uvMatrix) {
      shader.uvMatrix.update();
      this.calculateUvs();
    }
    this.calculateVertices();
    this.indices = geometry.indexBuffer.data;
    this._tintRGB = shader._tintRGB;
    this._texture = shader.texture;
    const pluginName = this.material.pluginName;
    renderer2.batch.setObjectRenderer(renderer2.plugins[pluginName]);
    renderer2.plugins[pluginName].render(this);
  }
  calculateVertices() {
    const geometry = this.geometry;
    const verticesBuffer = geometry.buffers[0];
    const vertices = verticesBuffer.data;
    const vertexDirtyId = verticesBuffer._updateID;
    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
      return;
    }
    this._transformID = this.transform._worldID;
    if (this.vertexData.length !== vertices.length) {
      this.vertexData = new Float32Array(vertices.length);
    }
    const wt = this.transform.worldTransform;
    const a8 = wt.a;
    const b3 = wt.b;
    const c3 = wt.c;
    const d2 = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const vertexData = this.vertexData;
    for (let i2 = 0; i2 < vertexData.length / 2; i2++) {
      const x2 = vertices[i2 * 2];
      const y2 = vertices[i2 * 2 + 1];
      vertexData[i2 * 2] = a8 * x2 + c3 * y2 + tx;
      vertexData[i2 * 2 + 1] = b3 * x2 + d2 * y2 + ty;
    }
    if (this._roundPixels) {
      const resolution = settings.RESOLUTION;
      for (let i2 = 0; i2 < vertexData.length; ++i2) {
        vertexData[i2] = Math.round(vertexData[i2] * resolution) / resolution;
      }
    }
    this.vertexDirty = vertexDirtyId;
  }
  calculateUvs() {
    const geomUvs = this.geometry.buffers[1];
    const shader = this.shader;
    if (!shader.uvMatrix.isSimple) {
      if (!this.batchUvs) {
        this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);
      }
      this.batchUvs.update();
      this.uvs = this.batchUvs.data;
    } else {
      this.uvs = geomUvs.data;
    }
  }
  _calculateBounds() {
    this.calculateVertices();
    this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
  }
  containsPoint(point) {
    if (!this.getBounds().contains(point.x, point.y)) {
      return false;
    }
    this.worldTransform.applyInverse(point, tempPoint$1);
    const vertices = this.geometry.getBuffer("aVertexPosition").data;
    const points = tempPolygon.points;
    const indices2 = this.geometry.getIndex().data;
    const len = indices2.length;
    const step = this.drawMode === 4 ? 3 : 1;
    for (let i2 = 0; i2 + 2 < len; i2 += step) {
      const ind0 = indices2[i2] * 2;
      const ind1 = indices2[i2 + 1] * 2;
      const ind2 = indices2[i2 + 2] * 2;
      points[0] = vertices[ind0];
      points[1] = vertices[ind0 + 1];
      points[2] = vertices[ind1];
      points[3] = vertices[ind1 + 1];
      points[4] = vertices[ind2];
      points[5] = vertices[ind2 + 1];
      if (tempPolygon.contains(tempPoint$1.x, tempPoint$1.y)) {
        return true;
      }
    }
    return false;
  }
  destroy(options) {
    super.destroy(options);
    if (this._cachedTexture) {
      this._cachedTexture.destroy();
      this._cachedTexture = null;
    }
    this.geometry = null;
    this.shader = null;
    this.state = null;
    this.uvs = null;
    this.indices = null;
    this.vertexData = null;
  }
};
let Mesh = _Mesh;
Mesh.BATCHABLE_SIZE = 100;
class MeshGeometry extends Geometry {
  constructor(vertices, uvs, index2) {
    super();
    const verticesBuffer = new Buffer$1(vertices);
    const uvsBuffer = new Buffer$1(uvs, true);
    const indexBuffer = new Buffer$1(index2, true, true);
    this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES.FLOAT).addIndex(indexBuffer);
    this._updateId = -1;
  }
  get vertexDirtyId() {
    return this.buffers[0]._updateID;
  }
}
var fragment$1 = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";
var vertex$1 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";
class MeshMaterial extends Shader {
  constructor(uSampler, options) {
    const uniforms = {
      uSampler,
      alpha: 1,
      uTextureMatrix: Matrix.IDENTITY,
      uColor: new Float32Array([1, 1, 1, 1])
    };
    options = Object.assign({
      tint: 16777215,
      alpha: 1,
      pluginName: "batch"
    }, options);
    if (options.uniforms) {
      Object.assign(uniforms, options.uniforms);
    }
    super(options.program || Program.from(vertex$1, fragment$1), uniforms);
    this._colorDirty = false;
    this.uvMatrix = new TextureMatrix(uSampler);
    this.batchable = options.program === void 0;
    this.pluginName = options.pluginName;
    this._tintColor = new Color(options.tint);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
    this._colorDirty = true;
    this.alpha = options.alpha;
  }
  get texture() {
    return this.uniforms.uSampler;
  }
  set texture(value2) {
    if (this.uniforms.uSampler !== value2) {
      if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value2.baseTexture.alphaMode) {
        this._colorDirty = true;
      }
      this.uniforms.uSampler = value2;
      this.uvMatrix.texture = value2;
    }
  }
  set alpha(value2) {
    if (value2 === this._alpha)
      return;
    this._alpha = value2;
    this._colorDirty = true;
  }
  get alpha() {
    return this._alpha;
  }
  set tint(value2) {
    if (value2 === this.tint)
      return;
    this._tintColor.setValue(value2);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
    this._colorDirty = true;
  }
  get tint() {
    return this._tintColor.value;
  }
  get tintValue() {
    return this._tintColor.toNumber();
  }
  update() {
    if (this._colorDirty) {
      this._colorDirty = false;
      const baseTexture = this.texture.baseTexture;
      const applyToChannels = baseTexture.alphaMode;
      Color.shared.setValue(this._tintColor).premultiply(this._alpha, applyToChannels).toArray(this.uniforms.uColor);
    }
    if (this.uvMatrix.update()) {
      this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
    }
  }
}
class PlaneGeometry extends MeshGeometry {
  constructor(width = 100, height = 100, segWidth = 10, segHeight = 10) {
    super();
    this.segWidth = segWidth;
    this.segHeight = segHeight;
    this.width = width;
    this.height = height;
    this.build();
  }
  build() {
    const total = this.segWidth * this.segHeight;
    const verts = [];
    const uvs = [];
    const indices2 = [];
    const segmentsX = this.segWidth - 1;
    const segmentsY = this.segHeight - 1;
    const sizeX = this.width / segmentsX;
    const sizeY = this.height / segmentsY;
    for (let i2 = 0; i2 < total; i2++) {
      const x2 = i2 % this.segWidth;
      const y2 = i2 / this.segWidth | 0;
      verts.push(x2 * sizeX, y2 * sizeY);
      uvs.push(x2 / segmentsX, y2 / segmentsY);
    }
    const totalSub = segmentsX * segmentsY;
    for (let i2 = 0; i2 < totalSub; i2++) {
      const xpos = i2 % segmentsX;
      const ypos = i2 / segmentsX | 0;
      const value2 = ypos * this.segWidth + xpos;
      const value22 = ypos * this.segWidth + xpos + 1;
      const value3 = (ypos + 1) * this.segWidth + xpos;
      const value4 = (ypos + 1) * this.segWidth + xpos + 1;
      indices2.push(value2, value22, value3, value22, value4, value3);
    }
    this.buffers[0].data = new Float32Array(verts);
    this.buffers[1].data = new Float32Array(uvs);
    this.indexBuffer.data = new Uint16Array(indices2);
    this.buffers[0].update();
    this.buffers[1].update();
    this.indexBuffer.update();
  }
}
class RopeGeometry extends MeshGeometry {
  constructor(width = 200, points, textureScale = 0) {
    super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));
    this.points = points;
    this._width = width;
    this.textureScale = textureScale;
    this.build();
  }
  get width() {
    return this._width;
  }
  build() {
    const points = this.points;
    if (!points)
      return;
    const vertexBuffer = this.getBuffer("aVertexPosition");
    const uvBuffer = this.getBuffer("aTextureCoord");
    const indexBuffer = this.getIndex();
    if (points.length < 1) {
      return;
    }
    if (vertexBuffer.data.length / 4 !== points.length) {
      vertexBuffer.data = new Float32Array(points.length * 4);
      uvBuffer.data = new Float32Array(points.length * 4);
      indexBuffer.data = new Uint16Array((points.length - 1) * 6);
    }
    const uvs = uvBuffer.data;
    const indices2 = indexBuffer.data;
    uvs[0] = 0;
    uvs[1] = 0;
    uvs[2] = 0;
    uvs[3] = 1;
    let amount = 0;
    let prev2 = points[0];
    const textureWidth = this._width * this.textureScale;
    const total = points.length;
    for (let i2 = 0; i2 < total; i2++) {
      const index2 = i2 * 4;
      if (this.textureScale > 0) {
        const dx = prev2.x - points[i2].x;
        const dy = prev2.y - points[i2].y;
        const distance2 = Math.sqrt(dx * dx + dy * dy);
        prev2 = points[i2];
        amount += distance2 / textureWidth;
      } else {
        amount = i2 / (total - 1);
      }
      uvs[index2] = amount;
      uvs[index2 + 1] = 0;
      uvs[index2 + 2] = amount;
      uvs[index2 + 3] = 1;
    }
    let indexCount = 0;
    for (let i2 = 0; i2 < total - 1; i2++) {
      const index2 = i2 * 2;
      indices2[indexCount++] = index2;
      indices2[indexCount++] = index2 + 1;
      indices2[indexCount++] = index2 + 2;
      indices2[indexCount++] = index2 + 2;
      indices2[indexCount++] = index2 + 1;
      indices2[indexCount++] = index2 + 3;
    }
    uvBuffer.update();
    indexBuffer.update();
    this.updateVertices();
  }
  updateVertices() {
    const points = this.points;
    if (points.length < 1) {
      return;
    }
    let lastPoint = points[0];
    let nextPoint;
    let perpX = 0;
    let perpY = 0;
    const vertices = this.buffers[0].data;
    const total = points.length;
    const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
    for (let i2 = 0; i2 < total; i2++) {
      const point = points[i2];
      const index2 = i2 * 4;
      if (i2 < points.length - 1) {
        nextPoint = points[i2 + 1];
      } else {
        nextPoint = point;
      }
      perpY = -(nextPoint.x - lastPoint.x);
      perpX = nextPoint.y - lastPoint.y;
      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
      if (perpLength < 1e-6) {
        perpX = 0;
        perpY = 0;
      } else {
        perpX /= perpLength;
        perpY /= perpLength;
        perpX *= halfWidth;
        perpY *= halfWidth;
      }
      vertices[index2] = point.x + perpX;
      vertices[index2 + 1] = point.y + perpY;
      vertices[index2 + 2] = point.x - perpX;
      vertices[index2 + 3] = point.y - perpY;
      lastPoint = point;
    }
    this.buffers[0].update();
  }
  update() {
    if (this.textureScale > 0) {
      this.build();
    } else {
      this.updateVertices();
    }
  }
}
class SimplePlane extends Mesh {
  constructor(texture, verticesX, verticesY) {
    const planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
    const meshMaterial = new MeshMaterial(Texture.WHITE);
    super(planeGeometry, meshMaterial);
    this.texture = texture;
    this.autoResize = true;
  }
  textureUpdated() {
    this._textureID = this.shader.texture._updateID;
    const geometry = this.geometry;
    const { width, height } = this.shader.texture;
    if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
      geometry.width = this.shader.texture.width;
      geometry.height = this.shader.texture.height;
      geometry.build();
    }
  }
  set texture(value2) {
    if (this.shader.texture === value2) {
      return;
    }
    this.shader.texture = value2;
    this._textureID = -1;
    if (value2.baseTexture.valid) {
      this.textureUpdated();
    } else {
      value2.once("update", this.textureUpdated, this);
    }
  }
  get texture() {
    return this.shader.texture;
  }
  _render(renderer2) {
    if (this._textureID !== this.shader.texture._updateID) {
      this.textureUpdated();
    }
    super._render(renderer2);
  }
  destroy(options) {
    this.shader.texture.off("update", this.textureUpdated, this);
    super.destroy(options);
  }
}
const DEFAULT_BORDER_SIZE = 10;
class NineSlicePlane extends SimplePlane {
  constructor(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
    var _a, _b, _c, _d;
    super(Texture.WHITE, 4, 4);
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    this._width = this._origWidth;
    this._height = this._origHeight;
    this._leftWidth = leftWidth ?? ((_a = texture.defaultBorders) == null ? void 0 : _a.left) ?? DEFAULT_BORDER_SIZE;
    this._rightWidth = rightWidth ?? ((_b = texture.defaultBorders) == null ? void 0 : _b.right) ?? DEFAULT_BORDER_SIZE;
    this._topHeight = topHeight ?? ((_c = texture.defaultBorders) == null ? void 0 : _c.top) ?? DEFAULT_BORDER_SIZE;
    this._bottomHeight = bottomHeight ?? ((_d = texture.defaultBorders) == null ? void 0 : _d.bottom) ?? DEFAULT_BORDER_SIZE;
    this.texture = texture;
  }
  textureUpdated() {
    this._textureID = this.shader.texture._updateID;
    this._refresh();
  }
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value2) {
    this.geometry.getBuffer("aVertexPosition").data = value2;
  }
  updateHorizontalVertices() {
    const vertices = this.vertices;
    const scale = this._getMinScale();
    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
    vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
    vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
  }
  updateVerticalVertices() {
    const vertices = this.vertices;
    const scale = this._getMinScale();
    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
    vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
    vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
  }
  _getMinScale() {
    const w2 = this._leftWidth + this._rightWidth;
    const scaleW = this._width > w2 ? 1 : this._width / w2;
    const h2 = this._topHeight + this._bottomHeight;
    const scaleH = this._height > h2 ? 1 : this._height / h2;
    const scale = Math.min(scaleW, scaleH);
    return scale;
  }
  get width() {
    return this._width;
  }
  set width(value2) {
    this._width = value2;
    this._refresh();
  }
  get height() {
    return this._height;
  }
  set height(value2) {
    this._height = value2;
    this._refresh();
  }
  get leftWidth() {
    return this._leftWidth;
  }
  set leftWidth(value2) {
    this._leftWidth = value2;
    this._refresh();
  }
  get rightWidth() {
    return this._rightWidth;
  }
  set rightWidth(value2) {
    this._rightWidth = value2;
    this._refresh();
  }
  get topHeight() {
    return this._topHeight;
  }
  set topHeight(value2) {
    this._topHeight = value2;
    this._refresh();
  }
  get bottomHeight() {
    return this._bottomHeight;
  }
  set bottomHeight(value2) {
    this._bottomHeight = value2;
    this._refresh();
  }
  _refresh() {
    const texture = this.texture;
    const uvs = this.geometry.buffers[1].data;
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    const _uvw = 1 / this._origWidth;
    const _uvh = 1 / this._origHeight;
    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
    this.updateHorizontalVertices();
    this.updateVerticalVertices();
    this.geometry.buffers[0].update();
    this.geometry.buffers[1].update();
  }
}
class SimpleMesh extends Mesh {
  constructor(texture = Texture.EMPTY, vertices, uvs, indices2, drawMode) {
    const geometry = new MeshGeometry(vertices, uvs, indices2);
    geometry.getBuffer("aVertexPosition").static = false;
    const meshMaterial = new MeshMaterial(texture);
    super(geometry, meshMaterial, null, drawMode);
    this.autoUpdate = true;
  }
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value2) {
    this.geometry.getBuffer("aVertexPosition").data = value2;
  }
  _render(renderer2) {
    if (this.autoUpdate) {
      this.geometry.getBuffer("aVertexPosition").update();
    }
    super._render(renderer2);
  }
}
class SimpleRope extends Mesh {
  constructor(texture, points, textureScale = 0) {
    const ropeGeometry = new RopeGeometry(texture.height, points, textureScale);
    const meshMaterial = new MeshMaterial(texture);
    if (textureScale > 0) {
      texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;
    }
    super(ropeGeometry, meshMaterial);
    this.autoUpdate = true;
  }
  _render(renderer2) {
    const geometry = this.geometry;
    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
      geometry._width = this.shader.texture.height;
      geometry.update();
    }
    super._render(renderer2);
  }
}
class ParticleContainer extends Container {
  constructor(maxSize = 1500, properties, batchSize = 16384, autoResize = false) {
    super();
    const maxBatchSize = 16384;
    if (batchSize > maxBatchSize) {
      batchSize = maxBatchSize;
    }
    this._properties = [false, true, false, false, false];
    this._maxSize = maxSize;
    this._batchSize = batchSize;
    this._buffers = null;
    this._bufferUpdateIDs = [];
    this._updateID = 0;
    this.interactiveChildren = false;
    this.blendMode = BLEND_MODES.NORMAL;
    this.autoResize = autoResize;
    this.roundPixels = true;
    this.baseTexture = null;
    this.setProperties(properties);
    this._tintColor = new Color(0);
    this.tintRgb = new Float32Array(3);
    this.tint = 16777215;
  }
  setProperties(properties) {
    if (properties) {
      this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
      this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];
      this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];
      this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];
      this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
    }
  }
  updateTransform() {
    this.displayObjectUpdateTransform();
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value2) {
    this._tintColor.setValue(value2);
    this._tintColor.toRgbArray(this.tintRgb);
  }
  render(renderer2) {
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
      return;
    }
    if (!this.baseTexture) {
      this.baseTexture = this.children[0]._texture.baseTexture;
      if (!this.baseTexture.valid) {
        this.baseTexture.once("update", () => this.onChildrenChange(0));
      }
    }
    renderer2.batch.setObjectRenderer(renderer2.plugins.particle);
    renderer2.plugins.particle.render(this);
  }
  onChildrenChange(smallestChildIndex) {
    const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
    while (this._bufferUpdateIDs.length < bufferIndex) {
      this._bufferUpdateIDs.push(0);
    }
    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
  }
  dispose() {
    if (this._buffers) {
      for (let i2 = 0; i2 < this._buffers.length; ++i2) {
        this._buffers[i2].destroy();
      }
      this._buffers = null;
    }
  }
  destroy(options) {
    super.destroy(options);
    this.dispose();
    this._properties = null;
    this._buffers = null;
    this._bufferUpdateIDs = null;
  }
}
class ParticleBuffer {
  constructor(properties, dynamicPropertyFlags, size2) {
    this.geometry = new Geometry();
    this.indexBuffer = null;
    this.size = size2;
    this.dynamicProperties = [];
    this.staticProperties = [];
    for (let i2 = 0; i2 < properties.length; ++i2) {
      let property = properties[i2];
      property = {
        attributeName: property.attributeName,
        size: property.size,
        uploadFunction: property.uploadFunction,
        type: property.type || TYPES.FLOAT,
        offset: property.offset
      };
      if (dynamicPropertyFlags[i2]) {
        this.dynamicProperties.push(property);
      } else {
        this.staticProperties.push(property);
      }
    }
    this.staticStride = 0;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.dynamicStride = 0;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this._updateID = 0;
    this.initBuffers();
  }
  initBuffers() {
    const geometry = this.geometry;
    let dynamicOffset = 0;
    this.indexBuffer = new Buffer$1(createIndicesForQuads(this.size), true, true);
    geometry.addIndex(this.indexBuffer);
    this.dynamicStride = 0;
    for (let i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
      const property = this.dynamicProperties[i2];
      property.offset = dynamicOffset;
      dynamicOffset += property.size;
      this.dynamicStride += property.size;
    }
    const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
    this.dynamicData = new Float32Array(dynBuffer);
    this.dynamicDataUint32 = new Uint32Array(dynBuffer);
    this.dynamicBuffer = new Buffer$1(this.dynamicData, false, false);
    let staticOffset = 0;
    this.staticStride = 0;
    for (let i2 = 0; i2 < this.staticProperties.length; ++i2) {
      const property = this.staticProperties[i2];
      property.offset = staticOffset;
      staticOffset += property.size;
      this.staticStride += property.size;
    }
    const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
    this.staticData = new Float32Array(statBuffer);
    this.staticDataUint32 = new Uint32Array(statBuffer);
    this.staticBuffer = new Buffer$1(this.staticData, true, false);
    for (let i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
      const property = this.dynamicProperties[i2];
      geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);
    }
    for (let i2 = 0; i2 < this.staticProperties.length; ++i2) {
      const property = this.staticProperties[i2];
      geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);
    }
  }
  uploadDynamic(children, startIndex, amount) {
    for (let i2 = 0; i2 < this.dynamicProperties.length; i2++) {
      const property = this.dynamicProperties[i2];
      property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
    }
    this.dynamicBuffer._updateID++;
  }
  uploadStatic(children, startIndex, amount) {
    for (let i2 = 0; i2 < this.staticProperties.length; i2++) {
      const property = this.staticProperties[i2];
      property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
    }
    this.staticBuffer._updateID++;
  }
  destroy() {
    this.indexBuffer = null;
    this.dynamicProperties = null;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this.staticProperties = null;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.geometry.destroy();
  }
}
var fragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";
var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";
class ParticleRenderer extends ObjectRenderer {
  constructor(renderer2) {
    super(renderer2);
    this.shader = null;
    this.properties = null;
    this.tempMatrix = new Matrix();
    this.properties = [
      {
        attributeName: "aVertexPosition",
        size: 2,
        uploadFunction: this.uploadVertices,
        offset: 0
      },
      {
        attributeName: "aPositionCoord",
        size: 2,
        uploadFunction: this.uploadPosition,
        offset: 0
      },
      {
        attributeName: "aRotation",
        size: 1,
        uploadFunction: this.uploadRotation,
        offset: 0
      },
      {
        attributeName: "aTextureCoord",
        size: 2,
        uploadFunction: this.uploadUvs,
        offset: 0
      },
      {
        attributeName: "aColor",
        size: 1,
        type: TYPES.UNSIGNED_BYTE,
        uploadFunction: this.uploadTint,
        offset: 0
      }
    ];
    this.shader = Shader.from(vertex, fragment, {});
    this.state = State.for2d();
  }
  render(container) {
    const children = container.children;
    const maxSize = container._maxSize;
    const batchSize = container._batchSize;
    const renderer2 = this.renderer;
    let totalChildren = children.length;
    if (totalChildren === 0) {
      return;
    } else if (totalChildren > maxSize && !container.autoResize) {
      totalChildren = maxSize;
    }
    let buffers = container._buffers;
    if (!buffers) {
      buffers = container._buffers = this.generateBuffers(container);
    }
    const baseTexture = children[0]._texture.baseTexture;
    const premultiplied = baseTexture.alphaMode > 0;
    this.state.blendMode = correctBlendMode(container.blendMode, premultiplied);
    renderer2.state.set(this.state);
    const gl = renderer2.gl;
    const m2 = container.worldTransform.copyTo(this.tempMatrix);
    m2.prepend(renderer2.globalUniforms.uniforms.projectionMatrix);
    this.shader.uniforms.translationMatrix = m2.toArray(true);
    this.shader.uniforms.uColor = Color.shared.setValue(container.tintRgb).premultiply(container.worldAlpha, premultiplied).toArray(this.shader.uniforms.uColor);
    this.shader.uniforms.uSampler = baseTexture;
    this.renderer.shader.bind(this.shader);
    let updateStatic = false;
    for (let i2 = 0, j2 = 0; i2 < totalChildren; i2 += batchSize, j2 += 1) {
      let amount = totalChildren - i2;
      if (amount > batchSize) {
        amount = batchSize;
      }
      if (j2 >= buffers.length) {
        buffers.push(this._generateOneMoreBuffer(container));
      }
      const buffer2 = buffers[j2];
      buffer2.uploadDynamic(children, i2, amount);
      const bid = container._bufferUpdateIDs[j2] || 0;
      updateStatic = updateStatic || buffer2._updateID < bid;
      if (updateStatic) {
        buffer2._updateID = container._updateID;
        buffer2.uploadStatic(children, i2, amount);
      }
      renderer2.geometry.bind(buffer2.geometry);
      gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
    }
  }
  generateBuffers(container) {
    const buffers = [];
    const size2 = container._maxSize;
    const batchSize = container._batchSize;
    const dynamicPropertyFlags = container._properties;
    for (let i2 = 0; i2 < size2; i2 += batchSize) {
      buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
    }
    return buffers;
  }
  _generateOneMoreBuffer(container) {
    const batchSize = container._batchSize;
    const dynamicPropertyFlags = container._properties;
    return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
  }
  uploadVertices(children, startIndex, amount, array2, stride, offset) {
    let w0 = 0;
    let w1 = 0;
    let h0 = 0;
    let h1 = 0;
    for (let i2 = 0; i2 < amount; ++i2) {
      const sprite = children[startIndex + i2];
      const texture = sprite._texture;
      const sx = sprite.scale.x;
      const sy = sprite.scale.y;
      const trim = texture.trim;
      const orig = texture.orig;
      if (trim) {
        w1 = trim.x - sprite.anchor.x * orig.width;
        w0 = w1 + trim.width;
        h1 = trim.y - sprite.anchor.y * orig.height;
        h0 = h1 + trim.height;
      } else {
        w0 = orig.width * (1 - sprite.anchor.x);
        w1 = orig.width * -sprite.anchor.x;
        h0 = orig.height * (1 - sprite.anchor.y);
        h1 = orig.height * -sprite.anchor.y;
      }
      array2[offset] = w1 * sx;
      array2[offset + 1] = h1 * sy;
      array2[offset + stride] = w0 * sx;
      array2[offset + stride + 1] = h1 * sy;
      array2[offset + stride * 2] = w0 * sx;
      array2[offset + stride * 2 + 1] = h0 * sy;
      array2[offset + stride * 3] = w1 * sx;
      array2[offset + stride * 3 + 1] = h0 * sy;
      offset += stride * 4;
    }
  }
  uploadPosition(children, startIndex, amount, array2, stride, offset) {
    for (let i2 = 0; i2 < amount; i2++) {
      const spritePosition = children[startIndex + i2].position;
      array2[offset] = spritePosition.x;
      array2[offset + 1] = spritePosition.y;
      array2[offset + stride] = spritePosition.x;
      array2[offset + stride + 1] = spritePosition.y;
      array2[offset + stride * 2] = spritePosition.x;
      array2[offset + stride * 2 + 1] = spritePosition.y;
      array2[offset + stride * 3] = spritePosition.x;
      array2[offset + stride * 3 + 1] = spritePosition.y;
      offset += stride * 4;
    }
  }
  uploadRotation(children, startIndex, amount, array2, stride, offset) {
    for (let i2 = 0; i2 < amount; i2++) {
      const spriteRotation = children[startIndex + i2].rotation;
      array2[offset] = spriteRotation;
      array2[offset + stride] = spriteRotation;
      array2[offset + stride * 2] = spriteRotation;
      array2[offset + stride * 3] = spriteRotation;
      offset += stride * 4;
    }
  }
  uploadUvs(children, startIndex, amount, array2, stride, offset) {
    for (let i2 = 0; i2 < amount; ++i2) {
      const textureUvs = children[startIndex + i2]._texture._uvs;
      if (textureUvs) {
        array2[offset] = textureUvs.x0;
        array2[offset + 1] = textureUvs.y0;
        array2[offset + stride] = textureUvs.x1;
        array2[offset + stride + 1] = textureUvs.y1;
        array2[offset + stride * 2] = textureUvs.x2;
        array2[offset + stride * 2 + 1] = textureUvs.y2;
        array2[offset + stride * 3] = textureUvs.x3;
        array2[offset + stride * 3 + 1] = textureUvs.y3;
        offset += stride * 4;
      } else {
        array2[offset] = 0;
        array2[offset + 1] = 0;
        array2[offset + stride] = 0;
        array2[offset + stride + 1] = 0;
        array2[offset + stride * 2] = 0;
        array2[offset + stride * 2 + 1] = 0;
        array2[offset + stride * 3] = 0;
        array2[offset + stride * 3 + 1] = 0;
        offset += stride * 4;
      }
    }
  }
  uploadTint(children, startIndex, amount, array2, stride, offset) {
    for (let i2 = 0; i2 < amount; ++i2) {
      const sprite = children[startIndex + i2];
      const result = Color.shared.setValue(sprite._tintRGB).toPremultiplied(sprite.alpha, sprite.texture.baseTexture.alphaMode > 0);
      array2[offset] = result;
      array2[offset + stride] = result;
      array2[offset + stride * 2] = result;
      array2[offset + stride * 3] = result;
      offset += stride * 4;
    }
  }
  destroy() {
    super.destroy();
    if (this.shader) {
      this.shader.destroy();
      this.shader = null;
    }
    this.tempMatrix = null;
  }
}
ParticleRenderer.extension = {
  name: "particle",
  type: ExtensionType.RendererPlugin
};
extensions$1.add(ParticleRenderer);
var TEXT_GRADIENT = /* @__PURE__ */ ((TEXT_GRADIENT2) => {
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
  return TEXT_GRADIENT2;
})(TEXT_GRADIENT || {});
const contextSettings = {
  willReadFrequently: true
};
const _TextMetrics = class {
  static get experimentalLetterSpacingSupported() {
    let result = _TextMetrics._experimentalLetterSpacingSupported;
    if (result !== void 0) {
      const proto = settings.ADAPTER.getCanvasRenderingContext2D().prototype;
      result = _TextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
    }
    return result;
  }
  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
    this.text = text;
    this.style = style;
    this.width = width;
    this.height = height;
    this.lines = lines;
    this.lineWidths = lineWidths;
    this.lineHeight = lineHeight;
    this.maxLineWidth = maxLineWidth;
    this.fontProperties = fontProperties;
  }
  static measureText(text, style, wordWrap, canvas = _TextMetrics._canvas) {
    wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
    const font = style.toFontString();
    const fontProperties = _TextMetrics.measureFont(font);
    if (fontProperties.fontSize === 0) {
      fontProperties.fontSize = style.fontSize;
      fontProperties.ascent = style.fontSize;
    }
    const context2 = canvas.getContext("2d", contextSettings);
    context2.font = font;
    const outputText = wordWrap ? _TextMetrics.wordWrap(text, style, canvas) : text;
    const lines = outputText.split(/(?:\r\n|\r|\n)/);
    const lineWidths = new Array(lines.length);
    let maxLineWidth = 0;
    for (let i2 = 0; i2 < lines.length; i2++) {
      const lineWidth = _TextMetrics._measureText(lines[i2], style.letterSpacing, context2);
      lineWidths[i2] = lineWidth;
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    let width = maxLineWidth + style.strokeThickness;
    if (style.dropShadow) {
      width += style.dropShadowDistance;
    }
    const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
    let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + (lines.length - 1) * (lineHeight + style.leading);
    if (style.dropShadow) {
      height += style.dropShadowDistance;
    }
    return new _TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
  }
  static _measureText(text, letterSpacing, context2) {
    let useExperimentalLetterSpacing = false;
    if (_TextMetrics.experimentalLetterSpacingSupported) {
      if (_TextMetrics.experimentalLetterSpacing) {
        context2.letterSpacing = `${letterSpacing}px`;
        context2.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        context2.letterSpacing = "0px";
        context2.textLetterSpacing = "0px";
      }
    }
    let width = context2.measureText(text).width;
    if (width > 0) {
      if (useExperimentalLetterSpacing) {
        width -= letterSpacing;
      } else {
        width += (_TextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;
      }
    }
    return width;
  }
  static wordWrap(text, style, canvas = _TextMetrics._canvas) {
    const context2 = canvas.getContext("2d", contextSettings);
    let width = 0;
    let line = "";
    let lines = "";
    const cache2 = /* @__PURE__ */ Object.create(null);
    const { letterSpacing, whiteSpace } = style;
    const collapseSpaces = _TextMetrics.collapseSpaces(whiteSpace);
    const collapseNewlines = _TextMetrics.collapseNewlines(whiteSpace);
    let canPrependSpaces = !collapseSpaces;
    const wordWrapWidth = style.wordWrapWidth + letterSpacing;
    const tokens = _TextMetrics.tokenize(text);
    for (let i2 = 0; i2 < tokens.length; i2++) {
      let token = tokens[i2];
      if (_TextMetrics.isNewline(token)) {
        if (!collapseNewlines) {
          lines += _TextMetrics.addLine(line);
          canPrependSpaces = !collapseSpaces;
          line = "";
          width = 0;
          continue;
        }
        token = " ";
      }
      if (collapseSpaces) {
        const currIsBreakingSpace = _TextMetrics.isBreakingSpace(token);
        const lastIsBreakingSpace = _TextMetrics.isBreakingSpace(line[line.length - 1]);
        if (currIsBreakingSpace && lastIsBreakingSpace) {
          continue;
        }
      }
      const tokenWidth = _TextMetrics.getFromCache(token, letterSpacing, cache2, context2);
      if (tokenWidth > wordWrapWidth) {
        if (line !== "") {
          lines += _TextMetrics.addLine(line);
          line = "";
          width = 0;
        }
        if (_TextMetrics.canBreakWords(token, style.breakWords)) {
          const characters = _TextMetrics.wordWrapSplit(token);
          for (let j2 = 0; j2 < characters.length; j2++) {
            let char = characters[j2];
            let lastChar = char;
            let k4 = 1;
            while (characters[j2 + k4]) {
              const nextChar = characters[j2 + k4];
              if (!_TextMetrics.canBreakChars(lastChar, nextChar, token, j2, style.breakWords)) {
                char += nextChar;
              } else {
                break;
              }
              lastChar = nextChar;
              k4++;
            }
            j2 += k4 - 1;
            const characterWidth = _TextMetrics.getFromCache(char, letterSpacing, cache2, context2);
            if (characterWidth + width > wordWrapWidth) {
              lines += _TextMetrics.addLine(line);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
            line += char;
            width += characterWidth;
          }
        } else {
          if (line.length > 0) {
            lines += _TextMetrics.addLine(line);
            line = "";
            width = 0;
          }
          const isLastToken = i2 === tokens.length - 1;
          lines += _TextMetrics.addLine(token, !isLastToken);
          canPrependSpaces = false;
          line = "";
          width = 0;
        }
      } else {
        if (tokenWidth + width > wordWrapWidth) {
          canPrependSpaces = false;
          lines += _TextMetrics.addLine(line);
          line = "";
          width = 0;
        }
        if (line.length > 0 || !_TextMetrics.isBreakingSpace(token) || canPrependSpaces) {
          line += token;
          width += tokenWidth;
        }
      }
    }
    lines += _TextMetrics.addLine(line, false);
    return lines;
  }
  static addLine(line, newLine = true) {
    line = _TextMetrics.trimRight(line);
    line = newLine ? `${line}
` : line;
    return line;
  }
  static getFromCache(key, letterSpacing, cache2, context2) {
    let width = cache2[key];
    if (typeof width !== "number") {
      width = _TextMetrics._measureText(key, letterSpacing, context2) + letterSpacing;
      cache2[key] = width;
    }
    return width;
  }
  static collapseSpaces(whiteSpace) {
    return whiteSpace === "normal" || whiteSpace === "pre-line";
  }
  static collapseNewlines(whiteSpace) {
    return whiteSpace === "normal";
  }
  static trimRight(text) {
    if (typeof text !== "string") {
      return "";
    }
    for (let i2 = text.length - 1; i2 >= 0; i2--) {
      const char = text[i2];
      if (!_TextMetrics.isBreakingSpace(char)) {
        break;
      }
      text = text.slice(0, -1);
    }
    return text;
  }
  static isNewline(char) {
    if (typeof char !== "string") {
      return false;
    }
    return _TextMetrics._newlines.includes(char.charCodeAt(0));
  }
  static isBreakingSpace(char, _nextChar) {
    if (typeof char !== "string") {
      return false;
    }
    return _TextMetrics._breakingSpaces.includes(char.charCodeAt(0));
  }
  static tokenize(text) {
    const tokens = [];
    let token = "";
    if (typeof text !== "string") {
      return tokens;
    }
    for (let i2 = 0; i2 < text.length; i2++) {
      const char = text[i2];
      const nextChar = text[i2 + 1];
      if (_TextMetrics.isBreakingSpace(char, nextChar) || _TextMetrics.isNewline(char)) {
        if (token !== "") {
          tokens.push(token);
          token = "";
        }
        tokens.push(char);
        continue;
      }
      token += char;
    }
    if (token !== "") {
      tokens.push(token);
    }
    return tokens;
  }
  static canBreakWords(_token, breakWords) {
    return breakWords;
  }
  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
    return true;
  }
  static wordWrapSplit(token) {
    return _TextMetrics.graphemeSegmenter(token);
  }
  static measureFont(font) {
    if (_TextMetrics._fonts[font]) {
      return _TextMetrics._fonts[font];
    }
    const properties = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    };
    const canvas = _TextMetrics._canvas;
    const context2 = _TextMetrics._context;
    context2.font = font;
    const metricsString = _TextMetrics.METRICS_STRING + _TextMetrics.BASELINE_SYMBOL;
    const width = Math.ceil(context2.measureText(metricsString).width);
    let baseline = Math.ceil(context2.measureText(_TextMetrics.BASELINE_SYMBOL).width);
    const height = Math.ceil(_TextMetrics.HEIGHT_MULTIPLIER * baseline);
    baseline = baseline * _TextMetrics.BASELINE_MULTIPLIER | 0;
    if (width === 0 || height === 0) {
      _TextMetrics._fonts[font] = properties;
      return properties;
    }
    canvas.width = width;
    canvas.height = height;
    context2.fillStyle = "#f00";
    context2.fillRect(0, 0, width, height);
    context2.font = font;
    context2.textBaseline = "alphabetic";
    context2.fillStyle = "#000";
    context2.fillText(metricsString, 0, baseline);
    const imagedata = context2.getImageData(0, 0, width, height).data;
    const pixels = imagedata.length;
    const line = width * 4;
    let i2 = 0;
    let idx = 0;
    let stop = false;
    for (i2 = 0; i2 < baseline; ++i2) {
      for (let j2 = 0; j2 < line; j2 += 4) {
        if (imagedata[idx + j2] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx += line;
      } else {
        break;
      }
    }
    properties.ascent = baseline - i2;
    idx = pixels - line;
    stop = false;
    for (i2 = height; i2 > baseline; --i2) {
      for (let j2 = 0; j2 < line; j2 += 4) {
        if (imagedata[idx + j2] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx -= line;
      } else {
        break;
      }
    }
    properties.descent = i2 - baseline;
    properties.fontSize = properties.ascent + properties.descent;
    _TextMetrics._fonts[font] = properties;
    return properties;
  }
  static clearMetrics(font = "") {
    if (font) {
      delete _TextMetrics._fonts[font];
    } else {
      _TextMetrics._fonts = {};
    }
  }
  static get _canvas() {
    if (!_TextMetrics.__canvas) {
      let canvas;
      try {
        const c3 = new OffscreenCanvas(0, 0);
        const context2 = c3.getContext("2d", contextSettings);
        if (context2 == null ? void 0 : context2.measureText) {
          _TextMetrics.__canvas = c3;
          return c3;
        }
        canvas = settings.ADAPTER.createCanvas();
      } catch (ex) {
        canvas = settings.ADAPTER.createCanvas();
      }
      canvas.width = canvas.height = 10;
      _TextMetrics.__canvas = canvas;
    }
    return _TextMetrics.__canvas;
  }
  static get _context() {
    if (!_TextMetrics.__context) {
      _TextMetrics.__context = _TextMetrics._canvas.getContext("2d", contextSettings);
    }
    return _TextMetrics.__context;
  }
};
let TextMetrics = _TextMetrics;
TextMetrics.METRICS_STRING = "|ÉqÅ";
TextMetrics.BASELINE_SYMBOL = "M";
TextMetrics.BASELINE_MULTIPLIER = 1.4;
TextMetrics.HEIGHT_MULTIPLIER = 2;
TextMetrics.graphemeSegmenter = (() => {
  if (typeof (Intl == null ? void 0 : Intl.Segmenter) === "function") {
    const segmenter = new Intl.Segmenter();
    return (s2) => [...segmenter.segment(s2)].map((x2) => x2.segment);
  }
  return (s2) => [...s2];
})();
TextMetrics.experimentalLetterSpacing = false;
TextMetrics._fonts = {};
TextMetrics._newlines = [
  10,
  13
];
TextMetrics._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];
const genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
const _TextStyle = class {
  constructor(style) {
    this.styleID = 0;
    this.reset();
    deepCopyProperties(this, style, style);
  }
  clone() {
    const clonedProperties = {};
    deepCopyProperties(clonedProperties, this, _TextStyle.defaultStyle);
    return new _TextStyle(clonedProperties);
  }
  reset() {
    deepCopyProperties(this, _TextStyle.defaultStyle, _TextStyle.defaultStyle);
  }
  get align() {
    return this._align;
  }
  set align(align) {
    if (this._align !== align) {
      this._align = align;
      this.styleID++;
    }
  }
  get breakWords() {
    return this._breakWords;
  }
  set breakWords(breakWords) {
    if (this._breakWords !== breakWords) {
      this._breakWords = breakWords;
      this.styleID++;
    }
  }
  get dropShadow() {
    return this._dropShadow;
  }
  set dropShadow(dropShadow) {
    if (this._dropShadow !== dropShadow) {
      this._dropShadow = dropShadow;
      this.styleID++;
    }
  }
  get dropShadowAlpha() {
    return this._dropShadowAlpha;
  }
  set dropShadowAlpha(dropShadowAlpha) {
    if (this._dropShadowAlpha !== dropShadowAlpha) {
      this._dropShadowAlpha = dropShadowAlpha;
      this.styleID++;
    }
  }
  get dropShadowAngle() {
    return this._dropShadowAngle;
  }
  set dropShadowAngle(dropShadowAngle) {
    if (this._dropShadowAngle !== dropShadowAngle) {
      this._dropShadowAngle = dropShadowAngle;
      this.styleID++;
    }
  }
  get dropShadowBlur() {
    return this._dropShadowBlur;
  }
  set dropShadowBlur(dropShadowBlur) {
    if (this._dropShadowBlur !== dropShadowBlur) {
      this._dropShadowBlur = dropShadowBlur;
      this.styleID++;
    }
  }
  get dropShadowColor() {
    return this._dropShadowColor;
  }
  set dropShadowColor(dropShadowColor) {
    const outputColor = getColor(dropShadowColor);
    if (this._dropShadowColor !== outputColor) {
      this._dropShadowColor = outputColor;
      this.styleID++;
    }
  }
  get dropShadowDistance() {
    return this._dropShadowDistance;
  }
  set dropShadowDistance(dropShadowDistance) {
    if (this._dropShadowDistance !== dropShadowDistance) {
      this._dropShadowDistance = dropShadowDistance;
      this.styleID++;
    }
  }
  get fill() {
    return this._fill;
  }
  set fill(fill2) {
    const outputColor = getColor(fill2);
    if (this._fill !== outputColor) {
      this._fill = outputColor;
      this.styleID++;
    }
  }
  get fillGradientType() {
    return this._fillGradientType;
  }
  set fillGradientType(fillGradientType) {
    if (this._fillGradientType !== fillGradientType) {
      this._fillGradientType = fillGradientType;
      this.styleID++;
    }
  }
  get fillGradientStops() {
    return this._fillGradientStops;
  }
  set fillGradientStops(fillGradientStops) {
    if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
      this._fillGradientStops = fillGradientStops;
      this.styleID++;
    }
  }
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(fontFamily) {
    if (this.fontFamily !== fontFamily) {
      this._fontFamily = fontFamily;
      this.styleID++;
    }
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(fontSize) {
    if (this._fontSize !== fontSize) {
      this._fontSize = fontSize;
      this.styleID++;
    }
  }
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(fontStyle) {
    if (this._fontStyle !== fontStyle) {
      this._fontStyle = fontStyle;
      this.styleID++;
    }
  }
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(fontVariant) {
    if (this._fontVariant !== fontVariant) {
      this._fontVariant = fontVariant;
      this.styleID++;
    }
  }
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(fontWeight) {
    if (this._fontWeight !== fontWeight) {
      this._fontWeight = fontWeight;
      this.styleID++;
    }
  }
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(letterSpacing) {
    if (this._letterSpacing !== letterSpacing) {
      this._letterSpacing = letterSpacing;
      this.styleID++;
    }
  }
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(lineHeight) {
    if (this._lineHeight !== lineHeight) {
      this._lineHeight = lineHeight;
      this.styleID++;
    }
  }
  get leading() {
    return this._leading;
  }
  set leading(leading) {
    if (this._leading !== leading) {
      this._leading = leading;
      this.styleID++;
    }
  }
  get lineJoin() {
    return this._lineJoin;
  }
  set lineJoin(lineJoin) {
    if (this._lineJoin !== lineJoin) {
      this._lineJoin = lineJoin;
      this.styleID++;
    }
  }
  get miterLimit() {
    return this._miterLimit;
  }
  set miterLimit(miterLimit) {
    if (this._miterLimit !== miterLimit) {
      this._miterLimit = miterLimit;
      this.styleID++;
    }
  }
  get padding() {
    return this._padding;
  }
  set padding(padding) {
    if (this._padding !== padding) {
      this._padding = padding;
      this.styleID++;
    }
  }
  get stroke() {
    return this._stroke;
  }
  set stroke(stroke) {
    const outputColor = getColor(stroke);
    if (this._stroke !== outputColor) {
      this._stroke = outputColor;
      this.styleID++;
    }
  }
  get strokeThickness() {
    return this._strokeThickness;
  }
  set strokeThickness(strokeThickness) {
    if (this._strokeThickness !== strokeThickness) {
      this._strokeThickness = strokeThickness;
      this.styleID++;
    }
  }
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(textBaseline) {
    if (this._textBaseline !== textBaseline) {
      this._textBaseline = textBaseline;
      this.styleID++;
    }
  }
  get trim() {
    return this._trim;
  }
  set trim(trim) {
    if (this._trim !== trim) {
      this._trim = trim;
      this.styleID++;
    }
  }
  get whiteSpace() {
    return this._whiteSpace;
  }
  set whiteSpace(whiteSpace) {
    if (this._whiteSpace !== whiteSpace) {
      this._whiteSpace = whiteSpace;
      this.styleID++;
    }
  }
  get wordWrap() {
    return this._wordWrap;
  }
  set wordWrap(wordWrap) {
    if (this._wordWrap !== wordWrap) {
      this._wordWrap = wordWrap;
      this.styleID++;
    }
  }
  get wordWrapWidth() {
    return this._wordWrapWidth;
  }
  set wordWrapWidth(wordWrapWidth) {
    if (this._wordWrapWidth !== wordWrapWidth) {
      this._wordWrapWidth = wordWrapWidth;
      this.styleID++;
    }
  }
  toFontString() {
    const fontSizeString = typeof this.fontSize === "number" ? `${this.fontSize}px` : this.fontSize;
    let fontFamilies = this.fontFamily;
    if (!Array.isArray(this.fontFamily)) {
      fontFamilies = this.fontFamily.split(",");
    }
    for (let i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
      let fontFamily = fontFamilies[i2].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
        fontFamily = `"${fontFamily}"`;
      }
      fontFamilies[i2] = fontFamily;
    }
    return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
  }
};
let TextStyle = _TextStyle;
TextStyle.defaultStyle = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  leading: 0,
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: false,
  whiteSpace: "pre",
  wordWrap: false,
  wordWrapWidth: 100
};
function getColor(color) {
  const temp = Color.shared;
  if (!Array.isArray(color)) {
    return temp.setValue(color).toHex();
  } else {
    return color.map((c3) => temp.setValue(c3).toHex());
  }
}
function areArraysEqual(array1, array2) {
  if (!Array.isArray(array1) || !Array.isArray(array2)) {
    return false;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (let i2 = 0; i2 < array1.length; ++i2) {
    if (array1[i2] !== array2[i2]) {
      return false;
    }
  }
  return true;
}
function deepCopyProperties(target, source, propertyObj) {
  for (const prop in propertyObj) {
    if (Array.isArray(source[prop])) {
      target[prop] = source[prop].slice();
    } else {
      target[prop] = source[prop];
    }
  }
}
const defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
const _Text = class extends Sprite {
  constructor(text, style, canvas) {
    let ownCanvas = false;
    if (!canvas) {
      canvas = settings.ADAPTER.createCanvas();
      ownCanvas = true;
    }
    canvas.width = 3;
    canvas.height = 3;
    const texture = Texture.from(canvas);
    texture.orig = new Rectangle();
    texture.trim = new Rectangle();
    super(texture);
    this._ownCanvas = ownCanvas;
    this.canvas = canvas;
    this.context = canvas.getContext("2d", {
      willReadFrequently: true
    });
    this._resolution = _Text.defaultResolution ?? settings.RESOLUTION;
    this._autoResolution = _Text.defaultAutoResolution;
    this._text = null;
    this._style = null;
    this._styleListener = null;
    this._font = "";
    this.text = text;
    this.style = style;
    this.localStyleID = -1;
  }
  static get experimentalLetterSpacing() {
    return TextMetrics.experimentalLetterSpacing;
  }
  static set experimentalLetterSpacing(value2) {
    deprecation("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing");
    TextMetrics.experimentalLetterSpacing = value2;
  }
  updateText(respectDirty) {
    const style = this._style;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    this._font = this._style.toFontString();
    const context2 = this.context;
    const measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
    const width = measured.width;
    const height = measured.height;
    const lines = measured.lines;
    const lineHeight = measured.lineHeight;
    const lineWidths = measured.lineWidths;
    const maxLineWidth = measured.maxLineWidth;
    const fontProperties = measured.fontProperties;
    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);
    this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);
    context2.scale(this._resolution, this._resolution);
    context2.clearRect(0, 0, this.canvas.width, this.canvas.height);
    context2.font = this._font;
    context2.lineWidth = style.strokeThickness;
    context2.textBaseline = style.textBaseline;
    context2.lineJoin = style.lineJoin;
    context2.miterLimit = style.miterLimit;
    let linePositionX;
    let linePositionY;
    const passesCount = style.dropShadow ? 2 : 1;
    for (let i2 = 0; i2 < passesCount; ++i2) {
      const isShadowPass = style.dropShadow && i2 === 0;
      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
      const dsOffsetShadow = dsOffsetText * this._resolution;
      if (isShadowPass) {
        context2.fillStyle = "black";
        context2.strokeStyle = "black";
        const dropShadowColor = style.dropShadowColor;
        const dropShadowBlur = style.dropShadowBlur * this._resolution;
        const dropShadowDistance = style.dropShadowDistance * this._resolution;
        context2.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();
        context2.shadowBlur = dropShadowBlur;
        context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
        context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
      } else {
        context2.fillStyle = this._generateFillStyle(style, lines, measured);
        context2.strokeStyle = style.stroke;
        context2.shadowColor = "black";
        context2.shadowBlur = 0;
        context2.shadowOffsetX = 0;
        context2.shadowOffsetY = 0;
      }
      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
      if (lineHeight - fontProperties.fontSize < 0) {
        linePositionYShift = 0;
      }
      for (let i22 = 0; i22 < lines.length; i22++) {
        linePositionX = style.strokeThickness / 2;
        linePositionY = style.strokeThickness / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift;
        if (style.align === "right") {
          linePositionX += maxLineWidth - lineWidths[i22];
        } else if (style.align === "center") {
          linePositionX += (maxLineWidth - lineWidths[i22]) / 2;
        }
        if (style.stroke && style.strokeThickness) {
          this.drawLetterSpacing(lines[i22], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
        }
        if (style.fill) {
          this.drawLetterSpacing(lines[i22], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
        }
      }
    }
    this.updateTexture();
  }
  drawLetterSpacing(text, x2, y2, isStroke = false) {
    const style = this._style;
    const letterSpacing = style.letterSpacing;
    let useExperimentalLetterSpacing = false;
    if (TextMetrics.experimentalLetterSpacingSupported) {
      if (TextMetrics.experimentalLetterSpacing) {
        this.context.letterSpacing = `${letterSpacing}px`;
        this.context.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        this.context.letterSpacing = "0px";
        this.context.textLetterSpacing = "0px";
      }
    }
    if (letterSpacing === 0 || useExperimentalLetterSpacing) {
      if (isStroke) {
        this.context.strokeText(text, x2, y2);
      } else {
        this.context.fillText(text, x2, y2);
      }
      return;
    }
    let currentPosition = x2;
    const stringArray = TextMetrics.graphemeSegmenter(text);
    let previousWidth = this.context.measureText(text).width;
    let currentWidth = 0;
    for (let i2 = 0; i2 < stringArray.length; ++i2) {
      const currentChar = stringArray[i2];
      if (isStroke) {
        this.context.strokeText(currentChar, currentPosition, y2);
      } else {
        this.context.fillText(currentChar, currentPosition, y2);
      }
      let textStr = "";
      for (let j2 = i2 + 1; j2 < stringArray.length; ++j2) {
        textStr += stringArray[j2];
      }
      currentWidth = this.context.measureText(textStr).width;
      currentPosition += previousWidth - currentWidth + letterSpacing;
      previousWidth = currentWidth;
    }
  }
  updateTexture() {
    const canvas = this.canvas;
    if (this._style.trim) {
      const trimmed = trimCanvas(canvas);
      if (trimmed.data) {
        canvas.width = trimmed.width;
        canvas.height = trimmed.height;
        this.context.putImageData(trimmed.data, 0, 0);
      }
    }
    const texture = this._texture;
    const style = this._style;
    const padding = style.trim ? 0 : style.padding;
    const baseTexture = texture.baseTexture;
    texture.trim.width = texture._frame.width = canvas.width / this._resolution;
    texture.trim.height = texture._frame.height = canvas.height / this._resolution;
    texture.trim.x = -padding;
    texture.trim.y = -padding;
    texture.orig.width = texture._frame.width - padding * 2;
    texture.orig.height = texture._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
    texture.updateUvs();
    this.dirty = false;
  }
  _render(renderer2) {
    if (this._autoResolution && this._resolution !== renderer2.resolution) {
      this._resolution = renderer2.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._render(renderer2);
  }
  updateTransform() {
    this.updateText(true);
    super.updateTransform();
  }
  getBounds(skipUpdate, rect) {
    this.updateText(true);
    if (this._textureID === -1) {
      skipUpdate = false;
    }
    return super.getBounds(skipUpdate, rect);
  }
  getLocalBounds(rect) {
    this.updateText(true);
    return super.getLocalBounds.call(this, rect);
  }
  _calculateBounds() {
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  }
  _generateFillStyle(style, lines, metrics) {
    const fillStyle = style.fill;
    if (!Array.isArray(fillStyle)) {
      return fillStyle;
    } else if (fillStyle.length === 1) {
      return fillStyle[0];
    }
    let gradient;
    const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
    const padding = style.padding || 0;
    const width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;
    const height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;
    const fill2 = fillStyle.slice();
    const fillGradientStops = style.fillGradientStops.slice();
    if (!fillGradientStops.length) {
      const lengthPlus1 = fill2.length + 1;
      for (let i2 = 1; i2 < lengthPlus1; ++i2) {
        fillGradientStops.push(i2 / lengthPlus1);
      }
    }
    fill2.unshift(fillStyle[0]);
    fillGradientStops.unshift(0);
    fill2.push(fillStyle[fillStyle.length - 1]);
    fillGradientStops.push(1);
    if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
      const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
      for (let i2 = 0; i2 < lines.length; i2++) {
        const lastLineBottom = metrics.lineHeight * (i2 - 1) + textHeight;
        const thisLineTop = metrics.lineHeight * i2;
        let thisLineGradientStart = thisLineTop;
        if (i2 > 0 && lastLineBottom > thisLineTop) {
          thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;
        }
        const thisLineBottom = thisLineTop + textHeight;
        const nextLineTop = metrics.lineHeight * (i2 + 1);
        let thisLineGradientEnd = thisLineBottom;
        if (i2 + 1 < lines.length && nextLineTop < thisLineBottom) {
          thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;
        }
        const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
        for (let j2 = 0; j2 < fill2.length; j2++) {
          let lineStop = 0;
          if (typeof fillGradientStops[j2] === "number") {
            lineStop = fillGradientStops[j2];
          } else {
            lineStop = j2 / fill2.length;
          }
          let globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));
          globalStop = Number(globalStop.toFixed(5));
          gradient.addColorStop(globalStop, fill2[j2]);
        }
      }
    } else {
      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
      const totalIterations = fill2.length + 1;
      let currentIteration = 1;
      for (let i2 = 0; i2 < fill2.length; i2++) {
        let stop;
        if (typeof fillGradientStops[i2] === "number") {
          stop = fillGradientStops[i2];
        } else {
          stop = currentIteration / totalIterations;
        }
        gradient.addColorStop(stop, fill2[i2]);
        currentIteration++;
      }
    }
    return gradient;
  }
  destroy(options) {
    if (typeof options === "boolean") {
      options = { children: options };
    }
    options = Object.assign({}, defaultDestroyOptions, options);
    super.destroy(options);
    if (this._ownCanvas) {
      this.canvas.height = this.canvas.width = 0;
    }
    this.context = null;
    this.canvas = null;
    this._style = null;
  }
  get width() {
    this.updateText(true);
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value2) {
    this.updateText(true);
    const s2 = sign(this.scale.x) || 1;
    this.scale.x = s2 * value2 / this._texture.orig.width;
    this._width = value2;
  }
  get height() {
    this.updateText(true);
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value2) {
    this.updateText(true);
    const s2 = sign(this.scale.y) || 1;
    this.scale.y = s2 * value2 / this._texture.orig.height;
    this._height = value2;
  }
  get style() {
    return this._style;
  }
  set style(style) {
    style = style || {};
    if (style instanceof TextStyle) {
      this._style = style;
    } else {
      this._style = new TextStyle(style);
    }
    this.localStyleID = -1;
    this.dirty = true;
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === null || text === void 0 ? "" : text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value2) {
    this._autoResolution = false;
    if (this._resolution === value2) {
      return;
    }
    this._resolution = value2;
    this.dirty = true;
  }
};
let Text$1 = _Text;
Text$1.defaultAutoResolution = true;
class CountLimiter {
  constructor(maxItemsPerFrame) {
    this.maxItemsPerFrame = maxItemsPerFrame;
    this.itemsLeft = 0;
  }
  beginFrame() {
    this.itemsLeft = this.maxItemsPerFrame;
  }
  allowedToUpload() {
    return this.itemsLeft-- > 0;
  }
}
function findMultipleBaseTextures(item, queue2) {
  var _a;
  let result = false;
  if ((_a = item == null ? void 0 : item._textures) == null ? void 0 : _a.length) {
    for (let i2 = 0; i2 < item._textures.length; i2++) {
      if (item._textures[i2] instanceof Texture) {
        const baseTexture = item._textures[i2].baseTexture;
        if (!queue2.includes(baseTexture)) {
          queue2.push(baseTexture);
          result = true;
        }
      }
    }
  }
  return result;
}
function findBaseTexture(item, queue2) {
  if (item.baseTexture instanceof BaseTexture) {
    const texture = item.baseTexture;
    if (!queue2.includes(texture)) {
      queue2.push(texture);
    }
    return true;
  }
  return false;
}
function findTexture(item, queue2) {
  if (item._texture && item._texture instanceof Texture) {
    const texture = item._texture.baseTexture;
    if (!queue2.includes(texture)) {
      queue2.push(texture);
    }
    return true;
  }
  return false;
}
function drawText(_helper, item) {
  if (item instanceof Text$1) {
    item.updateText(true);
    return true;
  }
  return false;
}
function calculateTextStyle(_helper, item) {
  if (item instanceof TextStyle) {
    const font = item.toFontString();
    TextMetrics.measureFont(font);
    return true;
  }
  return false;
}
function findText(item, queue2) {
  if (item instanceof Text$1) {
    if (!queue2.includes(item.style)) {
      queue2.push(item.style);
    }
    if (!queue2.includes(item)) {
      queue2.push(item);
    }
    const texture = item._texture.baseTexture;
    if (!queue2.includes(texture)) {
      queue2.push(texture);
    }
    return true;
  }
  return false;
}
function findTextStyle(item, queue2) {
  if (item instanceof TextStyle) {
    if (!queue2.includes(item)) {
      queue2.push(item);
    }
    return true;
  }
  return false;
}
const _BasePrepare = class {
  constructor(renderer2) {
    this.limiter = new CountLimiter(_BasePrepare.uploadsPerFrame);
    this.renderer = renderer2;
    this.uploadHookHelper = null;
    this.queue = [];
    this.addHooks = [];
    this.uploadHooks = [];
    this.completes = [];
    this.ticking = false;
    this.delayedTick = () => {
      if (!this.queue) {
        return;
      }
      this.prepareItems();
    };
    this.registerFindHook(findText);
    this.registerFindHook(findTextStyle);
    this.registerFindHook(findMultipleBaseTextures);
    this.registerFindHook(findBaseTexture);
    this.registerFindHook(findTexture);
    this.registerUploadHook(drawText);
    this.registerUploadHook(calculateTextStyle);
  }
  upload(item) {
    return new Promise((resolve2) => {
      if (item) {
        this.add(item);
      }
      if (this.queue.length) {
        this.completes.push(resolve2);
        if (!this.ticking) {
          this.ticking = true;
          Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
        }
      } else {
        resolve2();
      }
    });
  }
  tick() {
    setTimeout(this.delayedTick, 0);
  }
  prepareItems() {
    this.limiter.beginFrame();
    while (this.queue.length && this.limiter.allowedToUpload()) {
      const item = this.queue[0];
      let uploaded = false;
      if (item && !item._destroyed) {
        for (let i2 = 0, len = this.uploadHooks.length; i2 < len; i2++) {
          if (this.uploadHooks[i2](this.uploadHookHelper, item)) {
            this.queue.shift();
            uploaded = true;
            break;
          }
        }
      }
      if (!uploaded) {
        this.queue.shift();
      }
    }
    if (!this.queue.length) {
      this.ticking = false;
      const completes = this.completes.slice(0);
      this.completes.length = 0;
      for (let i2 = 0, len = completes.length; i2 < len; i2++) {
        completes[i2]();
      }
    } else {
      Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
    }
  }
  registerFindHook(addHook) {
    if (addHook) {
      this.addHooks.push(addHook);
    }
    return this;
  }
  registerUploadHook(uploadHook) {
    if (uploadHook) {
      this.uploadHooks.push(uploadHook);
    }
    return this;
  }
  add(item) {
    for (let i2 = 0, len = this.addHooks.length; i2 < len; i2++) {
      if (this.addHooks[i2](item, this.queue)) {
        break;
      }
    }
    if (item instanceof Container) {
      for (let i2 = item.children.length - 1; i2 >= 0; i2--) {
        this.add(item.children[i2]);
      }
    }
    return this;
  }
  destroy() {
    if (this.ticking) {
      Ticker.system.remove(this.tick, this);
    }
    this.ticking = false;
    this.addHooks = null;
    this.uploadHooks = null;
    this.renderer = null;
    this.completes = null;
    this.queue = null;
    this.limiter = null;
    this.uploadHookHelper = null;
  }
};
let BasePrepare = _BasePrepare;
BasePrepare.uploadsPerFrame = 4;
Object.defineProperties(settings, {
  UPLOADS_PER_FRAME: {
    get() {
      return BasePrepare.uploadsPerFrame;
    },
    set(value2) {
      deprecation("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame");
      BasePrepare.uploadsPerFrame = value2;
    }
  }
});
function uploadBaseTextures(renderer2, item) {
  if (item instanceof BaseTexture) {
    if (!item._glTextures[renderer2.CONTEXT_UID]) {
      renderer2.texture.bind(item);
    }
    return true;
  }
  return false;
}
function uploadGraphics(renderer2, item) {
  if (!(item instanceof Graphics)) {
    return false;
  }
  const { geometry } = item;
  item.finishPoly();
  geometry.updateBatches();
  const { batches } = geometry;
  for (let i2 = 0; i2 < batches.length; i2++) {
    const { texture } = batches[i2].style;
    if (texture) {
      uploadBaseTextures(renderer2, texture.baseTexture);
    }
  }
  if (!geometry.batchable) {
    renderer2.geometry.bind(geometry, item._resolveDirectShader(renderer2));
  }
  return true;
}
function findGraphics(item, queue2) {
  if (item instanceof Graphics) {
    queue2.push(item);
    return true;
  }
  return false;
}
class Prepare extends BasePrepare {
  constructor(renderer2) {
    super(renderer2);
    this.uploadHookHelper = this.renderer;
    this.registerFindHook(findGraphics);
    this.registerUploadHook(uploadBaseTextures);
    this.registerUploadHook(uploadGraphics);
  }
}
Prepare.extension = {
  name: "prepare",
  type: ExtensionType.RendererSystem
};
extensions$1.add(Prepare);
class TimeLimiter {
  constructor(maxMilliseconds) {
    this.maxMilliseconds = maxMilliseconds;
    this.frameStart = 0;
  }
  beginFrame() {
    this.frameStart = Date.now();
  }
  allowedToUpload() {
    return Date.now() - this.frameStart < this.maxMilliseconds;
  }
}
class AnimatedSprite extends Sprite {
  constructor(textures, autoUpdate = true) {
    super(textures[0] instanceof Texture ? textures[0] : textures[0].texture);
    this._textures = null;
    this._durations = null;
    this._autoUpdate = autoUpdate;
    this._isConnectedToTicker = false;
    this.animationSpeed = 1;
    this.loop = true;
    this.updateAnchor = false;
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
    this._currentTime = 0;
    this._playing = false;
    this._previousFrame = null;
    this.textures = textures;
  }
  stop() {
    if (!this._playing) {
      return;
    }
    this._playing = false;
    if (this._autoUpdate && this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  play() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    if (this._autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
      this._isConnectedToTicker = true;
    }
  }
  gotoAndStop(frameNumber) {
    this.stop();
    this.currentFrame = frameNumber;
  }
  gotoAndPlay(frameNumber) {
    this.currentFrame = frameNumber;
    this.play();
  }
  update(deltaTime) {
    if (!this._playing) {
      return;
    }
    const elapsed = this.animationSpeed * deltaTime;
    const previousFrame = this.currentFrame;
    if (this._durations !== null) {
      let lag = this._currentTime % 1 * this._durations[this.currentFrame];
      lag += elapsed / 60 * 1e3;
      while (lag < 0) {
        this._currentTime--;
        lag += this._durations[this.currentFrame];
      }
      const sign2 = Math.sign(this.animationSpeed * deltaTime);
      this._currentTime = Math.floor(this._currentTime);
      while (lag >= this._durations[this.currentFrame]) {
        lag -= this._durations[this.currentFrame] * sign2;
        this._currentTime += sign2;
      }
      this._currentTime += lag / this._durations[this.currentFrame];
    } else {
      this._currentTime += elapsed;
    }
    if (this._currentTime < 0 && !this.loop) {
      this.gotoAndStop(0);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (this._currentTime >= this._textures.length && !this.loop) {
      this.gotoAndStop(this._textures.length - 1);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (previousFrame !== this.currentFrame) {
      if (this.loop && this.onLoop) {
        if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {
          this.onLoop();
        }
      }
      this.updateTexture();
    }
  }
  updateTexture() {
    const currentFrame = this.currentFrame;
    if (this._previousFrame === currentFrame) {
      return;
    }
    this._previousFrame = currentFrame;
    this._texture = this._textures[currentFrame];
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    this.uvs = this._texture._uvs.uvsFloat32;
    if (this.updateAnchor) {
      this._anchor.copyFrom(this._texture.defaultAnchor);
    }
    if (this.onFrameChange) {
      this.onFrameChange(this.currentFrame);
    }
  }
  destroy(options) {
    this.stop();
    super.destroy(options);
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
  }
  static fromFrames(frames) {
    const textures = [];
    for (let i2 = 0; i2 < frames.length; ++i2) {
      textures.push(Texture.from(frames[i2]));
    }
    return new AnimatedSprite(textures);
  }
  static fromImages(images) {
    const textures = [];
    for (let i2 = 0; i2 < images.length; ++i2) {
      textures.push(Texture.from(images[i2]));
    }
    return new AnimatedSprite(textures);
  }
  get totalFrames() {
    return this._textures.length;
  }
  get textures() {
    return this._textures;
  }
  set textures(value2) {
    if (value2[0] instanceof Texture) {
      this._textures = value2;
      this._durations = null;
    } else {
      this._textures = [];
      this._durations = [];
      for (let i2 = 0; i2 < value2.length; i2++) {
        this._textures.push(value2[i2].texture);
        this._durations.push(value2[i2].time);
      }
    }
    this._previousFrame = null;
    this.gotoAndStop(0);
    this.updateTexture();
  }
  get currentFrame() {
    let currentFrame = Math.floor(this._currentTime) % this._textures.length;
    if (currentFrame < 0) {
      currentFrame += this._textures.length;
    }
    return currentFrame;
  }
  set currentFrame(value2) {
    if (value2 < 0 || value2 > this.totalFrames - 1) {
      throw new Error(`[AnimatedSprite]: Invalid frame index value ${value2}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
    }
    const previousFrame = this.currentFrame;
    this._currentTime = value2;
    if (previousFrame !== this.currentFrame) {
      this.updateTexture();
    }
  }
  get playing() {
    return this._playing;
  }
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value2) {
    if (value2 !== this._autoUpdate) {
      this._autoUpdate = value2;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
        Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
}
const tempPoint = new Point();
class TilingSprite extends Sprite {
  constructor(texture, width = 100, height = 100) {
    super(texture);
    this.tileTransform = new Transform();
    this._width = width;
    this._height = height;
    this.uvMatrix = this.texture.uvMatrix || new TextureMatrix(texture);
    this.pluginName = "tilingSprite";
    this.uvRespectAnchor = false;
  }
  get clampMargin() {
    return this.uvMatrix.clampMargin;
  }
  set clampMargin(value2) {
    this.uvMatrix.clampMargin = value2;
    this.uvMatrix.update(true);
  }
  get tileScale() {
    return this.tileTransform.scale;
  }
  set tileScale(value2) {
    this.tileTransform.scale.copyFrom(value2);
  }
  get tilePosition() {
    return this.tileTransform.position;
  }
  set tilePosition(value2) {
    this.tileTransform.position.copyFrom(value2);
  }
  _onTextureUpdate() {
    if (this.uvMatrix) {
      this.uvMatrix.texture = this._texture;
    }
    this._cachedTint = 16777215;
  }
  _render(renderer2) {
    const texture = this._texture;
    if (!texture || !texture.valid) {
      return;
    }
    this.tileTransform.updateLocalTransform();
    this.uvMatrix.update();
    renderer2.batch.setObjectRenderer(renderer2.plugins[this.pluginName]);
    renderer2.plugins[this.pluginName].render(this);
  }
  _calculateBounds() {
    const minX = this._width * -this._anchor._x;
    const minY = this._height * -this._anchor._y;
    const maxX = this._width * (1 - this._anchor._x);
    const maxY = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  getLocalBounds(rect) {
    if (this.children.length === 0) {
      this._bounds.minX = this._width * -this._anchor._x;
      this._bounds.minY = this._height * -this._anchor._y;
      this._bounds.maxX = this._width * (1 - this._anchor._x);
      this._bounds.maxY = this._height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._bounds.getRectangle(rect);
    }
    return super.getLocalBounds.call(this, rect);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, tempPoint);
    const width = this._width;
    const height = this._height;
    const x1 = -width * this.anchor._x;
    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
      const y1 = -height * this.anchor._y;
      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
        return true;
      }
    }
    return false;
  }
  destroy(options) {
    super.destroy(options);
    this.tileTransform = null;
    this.uvMatrix = null;
  }
  static from(source, options) {
    const texture = source instanceof Texture ? source : Texture.from(source, options);
    return new TilingSprite(texture, options.width, options.height);
  }
  get width() {
    return this._width;
  }
  set width(value2) {
    this._width = value2;
  }
  get height() {
    return this._height;
  }
  set height(value2) {
    this._height = value2;
  }
}
var gl2FragmentSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n";
var gl2VertexSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var gl1FragmentSrc = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n";
var gl1VertexSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var fragmentSimpleSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n";
const tempMat = new Matrix();
class TilingSpriteRenderer extends ObjectRenderer {
  constructor(renderer2) {
    super(renderer2);
    renderer2.runners.contextChange.add(this);
    this.quad = new QuadUv();
    this.state = State.for2d();
  }
  contextChange() {
    const renderer2 = this.renderer;
    const uniforms = { globals: renderer2.globalUniforms };
    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);
    this.shader = renderer2.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);
  }
  render(ts) {
    const renderer2 = this.renderer;
    const quad = this.quad;
    let vertices = quad.vertices;
    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
    vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
    vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
    const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;
    const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
    vertices = quad.uvs;
    vertices[0] = vertices[6] = -anchorX;
    vertices[1] = vertices[3] = -anchorY;
    vertices[2] = vertices[4] = 1 - anchorX;
    vertices[5] = vertices[7] = 1 - anchorY;
    quad.invalidate();
    const tex = ts._texture;
    const baseTex = tex.baseTexture;
    const premultiplied = baseTex.alphaMode > 0;
    const lt = ts.tileTransform.localTransform;
    const uv = ts.uvMatrix;
    let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
    if (isSimple) {
      if (!baseTex._glTextures[renderer2.CONTEXT_UID]) {
        if (baseTex.wrapMode === WRAP_MODES.CLAMP) {
          baseTex.wrapMode = WRAP_MODES.REPEAT;
        }
      } else {
        isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;
      }
    }
    const shader = isSimple ? this.simpleShader : this.shader;
    const w2 = tex.width;
    const h2 = tex.height;
    const W2 = ts._width;
    const H2 = ts._height;
    tempMat.set(lt.a * w2 / W2, lt.b * w2 / H2, lt.c * h2 / W2, lt.d * h2 / H2, lt.tx / W2, lt.ty / H2);
    tempMat.invert();
    if (isSimple) {
      tempMat.prepend(uv.mapCoord);
    } else {
      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
      shader.uniforms.uClampFrame = uv.uClampFrame;
      shader.uniforms.uClampOffset = uv.uClampOffset;
    }
    shader.uniforms.uTransform = tempMat.toArray(true);
    shader.uniforms.uColor = Color.shared.setValue(ts.tint).premultiply(ts.worldAlpha, premultiplied).toArray(shader.uniforms.uColor);
    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
    shader.uniforms.uSampler = tex;
    renderer2.shader.bind(shader);
    renderer2.geometry.bind(quad);
    this.state.blendMode = correctBlendMode(ts.blendMode, premultiplied);
    renderer2.state.set(this.state);
    renderer2.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
  }
}
TilingSpriteRenderer.extension = {
  name: "tilingSprite",
  type: ExtensionType.RendererPlugin
};
extensions$1.add(TilingSpriteRenderer);
const _Spritesheet = class {
  constructor(texture, data, resolutionFilename = null) {
    this.linkedSheets = [];
    this._texture = texture instanceof Texture ? texture : null;
    this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;
    this.textures = {};
    this.animations = {};
    this.data = data;
    const resource = this.baseTexture.resource;
    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));
    this._frames = this.data.frames;
    this._frameKeys = Object.keys(this._frames);
    this._batchIndex = 0;
    this._callback = null;
  }
  _updateResolution(resolutionFilename = null) {
    const { scale } = this.data.meta;
    let resolution = getResolutionOfUrl(resolutionFilename, null);
    if (resolution === null) {
      resolution = parseFloat(scale ?? "1");
    }
    if (resolution !== 1) {
      this.baseTexture.setResolution(resolution);
    }
    return resolution;
  }
  parse() {
    return new Promise((resolve2) => {
      this._callback = resolve2;
      this._batchIndex = 0;
      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {
        this._processFrames(0);
        this._processAnimations();
        this._parseComplete();
      } else {
        this._nextBatch();
      }
    });
  }
  _processFrames(initialFrameIndex) {
    let frameIndex = initialFrameIndex;
    const maxFrames = _Spritesheet.BATCH_SIZE;
    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
      const i2 = this._frameKeys[frameIndex];
      const data = this._frames[i2];
      const rect = data.frame;
      if (rect) {
        let frame = null;
        let trim = null;
        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
        const orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
        if (data.rotated) {
          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
        } else {
          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        if (data.trimmed !== false && data.spriteSourceSize) {
          trim = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        this.textures[i2] = new Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor, data.borders);
        Texture.addToCache(this.textures[i2], i2);
      }
      frameIndex++;
    }
  }
  _processAnimations() {
    const animations = this.data.animations || {};
    for (const animName in animations) {
      this.animations[animName] = [];
      for (let i2 = 0; i2 < animations[animName].length; i2++) {
        const frameName = animations[animName][i2];
        this.animations[animName].push(this.textures[frameName]);
      }
    }
  }
  _parseComplete() {
    const callback = this._callback;
    this._callback = null;
    this._batchIndex = 0;
    callback.call(this, this.textures);
  }
  _nextBatch() {
    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);
    this._batchIndex++;
    setTimeout(() => {
      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {
        this._nextBatch();
      } else {
        this._processAnimations();
        this._parseComplete();
      }
    }, 0);
  }
  destroy(destroyBase = false) {
    var _a;
    for (const i2 in this.textures) {
      this.textures[i2].destroy();
    }
    this._frames = null;
    this._frameKeys = null;
    this.data = null;
    this.textures = null;
    if (destroyBase) {
      (_a = this._texture) == null ? void 0 : _a.destroy();
      this.baseTexture.destroy();
    }
    this._texture = null;
    this.baseTexture = null;
    this.linkedSheets = [];
  }
};
let Spritesheet$1 = _Spritesheet;
Spritesheet$1.BATCH_SIZE = 1e3;
const validImages = ["jpg", "png", "jpeg", "avif", "webp"];
function getCacheableAssets(keys2, asset, ignoreMultiPack) {
  const out = {};
  keys2.forEach((key) => {
    out[key] = asset;
  });
  Object.keys(asset.textures).forEach((key) => {
    out[key] = asset.textures[key];
  });
  if (!ignoreMultiPack) {
    const basePath = path.dirname(keys2[0]);
    asset.linkedSheets.forEach((item, i2) => {
      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i2]}`], item, true);
      Object.assign(out, out2);
    });
  }
  return out;
}
const spritesheetAsset = {
  extension: ExtensionType.Asset,
  cache: {
    test: (asset) => asset instanceof Spritesheet$1,
    getCacheableAssets: (keys2, asset) => getCacheableAssets(keys2, asset, false)
  },
  resolver: {
    test: (value2) => {
      const tempURL = value2.split("?")[0];
      const split = tempURL.split(".");
      const extension = split.pop();
      const format2 = split.pop();
      return extension === "json" && validImages.includes(format2);
    },
    parse: (value2) => {
      var _a;
      const split = value2.split(".");
      return {
        resolution: parseFloat(((_a = settings.RETINA_PREFIX.exec(value2)) == null ? void 0 : _a[1]) ?? "1"),
        format: split[split.length - 2],
        src: value2
      };
    }
  },
  loader: {
    name: "spritesheetLoader",
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Normal
    },
    async testParse(asset, options) {
      return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
    },
    async parse(asset, options, loader) {
      var _a, _b;
      let basePath = path.dirname(options.src);
      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
        basePath += "/";
      }
      let imagePath = basePath + asset.meta.image;
      imagePath = copySearchParams(imagePath, options.src);
      const assets = await loader.load([imagePath]);
      const texture = assets[imagePath];
      const spritesheet = new Spritesheet$1(texture.baseTexture, asset, options.src);
      await spritesheet.parse();
      const multiPacks = (_a = asset == null ? void 0 : asset.meta) == null ? void 0 : _a.related_multi_packs;
      if (Array.isArray(multiPacks)) {
        const promises = [];
        for (const item of multiPacks) {
          if (typeof item !== "string") {
            continue;
          }
          let itemUrl = basePath + item;
          if ((_b = options.data) == null ? void 0 : _b.ignoreMultiPack) {
            continue;
          }
          itemUrl = copySearchParams(itemUrl, options.src);
          promises.push(loader.load({
            src: itemUrl,
            data: {
              ignoreMultiPack: true
            }
          }));
        }
        const res = await Promise.all(promises);
        spritesheet.linkedSheets = res;
        res.forEach((item) => {
          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
        });
      }
      return spritesheet;
    },
    unload(spritesheet) {
      spritesheet.destroy(true);
    }
  }
};
extensions$1.add(spritesheetAsset);
class BitmapFontData {
  constructor() {
    this.info = [];
    this.common = [];
    this.page = [];
    this.char = [];
    this.kerning = [];
    this.distanceField = [];
  }
}
class TextFormat {
  static test(data) {
    return typeof data === "string" && data.startsWith("info face=");
  }
  static parse(txt) {
    const items = txt.match(/^[a-z]+\s+.+$/gm);
    const rawData = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (const i2 in items) {
      const name = items[i2].match(/^[a-z]+/gm)[0];
      const attributeList = items[i2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
      const itemData = {};
      for (const i22 in attributeList) {
        const split = attributeList[i22].split("=");
        const key = split[0];
        const strValue = split[1].replace(/"/gm, "");
        const floatValue = parseFloat(strValue);
        const value2 = isNaN(floatValue) ? strValue : floatValue;
        itemData[key] = value2;
      }
      rawData[name].push(itemData);
    }
    const font = new BitmapFontData();
    rawData.info.forEach((info) => font.info.push({
      face: info.face,
      size: parseInt(info.size, 10)
    }));
    rawData.common.forEach((common) => font.common.push({
      lineHeight: parseInt(common.lineHeight, 10)
    }));
    rawData.page.forEach((page) => font.page.push({
      id: parseInt(page.id, 10),
      file: page.file
    }));
    rawData.char.forEach((char) => font.char.push({
      id: parseInt(char.id, 10),
      page: parseInt(char.page, 10),
      x: parseInt(char.x, 10),
      y: parseInt(char.y, 10),
      width: parseInt(char.width, 10),
      height: parseInt(char.height, 10),
      xoffset: parseInt(char.xoffset, 10),
      yoffset: parseInt(char.yoffset, 10),
      xadvance: parseInt(char.xadvance, 10)
    }));
    rawData.kerning.forEach((kerning) => font.kerning.push({
      first: parseInt(kerning.first, 10),
      second: parseInt(kerning.second, 10),
      amount: parseInt(kerning.amount, 10)
    }));
    rawData.distanceField.forEach((df) => font.distanceField.push({
      distanceRange: parseInt(df.distanceRange, 10),
      fieldType: df.fieldType
    }));
    return font;
  }
}
class XMLFormat {
  static test(data) {
    const xml = data;
    return "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
  }
  static parse(xml) {
    const data = new BitmapFontData();
    const info = xml.getElementsByTagName("info");
    const common = xml.getElementsByTagName("common");
    const page = xml.getElementsByTagName("page");
    const char = xml.getElementsByTagName("char");
    const kerning = xml.getElementsByTagName("kerning");
    const distanceField = xml.getElementsByTagName("distanceField");
    for (let i2 = 0; i2 < info.length; i2++) {
      data.info.push({
        face: info[i2].getAttribute("face"),
        size: parseInt(info[i2].getAttribute("size"), 10)
      });
    }
    for (let i2 = 0; i2 < common.length; i2++) {
      data.common.push({
        lineHeight: parseInt(common[i2].getAttribute("lineHeight"), 10)
      });
    }
    for (let i2 = 0; i2 < page.length; i2++) {
      data.page.push({
        id: parseInt(page[i2].getAttribute("id"), 10) || 0,
        file: page[i2].getAttribute("file")
      });
    }
    for (let i2 = 0; i2 < char.length; i2++) {
      const letter = char[i2];
      data.char.push({
        id: parseInt(letter.getAttribute("id"), 10),
        page: parseInt(letter.getAttribute("page"), 10) || 0,
        x: parseInt(letter.getAttribute("x"), 10),
        y: parseInt(letter.getAttribute("y"), 10),
        width: parseInt(letter.getAttribute("width"), 10),
        height: parseInt(letter.getAttribute("height"), 10),
        xoffset: parseInt(letter.getAttribute("xoffset"), 10),
        yoffset: parseInt(letter.getAttribute("yoffset"), 10),
        xadvance: parseInt(letter.getAttribute("xadvance"), 10)
      });
    }
    for (let i2 = 0; i2 < kerning.length; i2++) {
      data.kerning.push({
        first: parseInt(kerning[i2].getAttribute("first"), 10),
        second: parseInt(kerning[i2].getAttribute("second"), 10),
        amount: parseInt(kerning[i2].getAttribute("amount"), 10)
      });
    }
    for (let i2 = 0; i2 < distanceField.length; i2++) {
      data.distanceField.push({
        fieldType: distanceField[i2].getAttribute("fieldType"),
        distanceRange: parseInt(distanceField[i2].getAttribute("distanceRange"), 10)
      });
    }
    return data;
  }
}
class XMLStringFormat {
  static test(data) {
    if (typeof data === "string" && data.includes("<font>")) {
      return XMLFormat.test(settings.ADAPTER.parseXML(data));
    }
    return false;
  }
  static parse(xmlTxt) {
    return XMLFormat.parse(settings.ADAPTER.parseXML(xmlTxt));
  }
}
const formats = [
  TextFormat,
  XMLFormat,
  XMLStringFormat
];
function autoDetectFormat(data) {
  for (let i2 = 0; i2 < formats.length; i2++) {
    if (formats[i2].test(data)) {
      return formats[i2];
    }
  }
  return null;
}
function generateFillStyle(canvas, context2, style, resolution, lines, metrics) {
  const fillStyle = style.fill;
  if (!Array.isArray(fillStyle)) {
    return fillStyle;
  } else if (fillStyle.length === 1) {
    return fillStyle[0];
  }
  let gradient;
  const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
  const padding = style.padding || 0;
  const width = canvas.width / resolution - dropShadowCorrection - padding * 2;
  const height = canvas.height / resolution - dropShadowCorrection - padding * 2;
  const fill2 = fillStyle.slice();
  const fillGradientStops = style.fillGradientStops.slice();
  if (!fillGradientStops.length) {
    const lengthPlus1 = fill2.length + 1;
    for (let i2 = 1; i2 < lengthPlus1; ++i2) {
      fillGradientStops.push(i2 / lengthPlus1);
    }
  }
  fill2.unshift(fillStyle[0]);
  fillGradientStops.unshift(0);
  fill2.push(fillStyle[fillStyle.length - 1]);
  fillGradientStops.push(1);
  if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
    gradient = context2.createLinearGradient(width / 2, padding, width / 2, height + padding);
    let lastIterationStop = 0;
    const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
    const gradStopLineHeight = textHeight / height;
    for (let i2 = 0; i2 < lines.length; i2++) {
      const thisLineTop = metrics.lineHeight * i2;
      for (let j2 = 0; j2 < fill2.length; j2++) {
        let lineStop = 0;
        if (typeof fillGradientStops[j2] === "number") {
          lineStop = fillGradientStops[j2];
        } else {
          lineStop = j2 / fill2.length;
        }
        const globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
        let clampedStop = Math.max(lastIterationStop, globalStop);
        clampedStop = Math.min(clampedStop, 1);
        gradient.addColorStop(clampedStop, fill2[j2]);
        lastIterationStop = clampedStop;
      }
    }
  } else {
    gradient = context2.createLinearGradient(padding, height / 2, width + padding, height / 2);
    const totalIterations = fill2.length + 1;
    let currentIteration = 1;
    for (let i2 = 0; i2 < fill2.length; i2++) {
      let stop;
      if (typeof fillGradientStops[i2] === "number") {
        stop = fillGradientStops[i2];
      } else {
        stop = currentIteration / totalIterations;
      }
      gradient.addColorStop(stop, fill2[i2]);
      currentIteration++;
    }
  }
  return gradient;
}
function drawGlyph(canvas, context2, metrics, x2, y2, resolution, style) {
  const char = metrics.text;
  const fontProperties = metrics.fontProperties;
  context2.translate(x2, y2);
  context2.scale(resolution, resolution);
  const tx = style.strokeThickness / 2;
  const ty = -(style.strokeThickness / 2);
  context2.font = style.toFontString();
  context2.lineWidth = style.strokeThickness;
  context2.textBaseline = style.textBaseline;
  context2.lineJoin = style.lineJoin;
  context2.miterLimit = style.miterLimit;
  context2.fillStyle = generateFillStyle(canvas, context2, style, resolution, [char], metrics);
  context2.strokeStyle = style.stroke;
  if (style.dropShadow) {
    const dropShadowColor = style.dropShadowColor;
    const dropShadowBlur = style.dropShadowBlur * resolution;
    const dropShadowDistance = style.dropShadowDistance * resolution;
    context2.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();
    context2.shadowBlur = dropShadowBlur;
    context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
    context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
  } else {
    context2.shadowColor = "black";
    context2.shadowBlur = 0;
    context2.shadowOffsetX = 0;
    context2.shadowOffsetY = 0;
  }
  if (style.stroke && style.strokeThickness) {
    context2.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  if (style.fill) {
    context2.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  context2.setTransform(1, 0, 0, 1, 0, 0);
  context2.fillStyle = "rgba(0, 0, 0, 0)";
}
function extractCharCode(str2) {
  return str2.codePointAt ? str2.codePointAt(0) : str2.charCodeAt(0);
}
function splitTextToCharacters(text) {
  return Array.from ? Array.from(text) : text.split("");
}
function resolveCharacters(chars2) {
  if (typeof chars2 === "string") {
    chars2 = [chars2];
  }
  const result = [];
  for (let i2 = 0, j2 = chars2.length; i2 < j2; i2++) {
    const item = chars2[i2];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      }
      const startCode = item[0].charCodeAt(0);
      const endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (let i22 = startCode, j22 = endCode; i22 <= j22; i22++) {
        result.push(String.fromCharCode(i22));
      }
    } else {
      result.push(...splitTextToCharacters(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}
const _BitmapFont = class {
  constructor(data, textures, ownsTextures) {
    var _a;
    const [info] = data.info;
    const [common] = data.common;
    const [page] = data.page;
    const [distanceField] = data.distanceField;
    const res = getResolutionOfUrl(page.file);
    const pageTextures = {};
    this._ownsTextures = ownsTextures;
    this.font = info.face;
    this.size = info.size;
    this.lineHeight = common.lineHeight / res;
    this.chars = {};
    this.pageTextures = pageTextures;
    for (let i2 = 0; i2 < data.page.length; i2++) {
      const { id, file } = data.page[i2];
      pageTextures[id] = textures instanceof Array ? textures[i2] : textures[file];
      if ((distanceField == null ? void 0 : distanceField.fieldType) && distanceField.fieldType !== "none") {
        pageTextures[id].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;
        pageTextures[id].baseTexture.mipmap = MIPMAP_MODES.OFF;
      }
    }
    for (let i2 = 0; i2 < data.char.length; i2++) {
      const { id, page: page2 } = data.char[i2];
      let { x: x2, y: y2, width, height, xoffset, yoffset, xadvance } = data.char[i2];
      x2 /= res;
      y2 /= res;
      width /= res;
      height /= res;
      xoffset /= res;
      yoffset /= res;
      xadvance /= res;
      const rect = new Rectangle(x2 + pageTextures[page2].frame.x / res, y2 + pageTextures[page2].frame.y / res, width, height);
      this.chars[id] = {
        xOffset: xoffset,
        yOffset: yoffset,
        xAdvance: xadvance,
        kerning: {},
        texture: new Texture(pageTextures[page2].baseTexture, rect),
        page: page2
      };
    }
    for (let i2 = 0; i2 < data.kerning.length; i2++) {
      let { first, second, amount } = data.kerning[i2];
      first /= res;
      second /= res;
      amount /= res;
      if (this.chars[second]) {
        this.chars[second].kerning[first] = amount;
      }
    }
    this.distanceFieldRange = distanceField == null ? void 0 : distanceField.distanceRange;
    this.distanceFieldType = ((_a = distanceField == null ? void 0 : distanceField.fieldType) == null ? void 0 : _a.toLowerCase()) ?? "none";
  }
  destroy() {
    for (const id in this.chars) {
      this.chars[id].texture.destroy();
      this.chars[id].texture = null;
    }
    for (const id in this.pageTextures) {
      if (this._ownsTextures) {
        this.pageTextures[id].destroy(true);
      }
      this.pageTextures[id] = null;
    }
    this.chars = null;
    this.pageTextures = null;
  }
  static install(data, textures, ownsTextures) {
    let fontData;
    if (data instanceof BitmapFontData) {
      fontData = data;
    } else {
      const format2 = autoDetectFormat(data);
      if (!format2) {
        throw new Error("Unrecognized data format for font.");
      }
      fontData = format2.parse(data);
    }
    if (textures instanceof Texture) {
      textures = [textures];
    }
    const font = new _BitmapFont(fontData, textures, ownsTextures);
    _BitmapFont.available[font.font] = font;
    return font;
  }
  static uninstall(name) {
    const font = _BitmapFont.available[name];
    if (!font) {
      throw new Error(`No font found named '${name}'`);
    }
    font.destroy();
    delete _BitmapFont.available[name];
  }
  static from(name, textStyle, options) {
    if (!name) {
      throw new Error("[BitmapFont] Property `name` is required.");
    }
    const {
      chars: chars2,
      padding,
      resolution,
      textureWidth,
      textureHeight,
      ...baseOptions
    } = Object.assign({}, _BitmapFont.defaultOptions, options);
    const charsList = resolveCharacters(chars2);
    const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
    const lineWidth = textureWidth;
    const fontData = new BitmapFontData();
    fontData.info[0] = {
      face: style.fontFamily,
      size: style.fontSize
    };
    fontData.common[0] = {
      lineHeight: style.fontSize
    };
    let positionX = 0;
    let positionY = 0;
    let canvas;
    let context2;
    let baseTexture;
    let maxCharHeight = 0;
    const textures = [];
    for (let i2 = 0; i2 < charsList.length; i2++) {
      if (!canvas) {
        canvas = settings.ADAPTER.createCanvas();
        canvas.width = textureWidth;
        canvas.height = textureHeight;
        context2 = canvas.getContext("2d");
        baseTexture = new BaseTexture(canvas, { resolution, ...baseOptions });
        textures.push(new Texture(baseTexture));
        fontData.page.push({
          id: textures.length - 1,
          file: ""
        });
      }
      const character = charsList[i2];
      const metrics = TextMetrics.measureText(character, style, false, canvas);
      const width = metrics.width;
      const height = Math.ceil(metrics.height);
      const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
      if (positionY >= textureHeight - height * resolution) {
        if (positionY === 0) {
          throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
        }
        --i2;
        canvas = null;
        context2 = null;
        baseTexture = null;
        positionY = 0;
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
      if (textureGlyphWidth * resolution + positionX >= lineWidth) {
        if (positionX === 0) {
          throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
        }
        --i2;
        positionY += maxCharHeight * resolution;
        positionY = Math.ceil(positionY);
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      drawGlyph(canvas, context2, metrics, positionX, positionY, resolution, style);
      const id = extractCharCode(metrics.text);
      fontData.char.push({
        id,
        page: textures.length - 1,
        x: positionX / resolution,
        y: positionY / resolution,
        width: textureGlyphWidth,
        height,
        xoffset: 0,
        yoffset: 0,
        xadvance: width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0)
      });
      positionX += (textureGlyphWidth + 2 * padding) * resolution;
      positionX = Math.ceil(positionX);
    }
    for (let i2 = 0, len = charsList.length; i2 < len; i2++) {
      const first = charsList[i2];
      for (let j2 = 0; j2 < len; j2++) {
        const second = charsList[j2];
        const c12 = context2.measureText(first).width;
        const c22 = context2.measureText(second).width;
        const total = context2.measureText(first + second).width;
        const amount = total - (c12 + c22);
        if (amount) {
          fontData.kerning.push({
            first: extractCharCode(first),
            second: extractCharCode(second),
            amount
          });
        }
      }
    }
    const font = new _BitmapFont(fontData, textures, true);
    if (_BitmapFont.available[name] !== void 0) {
      _BitmapFont.uninstall(name);
    }
    _BitmapFont.available[name] = font;
    return font;
  }
};
let BitmapFont = _BitmapFont;
BitmapFont.ALPHA = [["a", "z"], ["A", "Z"], " "];
BitmapFont.NUMERIC = [["0", "9"]];
BitmapFont.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
BitmapFont.ASCII = [[" ", "~"]];
BitmapFont.defaultOptions = {
  resolution: 1,
  textureWidth: 512,
  textureHeight: 512,
  padding: 4,
  chars: _BitmapFont.ALPHANUMERIC
};
BitmapFont.available = {};
var msdfFrag = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // Gamma correction for coverage-like alpha\r\n  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r\n  float gamma = mix(1.0, 1.0 / 2.2, luma);\r\n  float coverage = pow(uColor.a * alpha, gamma);  \r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, coverage);\r\n}\r\n";
var msdfVert = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
const pageMeshDataDefaultPageMeshData = [];
const pageMeshDataMSDFPageMeshData = [];
const charRenderDataPool = [];
const _BitmapText = class extends Container {
  constructor(text, style = {}) {
    super();
    const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign({}, _BitmapText.styleDefaults, style);
    if (!BitmapFont.available[fontName]) {
      throw new Error(`Missing BitmapFont "${fontName}"`);
    }
    this._activePagesMeshData = [];
    this._textWidth = 0;
    this._textHeight = 0;
    this._align = align;
    this._tintColor = new Color(tint);
    this._font = void 0;
    this._fontName = fontName;
    this._fontSize = fontSize;
    this.text = text;
    this._maxWidth = maxWidth;
    this._maxLineHeight = 0;
    this._letterSpacing = letterSpacing;
    this._anchor = new ObservablePoint(() => {
      this.dirty = true;
    }, this, 0, 0);
    this._roundPixels = settings.ROUND_PIXELS;
    this.dirty = true;
    this._resolution = settings.RESOLUTION;
    this._autoResolution = true;
    this._textureCache = {};
  }
  updateText() {
    var _a;
    const data = BitmapFont.available[this._fontName];
    const fontSize = this.fontSize;
    const scale = fontSize / data.size;
    const pos = new Point();
    const chars2 = [];
    const lineWidths = [];
    const lineSpaces = [];
    const text = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
    const charsInput = splitTextToCharacters(text);
    const maxWidth = this._maxWidth * data.size / fontSize;
    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    let prevCharCode = null;
    let lastLineWidth = 0;
    let maxLineWidth = 0;
    let line = 0;
    let lastBreakPos = -1;
    let lastBreakWidth = 0;
    let spacesRemoved = 0;
    let maxLineHeight = 0;
    let spaceCount = 0;
    for (let i2 = 0; i2 < charsInput.length; i2++) {
      const char = charsInput[i2];
      const charCode = extractCharCode(char);
      if (/(?:\s)/.test(char)) {
        lastBreakPos = i2;
        lastBreakWidth = lastLineWidth;
        spaceCount++;
      }
      if (char === "\r" || char === "\n") {
        lineWidths.push(lastLineWidth);
        lineSpaces.push(-1);
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        ++line;
        ++spacesRemoved;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
        continue;
      }
      const charData = data.chars[charCode];
      if (!charData) {
        continue;
      }
      if (prevCharCode && charData.kerning[prevCharCode]) {
        pos.x += charData.kerning[prevCharCode];
      }
      const charRenderData = charRenderDataPool.pop() || {
        texture: Texture.EMPTY,
        line: 0,
        charCode: 0,
        prevSpaces: 0,
        position: new Point()
      };
      charRenderData.texture = charData.texture;
      charRenderData.line = line;
      charRenderData.charCode = charCode;
      charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2);
      charRenderData.position.y = Math.round(pos.y + charData.yOffset);
      charRenderData.prevSpaces = spaceCount;
      chars2.push(charRenderData);
      lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);
      pos.x += charData.xAdvance + this._letterSpacing;
      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
      prevCharCode = charCode;
      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
        ++spacesRemoved;
        removeItems(chars2, 1 + lastBreakPos - spacesRemoved, 1 + i2 - lastBreakPos);
        i2 = lastBreakPos;
        lastBreakPos = -1;
        lineWidths.push(lastBreakWidth);
        lineSpaces.push(chars2.length > 0 ? chars2[chars2.length - 1].prevSpaces : 0);
        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
        line++;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
      }
    }
    const lastChar = charsInput[charsInput.length - 1];
    if (lastChar !== "\r" && lastChar !== "\n") {
      if (/(?:\s)/.test(lastChar)) {
        lastLineWidth = lastBreakWidth;
      }
      lineWidths.push(lastLineWidth);
      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
      lineSpaces.push(-1);
    }
    const lineAlignOffsets = [];
    for (let i2 = 0; i2 <= line; i2++) {
      let alignOffset = 0;
      if (this._align === "right") {
        alignOffset = maxLineWidth - lineWidths[i2];
      } else if (this._align === "center") {
        alignOffset = (maxLineWidth - lineWidths[i2]) / 2;
      } else if (this._align === "justify") {
        alignOffset = lineSpaces[i2] < 0 ? 0 : (maxLineWidth - lineWidths[i2]) / lineSpaces[i2];
      }
      lineAlignOffsets.push(alignOffset);
    }
    const lenChars = chars2.length;
    const pagesMeshData = {};
    const newPagesMeshData = [];
    const activePagesMeshData = this._activePagesMeshData;
    pageMeshDataPool.push(...activePagesMeshData);
    for (let i2 = 0; i2 < lenChars; i2++) {
      const texture = chars2[i2].texture;
      const baseTextureUid = texture.baseTexture.uid;
      if (!pagesMeshData[baseTextureUid]) {
        let pageMeshData = pageMeshDataPool.pop();
        if (!pageMeshData) {
          const geometry = new MeshGeometry();
          let material;
          let meshBlendMode;
          if (data.distanceFieldType === "none") {
            material = new MeshMaterial(Texture.EMPTY);
            meshBlendMode = BLEND_MODES.NORMAL;
          } else {
            material = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });
            meshBlendMode = BLEND_MODES.NORMAL_NPM;
          }
          const mesh = new Mesh(geometry, material);
          mesh.blendMode = meshBlendMode;
          pageMeshData = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        pageMeshData.index = 0;
        pageMeshData.indexCount = 0;
        pageMeshData.vertexCount = 0;
        pageMeshData.uvsCount = 0;
        pageMeshData.total = 0;
        const { _textureCache } = this;
        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);
        pageMeshData.mesh.texture = _textureCache[baseTextureUid];
        pageMeshData.mesh.tint = this._tintColor.value;
        newPagesMeshData.push(pageMeshData);
        pagesMeshData[baseTextureUid] = pageMeshData;
      }
      pagesMeshData[baseTextureUid].total++;
    }
    for (let i2 = 0; i2 < activePagesMeshData.length; i2++) {
      if (!newPagesMeshData.includes(activePagesMeshData[i2])) {
        this.removeChild(activePagesMeshData[i2].mesh);
      }
    }
    for (let i2 = 0; i2 < newPagesMeshData.length; i2++) {
      if (newPagesMeshData[i2].mesh.parent !== this) {
        this.addChild(newPagesMeshData[i2].mesh);
      }
    }
    this._activePagesMeshData = newPagesMeshData;
    for (const i2 in pagesMeshData) {
      const pageMeshData = pagesMeshData[i2];
      const total = pageMeshData.total;
      if (!(((_a = pageMeshData.indices) == null ? void 0 : _a.length) > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {
        pageMeshData.vertices = new Float32Array(4 * 2 * total);
        pageMeshData.uvs = new Float32Array(4 * 2 * total);
        pageMeshData.indices = new Uint16Array(6 * total);
      } else {
        const total2 = pageMeshData.total;
        const vertices = pageMeshData.vertices;
        for (let i22 = total2 * 4 * 2; i22 < vertices.length; i22++) {
          vertices[i22] = 0;
        }
      }
      pageMeshData.mesh.size = 6 * total;
    }
    for (let i2 = 0; i2 < lenChars; i2++) {
      const char = chars2[i2];
      let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
      if (this._roundPixels) {
        offset = Math.round(offset);
      }
      const xPos = offset * scale;
      const yPos = char.position.y * scale;
      const texture = char.texture;
      const pageMesh = pagesMeshData[texture.baseTexture.uid];
      const textureFrame = texture.frame;
      const textureUvs = texture._uvs;
      const index2 = pageMesh.index++;
      pageMesh.indices[index2 * 6 + 0] = 0 + index2 * 4;
      pageMesh.indices[index2 * 6 + 1] = 1 + index2 * 4;
      pageMesh.indices[index2 * 6 + 2] = 2 + index2 * 4;
      pageMesh.indices[index2 * 6 + 3] = 0 + index2 * 4;
      pageMesh.indices[index2 * 6 + 4] = 2 + index2 * 4;
      pageMesh.indices[index2 * 6 + 5] = 3 + index2 * 4;
      pageMesh.vertices[index2 * 8 + 0] = xPos;
      pageMesh.vertices[index2 * 8 + 1] = yPos;
      pageMesh.vertices[index2 * 8 + 2] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index2 * 8 + 3] = yPos;
      pageMesh.vertices[index2 * 8 + 4] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index2 * 8 + 5] = yPos + textureFrame.height * scale;
      pageMesh.vertices[index2 * 8 + 6] = xPos;
      pageMesh.vertices[index2 * 8 + 7] = yPos + textureFrame.height * scale;
      pageMesh.uvs[index2 * 8 + 0] = textureUvs.x0;
      pageMesh.uvs[index2 * 8 + 1] = textureUvs.y0;
      pageMesh.uvs[index2 * 8 + 2] = textureUvs.x1;
      pageMesh.uvs[index2 * 8 + 3] = textureUvs.y1;
      pageMesh.uvs[index2 * 8 + 4] = textureUvs.x2;
      pageMesh.uvs[index2 * 8 + 5] = textureUvs.y2;
      pageMesh.uvs[index2 * 8 + 6] = textureUvs.x3;
      pageMesh.uvs[index2 * 8 + 7] = textureUvs.y3;
    }
    this._textWidth = maxLineWidth * scale;
    this._textHeight = (pos.y + data.lineHeight) * scale;
    for (const i2 in pagesMeshData) {
      const pageMeshData = pagesMeshData[i2];
      if (this.anchor.x !== 0 || this.anchor.y !== 0) {
        let vertexCount = 0;
        const anchorOffsetX = this._textWidth * this.anchor.x;
        const anchorOffsetY = this._textHeight * this.anchor.y;
        for (let i22 = 0; i22 < pageMeshData.total; i22++) {
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
        }
      }
      this._maxLineHeight = maxLineHeight * scale;
      const vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
      const textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
      const indexBuffer = pageMeshData.mesh.geometry.getIndex();
      vertexBuffer.data = pageMeshData.vertices;
      textureBuffer.data = pageMeshData.uvs;
      indexBuffer.data = pageMeshData.indices;
      vertexBuffer.update();
      textureBuffer.update();
      indexBuffer.update();
    }
    for (let i2 = 0; i2 < chars2.length; i2++) {
      charRenderDataPool.push(chars2[i2]);
    }
    this._font = data;
    this.dirty = false;
  }
  updateTransform() {
    this.validate();
    this.containerUpdateTransform();
  }
  _render(renderer2) {
    if (this._autoResolution && this._resolution !== renderer2.resolution) {
      this._resolution = renderer2.resolution;
      this.dirty = true;
    }
    const { distanceFieldRange, distanceFieldType, size: size2 } = BitmapFont.available[this._fontName];
    if (distanceFieldType !== "none") {
      const { a: a8, b: b3, c: c3, d: d2 } = this.worldTransform;
      const dx = Math.sqrt(a8 * a8 + b3 * b3);
      const dy = Math.sqrt(c3 * c3 + d2 * d2);
      const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
      const fontScale = this.fontSize / size2;
      const resolution = renderer2._view.resolution;
      for (const mesh of this._activePagesMeshData) {
        mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;
      }
    }
    super._render(renderer2);
  }
  getLocalBounds() {
    this.validate();
    return super.getLocalBounds();
  }
  validate() {
    const font = BitmapFont.available[this._fontName];
    if (!font) {
      throw new Error(`Missing BitmapFont "${this._fontName}"`);
    }
    if (this._font !== font) {
      this.dirty = true;
    }
    if (this.dirty) {
      this.updateText();
    }
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value2) {
    if (this.tint === value2)
      return;
    this._tintColor.setValue(value2);
    for (let i2 = 0; i2 < this._activePagesMeshData.length; i2++) {
      this._activePagesMeshData[i2].mesh.tint = value2;
    }
  }
  get align() {
    return this._align;
  }
  set align(value2) {
    if (this._align !== value2) {
      this._align = value2;
      this.dirty = true;
    }
  }
  get fontName() {
    return this._fontName;
  }
  set fontName(value2) {
    if (!BitmapFont.available[value2]) {
      throw new Error(`Missing BitmapFont "${value2}"`);
    }
    if (this._fontName !== value2) {
      this._fontName = value2;
      this.dirty = true;
    }
  }
  get fontSize() {
    return this._fontSize ?? BitmapFont.available[this._fontName].size;
  }
  set fontSize(value2) {
    if (this._fontSize !== value2) {
      this._fontSize = value2;
      this.dirty = true;
    }
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(value2) {
    if (typeof value2 === "number") {
      this._anchor.set(value2);
    } else {
      this._anchor.copyFrom(value2);
    }
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === null || text === void 0 ? "" : text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get maxWidth() {
    return this._maxWidth;
  }
  set maxWidth(value2) {
    if (this._maxWidth === value2) {
      return;
    }
    this._maxWidth = value2;
    this.dirty = true;
  }
  get maxLineHeight() {
    this.validate();
    return this._maxLineHeight;
  }
  get textWidth() {
    this.validate();
    return this._textWidth;
  }
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(value2) {
    if (this._letterSpacing !== value2) {
      this._letterSpacing = value2;
      this.dirty = true;
    }
  }
  get roundPixels() {
    return this._roundPixels;
  }
  set roundPixels(value2) {
    if (value2 !== this._roundPixels) {
      this._roundPixels = value2;
      this.dirty = true;
    }
  }
  get textHeight() {
    this.validate();
    return this._textHeight;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value2) {
    this._autoResolution = false;
    if (this._resolution === value2) {
      return;
    }
    this._resolution = value2;
    this.dirty = true;
  }
  destroy(options) {
    const { _textureCache } = this;
    const data = BitmapFont.available[this._fontName];
    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    pageMeshDataPool.push(...this._activePagesMeshData);
    for (const pageMeshData of this._activePagesMeshData) {
      this.removeChild(pageMeshData.mesh);
    }
    this._activePagesMeshData = [];
    pageMeshDataPool.filter((page) => _textureCache[page.mesh.texture.baseTexture.uid]).forEach((page) => {
      page.mesh.texture = Texture.EMPTY;
    });
    for (const id in _textureCache) {
      const texture = _textureCache[id];
      texture.destroy();
      delete _textureCache[id];
    }
    this._font = null;
    this._tintColor = null;
    this._textureCache = null;
    super.destroy(options);
  }
};
let BitmapText = _BitmapText;
BitmapText.styleDefaults = {
  align: "left",
  tint: 16777215,
  maxWidth: 0,
  letterSpacing: 0
};
const validExtensions = [".xml", ".fnt"];
const loadBitmapFont = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Normal
  },
  name: "loadBitmapFont",
  test(url2) {
    return validExtensions.includes(path.extname(url2).toLowerCase());
  },
  async testParse(data) {
    return TextFormat.test(data) || XMLStringFormat.test(data);
  },
  async parse(asset, data, loader) {
    const fontData = TextFormat.test(asset) ? TextFormat.parse(asset) : XMLStringFormat.parse(asset);
    const { src } = data;
    const { page: pages } = fontData;
    const textureUrls = [];
    for (let i2 = 0; i2 < pages.length; ++i2) {
      const pageFile = pages[i2].file;
      let imagePath = path.join(path.dirname(src), pageFile);
      imagePath = copySearchParams(imagePath, src);
      textureUrls.push(imagePath);
    }
    const loadedTextures = await loader.load(textureUrls);
    const textures = textureUrls.map((url2) => loadedTextures[url2]);
    return BitmapFont.install(fontData, textures, true);
  },
  async load(url2, _options) {
    const response = await settings.ADAPTER.fetch(url2);
    return response.text();
  },
  unload(bitmapFont) {
    bitmapFont.destroy();
  }
};
extensions$1.add(loadBitmapFont);
const _HTMLTextStyle = class extends TextStyle {
  constructor() {
    super(...arguments);
    this._fonts = [];
    this._overrides = [];
    this._stylesheet = "";
    this.fontsDirty = false;
  }
  static from(originalStyle) {
    return new _HTMLTextStyle(Object.keys(_HTMLTextStyle.defaultOptions).reduce((obj, prop) => ({ ...obj, [prop]: originalStyle[prop] }), {}));
  }
  cleanFonts() {
    if (this._fonts.length > 0) {
      this._fonts.forEach((font) => {
        URL.revokeObjectURL(font.src);
        font.refs--;
        if (font.refs === 0) {
          if (font.fontFace) {
            document.fonts.delete(font.fontFace);
          }
          delete _HTMLTextStyle.availableFonts[font.originalUrl];
        }
      });
      this.fontFamily = "Arial";
      this._fonts.length = 0;
      this.styleID++;
      this.fontsDirty = true;
    }
  }
  loadFont(url2, options = {}) {
    const { availableFonts } = _HTMLTextStyle;
    if (availableFonts[url2]) {
      const font = availableFonts[url2];
      this._fonts.push(font);
      font.refs++;
      this.styleID++;
      this.fontsDirty = true;
      return Promise.resolve();
    }
    return settings.ADAPTER.fetch(url2).then((response) => response.blob()).then(async (blob) => new Promise((resolve2, reject) => {
      const src = URL.createObjectURL(blob);
      const reader = new FileReader();
      reader.onload = () => resolve2([src, reader.result]);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    })).then(async ([src, dataSrc]) => {
      const font = Object.assign({
        family: path.basename(url2, path.extname(url2)),
        weight: "normal",
        style: "normal",
        src,
        dataSrc,
        refs: 1,
        originalUrl: url2,
        fontFace: null
      }, options);
      availableFonts[url2] = font;
      this._fonts.push(font);
      this.styleID++;
      const fontFace = new FontFace(font.family, `url(${font.src})`, {
        weight: font.weight,
        style: font.style
      });
      font.fontFace = fontFace;
      await fontFace.load();
      document.fonts.add(fontFace);
      await document.fonts.ready;
      this.styleID++;
      this.fontsDirty = true;
    });
  }
  addOverride(...value2) {
    const toAdd = value2.filter((v2) => !this._overrides.includes(v2));
    if (toAdd.length > 0) {
      this._overrides.push(...toAdd);
      this.styleID++;
    }
  }
  removeOverride(...value2) {
    const toRemove = value2.filter((v2) => this._overrides.includes(v2));
    if (toRemove.length > 0) {
      this._overrides = this._overrides.filter((v2) => !toRemove.includes(v2));
      this.styleID++;
    }
  }
  toCSS(scale) {
    return [
      `transform: scale(${scale})`,
      `transform-origin: top left`,
      "display: inline-block",
      `color: ${this.normalizeColor(this.fill)}`,
      `font-size: ${this.fontSize}px`,
      `font-family: ${this.fontFamily}`,
      `font-weight: ${this.fontWeight}`,
      `font-style: ${this.fontStyle}`,
      `font-variant: ${this.fontVariant}`,
      `letter-spacing: ${this.letterSpacing}px`,
      `text-align: ${this.align}`,
      `padding: ${this.padding}px`,
      `white-space: ${this.whiteSpace}`,
      ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [],
      ...this.wordWrap ? [
        `word-wrap: ${this.breakWords ? "break-all" : "break-word"}`,
        `max-width: ${this.wordWrapWidth}px`
      ] : [],
      ...this.strokeThickness ? [
        `-webkit-text-stroke-width: ${this.strokeThickness}px`,
        `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        `text-stroke-width: ${this.strokeThickness}px`,
        `text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        "paint-order: stroke"
      ] : [],
      ...this.dropShadow ? [this.dropShadowToCSS()] : [],
      ...this._overrides
    ].join(";");
  }
  toGlobalCSS() {
    return this._fonts.reduce((result, font) => `${result}
            @font-face {
                font-family: "${font.family}";
                src: url('${font.dataSrc}');
                font-weight: ${font.weight};
                font-style: ${font.style}; 
            }`, this._stylesheet);
  }
  get stylesheet() {
    return this._stylesheet;
  }
  set stylesheet(value2) {
    if (this._stylesheet !== value2) {
      this._stylesheet = value2;
      this.styleID++;
    }
  }
  normalizeColor(color) {
    if (Array.isArray(color)) {
      color = rgb2hex(color);
    }
    if (typeof color === "number") {
      return hex2string(color);
    }
    return color;
  }
  dropShadowToCSS() {
    let color = this.normalizeColor(this.dropShadowColor);
    const alpha = this.dropShadowAlpha;
    const x2 = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance);
    const y2 = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
    if (color.startsWith("#") && alpha < 1) {
      color += (alpha * 255 | 0).toString(16).padStart(2, "0");
    }
    const position = `${x2}px ${y2}px`;
    if (this.dropShadowBlur > 0) {
      return `text-shadow: ${position} ${this.dropShadowBlur}px ${color}`;
    }
    return `text-shadow: ${position} ${color}`;
  }
  reset() {
    Object.assign(this, _HTMLTextStyle.defaultOptions);
  }
  onBeforeDraw() {
    const { fontsDirty: prevFontsDirty } = this;
    this.fontsDirty = false;
    if (this.isSafari && this._fonts.length > 0 && prevFontsDirty) {
      return new Promise((resolve2) => setTimeout(resolve2, 100));
    }
    return Promise.resolve();
  }
  get isSafari() {
    const { userAgent } = settings.ADAPTER.getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent);
  }
  set fillGradientStops(_value) {
    console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText");
  }
  get fillGradientStops() {
    return super.fillGradientStops;
  }
  set fillGradientType(_value) {
    console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText");
  }
  get fillGradientType() {
    return super.fillGradientType;
  }
  set miterLimit(_value) {
    console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText");
  }
  get miterLimit() {
    return super.miterLimit;
  }
  set trim(_value) {
    console.warn("[HTMLTextStyle] trim is not supported by HTMLText");
  }
  get trim() {
    return super.trim;
  }
  set textBaseline(_value) {
    console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText");
  }
  get textBaseline() {
    return super.textBaseline;
  }
  set leading(_value) {
    console.warn("[HTMLTextStyle] leading is not supported by HTMLText");
  }
  get leading() {
    return super.leading;
  }
  set lineJoin(_value) {
    console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText");
  }
  get lineJoin() {
    return super.lineJoin;
  }
};
let HTMLTextStyle = _HTMLTextStyle;
HTMLTextStyle.availableFonts = {};
HTMLTextStyle.defaultOptions = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  whiteSpace: "normal",
  wordWrap: false,
  wordWrapWidth: 100
};
const _HTMLText = class extends Sprite {
  constructor(text = "", style = {}) {
    super(Texture.EMPTY);
    this._text = null;
    this._style = null;
    this._autoResolution = true;
    this._loading = false;
    this.localStyleID = -1;
    this.dirty = false;
    this.ownsStyle = false;
    const image = new Image();
    const texture = Texture.from(image, {
      scaleMode: settings.SCALE_MODE,
      resourceOptions: {
        autoLoad: false
      }
    });
    texture.orig = new Rectangle();
    texture.trim = new Rectangle();
    this.texture = texture;
    const nssvg = "http://www.w3.org/2000/svg";
    const nsxhtml = "http://www.w3.org/1999/xhtml";
    const svgRoot = document.createElementNS(nssvg, "svg");
    const foreignObject = document.createElementNS(nssvg, "foreignObject");
    const domElement = document.createElementNS(nsxhtml, "div");
    const styleElement = document.createElementNS(nsxhtml, "style");
    foreignObject.setAttribute("width", "10000");
    foreignObject.setAttribute("height", "10000");
    foreignObject.style.overflow = "hidden";
    svgRoot.appendChild(foreignObject);
    this.maxWidth = _HTMLText.defaultMaxWidth;
    this.maxHeight = _HTMLText.defaultMaxHeight;
    this._domElement = domElement;
    this._styleElement = styleElement;
    this._svgRoot = svgRoot;
    this._foreignObject = foreignObject;
    this._foreignObject.appendChild(styleElement);
    this._foreignObject.appendChild(domElement);
    this._image = image;
    this._loadImage = new Image();
    this._autoResolution = _HTMLText.defaultAutoResolution;
    this._resolution = _HTMLText.defaultResolution ?? settings.RESOLUTION;
    this.text = text;
    this.style = style;
  }
  measureText(overrides) {
    var _a, _b;
    const { text, style, resolution } = Object.assign({
      text: this._text,
      style: this._style,
      resolution: this._resolution
    }, overrides);
    Object.assign(this._domElement, {
      innerHTML: text,
      style: style.toCSS(resolution)
    });
    this._styleElement.textContent = style.toGlobalCSS();
    document.body.appendChild(this._svgRoot);
    const contentBounds = this._domElement.getBoundingClientRect();
    this._svgRoot.remove();
    const contentWidth = Math.min(this.maxWidth, Math.ceil(contentBounds.width));
    const contentHeight = Math.min(this.maxHeight, Math.ceil(contentBounds.height));
    this._svgRoot.setAttribute("width", contentWidth.toString());
    this._svgRoot.setAttribute("height", contentHeight.toString());
    if (text !== this._text) {
      this._domElement.innerHTML = this._text;
    }
    if (style !== this._style) {
      Object.assign(this._domElement, { style: (_a = this._style) == null ? void 0 : _a.toCSS(resolution) });
      this._styleElement.textContent = (_b = this._style) == null ? void 0 : _b.toGlobalCSS();
    }
    return {
      width: contentWidth + style.padding * 2,
      height: contentHeight + style.padding * 2
    };
  }
  async updateText(respectDirty = true) {
    const { style, _image: image, _loadImage: loadImage } = this;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    const { width, height } = this.measureText();
    image.width = loadImage.width = Math.ceil(Math.max(1, width));
    image.height = loadImage.height = Math.ceil(Math.max(1, height));
    if (!this._loading) {
      this._loading = true;
      await new Promise((resolve2) => {
        loadImage.onload = async () => {
          await style.onBeforeDraw();
          this._loading = false;
          image.src = loadImage.src;
          loadImage.onload = null;
          loadImage.src = "";
          this.updateTexture();
          resolve2();
        };
        const svgURL = new XMLSerializer().serializeToString(this._svgRoot);
        loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;
      });
    }
  }
  get source() {
    return this._image;
  }
  updateTexture() {
    const { style, texture, _image: image, resolution } = this;
    const { padding } = style;
    const { baseTexture } = texture;
    texture.trim.width = texture._frame.width = image.width / resolution;
    texture.trim.height = texture._frame.height = image.height / resolution;
    texture.trim.x = -padding;
    texture.trim.y = -padding;
    texture.orig.width = texture._frame.width - padding * 2;
    texture.orig.height = texture._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(image.width, image.height, resolution);
    this.dirty = false;
  }
  _render(renderer2) {
    if (this._autoResolution && this._resolution !== renderer2.resolution) {
      this._resolution = renderer2.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._render(renderer2);
  }
  _renderCanvas(renderer2) {
    if (this._autoResolution && this._resolution !== renderer2.resolution) {
      this._resolution = renderer2.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._renderCanvas(renderer2);
  }
  getLocalBounds(rect) {
    this.updateText(true);
    return super.getLocalBounds(rect);
  }
  _calculateBounds() {
    this.updateText(true);
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  }
  _onStyleChange() {
    this.dirty = true;
  }
  destroy(options) {
    var _a, _b, _c, _d, _e;
    if (typeof options === "boolean") {
      options = { children: options };
    }
    options = Object.assign({}, _HTMLText.defaultDestroyOptions, options);
    super.destroy(options);
    const forceClear = null;
    if (this.ownsStyle) {
      (_a = this._style) == null ? void 0 : _a.cleanFonts();
    }
    this._style = forceClear;
    (_b = this._svgRoot) == null ? void 0 : _b.remove();
    this._svgRoot = forceClear;
    (_c = this._domElement) == null ? void 0 : _c.remove();
    this._domElement = forceClear;
    (_d = this._foreignObject) == null ? void 0 : _d.remove();
    this._foreignObject = forceClear;
    (_e = this._styleElement) == null ? void 0 : _e.remove();
    this._styleElement = forceClear;
    this._loadImage.src = "";
    this._loadImage.onload = null;
    this._loadImage = forceClear;
    this._image.src = "";
    this._image = forceClear;
  }
  get width() {
    this.updateText(true);
    return Math.abs(this.scale.x) * this._image.width / this.resolution;
  }
  set width(value2) {
    this.updateText(true);
    const s2 = sign(this.scale.x) || 1;
    this.scale.x = s2 * value2 / this._image.width / this.resolution;
    this._width = value2;
  }
  get height() {
    this.updateText(true);
    return Math.abs(this.scale.y) * this._image.height / this.resolution;
  }
  set height(value2) {
    this.updateText(true);
    const s2 = sign(this.scale.y) || 1;
    this.scale.y = s2 * value2 / this._image.height / this.resolution;
    this._height = value2;
  }
  get style() {
    return this._style;
  }
  set style(style) {
    if (this._style === style) {
      return;
    }
    style = style || {};
    if (style instanceof HTMLTextStyle) {
      this.ownsStyle = false;
      this._style = style;
    } else if (style instanceof TextStyle) {
      console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle");
      this.ownsStyle = true;
      this._style = HTMLTextStyle.from(style);
    } else {
      this.ownsStyle = true;
      this._style = new HTMLTextStyle(style);
    }
    this.localStyleID = -1;
    this.dirty = true;
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === "" || text === null || text === void 0 ? " " : text);
    text = this.sanitiseText(text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value2) {
    this._autoResolution = false;
    if (this._resolution === value2) {
      return;
    }
    this._resolution = value2;
    this.dirty = true;
  }
  sanitiseText(text) {
    return text.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;");
  }
};
let HTMLText = _HTMLText;
HTMLText.defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
HTMLText.defaultMaxWidth = 2024;
HTMLText.defaultMaxHeight = 2024;
HTMLText.defaultAutoResolution = true;
const PIXI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ALPHA_MODES,
  AbstractMultiResource,
  AccessibilityManager,
  AlphaFilter,
  AnimatedSprite,
  Application,
  ArrayResource,
  Assets,
  AssetsClass,
  Attribute,
  BLEND_MODES,
  BUFFER_BITS,
  BUFFER_TYPE,
  BackgroundSystem,
  BaseImageResource,
  BasePrepare,
  BaseRenderTexture,
  BaseTexture,
  BatchDrawCall,
  BatchGeometry,
  BatchRenderer,
  BatchShaderGenerator,
  BatchSystem,
  BatchTextureArray,
  BitmapFont,
  BitmapFontData,
  BitmapText,
  BlobResource,
  BlurFilter,
  BlurFilterPass,
  Bounds,
  BrowserAdapter,
  Buffer: Buffer$1,
  BufferResource,
  BufferSystem,
  CLEAR_MODES,
  COLOR_MASK_BITS,
  Cache,
  CanvasResource,
  Circle,
  Color,
  ColorMatrixFilter,
  CompressedTextureResource,
  Container,
  ContextSystem,
  CountLimiter,
  CubeResource,
  DEG_TO_RAD,
  DRAW_MODES,
  DisplacementFilter,
  DisplayObject,
  ENV,
  Ellipse,
  EventBoundary,
  EventSystem,
  ExtensionType,
  Extract,
  FORMATS,
  FORMATS_TO_COMPONENTS,
  FXAAFilter,
  FederatedDisplayObject,
  FederatedEvent,
  FederatedMouseEvent,
  FederatedPointerEvent,
  FederatedWheelEvent,
  FillStyle,
  Filter,
  FilterState,
  FilterSystem,
  Framebuffer,
  FramebufferSystem,
  GC_MODES,
  GLFramebuffer,
  GLProgram,
  GLTexture,
  GRAPHICS_CURVES,
  GenerateTextureSystem,
  Geometry,
  GeometrySystem,
  Graphics,
  GraphicsData,
  GraphicsGeometry,
  HTMLText,
  HTMLTextStyle,
  IGLUniformData,
  INSTALLED,
  INTERNAL_FORMATS,
  INTERNAL_FORMAT_TO_BYTES_PER_PIXEL,
  ImageBitmapResource,
  ImageResource,
  LINE_CAP,
  LINE_JOIN,
  LineStyle,
  LoaderParserPriority,
  MASK_TYPES,
  MIPMAP_MODES,
  MSAA_QUALITY,
  MaskData,
  MaskSystem,
  Matrix,
  Mesh,
  MeshBatchUvs,
  MeshGeometry,
  MeshMaterial,
  MultisampleSystem,
  NineSlicePlane,
  NoiseFilter,
  ObjectRenderer,
  ObjectRendererSystem,
  ObservablePoint,
  PI_2,
  PRECISION,
  ParticleContainer,
  ParticleRenderer,
  PlaneGeometry,
  PluginSystem: PluginSystem2,
  Point,
  Polygon,
  Prepare,
  Program,
  ProjectionSystem,
  Quad,
  QuadUv,
  RAD_TO_DEG,
  RENDERER_TYPE,
  Rectangle,
  RenderTexture,
  RenderTexturePool,
  RenderTextureSystem,
  Renderer,
  ResizePlugin,
  Resource,
  RopeGeometry,
  RoundedRectangle,
  Runner,
  SAMPLER_TYPES,
  SCALE_MODES,
  SHAPES,
  SVGResource,
  ScissorSystem,
  Shader,
  ShaderSystem,
  SimpleMesh,
  SimplePlane,
  SimpleRope,
  Sprite,
  SpriteMaskFilter,
  Spritesheet: Spritesheet$1,
  StartupSystem,
  State,
  StateSystem,
  StencilSystem,
  SystemManager,
  TARGETS,
  TEXT_GRADIENT,
  TYPES,
  TYPES_TO_BYTES_PER_COMPONENT,
  TYPES_TO_BYTES_PER_PIXEL,
  TemporaryDisplayObject,
  Text: Text$1,
  TextFormat,
  TextMetrics,
  TextStyle,
  Texture,
  TextureGCSystem,
  TextureMatrix,
  TextureSystem,
  TextureUvs,
  Ticker,
  TickerPlugin,
  TilingSprite,
  TilingSpriteRenderer,
  TimeLimiter,
  Transform,
  TransformFeedback,
  TransformFeedbackSystem,
  UPDATE_PRIORITY,
  UniformGroup,
  VERSION,
  VideoResource,
  ViewSystem,
  ViewableBuffer,
  WRAP_MODES,
  XMLFormat,
  XMLStringFormat,
  accessibleTarget,
  autoDetectFormat,
  autoDetectRenderer,
  autoDetectResource,
  cacheTextureArray,
  checkDataUrl,
  checkExtension,
  checkMaxIfStatementsInShader,
  convertToList,
  copySearchParams,
  createStringVariations,
  createTexture,
  createUBOElements,
  curves,
  defaultFilterVertex,
  defaultVertex,
  detectAvif,
  detectCompressedTextures,
  detectDefaults,
  detectWebp,
  extensions: extensions$1,
  filters,
  generateProgram,
  generateUniformBufferSync,
  getFontFamilyName,
  getTestContext,
  getUBOData,
  graphicsUtils,
  groupD8,
  isMobile,
  isSingleItem,
  loadBitmapFont,
  loadDDS,
  loadImageBitmap,
  loadJson,
  loadKTX,
  loadSVG,
  loadTextures,
  loadTxt,
  loadWebFont,
  parseDDS,
  parseKTX,
  resolveCompressedTextureUrl,
  resolveTextureUrl,
  settings,
  spritesheetAsset,
  uniformParsers,
  unsafeEvalSupported,
  utils: index
}, Symbol.toStringTag, { value: "Module" }));
class CommonLayer extends Container {
  constructor(layer, map2) {
    super();
    this.layer = layer;
    this.map = map2;
    this.applyProperties();
  }
  applyProperties() {
    this.alpha = this.layer.opacity ?? 1;
    this.visible = this.layer.visible ?? true;
    this.x = this.layer.offsetx ?? 0;
    this.y = this.layer.offsety ?? 0;
    this.z = this.layer.properties.z ?? 0;
  }
}
class ImageLayer extends CommonLayer {
  applyProperties() {
    super.applyProperties();
    const engine = this.map["renderer"]["clientEngine"];
    if (this.layer.image && this.layer.image.source && engine) {
      const {
        width,
        height,
        source
      } = this.layer.image;
      const data = this.map.getData();
      const texture = Texture.from(engine.getResourceUrl(source));
      const tilingSprite = new TilingSprite(texture, this.layer.repeatx ? data.width * data.tilewidth : width, this.layer.repeaty ? data.height * data.tileheight : height);
      this.addChild(tilingSprite);
    }
  }
}
class Tile2 extends AnimatedSprite {
  static getTextures(tile, tileSet) {
    const textures = [];
    if (tile.animations && tile.animations.length) {
      tile.animations.forEach((frame) => {
        textures.push(tileSet.textures[frame.tileid].clone());
      });
    } else {
      textures.push(tileSet.textures[tile.gid - tileSet.firstgid].clone());
    }
    return textures;
  }
  constructor(tile, tileSet) {
    super(Tile2.getTextures(tile, tileSet));
    this.tile = tile;
    this.tileSet = tileSet;
    this.animations = [];
    this._x = 0;
    this._y = 0;
    this.properties = {};
    this.animations = tile.animations || [];
    this.properties = tile.properties;
    this.textures = Tile2.getTextures(tile, tileSet);
    this.texture = this.textures[0];
    this.flip();
  }
  get gid() {
    return this.tile.gid;
  }
  setAnimation(frame) {
    const size2 = this.animations.length;
    if (size2 > 1) {
      const offset = (this.animations[1].tileid - this.animations[0].tileid) * this.width;
      frame.tileAnimX(offset, size2);
    }
  }
  flip() {
    let symmetry;
    let i2 = 0;
    const add2 = (symmetrySecond) => {
      i2++;
      if (symmetry)
        symmetry = groupD8.add(symmetry, symmetrySecond);
      else
        symmetry = symmetrySecond;
    };
    if (this.tile.horizontalFlip) {
      add2(groupD8.MIRROR_HORIZONTAL);
    }
    if (this.tile.verticalFlip) {
      add2(groupD8.MIRROR_VERTICAL);
    }
    if (this.tile.diagonalFlip) {
      if (i2 % 2 == 0) {
        add2(groupD8.MAIN_DIAGONAL);
      } else {
        add2(groupD8.REVERSE_DIAGONAL);
      }
    }
    if (symmetry)
      this.texture.rotate = symmetry;
  }
}
let B$1 = class B {
  /** @param renderer */
  constructor(t2) {
    this.tileAnim = [0, 0], this.dontUseTransform = false, this.renderer = t2, this.tileAnim = [0, 0];
  }
  static registerExtension() {
    extensions$1.add({
      name: "tilemap",
      type: ExtensionType.CanvasRendererPlugin,
      ref: B
    });
  }
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  static getInstance(t2) {
    if (!t2.plugins.tilemap)
      throw new Error("Extension not registered!");
    return t2.plugins.tilemap;
  }
};
const m$1 = {
  /** The default number of textures per tilemap in a tilemap composite. */
  TEXTURES_PER_TILEMAP: 16,
  /**
   * The width/height of each texture tile in a {@link TEXTILE_DIMEN}. This is 1024px by default.
   *
   * This should fit all tile base-textures; otherwise, {@link TextileResource} may fail to correctly
   * upload the textures togther in a tiled fashion.
   */
  TEXTILE_DIMEN: 1024,
  /**
   * The number of texture tiles per {@link TextileResource}.
   *
   * Texture tiling is disabled by default, and so this is set to `1` by default. If it is set to a
   * higher value, textures will be uploaded together in a tiled fashion.
   *
   * Since {@link TextileResource} is a dual-column format, this should be even for packing
   * efficiency. The optimal value is usually 4.
   */
  TEXTILE_UNITS: 1,
  /** The scaling mode of the combined texture tiling. */
  TEXTILE_SCALE_MODE: SCALE_MODES.LINEAR,
  /** This will enable 32-bit index buffers. It's useful when you have more than 16K tiles. */
  use32bitIndex: false,
  /** Flags whether textiles should be cleared when each tile is uploaded. */
  DO_CLEAR: true,
  // Backward compatibility
  get maxTextures() {
    return this.MAX_TEXTURES;
  },
  set maxTextures(o2) {
    this.MAX_TEXTURES = o2;
  },
  get boundSize() {
    return this.TEXTURE_TILE_DIMEN;
  },
  set boundSize(o2) {
    this.TILE_TEXTURE_DIMEN = o2;
  },
  get boundCountPerBuffer() {
    return this.TEXTILE_UNITS;
  },
  set boundCountPerBuffer(o2) {
    this.TEXTILE_UNITS = o2;
  }
};
var it = /* @__PURE__ */ ((o2) => (o2[o2.U = 0] = "U", o2[o2.V = 1] = "V", o2[o2.X = 2] = "X", o2[o2.Y = 3] = "Y", o2[o2.TILE_WIDTH = 4] = "TILE_WIDTH", o2[o2.TILE_HEIGHT = 5] = "TILE_HEIGHT", o2[o2.ROTATE = 6] = "ROTATE", o2[o2.ANIM_X = 7] = "ANIM_X", o2[o2.ANIM_Y = 8] = "ANIM_Y", o2[o2.TEXTURE_INDEX = 9] = "TEXTURE_INDEX", o2[o2.ANIM_COUNT_X = 10] = "ANIM_COUNT_X", o2[o2.ANIM_COUNT_Y = 11] = "ANIM_COUNT_Y", o2[o2.ANIM_DIVISOR = 12] = "ANIM_DIVISOR", o2[o2.ALPHA = 13] = "ALPHA", o2))(it || {});
const L$1 = Object.keys(it).length / 2;
let k$2 = class k extends Container {
  /**
   * @param tileset - The tileset to use for the tilemap. This can be reset later with {@link Tilemap.setTileset}. The
   *      base-textures in this array must not be duplicated.
   */
  constructor(t2) {
    super(), this.shadowColor = new Float32Array([0, 0, 0, 0.5]), this._globalMat = null, this.tileAnim = null, this.modificationMarker = 0, this.offsetX = 0, this.offsetY = 0, this.compositeParent = false, this.tilemapBounds = new Bounds(), this.hasAnimatedTile = false, this.pointsBuf = [], this.renderCanvas = (e3) => {
      const i2 = B$1.getInstance(e3);
      if (i2 && !i2.dontUseTransform) {
        const s2 = this.worldTransform;
        e3.canvasContext.activeContext.setTransform(
          s2.a,
          s2.b,
          s2.c,
          s2.d,
          s2.tx * e3.resolution,
          s2.ty * e3.resolution
        );
      }
      this.renderCanvasCore(e3);
    }, this.vbId = 0, this.vb = null, this.vbBuffer = null, this.vbArray = null, this.vbInts = null, this.setTileset(t2);
  }
  /**
   * @returns The tileset of this tilemap.
   */
  getTileset() {
    return this.tileset;
  }
  /**
   * Define the tileset used by the tilemap.
   *
   * @param tileset - The list of textures to use in the tilemap. If a base-texture (not array) is passed, it will
   *  be wrapped into an array. This should not contain any duplicates.
   */
  setTileset(t2 = []) {
    Array.isArray(t2) || (t2 = [t2]);
    for (let e3 = 0; e3 < t2.length; e3++)
      t2[e3].baseTexture && (t2[e3] = t2[e3].baseTexture);
    return this.tileset = t2, this;
  }
  /**  Clears all the tiles added into this tilemap. */
  clear() {
    return this.pointsBuf.length = 0, this.modificationMarker = 0, this.tilemapBounds.clear(), this.hasAnimatedTile = false, this;
  }
  /**
   * Adds a tile that paints the given texture at (x, y).
   *
   * @param tileTexture - The tiling texture to render.
   * @param x - The local x-coordinate of the tile's position.
   * @param y - The local y-coordinate of the tile's position.
   * @param options - Additional tile options.
   * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.
   * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.
   * @param [options.tileWidth=texture.orig.width] - The local width of the tile.
   * @param [options.tileHeight=texture.orig.height] - The local height of the tile.
   * @param [options.animX=0] - For animated tiles, this is the "offset" along the x-axis for adjacent
   *      animation frame textures in the base-texture.
   * @param [options.animY=0] - For animated tiles, this is the "offset" along the y-axis for adjacent
   *      animation frames textures in the base-texture.
   * @param [options.rotate=0]
   * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures
   *      per row.
   * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures
   *      per column.
   * @param [options.animDivisor=1] - For animated tiles, this is the animation duration of each frame
   * @param [options.alpha=1] - Tile alpha
   * @return This tilemap, good for chaining.
   */
  tile(t2, e3, i2, s2 = {}) {
    let a8, u2 = -1;
    if (typeof t2 == "number")
      u2 = t2, a8 = this.tileset[u2];
    else {
      let b3;
      typeof t2 == "string" ? b3 = Texture.from(t2) : b3 = t2;
      const X2 = this.tileset;
      for (let v2 = 0; v2 < X2.length; v2++)
        if (X2[v2] === b3.castToBaseTexture()) {
          u2 = v2;
          break;
        }
      "baseTexture" in b3 && (s2.u = s2.u ?? b3.frame.x, s2.v = s2.v ?? b3.frame.y, s2.tileWidth = s2.tileWidth ?? b3.orig.width, s2.tileHeight = s2.tileHeight ?? b3.orig.height), a8 = b3.castToBaseTexture();
    }
    if (!a8 || u2 < 0)
      return console.error("The tile texture was not found in the tilemap tileset."), this;
    const {
      u: l2 = 0,
      v: h2 = 0,
      tileWidth: d2 = a8.realWidth,
      tileHeight: f3 = a8.realHeight,
      animX: p2 = 0,
      animY: r2 = 0,
      rotate: n2 = 0,
      animCountX: A2 = 1024,
      animCountY: w2 = 1024,
      animDivisor: C2 = 1,
      alpha: c3 = 1
    } = s2, E2 = this.pointsBuf;
    return this.hasAnimatedTile = this.hasAnimatedTile || p2 > 0 || r2 > 0, E2.push(l2), E2.push(h2), E2.push(e3), E2.push(i2), E2.push(d2), E2.push(f3), E2.push(n2), E2.push(p2 | 0), E2.push(r2 | 0), E2.push(u2), E2.push(A2), E2.push(w2), E2.push(C2), E2.push(c3), this.tilemapBounds.addFramePad(e3, i2, e3 + d2, i2 + f3, 0, 0), this;
  }
  /** Changes the rotation of the last tile. */
  tileRotate(t2) {
    const e3 = this.pointsBuf;
    e3[e3.length - (L$1 - 9)] = t2;
  }
  /** Changes the `animX`, `animCountX` of the last tile. */
  tileAnimX(t2, e3) {
    const i2 = this.pointsBuf;
    i2[i2.length - (L$1 - 7)] = t2, i2[i2.length - (L$1 - 10)] = e3;
  }
  /** Changes the `animY`, `animCountY` of the last tile. */
  tileAnimY(t2, e3) {
    const i2 = this.pointsBuf;
    i2[i2.length - (L$1 - 8)] = t2, i2[i2.length - (L$1 - 11)] = e3;
  }
  /** Changes the `animDivisor` value of the last tile. */
  tileAnimDivisor(t2) {
    const e3 = this.pointsBuf;
    e3[e3.length - (L$1 - 12)] = t2;
  }
  tileAlpha(t2) {
    const e3 = this.pointsBuf;
    e3[e3.length - (L$1 - 13)] = t2;
  }
  renderCanvasCore(t2) {
    if (this.tileset.length === 0)
      return;
    const e3 = this.pointsBuf, i2 = this.tileAnim || t2.plugins.tilemap && t2.plugins.tilemap.tileAnim;
    t2.canvasContext.activeContext.fillStyle = "#000000";
    for (let s2 = 0, a8 = e3.length; s2 < a8; s2 += L$1) {
      let u2 = e3[
        s2 + 0
        /* U */
      ], l2 = e3[
        s2 + 1
        /* V */
      ];
      const h2 = e3[
        s2 + 2
        /* X */
      ], d2 = e3[
        s2 + 3
        /* Y */
      ], f3 = e3[
        s2 + 4
        /* TILE_WIDTH */
      ], p2 = e3[
        s2 + 5
        /* TILE_HEIGHT */
      ];
      u2 += e3[
        s2 + 7
        /* ANIM_X */
      ] * i2[0], l2 += e3[
        s2 + 8
        /* ANIM_Y */
      ] * i2[1];
      const r2 = e3[
        s2 + 9
        /* TEXTURE_INDEX */
      ], n2 = e3[
        s2 + 13
        /* ALPHA */
      ];
      r2 >= 0 && this.tileset[r2] ? (t2.canvasContext.activeContext.globalAlpha = n2, t2.canvasContext.activeContext.drawImage(
        this.tileset[r2].getDrawableSource(),
        u2,
        l2,
        f3,
        p2,
        h2,
        d2,
        f3,
        p2
      )) : (t2.canvasContext.activeContext.globalAlpha = 0.5, t2.canvasContext.activeContext.fillRect(h2, d2, f3, p2)), t2.canvasContext.activeContext.globalAlpha = 1;
    }
  }
  destroyVb() {
    this.vb && (this.vb.destroy(), this.vb = null);
  }
  render(t2) {
    const e3 = t2.plugins.tilemap, i2 = e3.getShader();
    t2.batch.setObjectRenderer(e3), this._globalMat = i2.uniforms.projTransMatrix, t2.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform), i2.uniforms.shadowColor = this.shadowColor, i2.uniforms.animationFrame = this.tileAnim || e3.tileAnim, this.renderWebGLCore(t2, e3);
  }
  renderWebGLCore(t2, e3) {
    const i2 = this.pointsBuf;
    if (i2.length === 0)
      return;
    const s2 = i2.length / L$1, a8 = e3.getShader(), u2 = this.tileset;
    if (u2.length === 0)
      return;
    e3.bindTileTextures(t2, u2), t2.shader.bind(a8, false);
    let l2 = this.vb;
    l2 || (l2 = e3.createVb(), this.vb = l2, this.vbId = l2.id, this.vbBuffer = null, this.modificationMarker = 0), e3.checkIndexBuffer(s2, l2);
    const d2 = l2.getBuffer("aVertexPosition"), f3 = s2 * l2.vertPerQuad;
    if (f3 !== 0) {
      if (this.modificationMarker !== f3) {
        this.modificationMarker = f3;
        const p2 = l2.stride * f3;
        if (!this.vbBuffer || this.vbBuffer.byteLength < p2) {
          let c3 = l2.stride;
          for (; c3 < p2; )
            c3 *= 2;
          this.vbBuffer = new ArrayBuffer(c3), this.vbArray = new Float32Array(this.vbBuffer), this.vbInts = new Uint32Array(this.vbBuffer), d2.update(this.vbBuffer);
        }
        const r2 = this.vbArray;
        let n2 = 0, A2 = 0, w2 = this.offsetX, C2 = this.offsetY;
        for (let c3 = 0; c3 < i2.length; c3 += L$1) {
          if (this.compositeParent) {
            const M2 = i2[
              c3 + 9
              /* TEXTURE_INDEX */
            ];
            A2 = M2, w2 = 0, C2 = 0;
          }
          const b3 = i2[
            c3 + 2
            /* X */
          ], X2 = i2[
            c3 + 3
            /* Y */
          ], v2 = i2[
            c3 + 4
            /* TILE_WIDTH */
          ], y2 = i2[
            c3 + 5
            /* TILE_HEIGHT */
          ], g2 = i2[
            c3 + 0
            /* U */
          ] + w2, x2 = i2[
            c3 + 1
            /* V */
          ] + C2;
          let T2 = i2[
            c3 + 6
            /* ROTATE */
          ];
          const rt = i2[
            c3 + 7
            /* ANIM_X */
          ], nt = i2[
            c3 + 8
            /* ANIM_Y */
          ], at = i2[
            c3 + 10
            /* ANIM_COUNT_X */
          ] || 1024, ot = i2[
            c3 + 11
            /* ANIM_COUNT_Y */
          ] || 1024, D2 = rt + at * 2048, S2 = nt + ot * 2048, F2 = i2[
            c3 + 12
            /* ANIM_DIVISOR */
          ], Y2 = i2[
            c3 + 13
            /* ALPHA */
          ];
          let P, H2, U2, W2, V2, j2, G2, z2;
          if (T2 === 0)
            P = g2, H2 = x2, U2 = g2 + v2, W2 = x2, V2 = g2 + v2, j2 = x2 + y2, G2 = g2, z2 = x2 + y2;
          else {
            let M2 = v2 / 2, _2 = y2 / 2;
            T2 % 4 !== 0 && (M2 = y2 / 2, _2 = v2 / 2);
            const N2 = g2 + M2, R2 = x2 + _2;
            T2 = groupD8.add(T2, groupD8.NW), P = N2 + M2 * groupD8.uX(T2), H2 = R2 + _2 * groupD8.uY(T2), T2 = groupD8.add(T2, 2), U2 = N2 + M2 * groupD8.uX(T2), W2 = R2 + _2 * groupD8.uY(T2), T2 = groupD8.add(T2, 2), V2 = N2 + M2 * groupD8.uX(T2), j2 = R2 + _2 * groupD8.uY(T2), T2 = groupD8.add(T2, 2), G2 = N2 + M2 * groupD8.uX(T2), z2 = R2 + _2 * groupD8.uY(T2);
          }
          r2[n2++] = b3, r2[n2++] = X2, r2[n2++] = P, r2[n2++] = H2, r2[n2++] = g2 + 0.5, r2[n2++] = x2 + 0.5, r2[n2++] = g2 + v2 - 0.5, r2[n2++] = x2 + y2 - 0.5, r2[n2++] = D2, r2[n2++] = S2, r2[n2++] = A2, r2[n2++] = F2, r2[n2++] = Y2, r2[n2++] = b3 + v2, r2[n2++] = X2, r2[n2++] = U2, r2[n2++] = W2, r2[n2++] = g2 + 0.5, r2[n2++] = x2 + 0.5, r2[n2++] = g2 + v2 - 0.5, r2[n2++] = x2 + y2 - 0.5, r2[n2++] = D2, r2[n2++] = S2, r2[n2++] = A2, r2[n2++] = F2, r2[n2++] = Y2, r2[n2++] = b3 + v2, r2[n2++] = X2 + y2, r2[n2++] = V2, r2[n2++] = j2, r2[n2++] = g2 + 0.5, r2[n2++] = x2 + 0.5, r2[n2++] = g2 + v2 - 0.5, r2[n2++] = x2 + y2 - 0.5, r2[n2++] = D2, r2[n2++] = S2, r2[n2++] = A2, r2[n2++] = F2, r2[n2++] = Y2, r2[n2++] = b3, r2[n2++] = X2 + y2, r2[n2++] = G2, r2[n2++] = z2, r2[n2++] = g2 + 0.5, r2[n2++] = x2 + 0.5, r2[n2++] = g2 + v2 - 0.5, r2[n2++] = x2 + y2 - 0.5, r2[n2++] = D2, r2[n2++] = S2, r2[n2++] = A2, r2[n2++] = F2, r2[n2++] = Y2;
        }
        d2.update(r2);
      }
      t2.geometry.bind(l2, a8), t2.geometry.draw(DRAW_MODES.TRIANGLES, s2 * 6, 0);
    }
  }
  /**
   * @internal
   * @ignore
   */
  isModified(t2) {
    return !!(this.modificationMarker !== this.pointsBuf.length || t2 && this.hasAnimatedTile);
  }
  /**
   * This will pull forward the modification marker.
   *
   * @internal
   * @ignore
   */
  clearModify() {
    this.modificationMarker = this.pointsBuf.length;
  }
  /** @override */
  _calculateBounds() {
    const { minX: t2, minY: e3, maxX: i2, maxY: s2 } = this.tilemapBounds;
    this._bounds.addFrame(this.transform, t2, e3, i2, s2);
  }
  /** @override */
  getLocalBounds(t2) {
    return this.children.length === 0 ? this.tilemapBounds.getRectangle(t2) : super.getLocalBounds.call(this, t2);
  }
  /** @override */
  destroy(t2) {
    super.destroy(t2), this.destroyVb();
  }
  /**
   * Deprecated signature for {@link Tilemap.tile tile}.
   *
   * @deprecated Since @pixi/tilemap 3.
   */
  addFrame(t2, e3, i2, s2, a8) {
    return this.tile(
      t2,
      e3,
      i2,
      {
        animX: s2,
        animY: a8
      }
    ), true;
  }
  /**
   * Deprecated signature for {@link Tilemap.tile tile}.
   *
   * @deprecated Since @pixi/tilemap 3.
   */
  // eslint-disable-next-line max-params
  addRect(t2, e3, i2, s2, a8, u2, l2, h2 = 0, d2 = 0, f3 = 0, p2 = 1024, r2 = 1024, n2 = 1, A2 = 1) {
    return this.tile(
      t2,
      s2,
      a8,
      {
        u: e3,
        v: i2,
        tileWidth: u2,
        tileHeight: l2,
        animX: h2,
        animY: d2,
        rotate: f3,
        animCountX: p2,
        animCountY: r2,
        animDivisor: n2,
        alpha: A2
      }
    );
  }
};
let Z$1 = class Z extends Container {
  /**
   * @param tileset - A list of tile base-textures that will be used to eagerly initialized the layered
   *  tilemaps. This is only an performance optimization, and using {@link CompositeTilemap.tile tile}
   *  will work equivalently.
   */
  constructor(t2) {
    super(), this.tileAnim = null, this.lastModifiedTilemap = null, this.modificationMarker = 0, this.shadowColor = new Float32Array([0, 0, 0, 0.5]), this._globalMat = null, this.setBitmaps = this.tileset, this.tileset(t2), this.texturesPerTilemap = m$1.TEXTURES_PER_TILEMAP;
  }
  /**
   * This will preinitialize the tilesets of the layered tilemaps.
   *
   * If used after a tilemap has been created (or a tile added), this will overwrite the tile textures of the
   * existing tilemaps. Passing the tileset to the constructor instead is the best practice.
   *
   * @param tileTextures - The list of tile textures that make up the tileset.
   */
  tileset(t2) {
    t2 || (t2 = []);
    const e3 = this.texturesPerTilemap, i2 = this.children.length, s2 = Math.ceil(t2.length / e3);
    for (let a8 = 0; a8 < Math.min(i2, s2); a8++)
      this.children[a8].setTileset(
        t2.slice(a8 * e3, (a8 + 1) * e3)
      );
    for (let a8 = i2; a8 < s2; a8++) {
      const u2 = new k$2(t2.slice(a8 * e3, (a8 + 1) * e3));
      u2.compositeParent = true, u2.offsetX = m$1.TEXTILE_DIMEN, u2.offsetY = m$1.TEXTILE_DIMEN, this.addChild(u2);
    }
    return this;
  }
  /** Clears the tilemap composite. */
  clear() {
    for (let t2 = 0; t2 < this.children.length; t2++)
      this.children[t2].clear();
    return this.modificationMarker = 0, this;
  }
  /** Changes the rotation of the last added tile. */
  tileRotate(t2) {
    return this.lastModifiedTilemap && this.lastModifiedTilemap.tileRotate(t2), this;
  }
  /** Changes `animX`, `animCountX` of the last added tile. */
  tileAnimX(t2, e3) {
    return this.lastModifiedTilemap && this.lastModifiedTilemap.tileAnimX(t2, e3), this;
  }
  /** Changes `animY`, `animCountY` of the last added tile. */
  tileAnimY(t2, e3) {
    return this.lastModifiedTilemap && this.lastModifiedTilemap.tileAnimY(t2, e3), this;
  }
  /** Changes `tileAnimDivisor` value of the last added tile. */
  tileAnimDivisor(t2) {
    return this.lastModifiedTilemap && this.lastModifiedTilemap.tileAnimDivisor(t2), this;
  }
  /**
   * Adds a tile that paints the given tile texture at (x, y).
   *
   * @param tileTexture - The tile texture. You can pass an index into the composite tilemap as well.
   * @param x - The local x-coordinate of the tile's location.
   * @param y - The local y-coordinate of the tile's location.
   * @param options - Additional options to pass to {@link Tilemap.tile}.
   * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.
   * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.
   * @param [options.tileWidth=texture.orig.width] - The local width of the tile.
   * @param [options.tileHeight=texture.orig.height] - The local height of the tile.
   * @param [options.animX=0] - For animated tiles, this is the "offset" along the x-axis for adjacent
   *      animation frame textures in the base-texture.
   * @param [options.animY=0] - For animated tiles, this is the "offset" along the y-axis for adjacent
   *      animation frames textures in the base-texture.
   * @param [options.rotate=0]
   * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures
   *      per row.
   * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures
   *      per column.
   * @param [options.animDivisor=1] - For animated tiles, this is the animation duration each frame
   * @param [options.alpha=1] - Tile alpha
   * @return This tilemap, good for chaining.
   */
  tile(t2, e3, i2, s2 = {}) {
    let a8 = null;
    const u2 = this.children;
    if (this.lastModifiedTilemap = null, typeof t2 == "number") {
      const l2 = t2 / this.texturesPerTilemap >> 0;
      let h2 = 0;
      if (a8 = u2[l2], a8)
        h2 = t2 % this.texturesPerTilemap;
      else {
        if (a8 = u2[0], !a8)
          return this;
        h2 = 0;
      }
      a8.tile(
        h2,
        e3,
        i2,
        s2
      );
    } else {
      typeof t2 == "string" && (t2 = Texture.from(t2));
      for (let l2 = 0; l2 < u2.length; l2++) {
        const h2 = u2[l2], d2 = h2.getTileset();
        for (let f3 = 0; f3 < d2.length; f3++)
          if (d2[f3] === t2.baseTexture) {
            a8 = h2;
            break;
          }
        if (a8)
          break;
      }
      if (!a8) {
        for (let l2 = u2.length - 1; l2 >= 0; l2--) {
          const h2 = u2[l2];
          if (h2.getTileset().length < this.texturesPerTilemap) {
            a8 = h2, h2.getTileset().push(t2.baseTexture);
            break;
          }
        }
        a8 || (a8 = new k$2(t2.baseTexture), a8.compositeParent = true, a8.offsetX = m$1.TEXTILE_DIMEN, a8.offsetY = m$1.TEXTILE_DIMEN, this.addChild(a8));
      }
      a8.tile(
        t2,
        e3,
        i2,
        s2
      );
    }
    return this.lastModifiedTilemap = a8, this;
  }
  renderCanvas(t2) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
      return;
    const e3 = B$1.getInstance(t2);
    if (e3 && !e3.dontUseTransform) {
      const s2 = this.worldTransform;
      t2.canvasContext.activeContext.setTransform(
        s2.a,
        s2.b,
        s2.c,
        s2.d,
        s2.tx * t2.resolution,
        s2.ty * t2.resolution
      );
    }
    const i2 = this.children;
    for (let s2 = 0; s2 < i2.length; s2++) {
      const a8 = i2[s2];
      a8.tileAnim = this.tileAnim, a8.renderCanvasCore(t2);
    }
  }
  render(t2) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
      return;
    const e3 = t2.plugins.tilemap, i2 = e3.getShader();
    t2.batch.setObjectRenderer(e3), this._globalMat = i2.uniforms.projTransMatrix, t2.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform), i2.uniforms.shadowColor = this.shadowColor, i2.uniforms.animationFrame = this.tileAnim || e3.tileAnim, t2.shader.bind(i2, false);
    const s2 = this.children;
    for (let a8 = 0; a8 < s2.length; a8++)
      s2[a8].renderWebGLCore(t2, e3);
  }
  /**
   * @internal
   * @ignore
   */
  isModified(t2) {
    const e3 = this.children;
    if (this.modificationMarker !== e3.length)
      return true;
    for (let i2 = 0; i2 < e3.length; i2++)
      if (e3[i2].isModified(t2))
        return true;
    return false;
  }
  /**
   * @internal
   * @ignore
   */
  clearModify() {
    const t2 = this.children;
    this.modificationMarker = t2.length;
    for (let e3 = 0; e3 < t2.length; e3++)
      t2[e3].clearModify();
  }
  /**
   * @deprecated Since @pixi/tilemap 3.
   * @see CompositeTilemap.tile
   */
  addFrame(t2, e3, i2, s2, a8, u2, l2, h2, d2) {
    return this.tile(
      t2,
      e3,
      i2,
      {
        animX: s2,
        animY: a8,
        animCountX: u2,
        animCountY: l2,
        animDivisor: h2,
        alpha: d2
      }
    );
  }
  /**
   * @deprecated @pixi/tilemap 3
   * @see CompositeTilemap.tile
   */
  // eslint-disable-next-line max-params
  addRect(t2, e3, i2, s2, a8, u2, l2, h2, d2, f3, p2, r2) {
    const n2 = t2 / this.texturesPerTilemap >> 0, A2 = t2 % this.texturesPerTilemap;
    return this.children[n2] && this.children[n2].getTileset() ? (this.lastModifiedTilemap = this.children[n2], this.lastModifiedTilemap.addRect(
      A2,
      e3,
      i2,
      s2,
      a8,
      u2,
      l2,
      h2,
      d2,
      f3,
      p2,
      r2
    )) : this.lastModifiedTilemap = null, this;
  }
  /**
   * @deprecated Since @pixi/tilemap 3.
   * @readonly
   * @see CompositeTilemap.texturesPerTilemap
   */
  get texPerChild() {
    return this.texturesPerTilemap;
  }
};
function It(o2) {
  let t2 = "";
  t2 += `
`, t2 += `
`, t2 += "if(vTextureId <= -1.0) {", t2 += `
	color = shadowColor;`, t2 += `
}`;
  for (let e3 = 0; e3 < o2; e3++)
    t2 += `
else `, e3 < o2 - 1 && (t2 += `if(textureId == ${e3}.0)`), t2 += `
{`, t2 += `
	color = texture2D(uSamplers[${e3}], textureCoord * uSamplerSize[${e3}]);`, t2 += `
}`;
  return t2 += `
`, t2 += `
`, t2;
}
function At(o2, t2) {
  const e3 = [];
  for (let s2 = 0; s2 < t2; s2++)
    e3[s2] = s2;
  o2.uniforms.uSamplers = e3;
  const i2 = [];
  for (let s2 = 0; s2 < t2; s2++)
    i2.push(1 / 2048), i2.push(1 / 2048);
  o2.uniforms.uSamplerSize = i2;
}
function Mt(o2, t2) {
  return t2.replace(/%count%/gi, `${o2}`).replace(/%forloop%/gi, It(o2));
}
const yt = `#version 100
precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aFrame;
attribute vec2 aAnim;
attribute float aAnimDivisor;
attribute float aTextureId;
attribute float aAlpha;

uniform mat3 projTransMatrix;
uniform vec2 animationFrame;

varying vec2 vTextureCoord;
varying float vTextureId;
varying vec4 vFrame;
varying float vAlpha;

void main(void)
{
   gl_Position = vec4((projTransMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vec2 animCount = floor((aAnim + 0.5) / 2048.0);
   vec2 animFrameOffset = aAnim - animCount * 2048.0;
   vec2 currentFrame = floor(animationFrame / aAnimDivisor);
   vec2 animOffset = animFrameOffset * floor(mod(currentFrame + 0.5, animCount));

   vTextureCoord = aTextureCoord + animOffset;
   vFrame = aFrame + vec4(animOffset, animOffset);
   vTextureId = aTextureId;
   vAlpha = aAlpha;
}
`, Lt = `#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
varying vec2 vTextureCoord;
varying vec4 vFrame;
varying float vTextureId;
varying float vAlpha;
uniform vec4 shadowColor;
uniform sampler2D uSamplers[%count%];
uniform vec2 uSamplerSize[%count%];

void main(void)
{
   vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);
   float textureId = floor(vTextureId + 0.5);

   vec4 color;
   %forloop%
   gl_FragColor = color * vAlpha;
}
`;
let Q$1 = class Q extends Shader {
  constructor(t2) {
    super(
      new Program(
        yt,
        Mt(t2, Lt)
      ),
      {
        animationFrame: new Float32Array(2),
        uSamplers: [],
        uSamplerSize: [],
        projTransMatrix: new Matrix()
      }
    ), this.maxTextures = 0, this.maxTextures = t2, At(this, this.maxTextures);
  }
};
let K$1 = class K extends Geometry {
  constructor() {
    super(), this.vertSize = 13, this.vertPerQuad = 4, this.stride = this.vertSize * 4, this.lastTimeAccess = 0;
    const t2 = this.buf = new Buffer$1(new Float32Array(2), true, false);
    this.addAttribute("aVertexPosition", t2, 0, false, 0, this.stride, 0).addAttribute("aTextureCoord", t2, 0, false, 0, this.stride, 2 * 4).addAttribute("aFrame", t2, 0, false, 0, this.stride, 4 * 4).addAttribute("aAnim", t2, 0, false, 0, this.stride, 8 * 4).addAttribute("aTextureId", t2, 0, false, 0, this.stride, 10 * 4).addAttribute("aAnimDivisor", t2, 0, false, 0, this.stride, 11 * 4).addAttribute("aAlpha", t2, 0, false, 0, this.stride, 12 * 4);
  }
};
class st extends ObjectRenderer {
  /** @param renderer - The managing renderer */
  constructor(t2) {
    super(t2), this.tileAnim = [0, 0], this.ibLen = 0, this.indexBuffer = null, this.textiles = [], this.shader = new Q$1(m$1.TEXTURES_PER_TILEMAP), this.indexBuffer = new Buffer$1(void 0, true, true), this.checkIndexBuffer(2e3), this.makeTextiles();
  }
  /**
  * Binds the tile textures to the renderer, and updates the tilemap shader's `uSamplerSize` uniform.
  *
  * If {@link settings.TEXTILE_UNITS}
  *
  * @param renderer - The renderer to which the textures are to be bound.
  * @param textures - The tile textures being bound.
  */
  bindTileTextures(t2, e3) {
    const i2 = e3.length, s2 = this.shader, a8 = m$1.TEXTURES_PER_TILEMAP, u2 = s2.uniforms.uSamplerSize;
    if (!(i2 > m$1.TEXTILE_UNITS * a8)) {
      for (let l2 = 0; l2 < e3.length; l2++) {
        const h2 = e3[l2];
        if (!h2 || !h2.valid)
          return;
        t2.texture.bind(e3[l2], l2), u2[l2 * 2] = 1 / e3[l2].realWidth, u2[l2 * 2 + 1] = 1 / e3[l2].realHeight;
      }
      s2.uniforms.uSamplerSize = u2;
    }
  }
  start() {
  }
  /**
  * @internal
  * @ignore
  */
  createVb() {
    const t2 = new K$1();
    return t2.addIndex(this.indexBuffer), t2.lastTimeAccess = Date.now(), t2;
  }
  /** @return The {@link TilemapShader} shader that this rendering pipeline is using. */
  getShader() {
    return this.shader;
  }
  destroy() {
    super.destroy(), this.shader = null;
  }
  // eslint-disable-next-line no-unused-vars
  checkIndexBuffer(t2, e3 = null) {
    const i2 = t2 * 6;
    i2 <= this.ibLen || (this.ibLen = i2, this.indexBuffer.update(createIndicesForQuads(
      t2,
      m$1.use32bitIndex ? new Uint32Array(t2 * 6) : void 0
    )));
  }
  /** Makes textile resources and initializes {@link TileRenderer.textiles}. */
  makeTextiles() {
  }
}
extensions$1.add({
  name: "tilemap",
  type: ExtensionType.RendererPlugin,
  ref: st
});
m$1.use32bitIndex = true;
class TileLayer extends CommonLayer {
  static findTileSet(gid, tileSets) {
    let tileset;
    for (let i2 = tileSets.length - 1; i2 >= 0; i2--) {
      tileset = tileSets[i2];
      if (tileset.firstgid && tileset.firstgid <= gid) {
        break;
      }
    }
    return tileset;
  }
  constructor(layer, tileSets, map2) {
    super(layer, map2);
    this.tileSets = tileSets;
    this._tiles = {};
  }
  /** @internal */
  createTile(x2, y2, options = {}) {
    const {
      real,
      filter: filter2
    } = options;
    const {
      width,
      tilewidth,
      tileheight
    } = this.map.getData();
    if (real) {
      x2 = Math.floor(x2 / tilewidth);
      y2 = Math.floor(y2 / tileheight);
    }
    const i2 = x2 + y2 * width;
    const tiledTile = this.layer.getTileByIndex(i2);
    if (!tiledTile || tiledTile && tiledTile.gid == 0)
      return;
    const tileset = TileLayer.findTileSet(tiledTile.gid, this.tileSets);
    if (!tileset)
      return;
    const tile = new Tile2(tiledTile, tileset);
    tile.x = x2 * tilewidth;
    tile.y = y2 * tileheight + (tileheight - tile.texture.height);
    tile._x = x2;
    tile._y = y2;
    if (tileset.tileoffset) {
      tile.x += tileset.tileoffset.x ?? 0;
      tile.y += tileset.tileoffset.y ?? 0;
    }
    if (filter2) {
      const ret = filter2(tile);
      if (!ret)
        return;
    }
    return tile;
  }
  /** @internal */
  changeTile(x2, y2) {
    const {
      tilewidth,
      tileheight
    } = this.map.getData();
    x2 = Math.floor(x2 / tilewidth);
    y2 = Math.floor(y2 / tileheight);
    const oldTile = this._tiles[x2 + ";" + y2];
    const newTile = this.createTile(x2, y2);
    if (!oldTile && newTile) {
      this.addFrame(newTile, x2, y2);
    } else {
      if (newTile) {
        const bufComposite = new Z$1();
        const frame = bufComposite.tile(newTile.texture, newTile.x, newTile.y);
        newTile.setAnimation(frame);
        this._tiles[x2 + ";" + y2] = newTile;
        const pointsBufComposite = bufComposite.children[0].pointsBuf;
        [0, 1, 4, 6, 7, 8].forEach((i2) => {
          if (this.pointsBuf)
            this.pointsBuf[oldTile.pointsBufIndex + i2] = pointsBufComposite[i2];
        });
        this.tilemap.children[0].modificationMarker = 0;
        this.addFrame(newTile, x2, y2);
        this["modificationMarker"] = 0;
      } else {
        delete this._tiles[x2 + ";" + y2];
        if (this.pointsBuf)
          this.pointsBuf.splice(oldTile.pointsBufIndex, L$1);
      }
    }
  }
  /** @internal */
  get pointsBuf() {
    const child = this.tilemap.children[0];
    if (!child)
      return null;
    return child["pointsBuf"];
  }
  addFrame(tile, x2, y2) {
    const frame = this.tilemap.tile(tile.texture, tile.x, tile.y, {
      rotate: tile.texture.rotate
    });
    const pb = this.pointsBuf;
    if (!pb)
      return null;
    tile.pointsBufIndex = pb.length - L$1;
    tile.setAnimation(frame);
    this._tiles[x2 + ";" + y2] = tile;
  }
  /** @internal */
  create() {
    this.tilemap = new Z$1();
    const {
      width,
      height
    } = this.map.getData();
    for (let y2 = 0; y2 < height; y2++) {
      for (let x2 = 0; x2 < width; x2++) {
        const tile = this.createTile(x2, y2);
        if (tile) {
          this.addFrame(tile, x2, y2);
        }
      }
    }
    this.addChild(this.tilemap);
  }
}
function _initResource(memory, _resources, prop, engine) {
  for (let resource of _resources) {
    const pluralProp = prop + "s";
    if (resource[pluralProp]) {
      for (let key in resource[pluralProp]) {
        const instance = new resource();
        instance[prop] = engine.getResourceUrl(resource[pluralProp][key]);
        memory.set(key, instance);
      }
    } else {
      const instance = new resource(engine);
      instance[prop] = engine.getResourceUrl(instance[prop]);
      memory.set(resource.id, instance);
    }
  }
}
const spritesheets = /* @__PURE__ */ new Map();
function _initSpritesheet(_spritesheets, engine) {
  return _initResource(spritesheets, _spritesheets, "image", engine);
}
function log(message) {
  return new Error(`[RPGJS] - ${message}`);
}
class TileSet extends Tileset {
  constructor(tileSet) {
    super(tileSet);
    this.textures = [];
  }
  /** @internal */
  load() {
    const spritesheet = spritesheets.get(this.name);
    if (!spritesheet) {
      throw log(`Impossible to find ${this.name} tileset`);
    }
    this.baseTexture = spritesheet.resource;
    for (let y2 = this.margin; y2 < this.image.height; y2 += this.tileheight + this.spacing) {
      for (let x2 = this.margin; x2 < this.image.width; x2 += this.tilewidth + this.spacing) {
        this.textures.push(new Texture(this.baseTexture, new Rectangle(+x2, +y2, +this.tilewidth, +this.tileheight)));
      }
    }
  }
}
const {
  intersection
} = Utils$1;
class TileMap extends Container {
  constructor(context2, data) {
    super();
    this.context = context2;
    this.data = data;
    this.background = new Graphics();
    this.tilewidth = 0;
    this.tileheight = 0;
    this.frameRateAnimation = 10;
    this.tilesets = [];
    this.layers = {};
    this.tilesLayer = new Container();
    this.frameTile = 0;
    this.renderer = this.context.inject(RpgRenderer);
    this.x = 0;
    this.y = 0;
    this.create(data);
  }
  /** @internal */
  drawAnimateTile(frame) {
    if (frame % this.frameRateAnimation == 0) {
      this.renderer["renderer"].plugins.tilemap.tileAnim[0] = this.frameTile;
      this.frameTile++;
    }
  }
  getData() {
    return this.data;
  }
  setBackgroundColor(color) {
    color = color.replace("#", "");
    this.background.beginFill(parseInt(color, 16));
    this.background.drawRect(0, 0, (this.width || 0) * (this.tilewidth || 0), (this.height || 0) * (this.tileheight || 0));
    this.background.endFill();
  }
  create(data) {
    this.data = data;
    Object.assign(this, data);
    if (this.data.backgroundcolor)
      this.setBackgroundColor(this.data.backgroundcolor);
    this.addChild(this.background);
    this.tilesets = this.data.tilesets.map((tileSet) => {
      return new TileSet(tileSet);
    });
  }
  /** @internal */
  createOverlayTiles(x2, y2, instance) {
    const tilesLayer = [];
    this.data.layers.forEach((layerData) => {
      switch (layerData.type) {
        case TiledLayerType.Tile: {
          const tileLayer = new TileLayer(layerData, this.tilesets, this);
          const tile = tileLayer.createTile(x2, y2, {
            real: true,
            filter: (tile2) => {
              const {
                data,
                y: yObject,
                z: zObject
              } = instance;
              const {
                hHitbox,
                height
              } = data;
              const zLayer = tileLayer.z;
              const tileHasZ = tile2.properties.z !== void 0;
              let {
                z: z2
              } = tile2.properties;
              if (zLayer !== void 0) {
                z2 = zLayer + (z2 !== void 0 ? z2 : 0);
              }
              if (z2 == void 0)
                return false;
              const realZ = z2 * tile2.height;
              if (zObject + height < realZ) {
                return true;
              }
              if (zObject > realZ + tile2.height) {
                return false;
              }
              if (!tileHasZ)
                return false;
              if (yObject + hHitbox > tile2.y + tile2.height) {
                const zIntersection = intersection([
                  zObject,
                  zObject + tile2.height
                  /** Old code: height */
                ], [realZ, realZ + tile2.height]);
                if (!zIntersection) {
                  return true;
                }
                return false;
              }
              return true;
            }
          });
          if (tile) {
            tileLayer.addChild(tile);
            const size2 = tile.animations.length;
            if (size2 > 0) {
              const ms = 1e3 / 60;
              tile.animationSpeed = ms / (ms * this.frameRateAnimation);
              let frameIndex = this.frameTile % size2;
              tile.gotoAndPlay(frameIndex);
            }
            tilesLayer.push(tileLayer);
          }
          break;
        }
      }
    });
    return tilesLayer;
  }
  /** @internal */
  changeTile(x2, y2, layerName) {
    const layer = this.layers[layerName];
    if (!layer)
      throw log(`${layerName} not exists`);
    if (layer instanceof TileLayer) {
      layer.changeTile(x2, y2);
    }
  }
  /** @internal */
  load(options) {
    this.tilesLayer.removeChildren();
    this.tilesets.forEach((tileset) => tileset.load());
    this.data.layers.forEach((layerData) => {
      switch (layerData.type) {
        case TiledLayerType.Tile: {
          const tileLayer = new TileLayer(layerData, this.tilesets, this);
          if (options == null ? void 0 : options.drawTiles)
            tileLayer.create();
          this.layers[layerData.name] = tileLayer;
          this.tilesLayer.addChild(tileLayer);
          break;
        }
        case TiledLayerType.Image: {
          const imageLayer = new ImageLayer(layerData, this);
          this.layers[layerData.name] = imageLayer;
          this.tilesLayer.addChild(imageLayer);
          break;
        }
      }
    });
    this.addChild(this.tilesLayer);
  }
}
var S = Object.defineProperty;
var M = (c3, r2, t2) => r2 in c3 ? S(c3, r2, { enumerable: true, configurable: true, writable: true, value: t2 }) : c3[r2] = t2;
var o = (c3, r2, t2) => (M(c3, typeof r2 != "symbol" ? r2 + "" : r2, t2), t2);
let f$1 = class f {
  constructor(r2) {
    o(this, "parent");
    o(this, "paused");
    this.parent = r2, this.paused = false;
  }
  destroy() {
  }
  down(r2) {
    return false;
  }
  move(r2) {
    return false;
  }
  up(r2) {
    return false;
  }
  wheel(r2) {
    return false;
  }
  update(r2) {
  }
  resize() {
  }
  reset() {
  }
  pause() {
    this.paused = true;
  }
  resume() {
    this.paused = false;
  }
};
var C = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global$1 < "u" ? global$1 : typeof self < "u" ? self : {}, H = { exports: {} };
(function(c3, r2) {
  (function() {
    var t2, i2;
    i2 = function(e3) {
      return c3.exports = e3;
    }, t2 = {
      linear: function(e3, n2, s2, h2) {
        return s2 * e3 / h2 + n2;
      },
      easeInQuad: function(e3, n2, s2, h2) {
        return s2 * (e3 /= h2) * e3 + n2;
      },
      easeOutQuad: function(e3, n2, s2, h2) {
        return -s2 * (e3 /= h2) * (e3 - 2) + n2;
      },
      easeInOutQuad: function(e3, n2, s2, h2) {
        return (e3 /= h2 / 2) < 1 ? s2 / 2 * e3 * e3 + n2 : -s2 / 2 * (--e3 * (e3 - 2) - 1) + n2;
      },
      easeInCubic: function(e3, n2, s2, h2) {
        return s2 * (e3 /= h2) * e3 * e3 + n2;
      },
      easeOutCubic: function(e3, n2, s2, h2) {
        return s2 * ((e3 = e3 / h2 - 1) * e3 * e3 + 1) + n2;
      },
      easeInOutCubic: function(e3, n2, s2, h2) {
        return (e3 /= h2 / 2) < 1 ? s2 / 2 * e3 * e3 * e3 + n2 : s2 / 2 * ((e3 -= 2) * e3 * e3 + 2) + n2;
      },
      easeInQuart: function(e3, n2, s2, h2) {
        return s2 * (e3 /= h2) * e3 * e3 * e3 + n2;
      },
      easeOutQuart: function(e3, n2, s2, h2) {
        return -s2 * ((e3 = e3 / h2 - 1) * e3 * e3 * e3 - 1) + n2;
      },
      easeInOutQuart: function(e3, n2, s2, h2) {
        return (e3 /= h2 / 2) < 1 ? s2 / 2 * e3 * e3 * e3 * e3 + n2 : -s2 / 2 * ((e3 -= 2) * e3 * e3 * e3 - 2) + n2;
      },
      easeInQuint: function(e3, n2, s2, h2) {
        return s2 * (e3 /= h2) * e3 * e3 * e3 * e3 + n2;
      },
      easeOutQuint: function(e3, n2, s2, h2) {
        return s2 * ((e3 = e3 / h2 - 1) * e3 * e3 * e3 * e3 + 1) + n2;
      },
      easeInOutQuint: function(e3, n2, s2, h2) {
        return (e3 /= h2 / 2) < 1 ? s2 / 2 * e3 * e3 * e3 * e3 * e3 + n2 : s2 / 2 * ((e3 -= 2) * e3 * e3 * e3 * e3 + 2) + n2;
      },
      easeInSine: function(e3, n2, s2, h2) {
        return -s2 * Math.cos(e3 / h2 * (Math.PI / 2)) + s2 + n2;
      },
      easeOutSine: function(e3, n2, s2, h2) {
        return s2 * Math.sin(e3 / h2 * (Math.PI / 2)) + n2;
      },
      easeInOutSine: function(e3, n2, s2, h2) {
        return -s2 / 2 * (Math.cos(Math.PI * e3 / h2) - 1) + n2;
      },
      easeInExpo: function(e3, n2, s2, h2) {
        return e3 === 0 ? n2 : s2 * Math.pow(2, 10 * (e3 / h2 - 1)) + n2;
      },
      easeOutExpo: function(e3, n2, s2, h2) {
        return e3 === h2 ? n2 + s2 : s2 * (-Math.pow(2, -10 * e3 / h2) + 1) + n2;
      },
      easeInOutExpo: function(e3, n2, s2, h2) {
        return (e3 /= h2 / 2) < 1 ? s2 / 2 * Math.pow(2, 10 * (e3 - 1)) + n2 : s2 / 2 * (-Math.pow(2, -10 * --e3) + 2) + n2;
      },
      easeInCirc: function(e3, n2, s2, h2) {
        return -s2 * (Math.sqrt(1 - (e3 /= h2) * e3) - 1) + n2;
      },
      easeOutCirc: function(e3, n2, s2, h2) {
        return s2 * Math.sqrt(1 - (e3 = e3 / h2 - 1) * e3) + n2;
      },
      easeInOutCirc: function(e3, n2, s2, h2) {
        return (e3 /= h2 / 2) < 1 ? -s2 / 2 * (Math.sqrt(1 - e3 * e3) - 1) + n2 : s2 / 2 * (Math.sqrt(1 - (e3 -= 2) * e3) + 1) + n2;
      },
      easeInElastic: function(e3, n2, s2, h2) {
        var a8, p2, l2;
        return l2 = 1.70158, p2 = 0, a8 = s2, e3 === 0 || (e3 /= h2), p2 || (p2 = h2 * 0.3), a8 < Math.abs(s2) ? (a8 = s2, l2 = p2 / 4) : l2 = p2 / (2 * Math.PI) * Math.asin(s2 / a8), -(a8 * Math.pow(2, 10 * (e3 -= 1)) * Math.sin((e3 * h2 - l2) * (2 * Math.PI) / p2)) + n2;
      },
      easeOutElastic: function(e3, n2, s2, h2) {
        var a8, p2, l2;
        return l2 = 1.70158, p2 = 0, a8 = s2, e3 === 0 || (e3 /= h2), p2 || (p2 = h2 * 0.3), a8 < Math.abs(s2) ? (a8 = s2, l2 = p2 / 4) : l2 = p2 / (2 * Math.PI) * Math.asin(s2 / a8), a8 * Math.pow(2, -10 * e3) * Math.sin((e3 * h2 - l2) * (2 * Math.PI) / p2) + s2 + n2;
      },
      easeInOutElastic: function(e3, n2, s2, h2) {
        var a8, p2, l2;
        return l2 = 1.70158, p2 = 0, a8 = s2, e3 === 0 || (e3 /= h2 / 2), p2 || (p2 = h2 * (0.3 * 1.5)), a8 < Math.abs(s2) ? (a8 = s2, l2 = p2 / 4) : l2 = p2 / (2 * Math.PI) * Math.asin(s2 / a8), e3 < 1 ? -0.5 * (a8 * Math.pow(2, 10 * (e3 -= 1)) * Math.sin((e3 * h2 - l2) * (2 * Math.PI) / p2)) + n2 : a8 * Math.pow(2, -10 * (e3 -= 1)) * Math.sin((e3 * h2 - l2) * (2 * Math.PI) / p2) * 0.5 + s2 + n2;
      },
      easeInBack: function(e3, n2, s2, h2, a8) {
        return a8 === void 0 && (a8 = 1.70158), s2 * (e3 /= h2) * e3 * ((a8 + 1) * e3 - a8) + n2;
      },
      easeOutBack: function(e3, n2, s2, h2, a8) {
        return a8 === void 0 && (a8 = 1.70158), s2 * ((e3 = e3 / h2 - 1) * e3 * ((a8 + 1) * e3 + a8) + 1) + n2;
      },
      easeInOutBack: function(e3, n2, s2, h2, a8) {
        return a8 === void 0 && (a8 = 1.70158), (e3 /= h2 / 2) < 1 ? s2 / 2 * (e3 * e3 * (((a8 *= 1.525) + 1) * e3 - a8)) + n2 : s2 / 2 * ((e3 -= 2) * e3 * (((a8 *= 1.525) + 1) * e3 + a8) + 2) + n2;
      },
      easeInBounce: function(e3, n2, s2, h2) {
        var a8;
        return a8 = t2.easeOutBounce(h2 - e3, 0, s2, h2), s2 - a8 + n2;
      },
      easeOutBounce: function(e3, n2, s2, h2) {
        return (e3 /= h2) < 1 / 2.75 ? s2 * (7.5625 * e3 * e3) + n2 : e3 < 2 / 2.75 ? s2 * (7.5625 * (e3 -= 1.5 / 2.75) * e3 + 0.75) + n2 : e3 < 2.5 / 2.75 ? s2 * (7.5625 * (e3 -= 2.25 / 2.75) * e3 + 0.9375) + n2 : s2 * (7.5625 * (e3 -= 2.625 / 2.75) * e3 + 0.984375) + n2;
      },
      easeInOutBounce: function(e3, n2, s2, h2) {
        var a8;
        return e3 < h2 / 2 ? (a8 = t2.easeInBounce(e3 * 2, 0, s2, h2), a8 * 0.5 + n2) : (a8 = t2.easeOutBounce(e3 * 2 - h2, 0, s2, h2), a8 * 0.5 + s2 * 0.5 + n2);
      }
    }, i2(t2);
  }).call(C);
})(H);
const b$1 = H.exports;
function W(c3, r2) {
  if (c3) {
    if (typeof c3 == "function")
      return c3;
    if (typeof c3 == "string")
      return b$1[c3];
  } else
    return b$1[r2];
}
const I = {
  removeOnInterrupt: false,
  ease: "linear",
  time: 1e3
};
let k$1 = class k2 extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "startX");
    o(this, "startY");
    o(this, "deltaX");
    o(this, "deltaY");
    o(this, "keepCenter");
    o(this, "startWidth", null);
    o(this, "startHeight", null);
    o(this, "deltaWidth", null);
    o(this, "deltaHeight", null);
    o(this, "width", null);
    o(this, "height", null);
    o(this, "time", 0);
    this.options = Object.assign({}, I, i2), this.options.ease = W(this.options.ease), this.setupPosition(), this.setupZoom(), this.time = 0;
  }
  setupPosition() {
    typeof this.options.position < "u" ? (this.startX = this.parent.center.x, this.startY = this.parent.center.y, this.deltaX = this.options.position.x - this.parent.center.x, this.deltaY = this.options.position.y - this.parent.center.y, this.keepCenter = false) : this.keepCenter = true;
  }
  setupZoom() {
    this.width = null, this.height = null, typeof this.options.scale < "u" ? this.width = this.parent.screenWidth / this.options.scale : typeof this.options.scaleX < "u" || typeof this.options.scaleY < "u" ? (typeof this.options.scaleX < "u" && (this.width = this.parent.screenWidth / this.options.scaleX), typeof this.options.scaleY < "u" && (this.height = this.parent.screenHeight / this.options.scaleY)) : (typeof this.options.width < "u" && (this.width = this.options.width), typeof this.options.height < "u" && (this.height = this.options.height)), this.width !== null && (this.startWidth = this.parent.screenWidthInWorldPixels, this.deltaWidth = this.width - this.startWidth), this.height !== null && (this.startHeight = this.parent.screenHeightInWorldPixels, this.deltaHeight = this.height - this.startHeight);
  }
  down() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("animate"), false;
  }
  complete() {
    this.parent.plugins.remove("animate"), this.width !== null && this.parent.fitWidth(this.width, this.keepCenter, this.height === null), this.height !== null && this.parent.fitHeight(this.height, this.keepCenter, this.width === null), !this.keepCenter && this.options.position && this.parent.moveCenter(this.options.position), this.parent.emit("animate-end", this.parent), this.options.callbackOnComplete && this.options.callbackOnComplete(this.parent);
  }
  update(t2) {
    if (this.paused)
      return;
    this.time += t2;
    const i2 = new Point(this.parent.scale.x, this.parent.scale.y);
    if (this.time >= this.options.time) {
      const e3 = this.parent.width, n2 = this.parent.height;
      this.complete(), (e3 !== this.parent.width || n2 !== this.parent.height) && this.parent.emit("zoomed", { viewport: this.parent, original: i2, type: "animate" });
    } else {
      const e3 = this.options.ease(this.time, 0, 1, this.options.time);
      if (this.width !== null) {
        const n2 = this.startWidth, s2 = this.deltaWidth;
        this.parent.fitWidth(
          n2 + s2 * e3,
          this.keepCenter,
          this.height === null
        );
      }
      if (this.height !== null) {
        const n2 = this.startHeight, s2 = this.deltaHeight;
        this.parent.fitHeight(
          n2 + s2 * e3,
          this.keepCenter,
          this.width === null
        );
      }
      if (this.width === null ? this.parent.scale.x = this.parent.scale.y : this.height === null && (this.parent.scale.y = this.parent.scale.x), !this.keepCenter) {
        const n2 = this.startX, s2 = this.startY, h2 = this.deltaX, a8 = this.deltaY, p2 = new Point(this.parent.x, this.parent.y);
        this.parent.moveCenter(n2 + h2 * e3, s2 + a8 * e3), this.parent.emit("moved", { viewport: this.parent, original: p2, type: "animate" });
      }
      (this.width || this.height) && this.parent.emit("zoomed", { viewport: this.parent, original: i2, type: "animate" });
    }
  }
};
const Y = {
  sides: "all",
  friction: 0.5,
  time: 150,
  ease: "easeInOutSine",
  underflow: "center",
  bounceBox: null
};
class X extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "left");
    o(this, "top");
    o(this, "right");
    o(this, "bottom");
    o(this, "underflowX");
    o(this, "underflowY");
    o(this, "ease");
    o(this, "toX");
    o(this, "toY");
    this.options = Object.assign({}, Y, i2), this.ease = W(this.options.ease, "easeInOutSine"), this.options.sides ? this.options.sides === "all" ? this.top = this.bottom = this.left = this.right = true : this.options.sides === "horizontal" ? (this.right = this.left = true, this.top = this.bottom = false) : this.options.sides === "vertical" ? (this.left = this.right = false, this.top = this.bottom = true) : (this.top = this.options.sides.indexOf("top") !== -1, this.bottom = this.options.sides.indexOf("bottom") !== -1, this.left = this.options.sides.indexOf("left") !== -1, this.right = this.options.sides.indexOf("right") !== -1) : this.left = this.top = this.right = this.bottom = false;
    const e3 = this.options.underflow.toLowerCase();
    e3 === "center" ? (this.underflowX = 0, this.underflowY = 0) : (this.underflowX = e3.indexOf("left") !== -1 ? -1 : e3.indexOf("right") !== -1 ? 1 : 0, this.underflowY = e3.indexOf("top") !== -1 ? -1 : e3.indexOf("bottom") !== -1 ? 1 : 0), this.reset();
  }
  isActive() {
    return this.toX !== null || this.toY !== null;
  }
  down() {
    return this.toX = this.toY = null, false;
  }
  up() {
    return this.bounce(), false;
  }
  update(t2) {
    if (!this.paused) {
      if (this.bounce(), this.toX) {
        const i2 = this.toX;
        i2.time += t2, this.parent.emit("moved", { viewport: this.parent, type: "bounce-x" }), i2.time >= this.options.time ? (this.parent.x = i2.end, this.toX = null, this.parent.emit("bounce-x-end", this.parent)) : this.parent.x = this.ease(i2.time, i2.start, i2.delta, this.options.time);
      }
      if (this.toY) {
        const i2 = this.toY;
        i2.time += t2, this.parent.emit("moved", { viewport: this.parent, type: "bounce-y" }), i2.time >= this.options.time ? (this.parent.y = i2.end, this.toY = null, this.parent.emit("bounce-y-end", this.parent)) : this.parent.y = this.ease(i2.time, i2.start, i2.delta, this.options.time);
      }
    }
  }
  calcUnderflowX() {
    let t2;
    switch (this.underflowX) {
      case -1:
        t2 = 0;
        break;
      case 1:
        t2 = this.parent.screenWidth - this.parent.screenWorldWidth;
        break;
      default:
        t2 = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
    }
    return t2;
  }
  calcUnderflowY() {
    let t2;
    switch (this.underflowY) {
      case -1:
        t2 = 0;
        break;
      case 1:
        t2 = this.parent.screenHeight - this.parent.screenWorldHeight;
        break;
      default:
        t2 = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
    }
    return t2;
  }
  oob() {
    const t2 = this.options.bounceBox;
    if (t2) {
      const i2 = typeof t2.x > "u" ? 0 : t2.x, e3 = typeof t2.y > "u" ? 0 : t2.y, n2 = typeof t2.width > "u" ? this.parent.worldWidth : t2.width, s2 = typeof t2.height > "u" ? this.parent.worldHeight : t2.height;
      return {
        left: this.parent.left < i2,
        right: this.parent.right > n2,
        top: this.parent.top < e3,
        bottom: this.parent.bottom > s2,
        topLeft: new Point(
          i2 * this.parent.scale.x,
          e3 * this.parent.scale.y
        ),
        bottomRight: new Point(
          n2 * this.parent.scale.x - this.parent.screenWidth,
          s2 * this.parent.scale.y - this.parent.screenHeight
        )
      };
    }
    return {
      left: this.parent.left < 0,
      right: this.parent.right > this.parent.worldWidth,
      top: this.parent.top < 0,
      bottom: this.parent.bottom > this.parent.worldHeight,
      topLeft: new Point(0, 0),
      bottomRight: new Point(
        this.parent.worldWidth * this.parent.scale.x - this.parent.screenWidth,
        this.parent.worldHeight * this.parent.scale.y - this.parent.screenHeight
      )
    };
  }
  bounce() {
    var s2, h2;
    if (this.paused)
      return;
    let t2, i2 = this.parent.plugins.get("decelerate", true);
    i2 && (i2.x || i2.y) && (i2.x && i2.percentChangeX === ((s2 = i2.options) == null ? void 0 : s2.friction) || i2.y && i2.percentChangeY === ((h2 = i2.options) == null ? void 0 : h2.friction)) && (t2 = this.oob(), (t2.left && this.left || t2.right && this.right) && (i2.percentChangeX = this.options.friction), (t2.top && this.top || t2.bottom && this.bottom) && (i2.percentChangeY = this.options.friction));
    const e3 = this.parent.plugins.get("drag", true) || {}, n2 = this.parent.plugins.get("pinch", true) || {};
    if (i2 = i2 || {}, !(e3 != null && e3.active) && !(n2 != null && n2.active) && (!this.toX || !this.toY) && (!i2.x || !i2.y)) {
      t2 = t2 || this.oob();
      const a8 = t2.topLeft, p2 = t2.bottomRight;
      if (!this.toX && !i2.x) {
        let l2 = null;
        t2.left && this.left ? l2 = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -a8.x : t2.right && this.right && (l2 = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -p2.x), l2 !== null && this.parent.x !== l2 && (this.toX = { time: 0, start: this.parent.x, delta: l2 - this.parent.x, end: l2 }, this.parent.emit("bounce-x-start", this.parent));
      }
      if (!this.toY && !i2.y) {
        let l2 = null;
        t2.top && this.top ? l2 = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -a8.y : t2.bottom && this.bottom && (l2 = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -p2.y), l2 !== null && this.parent.y !== l2 && (this.toY = { time: 0, start: this.parent.y, delta: l2 - this.parent.y, end: l2 }, this.parent.emit("bounce-y-start", this.parent));
      }
    }
  }
  reset() {
    this.toX = this.toY = null, this.bounce();
  }
}
const z = {
  left: false,
  right: false,
  top: false,
  bottom: false,
  direction: null,
  underflow: "center"
};
class A extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "last");
    o(this, "noUnderflow");
    o(this, "underflowX");
    o(this, "underflowY");
    this.options = Object.assign({}, z, i2), this.options.direction && (this.options.left = this.options.direction === "x" || this.options.direction === "all" ? true : null, this.options.right = this.options.direction === "x" || this.options.direction === "all" ? true : null, this.options.top = this.options.direction === "y" || this.options.direction === "all" ? true : null, this.options.bottom = this.options.direction === "y" || this.options.direction === "all" ? true : null), this.parseUnderflow(), this.last = { x: null, y: null, scaleX: null, scaleY: null }, this.update();
  }
  parseUnderflow() {
    const t2 = this.options.underflow.toLowerCase();
    t2 === "none" ? this.noUnderflow = true : t2 === "center" ? (this.underflowX = this.underflowY = 0, this.noUnderflow = false) : (this.underflowX = t2.indexOf("left") !== -1 ? -1 : t2.indexOf("right") !== -1 ? 1 : 0, this.underflowY = t2.indexOf("top") !== -1 ? -1 : t2.indexOf("bottom") !== -1 ? 1 : 0, this.noUnderflow = false);
  }
  move() {
    return this.update(), false;
  }
  update() {
    if (this.paused || this.parent.x === this.last.x && this.parent.y === this.last.y && this.parent.scale.x === this.last.scaleX && this.parent.scale.y === this.last.scaleY)
      return;
    const t2 = new Point(this.parent.x, this.parent.y), i2 = this.parent.plugins.decelerate || {};
    if (this.options.left !== null || this.options.right !== null) {
      let e3 = false;
      if (!this.noUnderflow && this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x !== 0 && (this.parent.x = 0, e3 = true);
            break;
          case 1:
            this.parent.x !== this.parent.screenWidth - this.parent.screenWorldWidth && (this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth, e3 = true);
            break;
          default:
            this.parent.x !== (this.parent.screenWidth - this.parent.screenWorldWidth) / 2 && (this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2, e3 = true);
        }
      else
        this.options.left !== null && this.parent.left < (this.options.left === true ? 0 : this.options.left) && (this.parent.x = -(this.options.left === true ? 0 : this.options.left) * this.parent.scale.x, i2.x = 0, e3 = true), this.options.right !== null && this.parent.right > (this.options.right === true ? this.parent.worldWidth : this.options.right) && (this.parent.x = -(this.options.right === true ? this.parent.worldWidth : this.options.right) * this.parent.scale.x + this.parent.screenWidth, i2.x = 0, e3 = true);
      e3 && this.parent.emit("moved", { viewport: this.parent, original: t2, type: "clamp-x" });
    }
    if (this.options.top !== null || this.options.bottom !== null) {
      let e3 = false;
      if (!this.noUnderflow && this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y !== 0 && (this.parent.y = 0, e3 = true);
            break;
          case 1:
            this.parent.y !== this.parent.screenHeight - this.parent.screenWorldHeight && (this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight, e3 = true);
            break;
          default:
            this.parent.y !== (this.parent.screenHeight - this.parent.screenWorldHeight) / 2 && (this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2, e3 = true);
        }
      else
        this.options.top !== null && this.parent.top < (this.options.top === true ? 0 : this.options.top) && (this.parent.y = -(this.options.top === true ? 0 : this.options.top) * this.parent.scale.y, i2.y = 0, e3 = true), this.options.bottom !== null && this.parent.bottom > (this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) && (this.parent.y = -(this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) * this.parent.scale.y + this.parent.screenHeight, i2.y = 0, e3 = true);
      e3 && this.parent.emit("moved", { viewport: this.parent, original: t2, type: "clamp-y" });
    }
    this.last.x = this.parent.x, this.last.y = this.parent.y, this.last.scaleX = this.parent.scale.x, this.last.scaleY = this.parent.scale.y;
  }
  reset() {
    this.update();
  }
}
const _ = {
  minWidth: null,
  minHeight: null,
  maxWidth: null,
  maxHeight: null,
  minScale: null,
  maxScale: null
};
class T extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    this.options = Object.assign({}, _, i2), this.clamp();
  }
  resize() {
    this.clamp();
  }
  clamp() {
    if (!this.paused) {
      if (this.options.minWidth || this.options.minHeight || this.options.maxWidth || this.options.maxHeight) {
        let t2 = this.parent.worldScreenWidth, i2 = this.parent.worldScreenHeight;
        if (this.options.minWidth !== null && t2 < this.options.minWidth) {
          const e3 = this.parent.scale.x;
          this.parent.fitWidth(this.options.minWidth, false, false, true), this.parent.scale.y *= this.parent.scale.x / e3, t2 = this.parent.worldScreenWidth, i2 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxWidth !== null && t2 > this.options.maxWidth) {
          const e3 = this.parent.scale.x;
          this.parent.fitWidth(this.options.maxWidth, false, false, true), this.parent.scale.y *= this.parent.scale.x / e3, t2 = this.parent.worldScreenWidth, i2 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.minHeight !== null && i2 < this.options.minHeight) {
          const e3 = this.parent.scale.y;
          this.parent.fitHeight(this.options.minHeight, false, false, true), this.parent.scale.x *= this.parent.scale.y / e3, t2 = this.parent.worldScreenWidth, i2 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxHeight !== null && i2 > this.options.maxHeight) {
          const e3 = this.parent.scale.y;
          this.parent.fitHeight(this.options.maxHeight, false, false, true), this.parent.scale.x *= this.parent.scale.y / e3, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
      } else if (this.options.minScale || this.options.maxScale) {
        const t2 = { x: null, y: null }, i2 = { x: null, y: null };
        if (typeof this.options.minScale == "number")
          t2.x = this.options.minScale, t2.y = this.options.minScale;
        else if (this.options.minScale !== null) {
          const s2 = this.options.minScale;
          t2.x = typeof s2.x > "u" ? null : s2.x, t2.y = typeof s2.y > "u" ? null : s2.y;
        }
        if (typeof this.options.maxScale == "number")
          i2.x = this.options.maxScale, i2.y = this.options.maxScale;
        else if (this.options.maxScale !== null) {
          const s2 = this.options.maxScale;
          i2.x = typeof s2.x > "u" ? null : s2.x, i2.y = typeof s2.y > "u" ? null : s2.y;
        }
        let e3 = this.parent.scale.x, n2 = this.parent.scale.y;
        t2.x !== null && e3 < t2.x && (e3 = t2.x), i2.x !== null && e3 > i2.x && (e3 = i2.x), t2.y !== null && n2 < t2.y && (n2 = t2.y), i2.y !== null && n2 > i2.y && (n2 = i2.y), (e3 !== this.parent.scale.x || n2 !== this.parent.scale.y) && (this.parent.scale.set(e3, n2), this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" }));
      }
    }
  }
  reset() {
    this.clamp();
  }
}
const D = {
  friction: 0.98,
  bounce: 0.8,
  minSpeed: 0.01
}, g = 16;
class E extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "x");
    o(this, "y");
    o(this, "percentChangeX");
    o(this, "percentChangeY");
    o(this, "saved");
    o(this, "timeSinceRelease");
    this.options = Object.assign({}, D, i2), this.saved = [], this.timeSinceRelease = 0, this.reset(), this.parent.on("moved", (e3) => this.handleMoved(e3));
  }
  down() {
    return this.saved = [], this.x = this.y = null, false;
  }
  isActive() {
    return !!(this.x || this.y);
  }
  move() {
    if (this.paused)
      return false;
    const t2 = this.parent.input.count();
    return (t2 === 1 || t2 > 1 && !this.parent.plugins.get("pinch", true)) && (this.saved.push({ x: this.parent.x, y: this.parent.y, time: performance.now() }), this.saved.length > 60 && this.saved.splice(0, 30)), false;
  }
  handleMoved(t2) {
    if (this.saved.length) {
      const i2 = this.saved[this.saved.length - 1];
      t2.type === "clamp-x" && t2.original ? i2.x === t2.original.x && (i2.x = this.parent.x) : t2.type === "clamp-y" && t2.original && i2.y === t2.original.y && (i2.y = this.parent.y);
    }
  }
  up() {
    if (this.parent.input.count() === 0 && this.saved.length) {
      const t2 = performance.now();
      for (const i2 of this.saved)
        if (i2.time >= t2 - 100) {
          const e3 = t2 - i2.time;
          this.x = (this.parent.x - i2.x) / e3, this.y = (this.parent.y - i2.y) / e3, this.percentChangeX = this.percentChangeY = this.options.friction, this.timeSinceRelease = 0;
          break;
        }
    }
    return false;
  }
  activate(t2) {
    t2 = t2 || {}, typeof t2.x < "u" && (this.x = t2.x, this.percentChangeX = this.options.friction), typeof t2.y < "u" && (this.y = t2.y, this.percentChangeY = this.options.friction);
  }
  update(t2) {
    if (this.paused)
      return;
    const i2 = this.x || this.y, e3 = this.timeSinceRelease, n2 = this.timeSinceRelease + t2;
    if (this.x) {
      const s2 = this.percentChangeX, h2 = Math.log(s2);
      this.parent.x += this.x * g / h2 * (Math.pow(s2, n2 / g) - Math.pow(s2, e3 / g)), this.x *= Math.pow(this.percentChangeX, t2 / g);
    }
    if (this.y) {
      const s2 = this.percentChangeY, h2 = Math.log(s2);
      this.parent.y += this.y * g / h2 * (Math.pow(s2, n2 / g) - Math.pow(s2, e3 / g)), this.y *= Math.pow(this.percentChangeY, t2 / g);
    }
    this.timeSinceRelease += t2, this.x && this.y ? Math.abs(this.x) < this.options.minSpeed && Math.abs(this.y) < this.options.minSpeed && (this.x = 0, this.y = 0) : (Math.abs(this.x || 0) < this.options.minSpeed && (this.x = 0), Math.abs(this.y || 0) < this.options.minSpeed && (this.y = 0)), i2 && this.parent.emit("moved", { viewport: this.parent, type: "decelerate" });
  }
  reset() {
    this.x = this.y = null;
  }
}
const L = {
  direction: "all",
  pressDrag: true,
  wheel: true,
  wheelScroll: 1,
  reverse: false,
  clampWheel: false,
  underflow: "center",
  factor: 1,
  mouseButtons: "all",
  keyToPress: null,
  ignoreKeyToPressOnTouch: false,
  lineHeight: 20,
  wheelSwapAxes: false
};
class U extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "moved");
    o(this, "reverse");
    o(this, "xDirection");
    o(this, "yDirection");
    o(this, "keyIsPressed");
    o(this, "mouse");
    o(this, "underflowX");
    o(this, "underflowY");
    o(this, "last");
    o(this, "current");
    o(this, "windowEventHandlers", []);
    this.options = Object.assign({}, L, i2), this.moved = false, this.reverse = this.options.reverse ? 1 : -1, this.xDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "x", this.yDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "y", this.keyIsPressed = false, this.parseUnderflow(), this.mouseButtons(this.options.mouseButtons), this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  handleKeyPresses(t2) {
    const i2 = (n2) => {
      t2.includes(n2.code) && (this.keyIsPressed = true);
    }, e3 = (n2) => {
      t2.includes(n2.code) && (this.keyIsPressed = false);
    };
    this.addWindowEventHandler("keyup", e3), this.addWindowEventHandler("keydown", i2);
  }
  addWindowEventHandler(t2, i2) {
    window.addEventListener(t2, i2), this.windowEventHandlers.push({ event: t2, handler: i2 });
  }
  destroy() {
    this.windowEventHandlers.forEach(({ event: t2, handler: i2 }) => {
      window.removeEventListener(t2, i2);
    });
  }
  mouseButtons(t2) {
    !t2 || t2 === "all" ? this.mouse = [true, true, true] : this.mouse = [
      t2.indexOf("left") !== -1,
      t2.indexOf("middle") !== -1,
      t2.indexOf("right") !== -1
    ];
  }
  parseUnderflow() {
    const t2 = this.options.underflow.toLowerCase();
    t2 === "center" ? (this.underflowX = 0, this.underflowY = 0) : (t2.includes("left") ? this.underflowX = -1 : t2.includes("right") ? this.underflowX = 1 : this.underflowX = 0, t2.includes("top") ? this.underflowY = -1 : t2.includes("bottom") ? this.underflowY = 1 : this.underflowY = 0);
  }
  checkButtons(t2) {
    const i2 = t2.pointerType === "mouse", e3 = this.parent.input.count();
    return !!((e3 === 1 || e3 > 1 && !this.parent.plugins.get("pinch", true)) && (!i2 || this.mouse[t2.button]));
  }
  checkKeyPress(t2) {
    return !this.options.keyToPress || this.keyIsPressed || this.options.ignoreKeyToPressOnTouch && t2.data.pointerType === "touch";
  }
  down(t2) {
    return this.paused || !this.options.pressDrag ? false : this.checkButtons(t2) && this.checkKeyPress(t2) ? (this.last = { x: t2.global.x, y: t2.global.y }, this.current = t2.pointerId, true) : (this.last = null, false);
  }
  get active() {
    return this.moved;
  }
  move(t2) {
    if (this.paused || !this.options.pressDrag)
      return false;
    if (this.last && this.current === t2.data.pointerId) {
      const i2 = t2.global.x, e3 = t2.global.y, n2 = this.parent.input.count();
      if (n2 === 1 || n2 > 1 && !this.parent.plugins.get("pinch", true)) {
        const s2 = i2 - this.last.x, h2 = e3 - this.last.y;
        if (this.moved || this.xDirection && this.parent.input.checkThreshold(s2) || this.yDirection && this.parent.input.checkThreshold(h2)) {
          const a8 = { x: i2, y: e3 };
          return this.xDirection && (this.parent.x += (a8.x - this.last.x) * this.options.factor), this.yDirection && (this.parent.y += (a8.y - this.last.y) * this.options.factor), this.last = a8, this.moved || this.parent.emit("drag-start", {
            event: t2,
            screen: new Point(this.last.x, this.last.y),
            world: this.parent.toWorld(new Point(this.last.x, this.last.y)),
            viewport: this.parent
          }), this.moved = true, this.parent.emit("moved", { viewport: this.parent, type: "drag" }), true;
        }
      } else
        this.moved = false;
    }
    return false;
  }
  up(t2) {
    if (this.paused)
      return false;
    const i2 = this.parent.input.touches;
    if (i2.length === 1) {
      const e3 = i2[0];
      return e3.last && (this.last = { x: e3.last.x, y: e3.last.y }, this.current = e3.id), this.moved = false, true;
    } else if (this.last && this.moved) {
      const e3 = new Point(this.last.x, this.last.y);
      return this.parent.emit("drag-end", {
        event: t2,
        screen: e3,
        world: this.parent.toWorld(e3),
        viewport: this.parent
      }), this.last = null, this.moved = false, true;
    }
    return false;
  }
  wheel(t2) {
    if (this.paused)
      return false;
    if (this.options.wheel) {
      const i2 = this.parent.plugins.get("wheel", true);
      if (!i2 || !i2.options.wheelZoom && !t2.ctrlKey) {
        const e3 = t2.deltaMode ? this.options.lineHeight : 1, n2 = [t2.deltaX, t2.deltaY], [s2, h2] = this.options.wheelSwapAxes ? n2.reverse() : n2;
        return this.xDirection && (this.parent.x += s2 * e3 * this.options.wheelScroll * this.reverse), this.yDirection && (this.parent.y += h2 * e3 * this.options.wheelScroll * this.reverse), this.options.clampWheel && this.clamp(), this.parent.emit("wheel-scroll", this.parent), this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.options.passiveWheel || t2.preventDefault(), this.parent.options.stopPropagation && t2.stopPropagation(), true;
      }
    }
    return false;
  }
  resume() {
    this.last = null, this.paused = false;
  }
  clamp() {
    const t2 = this.parent.plugins.get("decelerate", true) || {};
    if (this.options.clampWheel !== "y")
      if (this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x = 0;
            break;
          case 1:
            this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth;
            break;
          default:
            this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
        }
      else
        this.parent.left < 0 ? (this.parent.x = 0, t2.x = 0) : this.parent.right > this.parent.worldWidth && (this.parent.x = -this.parent.worldWidth * this.parent.scale.x + this.parent.screenWidth, t2.x = 0);
    if (this.options.clampWheel !== "x")
      if (this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y = 0;
            break;
          case 1:
            this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight;
            break;
          default:
            this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
        }
      else
        this.parent.top < 0 && (this.parent.y = 0, t2.y = 0), this.parent.bottom > this.parent.worldHeight && (this.parent.y = -this.parent.worldHeight * this.parent.scale.y + this.parent.screenHeight, t2.y = 0);
  }
}
const V = {
  speed: 0,
  acceleration: null,
  radius: null
};
class F extends f$1 {
  constructor(t2, i2, e3 = {}) {
    super(t2);
    o(this, "options");
    o(this, "target");
    o(this, "velocity");
    this.target = i2, this.options = Object.assign({}, V, e3), this.velocity = { x: 0, y: 0 };
  }
  update(t2) {
    if (this.paused)
      return;
    const i2 = this.parent.center;
    let e3 = this.target.x, n2 = this.target.y;
    if (this.options.radius)
      if (Math.sqrt(Math.pow(this.target.y - i2.y, 2) + Math.pow(this.target.x - i2.x, 2)) > this.options.radius) {
        const p2 = Math.atan2(this.target.y - i2.y, this.target.x - i2.x);
        e3 = this.target.x - Math.cos(p2) * this.options.radius, n2 = this.target.y - Math.sin(p2) * this.options.radius;
      } else
        return;
    const s2 = e3 - i2.x, h2 = n2 - i2.y;
    if (s2 || h2)
      if (this.options.speed)
        if (this.options.acceleration) {
          const a8 = Math.atan2(n2 - i2.y, e3 - i2.x), p2 = Math.sqrt(Math.pow(s2, 2) + Math.pow(h2, 2));
          if (p2) {
            const l2 = (Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2)) / (2 * this.options.acceleration);
            p2 > l2 ? this.velocity = {
              x: Math.min(this.velocity.x + (this.options.acceleration * t2, this.options.speed)),
              y: Math.min(this.velocity.y + (this.options.acceleration * t2, this.options.speed))
            } : this.velocity = {
              x: Math.max(this.velocity.x - this.options.acceleration * this.options.speed, 0),
              y: Math.max(this.velocity.y - this.options.acceleration * this.options.speed, 0)
            };
            const d2 = Math.cos(a8) * this.velocity.x, m2 = Math.sin(a8) * this.velocity.y, y2 = Math.abs(d2) > Math.abs(s2) ? e3 : i2.x + d2, x2 = Math.abs(m2) > Math.abs(h2) ? n2 : i2.y + m2;
            this.parent.moveCenter(y2, x2), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
          }
        } else {
          const a8 = Math.atan2(n2 - i2.y, e3 - i2.x), p2 = Math.cos(a8) * this.options.speed, l2 = Math.sin(a8) * this.options.speed, d2 = Math.abs(p2) > Math.abs(s2) ? e3 : i2.x + p2, m2 = Math.abs(l2) > Math.abs(h2) ? n2 : i2.y + l2;
          this.parent.moveCenter(d2, m2), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
        }
      else
        this.parent.moveCenter(e3, n2), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
  }
}
const B2 = {
  radius: null,
  distance: null,
  top: null,
  bottom: null,
  left: null,
  right: null,
  speed: 8,
  reverse: false,
  noDecelerate: false,
  linear: false,
  allowButtons: false
};
class N extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "reverse");
    o(this, "radiusSquared");
    o(this, "left");
    o(this, "top");
    o(this, "right");
    o(this, "bottom");
    o(this, "horizontal");
    o(this, "vertical");
    this.options = Object.assign({}, B2, i2), this.reverse = this.options.reverse ? 1 : -1, this.radiusSquared = typeof this.options.radius == "number" ? Math.pow(this.options.radius, 2) : null, this.resize();
  }
  resize() {
    const t2 = this.options.distance;
    t2 !== null ? (this.left = t2, this.top = t2, this.right = this.parent.screenWidth - t2, this.bottom = this.parent.screenHeight - t2) : this.options.radius || (this.left = this.options.left, this.top = this.options.top, this.right = this.options.right === null ? null : this.parent.screenWidth - this.options.right, this.bottom = this.options.bottom === null ? null : this.parent.screenHeight - this.options.bottom);
  }
  down() {
    return this.paused || this.options.allowButtons || (this.horizontal = this.vertical = null), false;
  }
  move(t2) {
    if (this.paused || t2.pointerType !== "mouse" && t2.pointerId !== 1 || !this.options.allowButtons && t2.buttons !== 0)
      return false;
    const i2 = t2.global.x, e3 = t2.global.y;
    if (this.radiusSquared) {
      const n2 = this.parent.toScreen(this.parent.center);
      if (Math.pow(n2.x - i2, 2) + Math.pow(n2.y - e3, 2) >= this.radiusSquared) {
        const h2 = Math.atan2(n2.y - e3, n2.x - i2);
        this.options.linear ? (this.horizontal = Math.round(Math.cos(h2)) * this.options.speed * this.reverse * (60 / 1e3), this.vertical = Math.round(Math.sin(h2)) * this.options.speed * this.reverse * (60 / 1e3)) : (this.horizontal = Math.cos(h2) * this.options.speed * this.reverse * (60 / 1e3), this.vertical = Math.sin(h2) * this.options.speed * this.reverse * (60 / 1e3));
      } else
        this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = 0;
    } else
      this.left !== null && i2 < this.left ? this.horizontal = Number(this.reverse) * this.options.speed * (60 / 1e3) : this.right !== null && i2 > this.right ? this.horizontal = -1 * this.reverse * this.options.speed * (60 / 1e3) : (this.decelerateHorizontal(), this.horizontal = 0), this.top !== null && e3 < this.top ? this.vertical = Number(this.reverse) * this.options.speed * (60 / 1e3) : this.bottom !== null && e3 > this.bottom ? this.vertical = -1 * this.reverse * this.options.speed * (60 / 1e3) : (this.decelerateVertical(), this.vertical = 0);
    return false;
  }
  decelerateHorizontal() {
    const t2 = this.parent.plugins.get("decelerate", true);
    this.horizontal && t2 && !this.options.noDecelerate && t2.activate({ x: this.horizontal * this.options.speed * this.reverse / (1e3 / 60) });
  }
  decelerateVertical() {
    const t2 = this.parent.plugins.get("decelerate", true);
    this.vertical && t2 && !this.options.noDecelerate && t2.activate({ y: this.vertical * this.options.speed * this.reverse / (1e3 / 60) });
  }
  up() {
    return this.paused || (this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = null), false;
  }
  update() {
    if (!this.paused && (this.horizontal || this.vertical)) {
      const t2 = this.parent.center;
      this.horizontal && (t2.x += this.horizontal * this.options.speed), this.vertical && (t2.y += this.vertical * this.options.speed), this.parent.moveCenter(t2), this.parent.emit("moved", { viewport: this.parent, type: "mouse-edges" });
    }
  }
}
const Z2 = {
  noDrag: false,
  percent: 1,
  center: null,
  factor: 1,
  axis: "all"
};
class R extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "active", false);
    o(this, "pinching", false);
    o(this, "moved", false);
    o(this, "lastCenter");
    this.options = Object.assign({}, Z2, i2);
  }
  down() {
    return this.parent.input.count() >= 2 ? (this.active = true, true) : false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  move(t2) {
    if (this.paused || !this.active)
      return false;
    const i2 = t2.global.x, e3 = t2.global.y, n2 = this.parent.input.touches;
    if (n2.length >= 2) {
      const s2 = n2[0], h2 = n2[1], a8 = s2.last && h2.last ? Math.sqrt(Math.pow(h2.last.x - s2.last.x, 2) + Math.pow(h2.last.y - s2.last.y, 2)) : null;
      if (s2.id === t2.pointerId ? s2.last = { x: i2, y: e3, data: t2 } : h2.id === t2.pointerId && (h2.last = { x: i2, y: e3, data: t2 }), a8) {
        let p2;
        const l2 = new Point(
          s2.last.x + (h2.last.x - s2.last.x) / 2,
          s2.last.y + (h2.last.y - s2.last.y) / 2
        );
        this.options.center || (p2 = this.parent.toLocal(l2));
        let d2 = Math.sqrt(Math.pow(
          h2.last.x - s2.last.x,
          2
        ) + Math.pow(h2.last.y - s2.last.y, 2));
        d2 = d2 === 0 ? d2 = 1e-10 : d2;
        const m2 = (1 - a8 / d2) * this.options.percent * (this.isAxisX() ? this.parent.scale.x : this.parent.scale.y);
        this.isAxisX() && (this.parent.scale.x += m2), this.isAxisY() && (this.parent.scale.y += m2), this.parent.emit("zoomed", { viewport: this.parent, type: "pinch", center: l2 });
        const y2 = this.parent.plugins.get("clamp-zoom", true);
        if (y2 && y2.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const x2 = this.parent.toGlobal(p2);
          this.parent.x += (l2.x - x2.x) * this.options.factor, this.parent.y += (l2.y - x2.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" });
        }
        !this.options.noDrag && this.lastCenter && (this.parent.x += (l2.x - this.lastCenter.x) * this.options.factor, this.parent.y += (l2.y - this.lastCenter.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" })), this.lastCenter = l2, this.moved = true;
      } else
        this.pinching || (this.parent.emit("pinch-start", this.parent), this.pinching = true);
      return true;
    }
    return false;
  }
  up() {
    return this.pinching && this.parent.input.touches.length <= 1 ? (this.active = false, this.lastCenter = null, this.pinching = false, this.moved = false, this.parent.emit("pinch-end", this.parent), true) : false;
  }
}
const j$1 = {
  topLeft: false,
  friction: 0.8,
  time: 1e3,
  ease: "easeInOutSine",
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false
};
class q extends f$1 {
  constructor(t2, i2, e3, n2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "ease");
    o(this, "x");
    o(this, "y");
    o(this, "percent");
    o(this, "snapping");
    o(this, "deltaX");
    o(this, "deltaY");
    o(this, "startX");
    o(this, "startY");
    this.options = Object.assign({}, j$1, n2), this.ease = W(n2.ease, "easeInOutSine"), this.x = i2, this.y = e3, this.options.forceStart && this.snapStart();
  }
  snapStart() {
    this.percent = 0, this.snapping = { time: 0 };
    const t2 = this.options.topLeft ? this.parent.corner : this.parent.center;
    this.deltaX = this.x - t2.x, this.deltaY = this.y - t2.y, this.startX = t2.x, this.startY = t2.y, this.parent.emit("snap-start", this.parent);
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap"), false;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap") : this.options.interrupt && (this.snapping = null), false;
  }
  up() {
    if (this.parent.input.count() === 0) {
      const t2 = this.parent.plugins.get("decelerate", true);
      t2 && (t2.x || t2.y) && (t2.percentChangeX = t2.percentChangeY = this.options.friction);
    }
    return false;
  }
  update(t2) {
    if (!this.paused && !(this.options.interrupt && this.parent.input.count() !== 0))
      if (this.snapping) {
        const i2 = this.snapping;
        i2.time += t2;
        let e3, n2, s2;
        const h2 = this.startX, a8 = this.startY, p2 = this.deltaX, l2 = this.deltaY;
        if (i2.time > this.options.time)
          e3 = true, n2 = h2 + p2, s2 = a8 + l2;
        else {
          const d2 = this.ease(i2.time, 0, 1, this.options.time);
          n2 = h2 + p2 * d2, s2 = a8 + l2 * d2;
        }
        this.options.topLeft ? this.parent.moveCorner(n2, s2) : this.parent.moveCenter(n2, s2), this.parent.emit("moved", { viewport: this.parent, type: "snap" }), e3 && (this.options.removeOnComplete && this.parent.plugins.remove("snap"), this.parent.emit("snap-end", this.parent), this.snapping = null);
      } else {
        const i2 = this.options.topLeft ? this.parent.corner : this.parent.center;
        (i2.x !== this.x || i2.y !== this.y) && this.snapStart();
      }
  }
}
const K2 = {
  width: 0,
  height: 0,
  time: 1e3,
  ease: "easeInOutSine",
  center: null,
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false,
  noMove: false
};
class G extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "ease");
    o(this, "xScale");
    o(this, "yScale");
    o(this, "xIndependent");
    o(this, "yIndependent");
    o(this, "snapping");
    this.options = Object.assign({}, K2, i2), this.ease = W(this.options.ease), this.xIndependent = false, this.yIndependent = false, this.xScale = 0, this.yScale = 0, this.options.width > 0 && (this.xScale = t2.screenWidth / this.options.width, this.xIndependent = true), this.options.height > 0 && (this.yScale = t2.screenHeight / this.options.height, this.yIndependent = true), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale, this.options.time === 0 ? (t2.container.scale.x = this.xScale, t2.container.scale.y = this.yScale, this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom")) : i2.forceStart && this.createSnapping();
  }
  createSnapping() {
    const t2 = this.parent.worldScreenWidth, i2 = this.parent.worldScreenHeight, e3 = this.parent.screenWidth / this.xScale, n2 = this.parent.screenHeight / this.yScale;
    this.snapping = {
      time: 0,
      startX: t2,
      startY: i2,
      deltaX: e3 - t2,
      deltaY: n2 - i2
    }, this.parent.emit("snap-zoom-start", this.parent);
  }
  resize() {
    this.snapping = null, this.options.width > 0 && (this.xScale = this.parent.screenWidth / this.options.width), this.options.height > 0 && (this.yScale = this.parent.screenHeight / this.options.height), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale;
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap-zoom"), false;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap-zoom") : this.options.interrupt && (this.snapping = null), false;
  }
  update(t2) {
    if (this.paused || this.options.interrupt && this.parent.input.count() !== 0)
      return;
    let i2;
    if (!this.options.center && !this.options.noMove && (i2 = this.parent.center), !this.snapping)
      (this.parent.scale.x !== this.xScale || this.parent.scale.y !== this.yScale) && this.createSnapping();
    else if (this.snapping) {
      const e3 = this.snapping;
      if (e3.time += t2, e3.time >= this.options.time)
        this.parent.scale.set(this.xScale, this.yScale), this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom"), this.parent.emit("snap-zoom-end", this.parent), this.snapping = null;
      else {
        const s2 = this.snapping, h2 = this.ease(s2.time, s2.startX, s2.deltaX, this.options.time), a8 = this.ease(s2.time, s2.startY, s2.deltaY, this.options.time);
        this.parent.scale.x = this.parent.screenWidth / h2, this.parent.scale.y = this.parent.screenHeight / a8;
      }
      const n2 = this.parent.plugins.get("clamp-zoom", true);
      n2 && n2.clamp(), this.options.noMove || (this.options.center ? this.parent.moveCenter(this.options.center) : this.parent.moveCenter(i2));
    }
  }
  resume() {
    this.snapping = null, super.resume();
  }
}
const Q2 = {
  percent: 0.1,
  smooth: false,
  interrupt: true,
  reverse: false,
  center: null,
  lineHeight: 20,
  axis: "all",
  keyToPress: null,
  trackpadPinch: false,
  wheelZoom: true
};
class J extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "smoothing");
    o(this, "smoothingCenter");
    o(this, "smoothingCount");
    o(this, "keyIsPressed");
    this.options = Object.assign({}, Q2, i2), this.keyIsPressed = false, this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  handleKeyPresses(t2) {
    window.addEventListener("keydown", (i2) => {
      t2.includes(i2.code) && (this.keyIsPressed = true);
    }), window.addEventListener("keyup", (i2) => {
      t2.includes(i2.code) && (this.keyIsPressed = false);
    });
  }
  checkKeyPress() {
    return !this.options.keyToPress || this.keyIsPressed;
  }
  down() {
    return this.options.interrupt && (this.smoothing = null), false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  update() {
    if (this.smoothing) {
      const t2 = this.smoothingCenter, i2 = this.smoothing;
      let e3;
      this.options.center || (e3 = this.parent.toLocal(t2)), this.isAxisX() && (this.parent.scale.x += i2.x), this.isAxisY() && (this.parent.scale.y += i2.y), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
      const n2 = this.parent.plugins.get("clamp-zoom", true);
      if (n2 && n2.clamp(), this.options.center)
        this.parent.moveCenter(this.options.center);
      else {
        const s2 = this.parent.toGlobal(e3);
        this.parent.x += t2.x - s2.x, this.parent.y += t2.y - s2.y;
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.smoothingCount++, this.smoothingCount >= this.options.smooth && (this.smoothing = null);
    }
  }
  pinch(t2) {
    if (this.paused)
      return;
    const i2 = this.parent.input.getPointerPosition(t2), e3 = -t2.deltaY * (t2.deltaMode ? this.options.lineHeight : 1) / 200, n2 = Math.pow(2, (1 + this.options.percent) * e3);
    let s2;
    this.options.center || (s2 = this.parent.toLocal(i2)), this.isAxisX() && (this.parent.scale.x *= n2), this.isAxisY() && (this.parent.scale.y *= n2), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
    const h2 = this.parent.plugins.get("clamp-zoom", true);
    if (h2 && h2.clamp(), this.options.center)
      this.parent.moveCenter(this.options.center);
    else {
      const a8 = this.parent.toGlobal(s2);
      this.parent.x += i2.x - a8.x, this.parent.y += i2.y - a8.y;
    }
    this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit(
      "wheel-start",
      { event: t2, viewport: this.parent }
    );
  }
  wheel(t2) {
    if (this.paused || !this.checkKeyPress())
      return false;
    if (t2.ctrlKey && this.options.trackpadPinch)
      this.pinch(t2);
    else if (this.options.wheelZoom) {
      const i2 = this.parent.input.getPointerPosition(t2), n2 = (this.options.reverse ? -1 : 1) * -t2.deltaY * (t2.deltaMode ? this.options.lineHeight : 1) / 500, s2 = Math.pow(2, (1 + this.options.percent) * n2);
      if (this.options.smooth) {
        const h2 = {
          x: this.smoothing ? this.smoothing.x * (this.options.smooth - this.smoothingCount) : 0,
          y: this.smoothing ? this.smoothing.y * (this.options.smooth - this.smoothingCount) : 0
        };
        this.smoothing = {
          x: ((this.parent.scale.x + h2.x) * s2 - this.parent.scale.x) / this.options.smooth,
          y: ((this.parent.scale.y + h2.y) * s2 - this.parent.scale.y) / this.options.smooth
        }, this.smoothingCount = 0, this.smoothingCenter = i2;
      } else {
        let h2;
        this.options.center || (h2 = this.parent.toLocal(i2)), this.isAxisX() && (this.parent.scale.x *= s2), this.isAxisY() && (this.parent.scale.y *= s2), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
        const a8 = this.parent.plugins.get("clamp-zoom", true);
        if (a8 && a8.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const p2 = this.parent.toGlobal(h2);
          this.parent.x += i2.x - p2.x, this.parent.y += i2.y - p2.y;
        }
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit(
        "wheel-start",
        { event: t2, viewport: this.parent }
      );
    }
    return !this.parent.options.passiveWheel;
  }
}
class $ {
  constructor(r2) {
    o(this, "viewport");
    o(this, "clickedAvailable");
    o(this, "isMouseDown");
    o(this, "last");
    o(this, "wheelFunction");
    o(this, "touches");
    this.viewport = r2, this.touches = [], this.addListeners();
  }
  addListeners() {
    this.viewport.eventMode = "static", this.viewport.forceHitArea || (this.viewport.hitArea = new Rectangle(0, 0, this.viewport.worldWidth, this.viewport.worldHeight)), this.viewport.on("pointerdown", this.down, this), this.viewport.options.allowPreserveDragOutside ? this.viewport.on("globalpointermove", this.move, this) : this.viewport.on("pointermove", this.move, this), this.viewport.on("pointerup", this.up, this), this.viewport.on("pointerupoutside", this.up, this), this.viewport.on("pointercancel", this.up, this), this.viewport.options.allowPreserveDragOutside || this.viewport.on("pointerleave", this.up, this), this.wheelFunction = (r2) => this.handleWheel(r2), this.viewport.options.events.domElement.addEventListener(
      "wheel",
      this.wheelFunction,
      { passive: this.viewport.options.passiveWheel }
    ), this.isMouseDown = false;
  }
  destroy() {
    this.viewport.options.events.domElement.removeEventListener("wheel", this.wheelFunction);
  }
  down(r2) {
    if (this.viewport.pause || !this.viewport.worldVisible)
      return;
    if (r2.pointerType === "mouse" ? this.isMouseDown = true : this.get(r2.pointerId) || this.touches.push({ id: r2.pointerId, last: null }), this.count() === 1) {
      this.last = r2.global.clone();
      const i2 = this.viewport.plugins.get("decelerate", true), e3 = this.viewport.plugins.get("bounce", true);
      (!i2 || !i2.isActive()) && (!e3 || !e3.isActive()) ? this.clickedAvailable = true : this.clickedAvailable = false;
    } else
      this.clickedAvailable = false;
    this.viewport.plugins.down(r2) && this.viewport.options.stopPropagation && r2.stopPropagation();
  }
  clear() {
    this.isMouseDown = false, this.touches = [], this.last = null;
  }
  checkThreshold(r2) {
    return Math.abs(r2) >= this.viewport.threshold;
  }
  move(r2) {
    if (this.viewport.pause || !this.viewport.worldVisible)
      return;
    const t2 = this.viewport.plugins.move(r2);
    if (this.clickedAvailable && this.last) {
      const i2 = r2.global.x - this.last.x, e3 = r2.global.y - this.last.y;
      (this.checkThreshold(i2) || this.checkThreshold(e3)) && (this.clickedAvailable = false);
    }
    t2 && this.viewport.options.stopPropagation && r2.stopPropagation();
  }
  up(r2) {
    if (this.viewport.pause || !this.viewport.worldVisible)
      return;
    r2.pointerType === "mouse" && (this.isMouseDown = false), r2.pointerType !== "mouse" && this.remove(r2.pointerId);
    const t2 = this.viewport.plugins.up(r2);
    this.clickedAvailable && this.count() === 0 && this.last && (this.viewport.emit("clicked", {
      event: r2,
      screen: this.last,
      world: this.viewport.toWorld(this.last),
      viewport: this.viewport
    }), this.clickedAvailable = false), t2 && this.viewport.options.stopPropagation && r2.stopPropagation();
  }
  getPointerPosition(r2) {
    const t2 = new Point();
    return this.viewport.options.events.mapPositionToPoint(t2, r2.clientX, r2.clientY), t2;
  }
  handleWheel(r2) {
    if (this.viewport.pause || !this.viewport.worldVisible)
      return;
    const t2 = this.viewport.toLocal(this.getPointerPosition(r2));
    this.viewport.left <= t2.x && t2.x <= this.viewport.right && this.viewport.top <= t2.y && t2.y <= this.viewport.bottom && this.viewport.plugins.wheel(r2) && !this.viewport.options.passiveWheel && r2.preventDefault();
  }
  pause() {
    this.touches = [], this.isMouseDown = false;
  }
  get(r2) {
    for (const t2 of this.touches)
      if (t2.id === r2)
        return t2;
    return null;
  }
  remove(r2) {
    for (let t2 = 0; t2 < this.touches.length; t2++)
      if (this.touches[t2].id === r2) {
        this.touches.splice(t2, 1);
        return;
      }
  }
  count() {
    return (this.isMouseDown ? 1 : 0) + this.touches.length;
  }
}
const w = [
  "drag",
  "pinch",
  "wheel",
  "follow",
  "mouse-edges",
  "decelerate",
  "animate",
  "bounce",
  "snap-zoom",
  "clamp-zoom",
  "snap",
  "clamp"
];
class tt {
  constructor(r2) {
    o(this, "plugins");
    o(this, "list");
    o(this, "viewport");
    this.viewport = r2, this.list = [], this.plugins = {};
  }
  add(r2, t2, i2 = w.length) {
    const e3 = this.plugins[r2];
    e3 && e3.destroy(), this.plugins[r2] = t2;
    const n2 = w.indexOf(r2);
    n2 !== -1 && w.splice(n2, 1), w.splice(i2, 0, r2), this.sort();
  }
  get(r2, t2) {
    var i2;
    return t2 && (i2 = this.plugins[r2]) != null && i2.paused ? null : this.plugins[r2];
  }
  update(r2) {
    for (const t2 of this.list)
      t2.update(r2);
  }
  resize() {
    for (const r2 of this.list)
      r2.resize();
  }
  reset() {
    for (const r2 of this.list)
      r2.reset();
  }
  removeAll() {
    this.list.forEach((r2) => {
      r2.destroy();
    }), this.plugins = {}, this.sort();
  }
  remove(r2) {
    var t2;
    this.plugins[r2] && ((t2 = this.plugins[r2]) == null || t2.destroy(), delete this.plugins[r2], this.viewport.emit("plugin-remove", r2), this.sort());
  }
  pause(r2) {
    var t2;
    (t2 = this.plugins[r2]) == null || t2.pause();
  }
  resume(r2) {
    var t2;
    (t2 = this.plugins[r2]) == null || t2.resume();
  }
  sort() {
    this.list = [];
    for (const r2 of w)
      this.plugins[r2] && this.list.push(this.plugins[r2]);
  }
  down(r2) {
    let t2 = false;
    for (const i2 of this.list)
      i2.down(r2) && (t2 = true);
    return t2;
  }
  move(r2) {
    let t2 = false;
    for (const i2 of this.viewport.plugins.list)
      i2.move(r2) && (t2 = true);
    return t2;
  }
  up(r2) {
    let t2 = false;
    for (const i2 of this.list)
      i2.up(r2) && (t2 = true);
    return t2;
  }
  wheel(r2) {
    let t2 = false;
    for (const i2 of this.list)
      i2.wheel(r2) && (t2 = true);
    return t2;
  }
}
const et = {
  screenWidth: window.innerWidth,
  screenHeight: window.innerHeight,
  worldWidth: null,
  worldHeight: null,
  threshold: 5,
  passiveWheel: true,
  stopPropagation: false,
  forceHitArea: null,
  noTicker: false,
  disableOnContextMenu: false,
  ticker: Ticker.shared,
  allowPreserveDragOutside: false
};
class ht extends Container {
  constructor(t2) {
    super();
    o(this, "moving");
    o(this, "screenWidth");
    o(this, "screenHeight");
    o(this, "threshold");
    o(this, "input");
    o(this, "plugins");
    o(this, "zooming");
    o(this, "lastViewport");
    o(this, "options");
    o(this, "_dirty");
    o(this, "_forceHitArea");
    o(this, "_hitAreaDefault");
    o(this, "_pause");
    o(this, "tickerFunction");
    o(this, "_worldWidth");
    o(this, "_worldHeight");
    o(this, "_disableOnContextMenu", (t3) => t3.preventDefault());
    this.options = {
      ...et,
      ...t2
    }, this.screenWidth = this.options.screenWidth, this.screenHeight = this.options.screenHeight, this._worldWidth = this.options.worldWidth, this._worldHeight = this.options.worldHeight, this.forceHitArea = this.options.forceHitArea, this.threshold = this.options.threshold, this.options.disableOnContextMenu && this.options.events.domElement.addEventListener("contextmenu", this._disableOnContextMenu), this.options.noTicker || (this.tickerFunction = () => this.update(this.options.ticker.elapsedMS), this.options.ticker.add(this.tickerFunction)), this.input = new $(this), this.plugins = new tt(this);
  }
  destroy(t2) {
    !this.options.noTicker && this.tickerFunction && this.options.ticker.remove(this.tickerFunction), this.options.disableOnContextMenu && this.options.events.domElement.removeEventListener("contextmenu", this._disableOnContextMenu), this.input.destroy(), super.destroy(t2);
  }
  update(t2) {
    this.pause || (this.plugins.update(t2), this.lastViewport && (this.lastViewport.x !== this.x || this.lastViewport.y !== this.y ? this.moving = true : this.moving && (this.emit("moved-end", this), this.moving = false), this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y ? this.zooming = true : this.zooming && (this.emit("zoomed-end", this), this.zooming = false)), this.forceHitArea || (this._hitAreaDefault = new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight), this.hitArea = this._hitAreaDefault), this._dirty = this._dirty || !this.lastViewport || this.lastViewport.x !== this.x || this.lastViewport.y !== this.y || this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y, this.lastViewport = {
      x: this.x,
      y: this.y,
      scaleX: this.scale.x,
      scaleY: this.scale.y
    }, this.emit("frame-end", this));
  }
  resize(t2 = window.innerWidth, i2 = window.innerHeight, e3, n2) {
    this.screenWidth = t2, this.screenHeight = i2, typeof e3 < "u" && (this._worldWidth = e3), typeof n2 < "u" && (this._worldHeight = n2), this.plugins.resize(), this.dirty = true;
  }
  get worldWidth() {
    return this._worldWidth ? this._worldWidth : this.width / this.scale.x;
  }
  set worldWidth(t2) {
    this._worldWidth = t2, this.plugins.resize();
  }
  get worldHeight() {
    return this._worldHeight ? this._worldHeight : this.height / this.scale.y;
  }
  set worldHeight(t2) {
    this._worldHeight = t2, this.plugins.resize();
  }
  getVisibleBounds() {
    return new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight);
  }
  toWorld(t2, i2) {
    return arguments.length === 2 ? this.toLocal(new Point(t2, i2)) : this.toLocal(t2);
  }
  toScreen(t2, i2) {
    return arguments.length === 2 ? this.toGlobal(new Point(t2, i2)) : this.toGlobal(t2);
  }
  get worldScreenWidth() {
    return this.screenWidth / this.scale.x;
  }
  get worldScreenHeight() {
    return this.screenHeight / this.scale.y;
  }
  get screenWorldWidth() {
    return this.worldWidth * this.scale.x;
  }
  get screenWorldHeight() {
    return this.worldHeight * this.scale.y;
  }
  get center() {
    return new Point(
      this.worldScreenWidth / 2 - this.x / this.scale.x,
      this.worldScreenHeight / 2 - this.y / this.scale.y
    );
  }
  set center(t2) {
    this.moveCenter(t2);
  }
  moveCenter(...t2) {
    let i2, e3;
    typeof t2[0] == "number" ? (i2 = t2[0], e3 = t2[1]) : (i2 = t2[0].x, e3 = t2[0].y);
    const n2 = (this.worldScreenWidth / 2 - i2) * this.scale.x, s2 = (this.worldScreenHeight / 2 - e3) * this.scale.y;
    return (this.x !== n2 || this.y !== s2) && (this.position.set(n2, s2), this.plugins.reset(), this.dirty = true), this;
  }
  get corner() {
    return new Point(-this.x / this.scale.x, -this.y / this.scale.y);
  }
  set corner(t2) {
    this.moveCorner(t2);
  }
  moveCorner(...t2) {
    let i2, e3;
    return t2.length === 1 ? (i2 = -t2[0].x * this.scale.x, e3 = -t2[0].y * this.scale.y) : (i2 = -t2[0] * this.scale.x, e3 = -t2[1] * this.scale.y), (i2 !== this.x || e3 !== this.y) && (this.position.set(i2, e3), this.plugins.reset(), this.dirty = true), this;
  }
  get screenWidthInWorldPixels() {
    return this.screenWidth / this.scale.x;
  }
  get screenHeightInWorldPixels() {
    return this.screenHeight / this.scale.y;
  }
  findFitWidth(t2) {
    return this.screenWidth / t2;
  }
  findFitHeight(t2) {
    return this.screenHeight / t2;
  }
  findFit(t2, i2) {
    const e3 = this.screenWidth / t2, n2 = this.screenHeight / i2;
    return Math.min(e3, n2);
  }
  findCover(t2, i2) {
    const e3 = this.screenWidth / t2, n2 = this.screenHeight / i2;
    return Math.max(e3, n2);
  }
  fitWidth(t2 = this.worldWidth, i2, e3 = true, n2) {
    let s2;
    i2 && (s2 = this.center), this.scale.x = this.screenWidth / t2, e3 && (this.scale.y = this.scale.x);
    const h2 = this.plugins.get("clamp-zoom", true);
    return !n2 && h2 && h2.clamp(), i2 && s2 && this.moveCenter(s2), this;
  }
  fitHeight(t2 = this.worldHeight, i2, e3 = true, n2) {
    let s2;
    i2 && (s2 = this.center), this.scale.y = this.screenHeight / t2, e3 && (this.scale.x = this.scale.y);
    const h2 = this.plugins.get("clamp-zoom", true);
    return !n2 && h2 && h2.clamp(), i2 && s2 && this.moveCenter(s2), this;
  }
  fitWorld(t2) {
    let i2;
    t2 && (i2 = this.center), this.scale.x = this.screenWidth / this.worldWidth, this.scale.y = this.screenHeight / this.worldHeight, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const e3 = this.plugins.get("clamp-zoom", true);
    return e3 && e3.clamp(), t2 && i2 && this.moveCenter(i2), this;
  }
  fit(t2, i2 = this.worldWidth, e3 = this.worldHeight) {
    let n2;
    t2 && (n2 = this.center), this.scale.x = this.screenWidth / i2, this.scale.y = this.screenHeight / e3, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const s2 = this.plugins.get("clamp-zoom", true);
    return s2 && s2.clamp(), t2 && n2 && this.moveCenter(n2), this;
  }
  setZoom(t2, i2) {
    let e3;
    i2 && (e3 = this.center), this.scale.set(t2);
    const n2 = this.plugins.get("clamp-zoom", true);
    return n2 && n2.clamp(), i2 && e3 && this.moveCenter(e3), this;
  }
  zoomPercent(t2, i2) {
    return this.setZoom(this.scale.x + this.scale.x * t2, i2);
  }
  zoom(t2, i2) {
    return this.fitWidth(t2 + this.worldScreenWidth, i2), this;
  }
  get scaled() {
    return this.scale.x;
  }
  set scaled(t2) {
    this.setZoom(t2, true);
  }
  snapZoom(t2) {
    return this.plugins.add("snap-zoom", new G(this, t2)), this;
  }
  OOB() {
    return {
      left: this.left < 0,
      right: this.right > this.worldWidth,
      top: this.top < 0,
      bottom: this.bottom > this.worldHeight,
      cornerPoint: new Point(
        this.worldWidth * this.scale.x - this.screenWidth,
        this.worldHeight * this.scale.y - this.screenHeight
      )
    };
  }
  get right() {
    return -this.x / this.scale.x + this.worldScreenWidth;
  }
  set right(t2) {
    this.x = -t2 * this.scale.x + this.screenWidth, this.plugins.reset();
  }
  get left() {
    return -this.x / this.scale.x;
  }
  set left(t2) {
    this.x = -t2 * this.scale.x, this.plugins.reset();
  }
  get top() {
    return -this.y / this.scale.y;
  }
  set top(t2) {
    this.y = -t2 * this.scale.y, this.plugins.reset();
  }
  get bottom() {
    return -this.y / this.scale.y + this.worldScreenHeight;
  }
  set bottom(t2) {
    this.y = -t2 * this.scale.y + this.screenHeight, this.plugins.reset();
  }
  get dirty() {
    return !!this._dirty;
  }
  set dirty(t2) {
    this._dirty = t2;
  }
  get forceHitArea() {
    return this._forceHitArea;
  }
  set forceHitArea(t2) {
    t2 ? (this._forceHitArea = t2, this.hitArea = t2) : (this._forceHitArea = null, this.hitArea = new Rectangle(0, 0, this.worldWidth, this.worldHeight));
  }
  drag(t2) {
    return this.plugins.add("drag", new U(this, t2)), this;
  }
  clamp(t2) {
    return this.plugins.add("clamp", new A(this, t2)), this;
  }
  decelerate(t2) {
    return this.plugins.add("decelerate", new E(this, t2)), this;
  }
  bounce(t2) {
    return this.plugins.add("bounce", new X(this, t2)), this;
  }
  pinch(t2) {
    return this.plugins.add("pinch", new R(this, t2)), this;
  }
  snap(t2, i2, e3) {
    return this.plugins.add("snap", new q(this, t2, i2, e3)), this;
  }
  follow(t2, i2) {
    return this.plugins.add("follow", new F(this, t2, i2)), this;
  }
  wheel(t2) {
    return this.plugins.add("wheel", new J(this, t2)), this;
  }
  animate(t2) {
    return this.plugins.add("animate", new k$1(this, t2)), this;
  }
  clampZoom(t2) {
    return this.plugins.add("clamp-zoom", new T(this, t2)), this;
  }
  mouseEdges(t2) {
    return this.plugins.add("mouse-edges", new N(this, t2)), this;
  }
  get pause() {
    return !!this._pause;
  }
  set pause(t2) {
    this._pause = t2, this.lastViewport = null, this.moving = false, this.zooming = false, t2 && this.input.pause();
  }
  ensureVisible(t2, i2, e3, n2, s2) {
    s2 && (e3 > this.worldScreenWidth || n2 > this.worldScreenHeight) && (this.fit(true, e3, n2), this.emit("zoomed", { viewport: this, type: "ensureVisible" }));
    let h2 = false;
    t2 < this.left ? (this.left = t2, h2 = true) : t2 + e3 > this.right && (this.right = t2 + e3, h2 = true), i2 < this.top ? (this.top = i2, h2 = true) : i2 + n2 > this.bottom && (this.bottom = i2 + n2, h2 = true), h2 && this.emit("moved", { viewport: this, type: "ensureVisible" });
  }
}
const _PixiViewport = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Animate: k$1,
  Bounce: X,
  Clamp: A,
  ClampZoom: T,
  Decelerate: E,
  Drag: U,
  Follow: F,
  InputManager: $,
  MouseEdges: N,
  Pinch: R,
  Plugin: f$1,
  PluginManager: tt,
  Snap: q,
  SnapZoom: G,
  Viewport: ht,
  Wheel: J
}, Symbol.toStringTag, { value: "Module" }));
var howler = {};
/*!
 *  howler.js v2.2.3
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
(function(exports) {
  (function() {
    var HowlerGlobal2 = function() {
      this.init();
    };
    HowlerGlobal2.prototype = {
      /**
       * Initialize the global Howler object.
       * @return {Howler}
       */
      init: function() {
        var self2 = this || Howler2;
        self2._counter = 1e3;
        self2._html5AudioPool = [];
        self2.html5PoolSize = 10;
        self2._codecs = {};
        self2._howls = [];
        self2._muted = false;
        self2._volume = 1;
        self2._canPlayEvent = "canplaythrough";
        self2._navigator = typeof window !== "undefined" && window.navigator ? window.navigator : null;
        self2.masterGain = null;
        self2.noAudio = false;
        self2.usingWebAudio = true;
        self2.autoSuspend = true;
        self2.ctx = null;
        self2.autoUnlock = true;
        self2._setup();
        return self2;
      },
      /**
       * Get/set the global volume for all sounds.
       * @param  {Float} vol Volume from 0.0 to 1.0.
       * @return {Howler/Float}     Returns self or current volume.
       */
      volume: function(vol) {
        var self2 = this || Howler2;
        vol = parseFloat(vol);
        if (!self2.ctx) {
          setupAudioContext();
        }
        if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
          self2._volume = vol;
          if (self2._muted) {
            return self2;
          }
          if (self2.usingWebAudio) {
            self2.masterGain.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
          }
          for (var i2 = 0; i2 < self2._howls.length; i2++) {
            if (!self2._howls[i2]._webAudio) {
              var ids = self2._howls[i2]._getSoundIds();
              for (var j2 = 0; j2 < ids.length; j2++) {
                var sound = self2._howls[i2]._soundById(ids[j2]);
                if (sound && sound._node) {
                  sound._node.volume = sound._volume * vol;
                }
              }
            }
          }
          return self2;
        }
        return self2._volume;
      },
      /**
       * Handle muting and unmuting globally.
       * @param  {Boolean} muted Is muted or not.
       */
      mute: function(muted) {
        var self2 = this || Howler2;
        if (!self2.ctx) {
          setupAudioContext();
        }
        self2._muted = muted;
        if (self2.usingWebAudio) {
          self2.masterGain.gain.setValueAtTime(muted ? 0 : self2._volume, Howler2.ctx.currentTime);
        }
        for (var i2 = 0; i2 < self2._howls.length; i2++) {
          if (!self2._howls[i2]._webAudio) {
            var ids = self2._howls[i2]._getSoundIds();
            for (var j2 = 0; j2 < ids.length; j2++) {
              var sound = self2._howls[i2]._soundById(ids[j2]);
              if (sound && sound._node) {
                sound._node.muted = muted ? true : sound._muted;
              }
            }
          }
        }
        return self2;
      },
      /**
       * Handle stopping all sounds globally.
       */
      stop: function() {
        var self2 = this || Howler2;
        for (var i2 = 0; i2 < self2._howls.length; i2++) {
          self2._howls[i2].stop();
        }
        return self2;
      },
      /**
       * Unload and destroy all currently loaded Howl objects.
       * @return {Howler}
       */
      unload: function() {
        var self2 = this || Howler2;
        for (var i2 = self2._howls.length - 1; i2 >= 0; i2--) {
          self2._howls[i2].unload();
        }
        if (self2.usingWebAudio && self2.ctx && typeof self2.ctx.close !== "undefined") {
          self2.ctx.close();
          self2.ctx = null;
          setupAudioContext();
        }
        return self2;
      },
      /**
       * Check for codec support of specific extension.
       * @param  {String} ext Audio file extention.
       * @return {Boolean}
       */
      codecs: function(ext2) {
        return (this || Howler2)._codecs[ext2.replace(/^x-/, "")];
      },
      /**
       * Setup various state values for global tracking.
       * @return {Howler}
       */
      _setup: function() {
        var self2 = this || Howler2;
        self2.state = self2.ctx ? self2.ctx.state || "suspended" : "suspended";
        self2._autoSuspend();
        if (!self2.usingWebAudio) {
          if (typeof Audio !== "undefined") {
            try {
              var test = new Audio();
              if (typeof test.oncanplaythrough === "undefined") {
                self2._canPlayEvent = "canplay";
              }
            } catch (e3) {
              self2.noAudio = true;
            }
          } else {
            self2.noAudio = true;
          }
        }
        try {
          var test = new Audio();
          if (test.muted) {
            self2.noAudio = true;
          }
        } catch (e3) {
        }
        if (!self2.noAudio) {
          self2._setupCodecs();
        }
        return self2;
      },
      /**
       * Check for browser support for various codecs and cache the results.
       * @return {Howler}
       */
      _setupCodecs: function() {
        var self2 = this || Howler2;
        var audioTest = null;
        try {
          audioTest = typeof Audio !== "undefined" ? new Audio() : null;
        } catch (err) {
          return self2;
        }
        if (!audioTest || typeof audioTest.canPlayType !== "function") {
          return self2;
        }
        var mpegTest = audioTest.canPlayType("audio/mpeg;").replace(/^no$/, "");
        var ua = self2._navigator ? self2._navigator.userAgent : "";
        var checkOpera = ua.match(/OPR\/([0-6].)/g);
        var isOldOpera = checkOpera && parseInt(checkOpera[0].split("/")[1], 10) < 33;
        var checkSafari = ua.indexOf("Safari") !== -1 && ua.indexOf("Chrome") === -1;
        var safariVersion = ua.match(/Version\/(.*?) /);
        var isOldSafari = checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15;
        self2._codecs = {
          mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType("audio/mp3;").replace(/^no$/, ""))),
          mpeg: !!mpegTest,
          opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
          ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
          oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
          wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType("audio/wav")).replace(/^no$/, ""),
          aac: !!audioTest.canPlayType("audio/aac;").replace(/^no$/, ""),
          caf: !!audioTest.canPlayType("audio/x-caf;").replace(/^no$/, ""),
          m4a: !!(audioTest.canPlayType("audio/x-m4a;") || audioTest.canPlayType("audio/m4a;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
          m4b: !!(audioTest.canPlayType("audio/x-m4b;") || audioTest.canPlayType("audio/m4b;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
          mp4: !!(audioTest.canPlayType("audio/x-mp4;") || audioTest.canPlayType("audio/mp4;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
          weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
          webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
          dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
          flac: !!(audioTest.canPlayType("audio/x-flac;") || audioTest.canPlayType("audio/flac;")).replace(/^no$/, "")
        };
        return self2;
      },
      /**
       * Some browsers/devices will only allow audio to be played after a user interaction.
       * Attempt to automatically unlock audio on the first user interaction.
       * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
       * @return {Howler}
       */
      _unlockAudio: function() {
        var self2 = this || Howler2;
        if (self2._audioUnlocked || !self2.ctx) {
          return;
        }
        self2._audioUnlocked = false;
        self2.autoUnlock = false;
        if (!self2._mobileUnloaded && self2.ctx.sampleRate !== 44100) {
          self2._mobileUnloaded = true;
          self2.unload();
        }
        self2._scratchBuffer = self2.ctx.createBuffer(1, 1, 22050);
        var unlock = function(e3) {
          while (self2._html5AudioPool.length < self2.html5PoolSize) {
            try {
              var audioNode = new Audio();
              audioNode._unlocked = true;
              self2._releaseHtml5Audio(audioNode);
            } catch (e4) {
              self2.noAudio = true;
              break;
            }
          }
          for (var i2 = 0; i2 < self2._howls.length; i2++) {
            if (!self2._howls[i2]._webAudio) {
              var ids = self2._howls[i2]._getSoundIds();
              for (var j2 = 0; j2 < ids.length; j2++) {
                var sound = self2._howls[i2]._soundById(ids[j2]);
                if (sound && sound._node && !sound._node._unlocked) {
                  sound._node._unlocked = true;
                  sound._node.load();
                }
              }
            }
          }
          self2._autoResume();
          var source = self2.ctx.createBufferSource();
          source.buffer = self2._scratchBuffer;
          source.connect(self2.ctx.destination);
          if (typeof source.start === "undefined") {
            source.noteOn(0);
          } else {
            source.start(0);
          }
          if (typeof self2.ctx.resume === "function") {
            self2.ctx.resume();
          }
          source.onended = function() {
            source.disconnect(0);
            self2._audioUnlocked = true;
            document.removeEventListener("touchstart", unlock, true);
            document.removeEventListener("touchend", unlock, true);
            document.removeEventListener("click", unlock, true);
            document.removeEventListener("keydown", unlock, true);
            for (var i3 = 0; i3 < self2._howls.length; i3++) {
              self2._howls[i3]._emit("unlock");
            }
          };
        };
        document.addEventListener("touchstart", unlock, true);
        document.addEventListener("touchend", unlock, true);
        document.addEventListener("click", unlock, true);
        document.addEventListener("keydown", unlock, true);
        return self2;
      },
      /**
       * Get an unlocked HTML5 Audio object from the pool. If none are left,
       * return a new Audio object and throw a warning.
       * @return {Audio} HTML5 Audio object.
       */
      _obtainHtml5Audio: function() {
        var self2 = this || Howler2;
        if (self2._html5AudioPool.length) {
          return self2._html5AudioPool.pop();
        }
        var testPlay = new Audio().play();
        if (testPlay && typeof Promise !== "undefined" && (testPlay instanceof Promise || typeof testPlay.then === "function")) {
          testPlay.catch(function() {
            console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
          });
        }
        return new Audio();
      },
      /**
       * Return an activated HTML5 Audio object to the pool.
       * @return {Howler}
       */
      _releaseHtml5Audio: function(audio) {
        var self2 = this || Howler2;
        if (audio._unlocked) {
          self2._html5AudioPool.push(audio);
        }
        return self2;
      },
      /**
       * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
       * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
       * @return {Howler}
       */
      _autoSuspend: function() {
        var self2 = this;
        if (!self2.autoSuspend || !self2.ctx || typeof self2.ctx.suspend === "undefined" || !Howler2.usingWebAudio) {
          return;
        }
        for (var i2 = 0; i2 < self2._howls.length; i2++) {
          if (self2._howls[i2]._webAudio) {
            for (var j2 = 0; j2 < self2._howls[i2]._sounds.length; j2++) {
              if (!self2._howls[i2]._sounds[j2]._paused) {
                return self2;
              }
            }
          }
        }
        if (self2._suspendTimer) {
          clearTimeout(self2._suspendTimer);
        }
        self2._suspendTimer = setTimeout(function() {
          if (!self2.autoSuspend) {
            return;
          }
          self2._suspendTimer = null;
          self2.state = "suspending";
          var handleSuspension = function() {
            self2.state = "suspended";
            if (self2._resumeAfterSuspend) {
              delete self2._resumeAfterSuspend;
              self2._autoResume();
            }
          };
          self2.ctx.suspend().then(handleSuspension, handleSuspension);
        }, 3e4);
        return self2;
      },
      /**
       * Automatically resume the Web Audio AudioContext when a new sound is played.
       * @return {Howler}
       */
      _autoResume: function() {
        var self2 = this;
        if (!self2.ctx || typeof self2.ctx.resume === "undefined" || !Howler2.usingWebAudio) {
          return;
        }
        if (self2.state === "running" && self2.ctx.state !== "interrupted" && self2._suspendTimer) {
          clearTimeout(self2._suspendTimer);
          self2._suspendTimer = null;
        } else if (self2.state === "suspended" || self2.state === "running" && self2.ctx.state === "interrupted") {
          self2.ctx.resume().then(function() {
            self2.state = "running";
            for (var i2 = 0; i2 < self2._howls.length; i2++) {
              self2._howls[i2]._emit("resume");
            }
          });
          if (self2._suspendTimer) {
            clearTimeout(self2._suspendTimer);
            self2._suspendTimer = null;
          }
        } else if (self2.state === "suspending") {
          self2._resumeAfterSuspend = true;
        }
        return self2;
      }
    };
    var Howler2 = new HowlerGlobal2();
    var Howl2 = function(o2) {
      var self2 = this;
      if (!o2.src || o2.src.length === 0) {
        console.error("An array of source files must be passed with any new Howl.");
        return;
      }
      self2.init(o2);
    };
    Howl2.prototype = {
      /**
       * Initialize a new Howl group object.
       * @param  {Object} o Passed in properties for this group.
       * @return {Howl}
       */
      init: function(o2) {
        var self2 = this;
        if (!Howler2.ctx) {
          setupAudioContext();
        }
        self2._autoplay = o2.autoplay || false;
        self2._format = typeof o2.format !== "string" ? o2.format : [o2.format];
        self2._html5 = o2.html5 || false;
        self2._muted = o2.mute || false;
        self2._loop = o2.loop || false;
        self2._pool = o2.pool || 5;
        self2._preload = typeof o2.preload === "boolean" || o2.preload === "metadata" ? o2.preload : true;
        self2._rate = o2.rate || 1;
        self2._sprite = o2.sprite || {};
        self2._src = typeof o2.src !== "string" ? o2.src : [o2.src];
        self2._volume = o2.volume !== void 0 ? o2.volume : 1;
        self2._xhr = {
          method: o2.xhr && o2.xhr.method ? o2.xhr.method : "GET",
          headers: o2.xhr && o2.xhr.headers ? o2.xhr.headers : null,
          withCredentials: o2.xhr && o2.xhr.withCredentials ? o2.xhr.withCredentials : false
        };
        self2._duration = 0;
        self2._state = "unloaded";
        self2._sounds = [];
        self2._endTimers = {};
        self2._queue = [];
        self2._playLock = false;
        self2._onend = o2.onend ? [{ fn: o2.onend }] : [];
        self2._onfade = o2.onfade ? [{ fn: o2.onfade }] : [];
        self2._onload = o2.onload ? [{ fn: o2.onload }] : [];
        self2._onloaderror = o2.onloaderror ? [{ fn: o2.onloaderror }] : [];
        self2._onplayerror = o2.onplayerror ? [{ fn: o2.onplayerror }] : [];
        self2._onpause = o2.onpause ? [{ fn: o2.onpause }] : [];
        self2._onplay = o2.onplay ? [{ fn: o2.onplay }] : [];
        self2._onstop = o2.onstop ? [{ fn: o2.onstop }] : [];
        self2._onmute = o2.onmute ? [{ fn: o2.onmute }] : [];
        self2._onvolume = o2.onvolume ? [{ fn: o2.onvolume }] : [];
        self2._onrate = o2.onrate ? [{ fn: o2.onrate }] : [];
        self2._onseek = o2.onseek ? [{ fn: o2.onseek }] : [];
        self2._onunlock = o2.onunlock ? [{ fn: o2.onunlock }] : [];
        self2._onresume = [];
        self2._webAudio = Howler2.usingWebAudio && !self2._html5;
        if (typeof Howler2.ctx !== "undefined" && Howler2.ctx && Howler2.autoUnlock) {
          Howler2._unlockAudio();
        }
        Howler2._howls.push(self2);
        if (self2._autoplay) {
          self2._queue.push({
            event: "play",
            action: function() {
              self2.play();
            }
          });
        }
        if (self2._preload && self2._preload !== "none") {
          self2.load();
        }
        return self2;
      },
      /**
       * Load the audio file.
       * @return {Howler}
       */
      load: function() {
        var self2 = this;
        var url2 = null;
        if (Howler2.noAudio) {
          self2._emit("loaderror", null, "No audio support.");
          return;
        }
        if (typeof self2._src === "string") {
          self2._src = [self2._src];
        }
        for (var i2 = 0; i2 < self2._src.length; i2++) {
          var ext2, str2;
          if (self2._format && self2._format[i2]) {
            ext2 = self2._format[i2];
          } else {
            str2 = self2._src[i2];
            if (typeof str2 !== "string") {
              self2._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
              continue;
            }
            ext2 = /^data:audio\/([^;,]+);/i.exec(str2);
            if (!ext2) {
              ext2 = /\.([^.]+)$/.exec(str2.split("?", 1)[0]);
            }
            if (ext2) {
              ext2 = ext2[1].toLowerCase();
            }
          }
          if (!ext2) {
            console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
          }
          if (ext2 && Howler2.codecs(ext2)) {
            url2 = self2._src[i2];
            break;
          }
        }
        if (!url2) {
          self2._emit("loaderror", null, "No codec support for selected audio sources.");
          return;
        }
        self2._src = url2;
        self2._state = "loading";
        if (window.location.protocol === "https:" && url2.slice(0, 5) === "http:") {
          self2._html5 = true;
          self2._webAudio = false;
        }
        new Sound2(self2);
        if (self2._webAudio) {
          loadBuffer(self2);
        }
        return self2;
      },
      /**
       * Play a sound or resume previous playback.
       * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
       * @param  {Boolean} internal Internal Use: true prevents event firing.
       * @return {Number}          Sound ID.
       */
      play: function(sprite, internal) {
        var self2 = this;
        var id = null;
        if (typeof sprite === "number") {
          id = sprite;
          sprite = null;
        } else if (typeof sprite === "string" && self2._state === "loaded" && !self2._sprite[sprite]) {
          return null;
        } else if (typeof sprite === "undefined") {
          sprite = "__default";
          if (!self2._playLock) {
            var num = 0;
            for (var i2 = 0; i2 < self2._sounds.length; i2++) {
              if (self2._sounds[i2]._paused && !self2._sounds[i2]._ended) {
                num++;
                id = self2._sounds[i2]._id;
              }
            }
            if (num === 1) {
              sprite = null;
            } else {
              id = null;
            }
          }
        }
        var sound = id ? self2._soundById(id) : self2._inactiveSound();
        if (!sound) {
          return null;
        }
        if (id && !sprite) {
          sprite = sound._sprite || "__default";
        }
        if (self2._state !== "loaded") {
          sound._sprite = sprite;
          sound._ended = false;
          var soundId = sound._id;
          self2._queue.push({
            event: "play",
            action: function() {
              self2.play(soundId);
            }
          });
          return soundId;
        }
        if (id && !sound._paused) {
          if (!internal) {
            self2._loadQueue("play");
          }
          return sound._id;
        }
        if (self2._webAudio) {
          Howler2._autoResume();
        }
        var seek = Math.max(0, sound._seek > 0 ? sound._seek : self2._sprite[sprite][0] / 1e3);
        var duration = Math.max(0, (self2._sprite[sprite][0] + self2._sprite[sprite][1]) / 1e3 - seek);
        var timeout = duration * 1e3 / Math.abs(sound._rate);
        var start = self2._sprite[sprite][0] / 1e3;
        var stop = (self2._sprite[sprite][0] + self2._sprite[sprite][1]) / 1e3;
        sound._sprite = sprite;
        sound._ended = false;
        var setParams = function() {
          sound._paused = false;
          sound._seek = seek;
          sound._start = start;
          sound._stop = stop;
          sound._loop = !!(sound._loop || self2._sprite[sprite][2]);
        };
        if (seek >= stop) {
          self2._ended(sound);
          return;
        }
        var node = sound._node;
        if (self2._webAudio) {
          var playWebAudio = function() {
            self2._playLock = false;
            setParams();
            self2._refreshBuffer(sound);
            var vol = sound._muted || self2._muted ? 0 : sound._volume;
            node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
            sound._playStart = Howler2.ctx.currentTime;
            if (typeof node.bufferSource.start === "undefined") {
              sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
            } else {
              sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
            }
            if (timeout !== Infinity) {
              self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
            }
            if (!internal) {
              setTimeout(function() {
                self2._emit("play", sound._id);
                self2._loadQueue();
              }, 0);
            }
          };
          if (Howler2.state === "running" && Howler2.ctx.state !== "interrupted") {
            playWebAudio();
          } else {
            self2._playLock = true;
            self2.once("resume", playWebAudio);
            self2._clearTimer(sound._id);
          }
        } else {
          var playHtml5 = function() {
            node.currentTime = seek;
            node.muted = sound._muted || self2._muted || Howler2._muted || node.muted;
            node.volume = sound._volume * Howler2.volume();
            node.playbackRate = sound._rate;
            try {
              var play = node.play();
              if (play && typeof Promise !== "undefined" && (play instanceof Promise || typeof play.then === "function")) {
                self2._playLock = true;
                setParams();
                play.then(function() {
                  self2._playLock = false;
                  node._unlocked = true;
                  if (!internal) {
                    self2._emit("play", sound._id);
                  } else {
                    self2._loadQueue();
                  }
                }).catch(function() {
                  self2._playLock = false;
                  self2._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                  sound._ended = true;
                  sound._paused = true;
                });
              } else if (!internal) {
                self2._playLock = false;
                setParams();
                self2._emit("play", sound._id);
              }
              node.playbackRate = sound._rate;
              if (node.paused) {
                self2._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                return;
              }
              if (sprite !== "__default" || sound._loop) {
                self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
              } else {
                self2._endTimers[sound._id] = function() {
                  self2._ended(sound);
                  node.removeEventListener("ended", self2._endTimers[sound._id], false);
                };
                node.addEventListener("ended", self2._endTimers[sound._id], false);
              }
            } catch (err) {
              self2._emit("playerror", sound._id, err);
            }
          };
          if (node.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") {
            node.src = self2._src;
            node.load();
          }
          var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler2._navigator.isCocoonJS;
          if (node.readyState >= 3 || loadedNoReadyState) {
            playHtml5();
          } else {
            self2._playLock = true;
            self2._state = "loading";
            var listener = function() {
              self2._state = "loaded";
              playHtml5();
              node.removeEventListener(Howler2._canPlayEvent, listener, false);
            };
            node.addEventListener(Howler2._canPlayEvent, listener, false);
            self2._clearTimer(sound._id);
          }
        }
        return sound._id;
      },
      /**
       * Pause playback and save current position.
       * @param  {Number} id The sound ID (empty to pause all in group).
       * @return {Howl}
       */
      pause: function(id) {
        var self2 = this;
        if (self2._state !== "loaded" || self2._playLock) {
          self2._queue.push({
            event: "pause",
            action: function() {
              self2.pause(id);
            }
          });
          return self2;
        }
        var ids = self2._getSoundIds(id);
        for (var i2 = 0; i2 < ids.length; i2++) {
          self2._clearTimer(ids[i2]);
          var sound = self2._soundById(ids[i2]);
          if (sound && !sound._paused) {
            sound._seek = self2.seek(ids[i2]);
            sound._rateSeek = 0;
            sound._paused = true;
            self2._stopFade(ids[i2]);
            if (sound._node) {
              if (self2._webAudio) {
                if (!sound._node.bufferSource) {
                  continue;
                }
                if (typeof sound._node.bufferSource.stop === "undefined") {
                  sound._node.bufferSource.noteOff(0);
                } else {
                  sound._node.bufferSource.stop(0);
                }
                self2._cleanBuffer(sound._node);
              } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                sound._node.pause();
              }
            }
          }
          if (!arguments[1]) {
            self2._emit("pause", sound ? sound._id : null);
          }
        }
        return self2;
      },
      /**
       * Stop playback and reset to start.
       * @param  {Number} id The sound ID (empty to stop all in group).
       * @param  {Boolean} internal Internal Use: true prevents event firing.
       * @return {Howl}
       */
      stop: function(id, internal) {
        var self2 = this;
        if (self2._state !== "loaded" || self2._playLock) {
          self2._queue.push({
            event: "stop",
            action: function() {
              self2.stop(id);
            }
          });
          return self2;
        }
        var ids = self2._getSoundIds(id);
        for (var i2 = 0; i2 < ids.length; i2++) {
          self2._clearTimer(ids[i2]);
          var sound = self2._soundById(ids[i2]);
          if (sound) {
            sound._seek = sound._start || 0;
            sound._rateSeek = 0;
            sound._paused = true;
            sound._ended = true;
            self2._stopFade(ids[i2]);
            if (sound._node) {
              if (self2._webAudio) {
                if (sound._node.bufferSource) {
                  if (typeof sound._node.bufferSource.stop === "undefined") {
                    sound._node.bufferSource.noteOff(0);
                  } else {
                    sound._node.bufferSource.stop(0);
                  }
                  self2._cleanBuffer(sound._node);
                }
              } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                sound._node.currentTime = sound._start || 0;
                sound._node.pause();
                if (sound._node.duration === Infinity) {
                  self2._clearSound(sound._node);
                }
              }
            }
            if (!internal) {
              self2._emit("stop", sound._id);
            }
          }
        }
        return self2;
      },
      /**
       * Mute/unmute a single sound or all sounds in this Howl group.
       * @param  {Boolean} muted Set to true to mute and false to unmute.
       * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
       * @return {Howl}
       */
      mute: function(muted, id) {
        var self2 = this;
        if (self2._state !== "loaded" || self2._playLock) {
          self2._queue.push({
            event: "mute",
            action: function() {
              self2.mute(muted, id);
            }
          });
          return self2;
        }
        if (typeof id === "undefined") {
          if (typeof muted === "boolean") {
            self2._muted = muted;
          } else {
            return self2._muted;
          }
        }
        var ids = self2._getSoundIds(id);
        for (var i2 = 0; i2 < ids.length; i2++) {
          var sound = self2._soundById(ids[i2]);
          if (sound) {
            sound._muted = muted;
            if (sound._interval) {
              self2._stopFade(sound._id);
            }
            if (self2._webAudio && sound._node) {
              sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler2.ctx.currentTime);
            } else if (sound._node) {
              sound._node.muted = Howler2._muted ? true : muted;
            }
            self2._emit("mute", sound._id);
          }
        }
        return self2;
      },
      /**
       * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
       *   volume() -> Returns the group's volume value.
       *   volume(id) -> Returns the sound id's current volume.
       *   volume(vol) -> Sets the volume of all sounds in this Howl group.
       *   volume(vol, id) -> Sets the volume of passed sound id.
       * @return {Howl/Number} Returns self or current volume.
       */
      volume: function() {
        var self2 = this;
        var args = arguments;
        var vol, id;
        if (args.length === 0) {
          return self2._volume;
        } else if (args.length === 1 || args.length === 2 && typeof args[1] === "undefined") {
          var ids = self2._getSoundIds();
          var index2 = ids.indexOf(args[0]);
          if (index2 >= 0) {
            id = parseInt(args[0], 10);
          } else {
            vol = parseFloat(args[0]);
          }
        } else if (args.length >= 2) {
          vol = parseFloat(args[0]);
          id = parseInt(args[1], 10);
        }
        var sound;
        if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "volume",
              action: function() {
                self2.volume.apply(self2, args);
              }
            });
            return self2;
          }
          if (typeof id === "undefined") {
            self2._volume = vol;
          }
          id = self2._getSoundIds(id);
          for (var i2 = 0; i2 < id.length; i2++) {
            sound = self2._soundById(id[i2]);
            if (sound) {
              sound._volume = vol;
              if (!args[2]) {
                self2._stopFade(id[i2]);
              }
              if (self2._webAudio && sound._node && !sound._muted) {
                sound._node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
              } else if (sound._node && !sound._muted) {
                sound._node.volume = vol * Howler2.volume();
              }
              self2._emit("volume", sound._id);
            }
          }
        } else {
          sound = id ? self2._soundById(id) : self2._sounds[0];
          return sound ? sound._volume : 0;
        }
        return self2;
      },
      /**
       * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
       * @param  {Number} from The value to fade from (0.0 to 1.0).
       * @param  {Number} to   The volume to fade to (0.0 to 1.0).
       * @param  {Number} len  Time in milliseconds to fade.
       * @param  {Number} id   The sound id (omit to fade all sounds).
       * @return {Howl}
       */
      fade: function(from2, to, len, id) {
        var self2 = this;
        if (self2._state !== "loaded" || self2._playLock) {
          self2._queue.push({
            event: "fade",
            action: function() {
              self2.fade(from2, to, len, id);
            }
          });
          return self2;
        }
        from2 = Math.min(Math.max(0, parseFloat(from2)), 1);
        to = Math.min(Math.max(0, parseFloat(to)), 1);
        len = parseFloat(len);
        self2.volume(from2, id);
        var ids = self2._getSoundIds(id);
        for (var i2 = 0; i2 < ids.length; i2++) {
          var sound = self2._soundById(ids[i2]);
          if (sound) {
            if (!id) {
              self2._stopFade(ids[i2]);
            }
            if (self2._webAudio && !sound._muted) {
              var currentTime = Howler2.ctx.currentTime;
              var end = currentTime + len / 1e3;
              sound._volume = from2;
              sound._node.gain.setValueAtTime(from2, currentTime);
              sound._node.gain.linearRampToValueAtTime(to, end);
            }
            self2._startFadeInterval(sound, from2, to, len, ids[i2], typeof id === "undefined");
          }
        }
        return self2;
      },
      /**
       * Starts the internal interval to fade a sound.
       * @param  {Object} sound Reference to sound to fade.
       * @param  {Number} from The value to fade from (0.0 to 1.0).
       * @param  {Number} to   The volume to fade to (0.0 to 1.0).
       * @param  {Number} len  Time in milliseconds to fade.
       * @param  {Number} id   The sound id to fade.
       * @param  {Boolean} isGroup   If true, set the volume on the group.
       */
      _startFadeInterval: function(sound, from2, to, len, id, isGroup) {
        var self2 = this;
        var vol = from2;
        var diff = to - from2;
        var steps = Math.abs(diff / 0.01);
        var stepLen = Math.max(4, steps > 0 ? len / steps : len);
        var lastTick = Date.now();
        sound._fadeTo = to;
        sound._interval = setInterval(function() {
          var tick = (Date.now() - lastTick) / len;
          lastTick = Date.now();
          vol += diff * tick;
          vol = Math.round(vol * 100) / 100;
          if (diff < 0) {
            vol = Math.max(to, vol);
          } else {
            vol = Math.min(to, vol);
          }
          if (self2._webAudio) {
            sound._volume = vol;
          } else {
            self2.volume(vol, sound._id, true);
          }
          if (isGroup) {
            self2._volume = vol;
          }
          if (to < from2 && vol <= to || to > from2 && vol >= to) {
            clearInterval(sound._interval);
            sound._interval = null;
            sound._fadeTo = null;
            self2.volume(to, sound._id);
            self2._emit("fade", sound._id);
          }
        }, stepLen);
      },
      /**
       * Internal method that stops the currently playing fade when
       * a new fade starts, volume is changed or the sound is stopped.
       * @param  {Number} id The sound id.
       * @return {Howl}
       */
      _stopFade: function(id) {
        var self2 = this;
        var sound = self2._soundById(id);
        if (sound && sound._interval) {
          if (self2._webAudio) {
            sound._node.gain.cancelScheduledValues(Howler2.ctx.currentTime);
          }
          clearInterval(sound._interval);
          sound._interval = null;
          self2.volume(sound._fadeTo, id);
          sound._fadeTo = null;
          self2._emit("fade", id);
        }
        return self2;
      },
      /**
       * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
       *   loop() -> Returns the group's loop value.
       *   loop(id) -> Returns the sound id's loop value.
       *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
       *   loop(loop, id) -> Sets the loop value of passed sound id.
       * @return {Howl/Boolean} Returns self or current loop value.
       */
      loop: function() {
        var self2 = this;
        var args = arguments;
        var loop, id, sound;
        if (args.length === 0) {
          return self2._loop;
        } else if (args.length === 1) {
          if (typeof args[0] === "boolean") {
            loop = args[0];
            self2._loop = loop;
          } else {
            sound = self2._soundById(parseInt(args[0], 10));
            return sound ? sound._loop : false;
          }
        } else if (args.length === 2) {
          loop = args[0];
          id = parseInt(args[1], 10);
        }
        var ids = self2._getSoundIds(id);
        for (var i2 = 0; i2 < ids.length; i2++) {
          sound = self2._soundById(ids[i2]);
          if (sound) {
            sound._loop = loop;
            if (self2._webAudio && sound._node && sound._node.bufferSource) {
              sound._node.bufferSource.loop = loop;
              if (loop) {
                sound._node.bufferSource.loopStart = sound._start || 0;
                sound._node.bufferSource.loopEnd = sound._stop;
                if (self2.playing(ids[i2])) {
                  self2.pause(ids[i2], true);
                  self2.play(ids[i2], true);
                }
              }
            }
          }
        }
        return self2;
      },
      /**
       * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
       *   rate() -> Returns the first sound node's current playback rate.
       *   rate(id) -> Returns the sound id's current playback rate.
       *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
       *   rate(rate, id) -> Sets the playback rate of passed sound id.
       * @return {Howl/Number} Returns self or the current playback rate.
       */
      rate: function() {
        var self2 = this;
        var args = arguments;
        var rate, id;
        if (args.length === 0) {
          id = self2._sounds[0]._id;
        } else if (args.length === 1) {
          var ids = self2._getSoundIds();
          var index2 = ids.indexOf(args[0]);
          if (index2 >= 0) {
            id = parseInt(args[0], 10);
          } else {
            rate = parseFloat(args[0]);
          }
        } else if (args.length === 2) {
          rate = parseFloat(args[0]);
          id = parseInt(args[1], 10);
        }
        var sound;
        if (typeof rate === "number") {
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "rate",
              action: function() {
                self2.rate.apply(self2, args);
              }
            });
            return self2;
          }
          if (typeof id === "undefined") {
            self2._rate = rate;
          }
          id = self2._getSoundIds(id);
          for (var i2 = 0; i2 < id.length; i2++) {
            sound = self2._soundById(id[i2]);
            if (sound) {
              if (self2.playing(id[i2])) {
                sound._rateSeek = self2.seek(id[i2]);
                sound._playStart = self2._webAudio ? Howler2.ctx.currentTime : sound._playStart;
              }
              sound._rate = rate;
              if (self2._webAudio && sound._node && sound._node.bufferSource) {
                sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler2.ctx.currentTime);
              } else if (sound._node) {
                sound._node.playbackRate = rate;
              }
              var seek = self2.seek(id[i2]);
              var duration = (self2._sprite[sound._sprite][0] + self2._sprite[sound._sprite][1]) / 1e3 - seek;
              var timeout = duration * 1e3 / Math.abs(sound._rate);
              if (self2._endTimers[id[i2]] || !sound._paused) {
                self2._clearTimer(id[i2]);
                self2._endTimers[id[i2]] = setTimeout(self2._ended.bind(self2, sound), timeout);
              }
              self2._emit("rate", sound._id);
            }
          }
        } else {
          sound = self2._soundById(id);
          return sound ? sound._rate : self2._rate;
        }
        return self2;
      },
      /**
       * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
       *   seek() -> Returns the first sound node's current seek position.
       *   seek(id) -> Returns the sound id's current seek position.
       *   seek(seek) -> Sets the seek position of the first sound node.
       *   seek(seek, id) -> Sets the seek position of passed sound id.
       * @return {Howl/Number} Returns self or the current seek position.
       */
      seek: function() {
        var self2 = this;
        var args = arguments;
        var seek, id;
        if (args.length === 0) {
          if (self2._sounds.length) {
            id = self2._sounds[0]._id;
          }
        } else if (args.length === 1) {
          var ids = self2._getSoundIds();
          var index2 = ids.indexOf(args[0]);
          if (index2 >= 0) {
            id = parseInt(args[0], 10);
          } else if (self2._sounds.length) {
            id = self2._sounds[0]._id;
            seek = parseFloat(args[0]);
          }
        } else if (args.length === 2) {
          seek = parseFloat(args[0]);
          id = parseInt(args[1], 10);
        }
        if (typeof id === "undefined") {
          return 0;
        }
        if (typeof seek === "number" && (self2._state !== "loaded" || self2._playLock)) {
          self2._queue.push({
            event: "seek",
            action: function() {
              self2.seek.apply(self2, args);
            }
          });
          return self2;
        }
        var sound = self2._soundById(id);
        if (sound) {
          if (typeof seek === "number" && seek >= 0) {
            var playing = self2.playing(id);
            if (playing) {
              self2.pause(id, true);
            }
            sound._seek = seek;
            sound._ended = false;
            self2._clearTimer(id);
            if (!self2._webAudio && sound._node && !isNaN(sound._node.duration)) {
              sound._node.currentTime = seek;
            }
            var seekAndEmit = function() {
              if (playing) {
                self2.play(id, true);
              }
              self2._emit("seek", id);
            };
            if (playing && !self2._webAudio) {
              var emitSeek = function() {
                if (!self2._playLock) {
                  seekAndEmit();
                } else {
                  setTimeout(emitSeek, 0);
                }
              };
              setTimeout(emitSeek, 0);
            } else {
              seekAndEmit();
            }
          } else {
            if (self2._webAudio) {
              var realTime = self2.playing(id) ? Howler2.ctx.currentTime - sound._playStart : 0;
              var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
              return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
            } else {
              return sound._node.currentTime;
            }
          }
        }
        return self2;
      },
      /**
       * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
       * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
       * @return {Boolean} True if playing and false if not.
       */
      playing: function(id) {
        var self2 = this;
        if (typeof id === "number") {
          var sound = self2._soundById(id);
          return sound ? !sound._paused : false;
        }
        for (var i2 = 0; i2 < self2._sounds.length; i2++) {
          if (!self2._sounds[i2]._paused) {
            return true;
          }
        }
        return false;
      },
      /**
       * Get the duration of this sound. Passing a sound id will return the sprite duration.
       * @param  {Number} id The sound id to check. If none is passed, return full source duration.
       * @return {Number} Audio duration in seconds.
       */
      duration: function(id) {
        var self2 = this;
        var duration = self2._duration;
        var sound = self2._soundById(id);
        if (sound) {
          duration = self2._sprite[sound._sprite][1] / 1e3;
        }
        return duration;
      },
      /**
       * Returns the current loaded state of this Howl.
       * @return {String} 'unloaded', 'loading', 'loaded'
       */
      state: function() {
        return this._state;
      },
      /**
       * Unload and destroy the current Howl object.
       * This will immediately stop all sound instances attached to this group.
       */
      unload: function() {
        var self2 = this;
        var sounds2 = self2._sounds;
        for (var i2 = 0; i2 < sounds2.length; i2++) {
          if (!sounds2[i2]._paused) {
            self2.stop(sounds2[i2]._id);
          }
          if (!self2._webAudio) {
            self2._clearSound(sounds2[i2]._node);
            sounds2[i2]._node.removeEventListener("error", sounds2[i2]._errorFn, false);
            sounds2[i2]._node.removeEventListener(Howler2._canPlayEvent, sounds2[i2]._loadFn, false);
            sounds2[i2]._node.removeEventListener("ended", sounds2[i2]._endFn, false);
            Howler2._releaseHtml5Audio(sounds2[i2]._node);
          }
          delete sounds2[i2]._node;
          self2._clearTimer(sounds2[i2]._id);
        }
        var index2 = Howler2._howls.indexOf(self2);
        if (index2 >= 0) {
          Howler2._howls.splice(index2, 1);
        }
        var remCache = true;
        for (i2 = 0; i2 < Howler2._howls.length; i2++) {
          if (Howler2._howls[i2]._src === self2._src || self2._src.indexOf(Howler2._howls[i2]._src) >= 0) {
            remCache = false;
            break;
          }
        }
        if (cache2 && remCache) {
          delete cache2[self2._src];
        }
        Howler2.noAudio = false;
        self2._state = "unloaded";
        self2._sounds = [];
        self2 = null;
        return null;
      },
      /**
       * Listen to a custom event.
       * @param  {String}   event Event name.
       * @param  {Function} fn    Listener to call.
       * @param  {Number}   id    (optional) Only listen to events for this sound.
       * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
       * @return {Howl}
       */
      on: function(event, fn, id, once3) {
        var self2 = this;
        var events2 = self2["_on" + event];
        if (typeof fn === "function") {
          events2.push(once3 ? { id, fn, once: once3 } : { id, fn });
        }
        return self2;
      },
      /**
       * Remove a custom event. Call without parameters to remove all events.
       * @param  {String}   event Event name.
       * @param  {Function} fn    Listener to remove. Leave empty to remove all.
       * @param  {Number}   id    (optional) Only remove events for this sound.
       * @return {Howl}
       */
      off: function(event, fn, id) {
        var self2 = this;
        var events2 = self2["_on" + event];
        var i2 = 0;
        if (typeof fn === "number") {
          id = fn;
          fn = null;
        }
        if (fn || id) {
          for (i2 = 0; i2 < events2.length; i2++) {
            var isId = id === events2[i2].id;
            if (fn === events2[i2].fn && isId || !fn && isId) {
              events2.splice(i2, 1);
              break;
            }
          }
        } else if (event) {
          self2["_on" + event] = [];
        } else {
          var keys2 = Object.keys(self2);
          for (i2 = 0; i2 < keys2.length; i2++) {
            if (keys2[i2].indexOf("_on") === 0 && Array.isArray(self2[keys2[i2]])) {
              self2[keys2[i2]] = [];
            }
          }
        }
        return self2;
      },
      /**
       * Listen to a custom event and remove it once fired.
       * @param  {String}   event Event name.
       * @param  {Function} fn    Listener to call.
       * @param  {Number}   id    (optional) Only listen to events for this sound.
       * @return {Howl}
       */
      once: function(event, fn, id) {
        var self2 = this;
        self2.on(event, fn, id, 1);
        return self2;
      },
      /**
       * Emit all events of a specific type and pass the sound id.
       * @param  {String} event Event name.
       * @param  {Number} id    Sound ID.
       * @param  {Number} msg   Message to go with event.
       * @return {Howl}
       */
      _emit: function(event, id, msg) {
        var self2 = this;
        var events2 = self2["_on" + event];
        for (var i2 = events2.length - 1; i2 >= 0; i2--) {
          if (!events2[i2].id || events2[i2].id === id || event === "load") {
            setTimeout(function(fn) {
              fn.call(this, id, msg);
            }.bind(self2, events2[i2].fn), 0);
            if (events2[i2].once) {
              self2.off(event, events2[i2].fn, events2[i2].id);
            }
          }
        }
        self2._loadQueue(event);
        return self2;
      },
      /**
       * Queue of actions initiated before the sound has loaded.
       * These will be called in sequence, with the next only firing
       * after the previous has finished executing (even if async like play).
       * @return {Howl}
       */
      _loadQueue: function(event) {
        var self2 = this;
        if (self2._queue.length > 0) {
          var task = self2._queue[0];
          if (task.event === event) {
            self2._queue.shift();
            self2._loadQueue();
          }
          if (!event) {
            task.action();
          }
        }
        return self2;
      },
      /**
       * Fired when playback ends at the end of the duration.
       * @param  {Sound} sound The sound object to work with.
       * @return {Howl}
       */
      _ended: function(sound) {
        var self2 = this;
        var sprite = sound._sprite;
        if (!self2._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
          setTimeout(self2._ended.bind(self2, sound), 100);
          return self2;
        }
        var loop = !!(sound._loop || self2._sprite[sprite][2]);
        self2._emit("end", sound._id);
        if (!self2._webAudio && loop) {
          self2.stop(sound._id, true).play(sound._id);
        }
        if (self2._webAudio && loop) {
          self2._emit("play", sound._id);
          sound._seek = sound._start || 0;
          sound._rateSeek = 0;
          sound._playStart = Howler2.ctx.currentTime;
          var timeout = (sound._stop - sound._start) * 1e3 / Math.abs(sound._rate);
          self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
        }
        if (self2._webAudio && !loop) {
          sound._paused = true;
          sound._ended = true;
          sound._seek = sound._start || 0;
          sound._rateSeek = 0;
          self2._clearTimer(sound._id);
          self2._cleanBuffer(sound._node);
          Howler2._autoSuspend();
        }
        if (!self2._webAudio && !loop) {
          self2.stop(sound._id, true);
        }
        return self2;
      },
      /**
       * Clear the end timer for a sound playback.
       * @param  {Number} id The sound ID.
       * @return {Howl}
       */
      _clearTimer: function(id) {
        var self2 = this;
        if (self2._endTimers[id]) {
          if (typeof self2._endTimers[id] !== "function") {
            clearTimeout(self2._endTimers[id]);
          } else {
            var sound = self2._soundById(id);
            if (sound && sound._node) {
              sound._node.removeEventListener("ended", self2._endTimers[id], false);
            }
          }
          delete self2._endTimers[id];
        }
        return self2;
      },
      /**
       * Return the sound identified by this ID, or return null.
       * @param  {Number} id Sound ID
       * @return {Object}    Sound object or null.
       */
      _soundById: function(id) {
        var self2 = this;
        for (var i2 = 0; i2 < self2._sounds.length; i2++) {
          if (id === self2._sounds[i2]._id) {
            return self2._sounds[i2];
          }
        }
        return null;
      },
      /**
       * Return an inactive sound from the pool or create a new one.
       * @return {Sound} Sound playback object.
       */
      _inactiveSound: function() {
        var self2 = this;
        self2._drain();
        for (var i2 = 0; i2 < self2._sounds.length; i2++) {
          if (self2._sounds[i2]._ended) {
            return self2._sounds[i2].reset();
          }
        }
        return new Sound2(self2);
      },
      /**
       * Drain excess inactive sounds from the pool.
       */
      _drain: function() {
        var self2 = this;
        var limit = self2._pool;
        var cnt = 0;
        var i2 = 0;
        if (self2._sounds.length < limit) {
          return;
        }
        for (i2 = 0; i2 < self2._sounds.length; i2++) {
          if (self2._sounds[i2]._ended) {
            cnt++;
          }
        }
        for (i2 = self2._sounds.length - 1; i2 >= 0; i2--) {
          if (cnt <= limit) {
            return;
          }
          if (self2._sounds[i2]._ended) {
            if (self2._webAudio && self2._sounds[i2]._node) {
              self2._sounds[i2]._node.disconnect(0);
            }
            self2._sounds.splice(i2, 1);
            cnt--;
          }
        }
      },
      /**
       * Get all ID's from the sounds pool.
       * @param  {Number} id Only return one ID if one is passed.
       * @return {Array}    Array of IDs.
       */
      _getSoundIds: function(id) {
        var self2 = this;
        if (typeof id === "undefined") {
          var ids = [];
          for (var i2 = 0; i2 < self2._sounds.length; i2++) {
            ids.push(self2._sounds[i2]._id);
          }
          return ids;
        } else {
          return [id];
        }
      },
      /**
       * Load the sound back into the buffer source.
       * @param  {Sound} sound The sound object to work with.
       * @return {Howl}
       */
      _refreshBuffer: function(sound) {
        var self2 = this;
        sound._node.bufferSource = Howler2.ctx.createBufferSource();
        sound._node.bufferSource.buffer = cache2[self2._src];
        if (sound._panner) {
          sound._node.bufferSource.connect(sound._panner);
        } else {
          sound._node.bufferSource.connect(sound._node);
        }
        sound._node.bufferSource.loop = sound._loop;
        if (sound._loop) {
          sound._node.bufferSource.loopStart = sound._start || 0;
          sound._node.bufferSource.loopEnd = sound._stop || 0;
        }
        sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler2.ctx.currentTime);
        return self2;
      },
      /**
       * Prevent memory leaks by cleaning up the buffer source after playback.
       * @param  {Object} node Sound's audio node containing the buffer source.
       * @return {Howl}
       */
      _cleanBuffer: function(node) {
        var self2 = this;
        var isIOS = Howler2._navigator && Howler2._navigator.vendor.indexOf("Apple") >= 0;
        if (Howler2._scratchBuffer && node.bufferSource) {
          node.bufferSource.onended = null;
          node.bufferSource.disconnect(0);
          if (isIOS) {
            try {
              node.bufferSource.buffer = Howler2._scratchBuffer;
            } catch (e3) {
            }
          }
        }
        node.bufferSource = null;
        return self2;
      },
      /**
       * Set the source to a 0-second silence to stop any downloading (except in IE).
       * @param  {Object} node Audio node to clear.
       */
      _clearSound: function(node) {
        var checkIE = /MSIE |Trident\//.test(Howler2._navigator && Howler2._navigator.userAgent);
        if (!checkIE) {
          node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA";
        }
      }
    };
    var Sound2 = function(howl) {
      this._parent = howl;
      this.init();
    };
    Sound2.prototype = {
      /**
       * Initialize a new Sound object.
       * @return {Sound}
       */
      init: function() {
        var self2 = this;
        var parent = self2._parent;
        self2._muted = parent._muted;
        self2._loop = parent._loop;
        self2._volume = parent._volume;
        self2._rate = parent._rate;
        self2._seek = 0;
        self2._paused = true;
        self2._ended = true;
        self2._sprite = "__default";
        self2._id = ++Howler2._counter;
        parent._sounds.push(self2);
        self2.create();
        return self2;
      },
      /**
       * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
       * @return {Sound}
       */
      create: function() {
        var self2 = this;
        var parent = self2._parent;
        var volume = Howler2._muted || self2._muted || self2._parent._muted ? 0 : self2._volume;
        if (parent._webAudio) {
          self2._node = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
          self2._node.gain.setValueAtTime(volume, Howler2.ctx.currentTime);
          self2._node.paused = true;
          self2._node.connect(Howler2.masterGain);
        } else if (!Howler2.noAudio) {
          self2._node = Howler2._obtainHtml5Audio();
          self2._errorFn = self2._errorListener.bind(self2);
          self2._node.addEventListener("error", self2._errorFn, false);
          self2._loadFn = self2._loadListener.bind(self2);
          self2._node.addEventListener(Howler2._canPlayEvent, self2._loadFn, false);
          self2._endFn = self2._endListener.bind(self2);
          self2._node.addEventListener("ended", self2._endFn, false);
          self2._node.src = parent._src;
          self2._node.preload = parent._preload === true ? "auto" : parent._preload;
          self2._node.volume = volume * Howler2.volume();
          self2._node.load();
        }
        return self2;
      },
      /**
       * Reset the parameters of this sound to the original state (for recycle).
       * @return {Sound}
       */
      reset: function() {
        var self2 = this;
        var parent = self2._parent;
        self2._muted = parent._muted;
        self2._loop = parent._loop;
        self2._volume = parent._volume;
        self2._rate = parent._rate;
        self2._seek = 0;
        self2._rateSeek = 0;
        self2._paused = true;
        self2._ended = true;
        self2._sprite = "__default";
        self2._id = ++Howler2._counter;
        return self2;
      },
      /**
       * HTML5 Audio error listener callback.
       */
      _errorListener: function() {
        var self2 = this;
        self2._parent._emit("loaderror", self2._id, self2._node.error ? self2._node.error.code : 0);
        self2._node.removeEventListener("error", self2._errorFn, false);
      },
      /**
       * HTML5 Audio canplaythrough listener callback.
       */
      _loadListener: function() {
        var self2 = this;
        var parent = self2._parent;
        parent._duration = Math.ceil(self2._node.duration * 10) / 10;
        if (Object.keys(parent._sprite).length === 0) {
          parent._sprite = { __default: [0, parent._duration * 1e3] };
        }
        if (parent._state !== "loaded") {
          parent._state = "loaded";
          parent._emit("load");
          parent._loadQueue();
        }
        self2._node.removeEventListener(Howler2._canPlayEvent, self2._loadFn, false);
      },
      /**
       * HTML5 Audio ended listener callback.
       */
      _endListener: function() {
        var self2 = this;
        var parent = self2._parent;
        if (parent._duration === Infinity) {
          parent._duration = Math.ceil(self2._node.duration * 10) / 10;
          if (parent._sprite.__default[1] === Infinity) {
            parent._sprite.__default[1] = parent._duration * 1e3;
          }
          parent._ended(self2);
        }
        self2._node.removeEventListener("ended", self2._endFn, false);
      }
    };
    var cache2 = {};
    var loadBuffer = function(self2) {
      var url2 = self2._src;
      if (cache2[url2]) {
        self2._duration = cache2[url2].duration;
        loadSound(self2);
        return;
      }
      if (/^data:[^;]+;base64,/.test(url2)) {
        var data = atob(url2.split(",")[1]);
        var dataView = new Uint8Array(data.length);
        for (var i2 = 0; i2 < data.length; ++i2) {
          dataView[i2] = data.charCodeAt(i2);
        }
        decodeAudioData(dataView.buffer, self2);
      } else {
        var xhr = new XMLHttpRequest();
        xhr.open(self2._xhr.method, url2, true);
        xhr.withCredentials = self2._xhr.withCredentials;
        xhr.responseType = "arraybuffer";
        if (self2._xhr.headers) {
          Object.keys(self2._xhr.headers).forEach(function(key) {
            xhr.setRequestHeader(key, self2._xhr.headers[key]);
          });
        }
        xhr.onload = function() {
          var code = (xhr.status + "")[0];
          if (code !== "0" && code !== "2" && code !== "3") {
            self2._emit("loaderror", null, "Failed loading audio file with status: " + xhr.status + ".");
            return;
          }
          decodeAudioData(xhr.response, self2);
        };
        xhr.onerror = function() {
          if (self2._webAudio) {
            self2._html5 = true;
            self2._webAudio = false;
            self2._sounds = [];
            delete cache2[url2];
            self2.load();
          }
        };
        safeXhrSend(xhr);
      }
    };
    var safeXhrSend = function(xhr) {
      try {
        xhr.send();
      } catch (e3) {
        xhr.onerror();
      }
    };
    var decodeAudioData = function(arraybuffer, self2) {
      var error2 = function() {
        self2._emit("loaderror", null, "Decoding audio data failed.");
      };
      var success = function(buffer2) {
        if (buffer2 && self2._sounds.length > 0) {
          cache2[self2._src] = buffer2;
          loadSound(self2, buffer2);
        } else {
          error2();
        }
      };
      if (typeof Promise !== "undefined" && Howler2.ctx.decodeAudioData.length === 1) {
        Howler2.ctx.decodeAudioData(arraybuffer).then(success).catch(error2);
      } else {
        Howler2.ctx.decodeAudioData(arraybuffer, success, error2);
      }
    };
    var loadSound = function(self2, buffer2) {
      if (buffer2 && !self2._duration) {
        self2._duration = buffer2.duration;
      }
      if (Object.keys(self2._sprite).length === 0) {
        self2._sprite = { __default: [0, self2._duration * 1e3] };
      }
      if (self2._state !== "loaded") {
        self2._state = "loaded";
        self2._emit("load");
        self2._loadQueue();
      }
    };
    var setupAudioContext = function() {
      if (!Howler2.usingWebAudio) {
        return;
      }
      try {
        if (typeof AudioContext !== "undefined") {
          Howler2.ctx = new AudioContext();
        } else if (typeof webkitAudioContext !== "undefined") {
          Howler2.ctx = new webkitAudioContext();
        } else {
          Howler2.usingWebAudio = false;
        }
      } catch (e3) {
        Howler2.usingWebAudio = false;
      }
      if (!Howler2.ctx) {
        Howler2.usingWebAudio = false;
      }
      var iOS = /iP(hone|od|ad)/.test(Howler2._navigator && Howler2._navigator.platform);
      var appVersion = Howler2._navigator && Howler2._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
      var version2 = appVersion ? parseInt(appVersion[1], 10) : null;
      if (iOS && version2 && version2 < 9) {
        var safari = /safari/.test(Howler2._navigator && Howler2._navigator.userAgent.toLowerCase());
        if (Howler2._navigator && !safari) {
          Howler2.usingWebAudio = false;
        }
      }
      if (Howler2.usingWebAudio) {
        Howler2.masterGain = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
        Howler2.masterGain.gain.setValueAtTime(Howler2._muted ? 0 : Howler2._volume, Howler2.ctx.currentTime);
        Howler2.masterGain.connect(Howler2.ctx.destination);
      }
      Howler2._setup();
    };
    {
      exports.Howler = Howler2;
      exports.Howl = Howl2;
    }
    if (typeof commonjsGlobal !== "undefined") {
      commonjsGlobal.HowlerGlobal = HowlerGlobal2;
      commonjsGlobal.Howler = Howler2;
      commonjsGlobal.Howl = Howl2;
      commonjsGlobal.Sound = Sound2;
    } else if (typeof window !== "undefined") {
      window.HowlerGlobal = HowlerGlobal2;
      window.Howler = Howler2;
      window.Howl = Howl2;
      window.Sound = Sound2;
    }
  })();
  /*!
   *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
   *  
   *  howler.js v2.2.3
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   */
  (function() {
    HowlerGlobal.prototype._pos = [0, 0, 0];
    HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];
    HowlerGlobal.prototype.stereo = function(pan) {
      var self2 = this;
      if (!self2.ctx || !self2.ctx.listener) {
        return self2;
      }
      for (var i2 = self2._howls.length - 1; i2 >= 0; i2--) {
        self2._howls[i2].stereo(pan);
      }
      return self2;
    };
    HowlerGlobal.prototype.pos = function(x2, y2, z2) {
      var self2 = this;
      if (!self2.ctx || !self2.ctx.listener) {
        return self2;
      }
      y2 = typeof y2 !== "number" ? self2._pos[1] : y2;
      z2 = typeof z2 !== "number" ? self2._pos[2] : z2;
      if (typeof x2 === "number") {
        self2._pos = [x2, y2, z2];
        if (typeof self2.ctx.listener.positionX !== "undefined") {
          self2.ctx.listener.positionX.setTargetAtTime(self2._pos[0], Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.positionY.setTargetAtTime(self2._pos[1], Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.positionZ.setTargetAtTime(self2._pos[2], Howler.ctx.currentTime, 0.1);
        } else {
          self2.ctx.listener.setPosition(self2._pos[0], self2._pos[1], self2._pos[2]);
        }
      } else {
        return self2._pos;
      }
      return self2;
    };
    HowlerGlobal.prototype.orientation = function(x2, y2, z2, xUp, yUp, zUp) {
      var self2 = this;
      if (!self2.ctx || !self2.ctx.listener) {
        return self2;
      }
      var or = self2._orientation;
      y2 = typeof y2 !== "number" ? or[1] : y2;
      z2 = typeof z2 !== "number" ? or[2] : z2;
      xUp = typeof xUp !== "number" ? or[3] : xUp;
      yUp = typeof yUp !== "number" ? or[4] : yUp;
      zUp = typeof zUp !== "number" ? or[5] : zUp;
      if (typeof x2 === "number") {
        self2._orientation = [x2, y2, z2, xUp, yUp, zUp];
        if (typeof self2.ctx.listener.forwardX !== "undefined") {
          self2.ctx.listener.forwardX.setTargetAtTime(x2, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.forwardY.setTargetAtTime(y2, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.forwardZ.setTargetAtTime(z2, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
        } else {
          self2.ctx.listener.setOrientation(x2, y2, z2, xUp, yUp, zUp);
        }
      } else {
        return or;
      }
      return self2;
    };
    Howl.prototype.init = function(_super) {
      return function(o2) {
        var self2 = this;
        self2._orientation = o2.orientation || [1, 0, 0];
        self2._stereo = o2.stereo || null;
        self2._pos = o2.pos || null;
        self2._pannerAttr = {
          coneInnerAngle: typeof o2.coneInnerAngle !== "undefined" ? o2.coneInnerAngle : 360,
          coneOuterAngle: typeof o2.coneOuterAngle !== "undefined" ? o2.coneOuterAngle : 360,
          coneOuterGain: typeof o2.coneOuterGain !== "undefined" ? o2.coneOuterGain : 0,
          distanceModel: typeof o2.distanceModel !== "undefined" ? o2.distanceModel : "inverse",
          maxDistance: typeof o2.maxDistance !== "undefined" ? o2.maxDistance : 1e4,
          panningModel: typeof o2.panningModel !== "undefined" ? o2.panningModel : "HRTF",
          refDistance: typeof o2.refDistance !== "undefined" ? o2.refDistance : 1,
          rolloffFactor: typeof o2.rolloffFactor !== "undefined" ? o2.rolloffFactor : 1
        };
        self2._onstereo = o2.onstereo ? [{ fn: o2.onstereo }] : [];
        self2._onpos = o2.onpos ? [{ fn: o2.onpos }] : [];
        self2._onorientation = o2.onorientation ? [{ fn: o2.onorientation }] : [];
        return _super.call(this, o2);
      };
    }(Howl.prototype.init);
    Howl.prototype.stereo = function(pan, id) {
      var self2 = this;
      if (!self2._webAudio) {
        return self2;
      }
      if (self2._state !== "loaded") {
        self2._queue.push({
          event: "stereo",
          action: function() {
            self2.stereo(pan, id);
          }
        });
        return self2;
      }
      var pannerType = typeof Howler.ctx.createStereoPanner === "undefined" ? "spatial" : "stereo";
      if (typeof id === "undefined") {
        if (typeof pan === "number") {
          self2._stereo = pan;
          self2._pos = [pan, 0, 0];
        } else {
          return self2._stereo;
        }
      }
      var ids = self2._getSoundIds(id);
      for (var i2 = 0; i2 < ids.length; i2++) {
        var sound = self2._soundById(ids[i2]);
        if (sound) {
          if (typeof pan === "number") {
            sound._stereo = pan;
            sound._pos = [pan, 0, 0];
            if (sound._node) {
              sound._pannerAttr.panningModel = "equalpower";
              if (!sound._panner || !sound._panner.pan) {
                setupPanner(sound, pannerType);
              }
              if (pannerType === "spatial") {
                if (typeof sound._panner.positionX !== "undefined") {
                  sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                  sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                  sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
                } else {
                  sound._panner.setPosition(pan, 0, 0);
                }
              } else {
                sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
              }
            }
            self2._emit("stereo", sound._id);
          } else {
            return sound._stereo;
          }
        }
      }
      return self2;
    };
    Howl.prototype.pos = function(x2, y2, z2, id) {
      var self2 = this;
      if (!self2._webAudio) {
        return self2;
      }
      if (self2._state !== "loaded") {
        self2._queue.push({
          event: "pos",
          action: function() {
            self2.pos(x2, y2, z2, id);
          }
        });
        return self2;
      }
      y2 = typeof y2 !== "number" ? 0 : y2;
      z2 = typeof z2 !== "number" ? -0.5 : z2;
      if (typeof id === "undefined") {
        if (typeof x2 === "number") {
          self2._pos = [x2, y2, z2];
        } else {
          return self2._pos;
        }
      }
      var ids = self2._getSoundIds(id);
      for (var i2 = 0; i2 < ids.length; i2++) {
        var sound = self2._soundById(ids[i2]);
        if (sound) {
          if (typeof x2 === "number") {
            sound._pos = [x2, y2, z2];
            if (sound._node) {
              if (!sound._panner || sound._panner.pan) {
                setupPanner(sound, "spatial");
              }
              if (typeof sound._panner.positionX !== "undefined") {
                sound._panner.positionX.setValueAtTime(x2, Howler.ctx.currentTime);
                sound._panner.positionY.setValueAtTime(y2, Howler.ctx.currentTime);
                sound._panner.positionZ.setValueAtTime(z2, Howler.ctx.currentTime);
              } else {
                sound._panner.setPosition(x2, y2, z2);
              }
            }
            self2._emit("pos", sound._id);
          } else {
            return sound._pos;
          }
        }
      }
      return self2;
    };
    Howl.prototype.orientation = function(x2, y2, z2, id) {
      var self2 = this;
      if (!self2._webAudio) {
        return self2;
      }
      if (self2._state !== "loaded") {
        self2._queue.push({
          event: "orientation",
          action: function() {
            self2.orientation(x2, y2, z2, id);
          }
        });
        return self2;
      }
      y2 = typeof y2 !== "number" ? self2._orientation[1] : y2;
      z2 = typeof z2 !== "number" ? self2._orientation[2] : z2;
      if (typeof id === "undefined") {
        if (typeof x2 === "number") {
          self2._orientation = [x2, y2, z2];
        } else {
          return self2._orientation;
        }
      }
      var ids = self2._getSoundIds(id);
      for (var i2 = 0; i2 < ids.length; i2++) {
        var sound = self2._soundById(ids[i2]);
        if (sound) {
          if (typeof x2 === "number") {
            sound._orientation = [x2, y2, z2];
            if (sound._node) {
              if (!sound._panner) {
                if (!sound._pos) {
                  sound._pos = self2._pos || [0, 0, -0.5];
                }
                setupPanner(sound, "spatial");
              }
              if (typeof sound._panner.orientationX !== "undefined") {
                sound._panner.orientationX.setValueAtTime(x2, Howler.ctx.currentTime);
                sound._panner.orientationY.setValueAtTime(y2, Howler.ctx.currentTime);
                sound._panner.orientationZ.setValueAtTime(z2, Howler.ctx.currentTime);
              } else {
                sound._panner.setOrientation(x2, y2, z2);
              }
            }
            self2._emit("orientation", sound._id);
          } else {
            return sound._orientation;
          }
        }
      }
      return self2;
    };
    Howl.prototype.pannerAttr = function() {
      var self2 = this;
      var args = arguments;
      var o2, id, sound;
      if (!self2._webAudio) {
        return self2;
      }
      if (args.length === 0) {
        return self2._pannerAttr;
      } else if (args.length === 1) {
        if (typeof args[0] === "object") {
          o2 = args[0];
          if (typeof id === "undefined") {
            if (!o2.pannerAttr) {
              o2.pannerAttr = {
                coneInnerAngle: o2.coneInnerAngle,
                coneOuterAngle: o2.coneOuterAngle,
                coneOuterGain: o2.coneOuterGain,
                distanceModel: o2.distanceModel,
                maxDistance: o2.maxDistance,
                refDistance: o2.refDistance,
                rolloffFactor: o2.rolloffFactor,
                panningModel: o2.panningModel
              };
            }
            self2._pannerAttr = {
              coneInnerAngle: typeof o2.pannerAttr.coneInnerAngle !== "undefined" ? o2.pannerAttr.coneInnerAngle : self2._coneInnerAngle,
              coneOuterAngle: typeof o2.pannerAttr.coneOuterAngle !== "undefined" ? o2.pannerAttr.coneOuterAngle : self2._coneOuterAngle,
              coneOuterGain: typeof o2.pannerAttr.coneOuterGain !== "undefined" ? o2.pannerAttr.coneOuterGain : self2._coneOuterGain,
              distanceModel: typeof o2.pannerAttr.distanceModel !== "undefined" ? o2.pannerAttr.distanceModel : self2._distanceModel,
              maxDistance: typeof o2.pannerAttr.maxDistance !== "undefined" ? o2.pannerAttr.maxDistance : self2._maxDistance,
              refDistance: typeof o2.pannerAttr.refDistance !== "undefined" ? o2.pannerAttr.refDistance : self2._refDistance,
              rolloffFactor: typeof o2.pannerAttr.rolloffFactor !== "undefined" ? o2.pannerAttr.rolloffFactor : self2._rolloffFactor,
              panningModel: typeof o2.pannerAttr.panningModel !== "undefined" ? o2.pannerAttr.panningModel : self2._panningModel
            };
          }
        } else {
          sound = self2._soundById(parseInt(args[0], 10));
          return sound ? sound._pannerAttr : self2._pannerAttr;
        }
      } else if (args.length === 2) {
        o2 = args[0];
        id = parseInt(args[1], 10);
      }
      var ids = self2._getSoundIds(id);
      for (var i2 = 0; i2 < ids.length; i2++) {
        sound = self2._soundById(ids[i2]);
        if (sound) {
          var pa = sound._pannerAttr;
          pa = {
            coneInnerAngle: typeof o2.coneInnerAngle !== "undefined" ? o2.coneInnerAngle : pa.coneInnerAngle,
            coneOuterAngle: typeof o2.coneOuterAngle !== "undefined" ? o2.coneOuterAngle : pa.coneOuterAngle,
            coneOuterGain: typeof o2.coneOuterGain !== "undefined" ? o2.coneOuterGain : pa.coneOuterGain,
            distanceModel: typeof o2.distanceModel !== "undefined" ? o2.distanceModel : pa.distanceModel,
            maxDistance: typeof o2.maxDistance !== "undefined" ? o2.maxDistance : pa.maxDistance,
            refDistance: typeof o2.refDistance !== "undefined" ? o2.refDistance : pa.refDistance,
            rolloffFactor: typeof o2.rolloffFactor !== "undefined" ? o2.rolloffFactor : pa.rolloffFactor,
            panningModel: typeof o2.panningModel !== "undefined" ? o2.panningModel : pa.panningModel
          };
          var panner = sound._panner;
          if (panner) {
            panner.coneInnerAngle = pa.coneInnerAngle;
            panner.coneOuterAngle = pa.coneOuterAngle;
            panner.coneOuterGain = pa.coneOuterGain;
            panner.distanceModel = pa.distanceModel;
            panner.maxDistance = pa.maxDistance;
            panner.refDistance = pa.refDistance;
            panner.rolloffFactor = pa.rolloffFactor;
            panner.panningModel = pa.panningModel;
          } else {
            if (!sound._pos) {
              sound._pos = self2._pos || [0, 0, -0.5];
            }
            setupPanner(sound, "spatial");
          }
        }
      }
      return self2;
    };
    Sound.prototype.init = function(_super) {
      return function() {
        var self2 = this;
        var parent = self2._parent;
        self2._orientation = parent._orientation;
        self2._stereo = parent._stereo;
        self2._pos = parent._pos;
        self2._pannerAttr = parent._pannerAttr;
        _super.call(this);
        if (self2._stereo) {
          parent.stereo(self2._stereo);
        } else if (self2._pos) {
          parent.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
        }
      };
    }(Sound.prototype.init);
    Sound.prototype.reset = function(_super) {
      return function() {
        var self2 = this;
        var parent = self2._parent;
        self2._orientation = parent._orientation;
        self2._stereo = parent._stereo;
        self2._pos = parent._pos;
        self2._pannerAttr = parent._pannerAttr;
        if (self2._stereo) {
          parent.stereo(self2._stereo);
        } else if (self2._pos) {
          parent.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
        } else if (self2._panner) {
          self2._panner.disconnect(0);
          self2._panner = void 0;
          parent._refreshBuffer(self2);
        }
        return _super.call(this);
      };
    }(Sound.prototype.reset);
    var setupPanner = function(sound, type) {
      type = type || "spatial";
      if (type === "spatial") {
        sound._panner = Howler.ctx.createPanner();
        sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
        sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
        sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
        sound._panner.distanceModel = sound._pannerAttr.distanceModel;
        sound._panner.maxDistance = sound._pannerAttr.maxDistance;
        sound._panner.refDistance = sound._pannerAttr.refDistance;
        sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
        sound._panner.panningModel = sound._pannerAttr.panningModel;
        if (typeof sound._panner.positionX !== "undefined") {
          sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
          sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
          sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
        } else {
          sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
        }
        if (typeof sound._panner.orientationX !== "undefined") {
          sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
          sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
          sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
        } else {
          sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
        }
      } else {
        sound._panner = Howler.ctx.createStereoPanner();
        sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
      }
      sound._panner.connect(sound._node);
      if (!sound._paused) {
        sound._parent.pause(sound._id, true).play(sound._id, true);
      }
    };
  })();
})(howler);
const sounds = /* @__PURE__ */ new Map();
function _initSound(_sounds, engine) {
  return _initResource(sounds, _sounds, "sound", engine);
}
class RpgSoundClass {
  constructor() {
    this.sounds = /* @__PURE__ */ new Map();
  }
  get(id) {
    if (this.sounds.has(id)) {
      return this.sounds.get(id);
    }
    const resource = sounds.get(id);
    if (!resource) {
      throw log(`Impossible to find the ${id} sound. Did you put the right name or create the sound?`);
    }
    const howl = new howler.Howl({
      src: [resource.sound],
      loop: resource.loop,
      autoplay: resource.autoplay,
      volume: resource.volume,
      sprite: resource.sprite
    });
    this.sounds.set(id, howl);
    return howl;
  }
  stop(id) {
    this.get(id).stop();
  }
  play(id) {
    const sound = this.get(id);
    if (!sound.playing()) {
      sound.play();
      return true;
    }
    return false;
  }
  clear() {
    this.sounds.clear();
    this.global.stop();
  }
  get global() {
    return howler.Howler;
  }
}
const RpgSound = new RpgSoundClass();
var Animation$1;
(function(Animation2) {
  Animation2["Stand"] = "stand";
  Animation2["Walk"] = "walk";
  Animation2["Attack"] = "attack";
  Animation2["Defense"] = "defense";
  Animation2["Skill"] = "skill";
})(Animation$1 || (Animation$1 = {}));
const {
  isFunction: isFunction$2,
  arrayEquals
} = Utils$1;
class Animation extends Sprite {
  get attachTo() {
    return this._attachTo;
  }
  set attachTo(component) {
    if (!component)
      return;
    component.animationIsPlaying = true;
    this._attachTo = component;
  }
  constructor(id) {
    super();
    this.id = id;
    this.currentAnimation = null;
    this.time = 0;
    this.frameIndex = 0;
    this.animations = /* @__PURE__ */ new Map();
    this._animation$ = new BehaviorSubject(null);
    this.animation$ = this._animation$.asObservable();
    this.spritesheet = spritesheets.get(this.id);
    if (!this.spritesheet) {
      throw log(`Impossible to find the ${this.id} spritesheet. Did you put the right name or create the spritesheet?`);
    }
    this.createAnimations();
  }
  createTextures(options) {
    const {
      width,
      height,
      framesHeight,
      framesWidth,
      image,
      offset
    } = options;
    const {
      baseTexture
    } = Texture.from(image);
    const spriteWidth = options.spriteWidth;
    const spriteHeight = options.spriteHeight;
    const frames = [];
    const offsetX = offset && offset.x || 0;
    const offsetY = offset && offset.y || 0;
    for (let i2 = 0; i2 < framesHeight; i2++) {
      frames[i2] = [];
      for (let j2 = 0; j2 < framesWidth; j2++) {
        const rectX = j2 * spriteWidth + offsetX;
        const rectY = i2 * spriteHeight + offsetY;
        if (rectY > height) {
          throw log(`Warning, there is a problem with the height of the "${this.id}" spritesheet. When cutting into frames, the frame exceeds the height of the image.`);
        }
        if (rectX > width) {
          throw log(`Warning, there is a problem with the width of the "${this.id}" spritesheet. When cutting into frames, the frame exceeds the width of the image.`);
        }
        frames[i2].push(new Texture(baseTexture, new Rectangle(rectX, rectY, spriteWidth, spriteHeight)));
      }
    }
    return frames;
  }
  createAnimations() {
    const {
      textures
    } = this.spritesheet;
    if (!textures) {
      return;
    }
    for (let animationName in textures) {
      const props = ["width", "height", "framesHeight", "framesWidth", "rectWidth", "rectHeight", "offset", "image", "sound"];
      const parentObj = props.reduce((prev2, val) => ({
        ...prev2,
        [val]: this.spritesheet[val]
      }), {});
      const optionsTextures = {
        ...parentObj,
        ...textures[animationName]
      };
      const {
        rectWidth,
        width = 0,
        framesWidth = 1,
        rectHeight,
        height = 0,
        framesHeight = 1
      } = optionsTextures;
      optionsTextures.spriteWidth = rectWidth ? rectWidth : width / framesWidth;
      optionsTextures.spriteHeight = rectHeight ? rectHeight : height / framesHeight;
      this.animations.set(animationName, {
        container: new Sprite(),
        frames: this.createTextures(optionsTextures),
        name: animationName,
        animations: textures[animationName].animations,
        params: [],
        data: optionsTextures,
        sprites: []
      });
    }
  }
  getSpriteSize(name) {
    var _a, _b;
    return ((_b = this.animations.get(((_a = this.currentAnimation) == null ? void 0 : _a.name) || Animation$1.Stand)) == null ? void 0 : _b.data[name]) || 0;
  }
  getSpriteHeight() {
    return this.getSpriteSize("spriteHeight");
  }
  getSpriteWidth() {
    return this.getSpriteSize("spriteWidth");
  }
  has(name) {
    return this.animations.has(name);
  }
  get(name) {
    return this.animations.get(name);
  }
  isPlaying(name) {
    if (!name)
      return !!this.currentAnimation;
    if (this.currentAnimation == null)
      return false;
    return this.currentAnimation.name == name;
  }
  stop() {
    var _a;
    this.currentAnimation = null;
    (_a = this.parent) == null ? void 0 : _a.removeChild(this);
  }
  play(name, params = []) {
    var _a;
    const animParams = (_a = this.currentAnimation) == null ? void 0 : _a.params;
    if (this.isPlaying(name) && arrayEquals(params, animParams || []))
      return;
    const animation = this.get(name);
    if (!animation) {
      throw new Error(`Impossible to play the ${name} animation because it doesn't exist on the ${this.id} spritesheet`);
    }
    this.removeChildren();
    animation.sprites = [];
    this.currentAnimation = animation;
    this.currentAnimation.params = params;
    this.time = 0;
    this.frameIndex = 0;
    let animations = animation.animations;
    animations = isFunction$2(animations) ? animations(...params) : animations;
    this.currentAnimation.container = new Container();
    for (let container of animations) {
      const sprite = new Sprite();
      for (let frame of container) {
        this.currentAnimation.sprites.push(frame);
      }
      this.currentAnimation.container.addChild(sprite);
    }
    const sound = this.currentAnimation.data.sound;
    if (sound) {
      RpgSound.get(sound).play();
    }
    this.addChild(this.currentAnimation.container);
    this.update(1);
  }
  update(deltaRatio) {
    if (!this.isPlaying() || !this.currentAnimation)
      return;
    const {
      frames,
      container,
      sprites,
      data
    } = this.currentAnimation;
    let frame = sprites[this.frameIndex];
    const nextFrame2 = sprites[this.frameIndex + 1];
    if (this.attachTo) {
      const sprite = this.attachTo;
      const pos = sprite == null ? void 0 : sprite.getPositionsOfGraphic("middle");
      if (pos) {
        container.x = pos.x;
        container.y = pos.y;
      }
    }
    for (let _sprite of container.children) {
      let applyTransformValue = function(prop, alias) {
        const optionProp = alias || prop;
        const val = getVal(optionProp);
        if (val !== void 0) {
          sprite[prop] = val;
        }
      };
      const sprite = _sprite;
      if (!frame || frame.frameY == void 0 || frame.frameX == void 0) {
        continue;
      }
      sprite.texture = frames[frame.frameY][frame.frameX];
      const getVal = (prop) => frame[prop] || data[prop] || this.spritesheet[prop];
      const applyTransform = (prop) => {
        const val = getVal(prop);
        if (val) {
          sprite[prop].set(...val);
        }
      };
      if (this.applyTransform) {
        frame = {
          ...frame,
          ...this.applyTransform(frame, data, this.spritesheet)
        };
      }
      const realSize = getVal("spriteRealSize");
      const heightOfSprite = typeof realSize == "number" ? realSize : realSize == null ? void 0 : realSize.height;
      const widthOfSprite = typeof realSize == "number" ? realSize : realSize == null ? void 0 : realSize.width;
      const applyAnchorBySize = () => {
        if (heightOfSprite && this.hitbox) {
          const {
            spriteWidth,
            spriteHeight
          } = data;
          const w2 = (spriteWidth - this.hitbox.w) / 2 / spriteWidth;
          const gap = (spriteHeight - heightOfSprite) / 2;
          const h2 = (spriteHeight - this.hitbox.h - gap) / spriteHeight;
          sprite.anchor.set(w2, h2);
        }
      };
      if (frame.sound) {
        RpgSound.get(frame.sound).play();
      }
      applyAnchorBySize();
      applyTransform("anchor");
      applyTransform("scale");
      applyTransform("skew");
      applyTransform("pivot");
      applyTransformValue("alpha", "opacity");
      applyTransformValue("x");
      applyTransformValue("y");
      applyTransformValue("angle");
      applyTransformValue("rotation");
      applyTransformValue("visible");
      this._animation$.next({
        spriteWidth: widthOfSprite || sprite.width,
        spriteHeight: heightOfSprite || sprite.height,
        anchor: sprite.anchor,
        width: getVal("spriteWidth"),
        height: getVal("spriteHeight")
      });
    }
    if (!nextFrame2) {
      this.time = 0;
      this.frameIndex = 0;
      if (this.attachTo) {
        this.attachTo.animationIsPlaying = false;
      }
      if (this.onFinish)
        this.onFinish();
      return;
    }
    this.time += deltaRatio;
    if (this.time >= nextFrame2.time) {
      this.frameIndex++;
    }
  }
}
class GameEngineClient extends RpgCommonGame {
  constructor() {
    super(...arguments);
    this._objects = new BehaviorSubject({});
    this._obsObjects = {};
    this._obsObjectsDeleteNotifier$ = {};
    this._shapes = new BehaviorSubject({});
    this._objectsChanged = new BehaviorSubject({});
    this.world = {
      getObjects: this.getObjects.bind(this),
      getObject: (id) => {
        const obj = this.getObject(id);
        if (!obj)
          return null;
        return obj.object;
      },
      getShape: (id) => {
        const obj = this.getShape(id);
        if (!obj)
          return null;
        return obj.object;
      },
      getAll: (id) => {
        const obj = this.getObjectAndShape(id);
        if (!obj)
          return null;
        return obj.object;
      },
      removeObject: this.removeObject.bind(this),
      getObjectsOfGroup: () => {
        return {
          ...this.getObjects(),
          ...this.events
        };
      },
      getShapesOfGroup: () => {
        return this.getShapes();
      }
    };
  }
  initialize() {
    super.initialize(GameSide.Client);
  }
  _get(prop, id) {
    const objects = this[prop].value;
    const val = objects[id];
    if (!val)
      return null;
    return val;
  }
  get objectsChanged() {
    return this._objectsChanged.asObservable();
  }
  setObjectsChanged(val) {
    this._objectsChanged.next(val);
  }
  listenObject(id) {
    return this._obsObjects[id].asObservable();
  }
  get objects() {
    return this._objects.asObservable();
  }
  get shapes() {
    return this._shapes.asObservable();
  }
  get all() {
    return combineLatest([this.objects, this.shapes]).pipe(map$7(([objects, shapes]) => {
      return {
        ...objects,
        ...shapes
      };
    }));
  }
  getShapes() {
    return this._shapes.value;
  }
  getObjects() {
    return this._objects.value;
  }
  getObject(id) {
    return this._get("_objects", id);
  }
  getShape(id) {
    return this._get("_shapes", id);
  }
  getObjectAndShape(id) {
    let obj = this.getObject(id);
    if (!obj)
      obj = this.getShape(id);
    return obj;
  }
  resetObjects() {
    for (let id in this._obsObjectsDeleteNotifier$) {
      this._obsObjectsDeleteNotifier$[id].next();
      this._obsObjectsDeleteNotifier$[id].complete();
      this._obsObjects[id].complete();
    }
    this._obsObjectsDeleteNotifier$ = {};
    this._obsObjects = {};
    this._objects.next({});
    this._shapes.next({});
  }
  getDeleteNotifier(id) {
    return this._obsObjectsDeleteNotifier$[id].asObservable();
  }
  _remove(prop, id) {
    const logic = prop == "_objects" ? this.getObject(id) : this.getShape(id);
    if (logic) {
      const objects = {
        ...this[prop].value
      };
      delete objects[id];
      this._obsObjectsDeleteNotifier$[id].next();
      this._obsObjectsDeleteNotifier$[id].complete();
      this._obsObjects[id].complete();
      delete this._obsObjects[id];
      delete this._obsObjectsDeleteNotifier$[id];
      this[prop].next(objects);
      return true;
    }
    return false;
  }
  removeObject(id) {
    if (this.events[id]) {
      delete this.events[id];
    }
    return this._remove("_objects", id);
  }
  removeShape(id) {
    return this._remove("_shapes", id);
  }
  removeObjectAndShape(id) {
    let bool = this.removeObject(id);
    if (!bool)
      bool = this.removeShape(id);
    return bool;
  }
  static toArray(obj, prop) {
    if (obj[prop])
      obj[prop] = Object.values(obj[prop]);
  }
  updateObject(obj) {
    const {
      playerId: id,
      params,
      localEvent,
      paramsChanged,
      isShape
    } = obj;
    if (paramsChanged.components) {
      paramsChanged.layout = {
        center: {
          lines: [{
            col: paramsChanged.components
          }]
        }
      };
    }
    const layoutToArray = (params2) => {
      const layout = params2.layout;
      if (layout) {
        ["center", "top", "right", "bottom", "left"].forEach((key) => {
          if (!layout[key])
            return;
          GameEngineClient.toArray(layout[key], "lines");
          if (!layout[key].lines)
            return;
          layout[key].lines.map((layout2) => {
            GameEngineClient.toArray(layout2, "col");
          });
        });
      }
    };
    layoutToArray(params);
    GameEngineClient.toArray(params, "polygon");
    const isMe = () => id == this.playerId;
    let logic;
    const createObsForObject = (data) => {
      this._obsObjectsDeleteNotifier$[id] = new Subject();
      this._obsObjects[id] = new BehaviorSubject(data);
    };
    if (isShape) {
      logic = this.world.getShape(id);
      if (!logic) {
        logic = this.addShape(params);
        createObsForObject({
          logic
        });
      }
    } else {
      if (localEvent) {
        logic = this.events[id];
        if (!logic) {
          logic = this.addEvent(RpgCommonPlayer, id);
          createObsForObject({
            logic
          });
          this.events[id] = {
            object: logic
          };
        } else {
          logic = logic.object;
        }
      } else {
        logic = this.world.getObject(id);
      }
      if (!logic) {
        logic = this.addPlayer(RpgCommonPlayer, id);
        createObsForObject({
          logic
        });
      }
    }
    logic.prevParamsChanged = Object.assign({}, logic);
    for (let key in params) {
      if (!localEvent && (key == "position" || key == "direction" && paramsChanged && paramsChanged.position)) {
        if (isMe() && logic.canMove)
          continue;
      }
      logic[key] = params[key];
    }
    if (paramsChanged) {
      layoutToArray(paramsChanged);
      if (paramsChanged.layout)
        logic.componentChanged = paramsChanged.layout;
      if (paramsChanged.teleported) {
        logic.position = {
          ...params.position
        };
        logic.direction = params.direction;
      }
      if (!logic.paramsChanged)
        logic.paramsChanged = {};
      logic.paramsChanged = paramsChanged;
    }
    const newObject = {
      object: logic,
      paramsChanged
    };
    this.setObject(id, newObject);
    return newObject;
  }
  setObject(id, newObject) {
    const propName = newObject.object instanceof RpgShape ? "_shapes" : "_objects";
    this[propName].next({
      ...this[propName].value,
      ...{
        [id]: newObject
      }
    });
    this._obsObjects[id].next(newObject);
  }
}
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i2 = links.length - 1; i2 >= 0; i2--) {
        const link2 = links[i2];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
function makeMap(str2, expectsLowerCase) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const list = str2.split(",");
  for (let i2 = 0; i2 < list.length; i2++) {
    map2[list[i2]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$1 = Object.assign;
const remove = (arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$2.call(val, key);
const isArray$1 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction$1 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isSymbol$1 = (val) => typeof val === "symbol";
const isObject$2 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$2(val) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString = (value2) => objectToString$1.call(value2);
const toRawType = (value2) => {
  return toTypeString(value2).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str2) => {
    const hit = cache2[str2];
    return hit || (cache2[str2] = fn(str2));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str2) => {
  return str2.replace(camelizeRE, (_2, c3) => c3 ? c3.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str2) => str2.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction(
  (str2) => str2.charAt(0).toUpperCase() + str2.slice(1)
);
const toHandlerKey = cacheStringFunction(
  (str2) => str2 ? `on${capitalize$1(str2)}` : ``
);
const hasChanged = (value2, oldValue) => !Object.is(value2, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](arg);
  }
};
const def = (obj, key, value2) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value: value2
  });
};
const looseToNumber = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
const toNumber = (val) => {
  const n2 = isString$1(val) ? Number(val) : NaN;
  return isNaN(n2) ? val : n2;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global$1 !== "undefined" ? global$1 : {});
};
function normalizeStyle(value2) {
  if (isArray$1(value2)) {
    const res = {};
    for (let i2 = 0; i2 < value2.length; i2++) {
      const item = value2[i2];
      const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$1(value2)) {
    return value2;
  } else if (isObject$2(value2)) {
    return value2;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value2) {
  let res = "";
  if (isString$1(value2)) {
    res = value2;
  } else if (isArray$1(value2)) {
    for (let i2 = 0; i2 < value2.length; i2++) {
      const normalized = normalizeClass(value2[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$2(value2)) {
    for (const name in value2) {
      if (value2[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props)
    return null;
  let { class: klass, style } = props;
  if (klass && !isString$1(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value2) {
  return !!value2 || value2 === "";
}
const toDisplayString = (val) => {
  return isString$1(val) ? val : val == null ? "" : isArray$1(val) || isObject$2(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$2(val) && !isArray$1(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i2, l2;
      for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
        this.effects[i2].stop();
      }
      for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
        this.cleanups[i2]();
      }
      if (this.scopes) {
        for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
          this.scopes[i2].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last2 = this.parent.scopes.pop();
        if (last2 && last2 !== this) {
          this.parent.scopes[this.index] = last2;
          last2.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i2 = 0; i2 < deps.length; i2++) {
      const dep = deps[i2];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].delete(effect2);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last2 = trackStack.pop();
  shouldTrack = last2 === void 0 ? true : last2;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$1(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$1(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$1(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$1(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
);
const get$1$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty$1(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$1(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$1;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$2(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value2, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value2)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value2) && !isReadonly(value2)) {
        oldValue = toRaw(oldValue);
        value2 = toRaw(value2);
      }
      if (!isArray$1(target) && isRef(oldValue) && !isRef(value2)) {
        oldValue.value = value2;
        return true;
      }
    }
    const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value2, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value2);
      } else if (hasChanged(value2, oldValue)) {
        trigger(target, "set", key, value2);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray$1(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend$1(
  {},
  mutableHandlers,
  {
    get: shallowGet,
    set: shallowSet
  }
);
const toShallow = (value2) => value2;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$2(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add$1(value2) {
  value2 = toRaw(value2);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value2);
  if (!hadKey) {
    target.add(value2);
    trigger(target, "add", value2, value2);
  }
  return this;
}
function set(key, value2) {
  value2 = toRaw(value2);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value2);
  if (!hadKey) {
    trigger(target, "add", key, value2);
  } else if (hasChanged(value2, oldValue)) {
    trigger(target, "set", key, value2);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach2(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value2, key) => {
      return callback.call(thisArg, wrap(value2), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value: value2, done: done2 } = innerIterator.next();
        return done2 ? { value: value2, done: done2 } : {
          value: isPair ? [wrap(value2[0]), wrap(value2[1])] : wrap(value2),
          done: done2
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$2(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add: add$1,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$2(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add: add$1,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$2(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$2(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(
      method,
      false,
      false
    );
    readonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      false
    );
    shallowInstrumentations2[method] = createIterableMethod(
      method,
      false,
      true
    );
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value2) {
  return value2["__v_skip"] || !Object.isExtensible(value2) ? 0 : targetTypeMap(toRawType(value2));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$2(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value2) {
  if (isReadonly(value2)) {
    return isReactive(value2["__v_raw"]);
  }
  return !!(value2 && value2["__v_isReactive"]);
}
function isReadonly(value2) {
  return !!(value2 && value2["__v_isReadonly"]);
}
function isShallow(value2) {
  return !!(value2 && value2["__v_isShallow"]);
}
function isProxy(value2) {
  return isReactive(value2) || isReadonly(value2);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value2) {
  def(value2, "__v_skip", true);
  return value2;
}
const toReactive = (value2) => isObject$2(value2) ? reactive(value2) : value2;
const toReadonly = (value2) => isObject$2(value2) ? readonly(value2) : value2;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    {
      triggerEffects(dep);
    }
  }
}
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value2, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value2)) {
      oldValue.value = value2;
      return true;
    } else {
      return Reflect.set(target, key, value2, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$1(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn(msg, ...args) {
  return;
}
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$1(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i2 = 0; i2 < fn.length; i2++) {
    values.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick$1(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i2 = queue.indexOf(job);
  if (i2 > flushIndex) {
    queue.splice(i2, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$1(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen2, i2 = isFlushing ? flushIndex + 1 : 0) {
  for (; i2 < queue.length; i2++) {
    const cb = queue[i2];
    if (cb && cb.pre) {
      queue.splice(i2, 1);
      i2--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a8, b3) => getId(a8) - getId(b3));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a8, b3) => {
  const diff = getId(a8) - getId(b3);
  if (diff === 0) {
    if (a8.pre && !b3.pre)
      return -1;
    if (b3.pre && !a8.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit2(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a8) => isString$1(a8) ? a8.trim() : a8);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$1(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$1(normalized, raw);
  }
  if (isObject$2(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev2 = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev2;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit3,
    render: render2,
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  let result;
  let fallthroughAttrs;
  const prev2 = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(
        render2.call(
          proxyToUse,
          proxyToUse,
          renderCache,
          props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render22 = Component;
      if (false)
        ;
      result = normalizeVNode(
        render22.length > 1 ? render22(
          props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return attrs;
            },
            slots,
            emit: emit3
          } : { attrs, slots, emit: emit3 }
        ) : render22(
          props,
          null
          /* we know it doesn't need it */
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root2 = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root2;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root2 = cloneVNode(root2, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root2 = cloneVNode(root2);
    root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root2.transition = vnode.transition;
  }
  {
    result = root2;
  }
  setCurrentRenderingInstance(prev2);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$1(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  var _a;
  const instance = getCurrentScope() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$1(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
    getter = () => source.map((s2) => {
      if (isRef(s2)) {
        return s2.value;
      } else if (isReactive(s2)) {
        return traverse(s2);
      } else if (isFunction$1(s2)) {
        return callWithErrorHandling(s2, instance, 2);
      } else
        ;
    });
  } else if (isFunction$1(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some(
        (v2, i2) => hasChanged(v2, oldValue[i2])
      ) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect.run.bind(effect),
      instance && instance.suspense
    );
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value2, options) {
  const publicThis = this.proxy;
  const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$1(value2)) {
    cb = value2;
  } else {
    cb = value2.handler;
    options = value2;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path2) {
  const segments = path2.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
function traverse(value2, seen2) {
  if (!isObject$2(value2) || value2["__v_skip"]) {
    return value2;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value2)) {
    return value2;
  }
  seen2.add(value2);
  if (isRef(value2)) {
    traverse(value2.value, seen2);
  } else if (isArray$1(value2)) {
    for (let i2 = 0; i2 < value2.length; i2++) {
      traverse(value2[i2], seen2);
    }
  } else if (isSet(value2) || isMap(value2)) {
    value2.forEach((v2) => {
      traverse(v2, seen2);
    });
  } else if (isPlainObject(value2)) {
    for (const key in value2) {
      traverse(value2[key], seen2);
    }
  }
  return value2;
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value2, arg, modifiers = EMPTY_OBJ] = directives[i2];
    if (dir) {
      if (isFunction$1(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value2);
      }
      bindings.push({
        dir,
        instance,
        value: value2,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding2 = bindings[i2];
    if (oldBindings) {
      binding2.oldValue = oldBindings[i2].value;
    }
    let hook = binding2.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding2,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c3 of children) {
          if (c3.type !== Comment) {
            child = c3;
            break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance
      );
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done2 = args[1];
    callHook2(hook, args);
    if (isArray$1(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done2();
    } else if (hook.length <= 1) {
      done2();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done2 = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done2]);
      } else {
        done2();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done2 = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done2]);
      } else {
        done2();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    let child = children[i2];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$1(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
        /* do not include inferred name to avoid breaking existing code */
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
}
function renderList(source, renderItem, cache2, index2) {
  let ret;
  const cached = cache2 && cache2[index2];
  if (isArray$1(source) || isString$1(source)) {
    ret = new Array(source.length);
    for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
      ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i2 = 0; i2 < source; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
    }
  } else if (isObject$2(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i2) => renderItem(item, i2, void 0, cached && cached[i2])
      );
    } else {
      const keys2 = Object.keys(source);
      ret = new Array(keys2.length);
      for (let i2 = 0, l2 = keys2.length; i2 < l2; i2++) {
        const key = keys2[i2];
        ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
      }
    }
  } else {
    ret = [];
  }
  if (cache2) {
    cache2[index2] = ret;
  }
  return ret;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default")
      props.name = name;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(
    Fragment,
    {
      key: props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name}`
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i2) => {
  if (!i2)
    return null;
  if (isStatefulComponent(i2))
    return getExposeProxy(i2) || i2.proxy;
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
    $: (i2) => i2,
    $el: (i2) => i2.vnode.el,
    $data: (i2) => i2.data,
    $props: (i2) => i2.props,
    $attrs: (i2) => i2.attrs,
    $slots: (i2) => i2.slots,
    $refs: (i2) => i2.refs,
    $parent: (i2) => getPublicInstance(i2.parent),
    $root: (i2) => getPublicInstance(i2.root),
    $emit: (i2) => i2.emit,
    $options: (i2) => resolveMergedOptions(i2),
    $forceUpdate: (i2) => i2.f || (i2.f = () => queueJob(i2.update)),
    $nextTick: (i2) => i2.n || (i2.n = nextTick$1.bind(i2.proxy)),
    $watch: (i2) => instanceWatch.bind(i2)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n2 = accessCache[key];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value2) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value2;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value2;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value2;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray$1(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters: filters2
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$1(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$2(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c3 = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c3.value,
        set: (v2) => c3.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$1(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$1(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$1(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$2(opt)) {
      if ("default" in opt) {
        injected = inject$1(
          opt.from || key,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject$1(opt.from || key);
      }
    } else {
      injected = inject$1(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v2) => injected.value = v2
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$1(raw)) {
    const handler = ctx[raw];
    if (isFunction$1(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$1(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$2(raw)) {
    if (isArray$1(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
    } else {
      const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$1(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base2 = instance.type;
  const { mixins, extends: extendsOptions } = base2;
  const {
    mixins: globalMixins,
    optionsCache: cache2,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache2.get(base2);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base2;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base2, optionMergeStrategies);
  }
  if (isObject$2(base2)) {
    cache2.set(base2, resolved);
  }
  return resolved;
}
function mergeOptions(to, from2, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from2;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m2) => mergeOptions(to, m2, strats, true)
    );
  }
  for (const key in from2) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from2[key]) : from2[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from2) {
  if (!from2) {
    return to;
  }
  if (!to) {
    return from2;
  }
  return function mergedDataFn() {
    return extend$1(
      isFunction$1(to) ? to.call(this, this) : to,
      isFunction$1(from2) ? from2.call(this, this) : from2
    );
  };
}
function mergeInject(to, from2) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from2));
}
function normalizeInject(raw) {
  if (isArray$1(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from2) {
  return to ? [...new Set([].concat(to, from2))] : from2;
}
function mergeObjectOptions(to, from2) {
  return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from2) : from2;
}
function mergeEmitsOrPropsOptions(to, from2) {
  if (to) {
    if (isArray$1(to) && isArray$1(from2)) {
      return [.../* @__PURE__ */ new Set([...to, ...from2])];
    }
    return extend$1(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from2 != null ? from2 : {})
    );
  } else {
    return from2;
  }
}
function mergeWatchOptions(to, from2) {
  if (!to)
    return from2;
  if (!from2)
    return to;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
  for (const key in from2) {
    merged[key] = mergeAsArray(to[key], from2[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render2, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$1(rootComponent)) {
      rootComponent = extend$1({}, rootComponent);
    }
    if (rootProps != null && !isObject$2(rootProps)) {
      rootProps = null;
    }
    const context2 = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app = context2.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context2,
      _instance: null,
      version,
      get config() {
        return context2.config;
      },
      set config(v2) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction$1(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction$1(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else
          ;
        return app;
      },
      mixin(mixin2) {
        {
          if (!context2.mixins.includes(mixin2)) {
            context2.mixins.push(mixin2);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context2.components[name];
        }
        context2.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context2.directives[name];
        }
        context2.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(
            rootComponent,
            rootProps
          );
          vnode.appContext = context2;
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value2) {
        context2.provides[key] = value2;
        return app;
      },
      runWithContext(fn) {
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = null;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value2) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value2;
  }
}
function inject$1(key, defaultValue2, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$1(defaultValue2) ? defaultValue2.call(instance && instance.proxy) : defaultValue2;
    } else
      ;
  }
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value2 = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value2 !== attrs[key]) {
              attrs[key] = value2;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value2,
              instance,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value2 !== attrs[key]) {
            attrs[key] = value2;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value2 = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value2;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value2;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value2 !== attrs[key]) {
          attrs[key] = value2;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value2, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value2 === void 0) {
      const defaultValue2 = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue2)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value2 = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value2 = propsDefaults[key] = defaultValue2.call(
            null,
            props
          );
          unsetCurrentInstance();
        }
      } else {
        value2 = defaultValue2;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value2 = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value2 === "" || value2 === hyphenate(key))) {
        value2 = true;
      }
    }
  }
  return value2;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$1(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      const normalizedKey = camelize(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend$1({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$2(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a8, b3) {
  return getType(a8) === getType(b3);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$1(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type));
  } else if (isFunction$1(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value2) => isArray$1(value2) ? value2.map(normalizeVNode) : [normalizeVNode(value2)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value2 = rawSlots[key];
    if (isFunction$1(value2)) {
      slots[key] = normalizeSlot(key, value2, ctx);
    } else if (value2 != null) {
      const normalized = normalizeSlotValue(value2);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(
        children,
        instance.slots = {}
      );
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$1(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$1(rawRef)) {
    rawRef.forEach(
      (r2, i2) => setRef(
        r2,
        oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i2] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value2 = isUnmount ? null : refValue;
  const { i: owner, r: ref } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref) {
    if (isString$1(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$1(ref)) {
    callWithErrorHandling(ref, owner, 12, [value2, refs]);
  } else {
    const _isString = isString$1(ref);
    const _isRef = isRef(ref);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;
          if (isUnmount) {
            isArray$1(existing) && remove(existing, refValue);
          } else {
            if (!isArray$1(existing)) {
              if (_isString) {
                refs[ref] = [refValue];
                if (hasOwn(setupState, ref)) {
                  setupState[ref] = refs[ref];
                }
              } else {
                ref.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref] = value2;
          if (hasOwn(setupState, ref)) {
            setupState[ref] = value2;
          }
        } else if (_isRef) {
          ref.value = value2;
          if (rawRef.k)
            refs[rawRef.k] = value2;
        } else
          ;
      };
      if (value2) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else
          ;
    }
    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      isSVG,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      isSVG,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        isSVG && type !== "foreignObject",
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el,
            key,
            null,
            props[key],
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          isSVG
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev2 = oldProps[key];
            const next = newProps[key];
            if (next !== prev2 || key === "value") {
              hostPatchProp(
                el,
                key,
                prev2,
                next,
                isSVG,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        isSVG
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              isSVG,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev2 = oldProps[key];
        if (next !== prev2 && key !== "value") {
          hostPatchProp(
            el,
            key,
            prev2,
            next,
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        n2.children,
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          isSVG,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(
      instance,
      initialVNode,
      container,
      anchor,
      parentSuspense,
      isSVG,
      optimized
    );
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m: m2, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            isSVG
          );
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u: u2, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
      // track it in component's effect scope
    );
    const update = instance.update = () => effect.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c12 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c22 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c12,
          c22,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c12,
          c22,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c12, parentComponent, parentSuspense);
      }
      if (c22 !== c12) {
        hostSetElementText(container, c22);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c12,
            c22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c12, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c12, c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c12 = c12 || EMPTY_ARR;
    c22 = c22 || EMPTY_ARR;
    const oldLength = c12.length;
    const newLength = c22.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c22[i2] = optimized ? cloneIfMounted(c22[i2]) : normalizeVNode(c22[i2]);
      patch(
        c12[i2],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c12,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c22,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c12, c22, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c22.length;
    let e12 = c12.length - 1;
    let e22 = l2 - 1;
    while (i2 <= e12 && i2 <= e22) {
      const n1 = c12[i2];
      const n2 = c22[i2] = optimized ? cloneIfMounted(c22[i2]) : normalizeVNode(c22[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e12 && i2 <= e22) {
      const n1 = c12[e12];
      const n2 = c22[e22] = optimized ? cloneIfMounted(c22[e22]) : normalizeVNode(c22[e22]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e12--;
      e22--;
    }
    if (i2 > e12) {
      if (i2 <= e22) {
        const nextPos = e22 + 1;
        const anchor = nextPos < l2 ? c22[nextPos].el : parentAnchor;
        while (i2 <= e22) {
          patch(
            null,
            c22[i2] = optimized ? cloneIfMounted(c22[i2]) : normalizeVNode(c22[i2]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          i2++;
        }
      }
    } else if (i2 > e22) {
      while (i2 <= e12) {
        unmount(c12[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e22; i2++) {
        const nextChild = c22[i2] = optimized ? cloneIfMounted(c22[i2]) : normalizeVNode(c22[i2]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j2;
      let patched = 0;
      const toBePatched = e22 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++)
        newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e12; i2++) {
        const prevChild = c12[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j2 = s2; j2 <= e22; j2++) {
            if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c22[j2])) {
              newIndex = j2;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c22[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j2 = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c22[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c22[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
            move(nextChild, container, anchor, 2);
          } else {
            j2--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          optimized,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render2 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render: render2,
    hydrate,
    createApp: createAppAPI(render2, hydrate)
  };
}
function toggleRecurse({ effect, update }, allowed) {
  effect.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$1(ch1) && isArray$1(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c12 = ch1[i2];
      let c22 = ch2[i2];
      if (c22.shapeFlag & 1 && !c22.dynamicChildren) {
        if (c22.patchFlag <= 0 || c22.patchFlag === 32) {
          c22 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c22.el = c12.el;
        }
        if (!shallow)
          traverseStaticChildren(c12, c22);
      }
      if (c22.type === Text) {
        c22.el = c12.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j2, u2, v2, c3;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j2 = result[result.length - 1];
      if (arr[j2] < arrI) {
        p2[i2] = j2;
        result.push(i2);
        continue;
      }
      u2 = 0;
      v2 = result.length - 1;
      while (u2 < v2) {
        c3 = u2 + v2 >> 1;
        if (arr[result[c3]] < arrI) {
          u2 = c3 + 1;
        } else {
          v2 = c3;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i2] = result[u2 - 1];
        }
        result[u2] = i2;
      }
    }
  }
  u2 = result.length;
  v2 = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v2;
    v2 = p2[v2];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value2) {
  isBlockTreeEnabled += value2;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
      /* isBlock */
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function isVNode(value2) {
  return value2 ? value2.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref,
  ref_key,
  ref_for
}) => {
  if (typeof ref === "number") {
    ref = "" + ref;
  }
  return ref != null ? isString$1(ref) || isRef(ref) || isFunction$1(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$1(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$1(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$2(style)) {
      if (isProxy(style) && !isArray$1(style)) {
        style = extend$1({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$2(type) ? 4 : isFunction$1(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend$1({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref ? isArray$1(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$1(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$1(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$1(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit2.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
{
  if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {
    globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];
  }
  globalCurrentInstanceSetters.push((i2) => currentInstance = i2);
  internalSetCurrentInstance = (instance) => {
    if (globalCurrentInstanceSetters.length > 1) {
      globalCurrentInstanceSetters.forEach((s2) => s2(instance));
    } else {
      globalCurrentInstanceSetters[0](instance);
    }
  };
}
const setCurrentInstance = (instance) => {
  internalSetCurrentInstance(instance);
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [instance.props, setupContext]
    );
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e3) => {
          handleError(e3, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$1(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$2(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$1(
          extend$1(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(
    instance.attrs,
    {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      }
    }
  ));
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      get attrs() {
        return getAttrsProxy(instance);
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
function getComponentName(Component, includeInferred = true) {
  return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function isClassComponent(value2) {
  return isFunction$1(value2) && "__vccOpts" in value2;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h(type, propsOrChildren, children) {
  const l2 = arguments.length;
  if (l2 === 2) {
    if (isObject$2(propsOrChildren) && !isArray$1(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l2 > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l2 === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject$1(ssrContextKey);
    return ctx;
  }
};
const version = "3.3.4";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value2, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value2 = (value2 ? [value2, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value2 == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value2);
  } else {
    el.className = value2;
  }
}
function patchStyle(el, prev2, next) {
  const style = el.style;
  const isCssString = isString$1(next);
  if (next && !isCssString) {
    if (prev2 && !isString$1(prev2)) {
      for (const key in prev2) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev2 !== next) {
        style.cssText = next;
      }
    } else if (prev2) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray$1(val)) {
    val.forEach((v2) => setStyle(style, name, v2));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value2, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value2 == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value2);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value2 == null || isBoolean2 && !includeBooleanAttr(value2)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean2 ? "" : value2);
    }
  }
}
function patchDOMProp(el, key, value2, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value2 == null ? "" : value2;
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    el._value = value2;
    const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
    const newValue = value2 == null ? "" : value2;
    if (oldValue !== newValue) {
      el.value = newValue;
    }
    if (value2 == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value2 === "" || value2 == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value2 = includeBooleanAttr(value2);
    } else if (value2 == null && type === "string") {
      value2 = "";
      needRemove = true;
    } else if (type === "number") {
      value2 = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value2;
  } catch (e3) {
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener$1(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener$1(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener$1(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener$1(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m2;
    while (m2 = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e3) => {
    if (!e3._vts) {
      e3._vts = Date.now();
    } else if (e3._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e3, invoker.value),
      instance,
      5,
      [e3]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e3, value2) {
  if (isArray$1(value2)) {
    const originalStop = e3.stopImmediatePropagation;
    e3.stopImmediatePropagation = () => {
      originalStop.call(e3);
      e3._stopped = true;
    };
    return value2.map((fn) => (e22) => !e22._stopped && fn && fn(e22));
  } else {
    return value2;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(
      el,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value2, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction$1(value2)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString$1(value2)) {
    return false;
  }
  return key in el;
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
Transition.props = /* @__PURE__ */ extend$1(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const callHook = (hook, args = []) => {
  if (isArray$1(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done2) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done2 && done2();
  };
  const finishLeave = (el, done2) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done2 && done2();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done2) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done2);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$1(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done2) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done2);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$2(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n2 = NumberOf(duration);
    return [n2, n2];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c3) => c3 && el.classList.add(c3));
  (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c3) => c3 && el.classList.remove(c3));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e3) => {
    if (e3.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d2, i2) => toMs(d2) + toMs(delays[i2])));
}
function toMs(s2) {
  return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction$1(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function normalizeContainer(container) {
  if (isString$1(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
const _hoisted_1$c = {
  id: "tooltips",
  style: {
    "position": "absolute",
    "top": "0",
    "left": "0"
  }
};
function render(_ctx, _cache) {
  return openBlock(), createElementBlock(
    "div",
    {},
    [(openBlock(true), createElementBlock(
      Fragment,
      null,
      renderList(_ctx.fixedGui, (ui) => {
        return openBlock(), createElementBlock(
          Fragment,
          null,
          [ui.display ? (openBlock(), createBlock(
            resolveDynamicComponent(ui.name),
            normalizeProps(mergeProps({
              key: 0,
              style: {
                pointerEvents: "auto"
              }
            }, ui.data)),
            null,
            16
            /* FULL_PROPS */
          )) : createCommentVNode("v-if", true)],
          64
          /* STABLE_FRAGMENT */
        );
      }),
      256
      /* UNKEYED_FRAGMENT */
    )), createBaseVNode("div", _hoisted_1$c, [(openBlock(true), createElementBlock(
      Fragment,
      null,
      renderList(_ctx.attachedGui, (ui) => {
        return openBlock(), createElementBlock(
          Fragment,
          null,
          [ui.display ? (openBlock(true), createElementBlock(
            Fragment,
            {
              key: 0
            },
            renderList(_ctx.tooltipFilter(_ctx.tooltips, ui), (tooltip) => {
              return openBlock(), createElementBlock(
                "div",
                {
                  style: normalizeStyle(_ctx.tooltipPosition(tooltip.position))
                },
                [(openBlock(), createBlock(
                  resolveDynamicComponent(ui.name),
                  mergeProps({
                    ...ui.data,
                    spriteData: tooltip,
                    style: {
                      pointerEvents: "auto"
                    }
                  }, {
                    ref_for: true,
                    ref: ui.name
                  }),
                  null,
                  16
                  /* FULL_PROPS */
                ))],
                4
                /* STYLE */
              );
            }),
            256
            /* UNKEYED_FRAGMENT */
          )) : createCommentVNode("v-if", true)],
          64
          /* STABLE_FRAGMENT */
        );
      }),
      256
      /* UNKEYED_FRAGMENT */
    ))])],
    32
    /* HYDRATE_EVENTS */
  );
}
class VueGui {
  constructor(rootEl, parentGui) {
    this.parentGui = parentGui;
    this.clientEngine = parentGui.clientEngine;
    this.renderer = this.clientEngine.renderer;
    this.gameEngine = this.clientEngine.gameEngine;
    const {
      gui
    } = parentGui;
    const obj = {
      render,
      data() {
        return {
          gui: {},
          tooltips: []
        };
      },
      provide: () => {
        return parentGui.getInjectObject();
      },
      computed: {
        fixedGui() {
          return Object.values(this.gui).filter((gui2) => !gui2.attachToSprite);
        },
        attachedGui() {
          return Object.values(this.gui).filter((gui2) => gui2.attachToSprite);
        }
      },
      methods: {
        tooltipPosition: parentGui.tooltipPosition.bind(parentGui),
        tooltipFilter: parentGui.tooltipFilter.bind(parentGui)
      }
    };
    this.app = createApp(obj);
    const guiVue = Object.values(gui).filter((ui) => !isFunction$5(ui));
    for (let ui of guiVue) {
      this.app.component(ui.name, ui.gui);
    }
    this.app.directive("propagate", {
      mounted: (el, binding2) => {
        el.eventListeners = {};
        EVENTS_MAP.MouseEvent.forEach((eventType) => {
          const callback = (ev) => {
            this.renderer.propagateEvent(ev);
          };
          el.eventListeners[eventType] = callback;
          el.addEventListener(eventType, callback);
        });
      },
      unmounted(el, binding2) {
        EVENTS_MAP.MouseEvent.forEach((eventType) => {
          const callback = el.eventListeners[eventType];
          if (callback) {
            el.removeEventListener(eventType, callback);
          }
        });
      }
    });
    this.vm = this.app.mount(rootEl);
    this.renderer.app = this.app;
    this.renderer.vm = this.vm;
  }
  _setSceneReady() {
    var _a;
    this.parentGui.listenTooltipObjects.subscribe((tooltips) => {
      this.vm.tooltips = [...tooltips];
    });
    (_a = this.parentGui.currentScene) == null ? void 0 : _a.objectsMoving.next({});
  }
  set gui(val) {
    for (let key in val) {
      if (val[key].isFunction)
        continue;
      this.vm.gui[key] = val[key];
    }
    this.vm.gui = Object.assign({}, this.vm.gui);
  }
}
const {
  elementToPositionAbsolute: elementToPositionAbsolute$1
} = Utils$1;
const COMPONENT_LIBRARIES = [VueGui];
class Gui {
  constructor() {
    this.gui = {};
    this.currentScene = null;
    this.librariesInstances = [];
  }
  async _initialize(context2, guiEl) {
    var _a;
    this.clientEngine = context2.inject(RpgClientEngine$2);
    this.renderer = context2.inject(RpgRenderer);
    this.gameEngine = context2.inject(GameEngineClient);
    const {
      gui
    } = this.renderer.options;
    for (let ui of gui) {
      let name = ui.name;
      if (isFunction$5(ui)) {
        name = camelToKebab(name);
      }
      this.gui[name] = {
        data: ui.data,
        attachToSprite: ui.rpgAttachToSprite,
        display: false,
        name,
        isFunction: isFunction$5(ui),
        gui: ui
      };
    }
    if ((_a = this.clientEngine.envs) == null ? void 0 : _a["VITE_REACT"]) {
      COMPONENT_LIBRARIES.push(await __vitePreload(() => import("./React-9ac52c66.js"), true ? [] : void 0).then((m2) => m2.ReactGui));
    }
    for (let componentClass of COMPONENT_LIBRARIES) {
      const el = document.createElement("div");
      elementToPositionAbsolute$1(el);
      el.style["pointer-events"] = "none";
      guiEl.appendChild(el);
      this.librariesInstances.push(new componentClass(el, this));
    }
    guiEl.style["pointer-events"] = "none";
  }
  _setSceneReady(scene) {
    this.currentScene = scene;
    this.librariesInstances.forEach((instance) => {
      if (instance._setSceneReady)
        instance._setSceneReady(scene);
    });
  }
  getInjectObject() {
    const self2 = this;
    return {
      /**
       * Recovery of the current scene
       *
       * ```js
       * export default {
       *      inject: ['rpgScene'],
       *      mounted() {
       *          const scene = this.rpgScene()
       *          scene.stopInputs()
       *      }
       * }
       * ```
       *
       * @prop {Function returns RpgScene} [rpgScene]
       * @memberof VueInject
       * */
      rpgScene: this.renderer.getScene.bind(this.renderer),
      /**
      * Retrieve the main container of the game
      *
      * ```js
      * export default {
      *      inject: ['rpgStage'],
      *      mounted() {
      *          const blur = new PIXI.BlurFilter()
                 this.rpgStage.filters = [blur]
      *      }
      * }
      * ```
      *
      * @prop {PIXI.Container} [rpgStage]
      * @memberof VueInject
      * */
      rpgStage: this.renderer.stage,
      /**
       * Listen to all the objects present in the room (events and players)
       *
       * ```js
       * export default {
       *      inject: ['rpgObjects'],
       *      mounted() {
       *          this.obs = this.rpgObjects.subscribe((objects) => {
       *              for (let id in objects) {
       *                  const obj = objects[id]
       *                  console.log(obj.object, obj.paramsChanged)
       *              }
       *          })
       *      },
       *      unmounted() {
       *          this.obs.unsubscribe()
       *      }
       * }
       * ```
       *
       * > remember to unsubscribe for memory leaks
       *
       * It is an observable that returns an object:
       *
       * * the key is the object identifier
       * * The value is an object comprising:
       *      * `object`: The entire object
       *      * `paramsChanged`: Only the representation of the properties that have been changed on this object
       *
       * @prop {Observable<{ [objectId]: { object: object, paramsChanged: object } }>} [rpgObjects]
       * @memberof VueInject
       * */
      rpgObjects: this.clientEngine.objects,
      /**
       * Recovers and listens to the current player
       *
       * ```js
       * export default {
       *      inject: ['rpgCurrentPlayer'],
       *      mounted() {
       *          this.obs = this.rpgCurrentPlayer.subscribe((obj) => {
       *              console.log(obj.object, obj.paramsChanged)
       *          })
       *      },
       *      unmounted() {
       *          this.obs.unsubscribe()
       *      }
       * }
       * ```
       *
       * * `object`: The whole player
       * * `paramsChanged`: Only the representation of the properties that have been changed on this player
       *
       * @prop {Observable<{ object: object, paramsChanged: object }>} [rpgCurrentPlayer]
       * @memberof VueInject
       * */
      rpgCurrentPlayer: this.clientEngine.objects.pipe(map$7((objects) => objects[this.gameEngine.playerId]), filter$1((player) => !!player)),
      rpgGameEngine: this.gameEngine,
      /**
       * Tell the server to close the GUI.
       *
       * It is a function with 2 parameters:
       * * `name`: The name of the component
       * * `data`: The data you want to pass to the server
       *
       * ```js
       * export default {
       *      inject: ['rpgGuiClose'],
       *      methods: {
       *          close() {
       *              this.rpgGuiClose('gui-name', {
       *                  amount: 1000
       *              })
       *          }
       *      }
       * }
       * ```
       *
       * @prop {Function(name, data)} [rpgGuiClose]
       * @memberof VueInject
       * */
      rpgGuiClose(name, data) {
        var _a;
        const guiId = name || ((_a = this.$options) == null ? void 0 : _a.name);
        self2.socket.emit("gui.exit", {
          guiId,
          data
        });
      },
      /**
       * Perform an interaction with the open GUI
       *
       * It is a function with 2 parameters:
       * * `guiId`: The name of the component/Gui
       * * `name`: The name of the interaction (defined on the server side)
       * * `data`: Data to be sent
       *
       * ```js
       * export default {
       *      inject: ['rpgGuiInteraction'],
       *      methods: {
       *          changeGold() {
       *              this.rpgGuiInteraction('gui-name', 'change-gold', {
       *                  amount: 100
       *              })
       *          }
       *      }
       * }
       * ```
       *
       * @prop {Function(guiId, name, data = {})} [rpgGuiInteraction]
       * @memberof VueInject
       * */
      rpgGuiInteraction: (guiId, name, data = {}) => {
        this.socket.emit("gui.interaction", {
          guiId,
          name,
          data
        });
      },
      /**
       * Listen to the keys that are pressed on the keyboard
       *
       * ```js
       * export default {
       *      inject: ['rpgKeypress'],
       *      mounted() {
       *          this.obs = this.rpgKeypress.subscribe(({ inputName, control }) => {
       *              console.log(inputName) // "escape"
       *              console.log(control.actionName) // "back"
       *          })
       *      },
       *      unmounted() {
       *          this.obs.unsubscribe()
       *      }
       * }
       * ```
       *
       * @prop {Observable<{ inputName: string, control: { actionName: string, options: any } }>} [rpgKeypress]
       * @memberof VueInject
       * */
      rpgKeypress: this.clientEngine.keyChange.pipe(map$7((name) => {
        const control = this.clientEngine.controls.getControl(name);
        return {
          inputName: name,
          control
        };
      })),
      /**
       * Recovers the socket.
       *
       * ```js
       * export default {
       *      inject: ['rpgSocket'],
       *      mounted() {
       *          const socket = this.rpgSocket()
       *          socket.emit('foo', 'bar')
       *      }
       * }
       * ```
       *
       * @prop {Function returns RpgScene} [rpgSocket]
       * @memberof VueInject
       * */
      rpgSocket: () => this.socket,
      /**
       * The RpgGui object to control GUIs
       *
       * ```js
       * export default {
       *      inject: ['rpgGui'],
       *      mounted() {
       *         const guis = this.rpgGui.getAll()
       *      }
       * }
       * ```
       *
       * @prop {RpgGui} [rpgGui]
       * @memberof VueInject
       * */
      rpgGui: this,
      /**
       * Equivalent to RpgSound
       *
       * ```js
       * export default {
       *      inject: ['rpgSound'],
       *      mounted() {
       *         this.rpgSound.get('my-sound-id').play()
       *      }
       * }
       * ```
       *
       * @prop {RpgSound} [rpgSound]
       * @memberof VueInject
       * */
      rpgSound: RpgSound,
      /**
       * Find the game's image and sound library
       *
       * ```js
       * export default {
       *      inject: ['rpgResource'],
       *      mounted() {
       *         const resourceImage = this.rpgResource.spritesheets.get('image_id')
       *         const resourceSound = this.rpgResource.sounds.get('sound_id')
       *      }
       * }
       * ```
       *
       * @prop { { spritesheets: Map, sounds: Map } } [rpgResource]
       * @memberof VueInject
       * */
      rpgResource: RpgResource,
      /**
       * Get RpgClientEngine instance
       *
       * ```js
       * export default {
       *      inject: ['rpgEngine'],
       *      mounted() {
       *         const vueInstance = this.rpgEngine.vueInstance
       *      }
       * }
       * ```
       *
       * @prop {RpgClientEngine} [rpgEngine]
       * @memberof VueInject
       * */
      rpgEngine: this.clientEngine
    };
  }
  /** @internal */
  _setSocket(socket) {
    this.socket = socket;
    this.socket.on("gui.open", ({
      guiId,
      data
    }) => {
      this.display(guiId, data);
    });
    this.socket.on("gui.tooltip", ({
      players,
      display
    }) => {
      var _a;
      for (let playerId of players) {
        const sprite = (_a = this.renderer.getScene()) == null ? void 0 : _a.getSprite(playerId);
        if (sprite)
          sprite.guiDisplay = display;
      }
    });
    this.socket.on("gui.exit", (guiId) => {
      this.hide(guiId);
    });
  }
  /** @internal */
  _setGui(id, obj) {
    const guiObj = this.get(id);
    if (!guiObj) {
      throw `The GUI named ${id} is non-existent. Please add the component in the gui property of the decorator @RpgClient`;
    }
    for (let key in obj) {
      guiObj[key] = obj[key];
    }
    this.librariesInstances.forEach((instance) => {
      instance.gui = Object.assign({}, this.gui);
    });
  }
  /**
  * Get a GUI. You retrieve GUI data and information whether it is displayed or not
  *
  * ```ts
  * import { RpgGui } from '@rpgjs/client'
  *
  * const gui = RpgGui.get('my-gui')
  * console.log(gui.display) // false
  * ```
  *
  * @title Get a GUI
  * @method RpgGui.get(id)
  * @param {string} id
  * @returns { { data: any, display: boolean } }
  * @memberof RpgGui
  */
  get(id) {
    if (typeof id != "string") {
      id = id.name;
    }
    return this.gui[id];
  }
  /**
   * Get all GUI. You retrieve GUI data and information whether it is displayed or not
   *
   * ```ts
   * import { RpgGui } from '@rpgjs/client'
   *
   * const gui = RpgGui.getAll()
   * console.log(gui) // { 'rpg-dialog': { data: {}, display: true } }
   * ```
   *
   * @title Get all GUI
   * @method RpgGui.getAll()
   * @returns { { [guiName]: { data: any, display: boolean }  }}
   * @memberof RpgGui
   */
  getAll() {
    return this.gui;
  }
  /**
   * Checks if the GUI exists RpgClient's gui array
   *
   * ```ts
   * import { RpgGui } from '@rpgjs/client'
   *
   * RpgGui.exists('my-gui') // true
   * ```
   *
   * @title GUI Exists ?
   * @method RpgGui.exists(id)
   * @param {string} id
   * @returns {boolean}
   * @memberof RpgGui
   */
  exists(id) {
    return !!this.get(id);
  }
  /**
   * Calls a GUI according to identifier. You can send retrievable data in the component
   *
   * ```ts
   * import { RpgGui } from '@rpgjs/client'
   *
   * RpgGui.display('my-gui')
   * ```
   *
   * @title Display GUI
   * @method RpgGui.display(id,data)
   * @param {string} id
   * @param {object} [data]
   * @returns {void}
   * @memberof RpgGui
   */
  display(id, data = {}) {
    this._setGui(id, {
      display: true,
      data
    });
  }
  /**
   * Hide a GUI according to its identifier
   *
   * ```ts
   * import { RpgGui } from '@rpgjs/client'
   *
   * RpgGui.hide('my-gui')
   * ```
   *
   * @title Hide GUI
   * @method RpgGui.hide(id)
   * @param {string} id
   * @returns {void}
   * @memberof RpgGui
   */
  hide(id) {
    this._setGui(id, {
      display: false
    });
  }
  /** @internal */
  clear() {
    this.gui = {};
  }
  /** @internal */
  tooltipPosition(position) {
    const scene = this.renderer.getScene();
    const viewport = scene == null ? void 0 : scene.viewport;
    if (viewport) {
      const currentZoom = viewport.scale.x;
      const left = (position.x - viewport.left) * currentZoom;
      const top = (position.y - viewport.top) * currentZoom;
      return {
        transform: `translate(${left}px,${top}px)`
      };
    }
    return {};
  }
  /** @internal */
  tooltipFilter(sprites) {
    return sprites.filter((tooltip) => tooltip.guiDisplay);
  }
  /** @internal */
  get listenTooltipObjects() {
    var _a;
    return combineLatest([this.clientEngine.gameEngine.all, (_a = this.currentScene) == null ? void 0 : _a.objectsMoving]).pipe(map$7(([objects]) => {
      return Object.values(objects).map((obj) => obj.object);
    }));
  }
}
const RpgGui = new Gui();
let Scene$1 = class Scene {
  constructor(context2) {
    this.context = context2;
    this.objects = /* @__PURE__ */ new Map();
    this.animationLayer = new Container();
    this.controls = this.context.inject(KeyboardControls);
    this.animations = [];
    this._data = new BehaviorSubject({
      data: {},
      partial: {}
    });
    this.game = this.context.inject(GameEngineClient);
    this.objectsMoving = new Subject();
    const {
      globalConfig
    } = this.game.clientEngine;
    const mergeInputs = {
      ...DefaultInput,
      ...globalConfig.inputs || {}
    };
    this.controls.setInputs(this.inputs || mergeInputs);
    RpgGui._setSceneReady(this);
  }
  /**
   * Listen to all the synchronized values of the scene with the server
   *
   * ```ts
   * import { RpgClient, RpgModule, RpgSceneMap } from '@rpgjs/client'
   *
   *  @RpgModule<RpgClient>({
          scenes: {
              map: {
                  onAfterLoading(scene: RpgSceneMap) {
                    scene.valuesChange.subscribe((obj) => {
                       console.log(obj.data, obj.partial)
                    })
                  }
              }
          }
      })
      export default class RpgClientModuleEngine {}
   * ```
   *
   * - `data` represents all the current data of the scene (`users`, `events` and others)
   * - `partial` represents only the data that has changed on the scene
   *
   * > In the class, you can also use the onChanges hook
   *
   *
   * @prop {Observable<{ data: object, partial: object }>} [valuesChange]
   * @readonly
   * @memberof RpgScene
   */
  get valuesChange() {
    return this._data.asObservable();
  }
  triggerSpriteChanges(logic, sprite, moving2) {
    if (this.onUpdateObject)
      this.onUpdateObject(logic, sprite, moving2);
    RpgPlugin.emit(HookClient.UpdateSprite, [sprite, logic], true);
  }
  /** @internal */
  update(obj) {
    if (!obj) {
      this.updateScene(this._data.value);
      return;
    }
    this.updateScene(obj);
    RpgPlugin.emit(HookClient.SceneOnChanges, [this, obj], true);
    this._data.next(obj);
  }
  /** @internal */
  draw(time, deltaTime, deltaRatio, frame) {
    const logicObjects = {
      ...this.game.world.getObjects(),
      ...this.game.events,
      ...this.game.getShapes()
    };
    const renderObjects = this.objects;
    const sizeLogic = Object.values(logicObjects).length;
    const objectMoving = {};
    for (let key in logicObjects) {
      const val = logicObjects[key].object;
      const valueChanged = logicObjects[key].paramsChanged;
      if (!renderObjects.has(key)) {
        const sprite = this.addObject(val, key);
        this.triggerSpriteChanges(val, sprite, true);
      } else {
        const object = renderObjects.get(key);
        if (!(object == null ? void 0 : object.update))
          return;
        const ret = object.update(val, valueChanged, time, deltaRatio);
        this.triggerSpriteChanges(val, object, ret.moving);
        if (ret.moving)
          objectMoving[val.id] = val;
      }
    }
    if (sizeLogic < renderObjects.size) {
      renderObjects.forEach((val, key) => {
        if (!logicObjects[key]) {
          this.removeObject(key);
        }
      });
    }
    for (let animation of this.animations) {
      animation.update(deltaRatio);
    }
    this.onDraw(time);
    if (Object.values(objectMoving).length) {
      this.objectsMoving.next(objectMoving);
    }
    RpgPlugin.emit(HookClient.SceneDraw, this);
  }
  /**
   * Display an animation on the scene
   *
   * The object is the following:
   * * `graphic`: Spritesheet id
   * * `animationName`: The name of the animation
   * * `attachTo`: Define a sprite. The animation will follow this sprite (optional)
   * * `x`: Position X (0 by default)
   * * `y`: Position Y (0 by default)
   * * `loop`: Display the animation in a loop (false by default)
   *
   * ```ts
   * import { RpgClient, RpgModule, RpgSceneMap } from '@rpgjs/client'
   *
    * @RpgModule<RpgClient>({
          scenes: {
              map: {
                  onAfterLoading(scene: RpgSceneMap) {
                      const animation = scene.showAnimation({
                          graphic: 'my-spritesheet',
                          animationName: 'my-anim'
                      })
                  }
              }
          }
      })
      export default class RpgClientModuleEngine {}
   * ```
   *
   * The return is an animation containing two methods:
   * * `play()`: Play the animation (Already the case when calling the method)
   * * `stop()`: Stop the animation
   *
   * They have a hook:
   *
   * `onFinish`: Triggered when the animation is finished
   *
   * ```ts
   * animation.onFinish = () => {
   *      console.log('finish !')
   * }
   * ```
   *
   * @title Show Animation
   * @method scene.showAnimation(object)
   * @param {object} object
   * @returns {Animation}
   * @memberof RpgScene
   */
  showAnimation({
    graphic,
    animationName,
    attachTo,
    x: x2 = 0,
    y: y2 = 0,
    loop = false,
    replaceGraphic = false
  }) {
    if (replaceGraphic && attachTo) {
      attachTo.showAnimation(graphic, animationName);
      return;
    }
    const animation = new Animation(graphic);
    this.animationLayer.addChild(animation);
    if (!loop) {
      animation.onFinish = () => {
        animation.stop();
      };
    }
    if (attachTo) {
      animation.attachTo = attachTo;
    } else {
      animation.x = x2;
      animation.y = y2;
    }
    animation.play(animationName);
    this.animations.push(animation);
    return animation;
  }
  /**
  * Retrieve a sprite according to its identifier
  *
  * @title Get Sprite
  * @method scene.getSprite(id)
  * @param {string} id
  * @returns {RpgSprite | undefined}
  * @memberof RpgScene
  */
  getSprite(id) {
    return this.getPlayer(id);
  }
  getPlayer(id) {
    return this.objects.get(id);
  }
  /**
  * Retrieve a sprite that the player controls
  *
  * @title Get Current Player
  * @method scene.getCurrentPlayer()
  * @returns {RpgSprite | undefined}
  * @memberof RpgScene
  */
  getCurrentPlayer() {
    return this.objects.get(this.game.playerId);
  }
  // Hooks
  onInit() {
  }
  onLoad() {
  }
  onChanges(obj) {
  }
  onDraw(t2) {
  }
  onAddSprite(sprite) {
  }
  onRemoveSprite(sprite) {
  }
};
const {
  capitalize
} = Utils$1;
class Character extends Sprite {
  constructor(component, graphic) {
    super();
    this.component = component;
    this.graphic = graphic;
    this.playStandardAnimation = true;
    this.objSaved = {};
    this.data = {};
    this.h = 1;
    this.w = 1;
    this.data = component.logic;
    this.setGraphic(graphic);
  }
  /** @internal */
  showAnimation(graphic, animationName) {
    const refreshAnimation = (graphic2) => {
      this.removeChild(this.animation);
      this.animation = new Animation(graphic2);
      this.addChild(this.animation);
      this.setAnimationAnchor();
    };
    const memoryGraphic = this.graphic;
    let graphicId = "";
    if (isArray$8(graphic)) {
      graphicId = graphic.find((id) => id == this.graphic);
    } else {
      graphicId = graphic;
    }
    if (!graphicId) {
      return null;
    }
    refreshAnimation(graphicId);
    this.component.animationIsPlaying = true;
    this.animation.onFinish = () => {
      this.playStandardAnimation = true;
      this.component.animationIsPlaying = false;
      refreshAnimation(memoryGraphic);
      this.update(this.objSaved);
    };
    this.playStandardAnimation = false;
    this.playAnimation(animationName);
    return this.animation;
  }
  /** @internal */
  setGraphic(graphic) {
    this.children.forEach((graphic2, index2) => {
      if (graphic2.id == this.graphic) {
        this.removeChildAt(index2);
      }
    });
    this.graphic = graphic;
    this.spritesheet = spritesheets.get(this.graphic);
    this.animation = new Animation(this.graphic);
    this.addChild(this.animation);
    this.setAnimationAnchor();
  }
  getGraphicHeight() {
    return this.animation.getSpriteHeight();
  }
  getGraphicWidth() {
    return this.animation.getSpriteWidth();
  }
  animationSprite() {
    return this.animation.animation$;
  }
  setAnimationAnchor() {
    this.animation.hitbox = {
      h: this.data.hHitbox,
      w: this.data.wHitbox
    };
    this.animation.applyTransform = (frame, animation, spritesheet) => {
      const {
        spriteWidth,
        spriteHeight
      } = animation;
      const prop = "spriteRealSize";
      const currentAnchor = frame[prop] || animation[prop] || spritesheet[prop];
      if (currentAnchor) {
        return {};
      }
      return {
        spriteRealSize: {
          width: spriteWidth,
          height: spriteHeight
        }
      };
    };
  }
  /** @internal */
  update(obj, options = {}, deltaRatio = 1) {
    const {
      moving: moving2
    } = options;
    this.data = obj;
    if (this.anim)
      this.anim.update(deltaRatio);
    if (this.animation)
      this.animation.update(deltaRatio);
    if (this.playStandardAnimation) {
      if (moving2) {
        RpgPlugin.emit(HookClient.SpriteMove, this);
        this.playAnimation(Animation$1.Walk);
      } else {
        this.playAnimation(Animation$1.Stand);
      }
    }
    this.objSaved = obj;
    return {
      moving: moving2,
      instance: this
    };
  }
  /** @internal */
  playAnimation(name) {
    const hook = `onCharacter${capitalize(name)}`;
    if (!this.spritesheet)
      return;
    if (this.spritesheet[hook]) {
      this.spritesheet[hook](this);
    } else if (this.animation.has(name)) {
      this.animation.play(name, [this.data.direction]);
    }
  }
}
Character.id = "graphic";
class RpgSprite extends Character {
}
var FUNC_ERROR_TEXT = "Expected a function";
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var INFINITY = 1 / 0;
var funcTag = "[object Function]", genTag = "[object GeneratorFunction]", symbolTag = "[object Symbol]";
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reEscapeChar = /\\(\\)?/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function isHostObject(value2) {
  var result = false;
  if (value2 != null && typeof value2.toString != "function") {
    try {
      result = !!(value2 + "");
    } catch (e3) {
    }
  }
  return result;
}
var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
var Symbol$1 = root.Symbol, splice = arrayProto.splice;
var Map$1 = getNative(root, "Map"), nativeCreate = getNative(Object, "create");
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function Hash(entries) {
  var index2 = -1, length2 = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : void 0;
}
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
}
function hashSet(key, value2) {
  var data = this.__data__;
  data[key] = nativeCreate && value2 === void 0 ? HASH_UNDEFINED : value2;
  return this;
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function ListCache(entries) {
  var index2 = -1, length2 = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function listCacheClear() {
  this.__data__ = [];
}
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value2) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    data.push([key, value2]);
  } else {
    data[index2][1] = value2;
  }
  return this;
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function MapCache(entries) {
  var index2 = -1, length2 = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function mapCacheClear() {
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function mapCacheDelete(key) {
  return getMapData(this, key)["delete"](key);
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value2) {
  getMapData(this, key).set(key, value2);
  return this;
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function assocIndexOf(array2, key) {
  var length2 = array2.length;
  while (length2--) {
    if (eq(array2[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
function baseGet(object, path2) {
  path2 = isKey(path2, object) ? [path2] : castPath(path2);
  var index2 = 0, length2 = path2.length;
  while (object != null && index2 < length2) {
    object = object[toKey(path2[index2++])];
  }
  return index2 && index2 == length2 ? object : void 0;
}
function baseIsNative(value2) {
  if (!isObject$1(value2) || isMasked(value2)) {
    return false;
  }
  var pattern = isFunction(value2) || isHostObject(value2) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value2));
}
function baseToString(value2) {
  if (typeof value2 == "string") {
    return value2;
  }
  if (isSymbol(value2)) {
    return symbolToString ? symbolToString.call(value2) : "";
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
}
function castPath(value2) {
  return isArray(value2) ? value2 : stringToPath(value2);
}
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function getNative(object, key) {
  var value2 = getValue(object, key);
  return baseIsNative(value2) ? value2 : void 0;
}
function isKey(value2, object) {
  if (isArray(value2)) {
    return false;
  }
  var type = typeof value2;
  if (type == "number" || type == "symbol" || type == "boolean" || value2 == null || isSymbol(value2)) {
    return true;
  }
  return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object != null && value2 in Object(object);
}
function isKeyable(value2) {
  var type = typeof value2;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
}
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var stringToPath = memoize(function(string) {
  string = toString$3(string);
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, string2) {
    result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
function toKey(value2) {
  if (typeof value2 == "string" || isSymbol(value2)) {
    return value2;
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
}
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e3) {
    }
    try {
      return func + "";
    } catch (e3) {
    }
  }
  return "";
}
function memoize(func, resolver) {
  if (typeof func != "function" || resolver && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
function eq(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var isArray = Array.isArray;
function isFunction(value2) {
  var tag = isObject$1(value2) ? objectToString.call(value2) : "";
  return tag == funcTag || tag == genTag;
}
function isObject$1(value2) {
  var type = typeof value2;
  return !!value2 && (type == "object" || type == "function");
}
function isObjectLike(value2) {
  return !!value2 && typeof value2 == "object";
}
function isSymbol(value2) {
  return typeof value2 == "symbol" || isObjectLike(value2) && objectToString.call(value2) == symbolTag;
}
function toString$3(value2) {
  return value2 == null ? "" : baseToString(value2);
}
function get(object, path2, defaultValue2) {
  var result = object == null ? void 0 : baseGet(object, path2);
  return result === void 0 ? defaultValue2 : result;
}
var lodash_get = get;
const get$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodash_get);
const REGEXP_VAR = /{([^\}]+)}/g;
class AbstractComponent extends Container {
  constructor(component, value2) {
    var _a;
    super();
    this.component = component;
    this.value = value2;
    this._onRender$ = new Subject();
    this._onDestroy$ = new Subject();
    this.onRender$ = this._onRender$.asObservable();
    this.game = this.component.game;
    this.firstRender = true;
    this.style = (_a = this.value) == null ? void 0 : _a.style;
    this.cacheText = {};
  }
  getStyle() {
    return this.style || {};
  }
  parseTextAndCache(text) {
    const matches = text.matchAll(REGEXP_VAR);
    this.cacheParams = [...this.cacheParams, ...Array.from(matches).map((match) => match[1])];
    return this.cacheParams;
  }
  replaceText(object, text) {
    return text.replace(REGEXP_VAR, (match, key) => {
      const value2 = get$1(object, key);
      if (value2 !== void 0) {
        this.cacheText[key] = value2;
        return value2 ?? "";
      }
      return value2 ?? this.cacheText[key] ?? "";
    });
  }
  getValue(object, expression) {
    if (typeof expression === "string") {
      const value2 = get$1(object, expression);
      if (value2 !== void 0) {
        if (this.cacheParams.indexOf(expression) === -1)
          this.cacheParams.push(expression);
        return value2;
      }
    }
    return expression;
  }
  verifyParams() {
    var _a;
    const params = this.component.logic;
    for (const param of this.cacheParams) {
      if (get$1(params, param) === void 0) {
        throw new Error(`Param ${param} not found in object ${(_a = this.component.logic) == null ? void 0 : _a.id}`);
      }
    }
  }
  onInit(cell) {
    var _a;
    this.cell = cell;
    this.verifyParams();
    const render2 = (object) => {
      const opacity = this.getValue(object, this.getStyle().opacity || this.value.opacity);
      if (opacity !== void 0) {
        this.alpha = Math.min(opacity, 1);
      }
    };
    render2(this.component.logic);
    const objectId = (_a = this.component.logic) == null ? void 0 : _a.id;
    this.game.listenObject(objectId).pipe(takeUntil(this._onDestroy$), filter$1((object) => {
      const params = object == null ? void 0 : object.paramsChanged;
      if (!params)
        return false;
      for (const param of this.cacheParams) {
        if (get$1(params, param))
          return true;
      }
      return false;
    })).subscribe(({
      object
    }) => {
      this.updateRender(object, this.firstRender);
      render2(object);
      this.firstRender = false;
      this._onRender$.next(this);
    });
  }
  onRemove() {
    this._onDestroy$.next();
    this._onDestroy$.complete();
  }
}
const DEFAULT_COLOR = "#000000";
class BarComponent extends AbstractComponent {
  constructor() {
    var _a;
    super(...arguments);
    this.barContainer = new Graphics();
    this.barFill = new Graphics();
    this.textContainer = new Text$1("");
    this.barHeight = ((_a = this.value.style) == null ? void 0 : _a.height) || 7;
    this.text = this.value.text || "";
    this.barStyle = this.getStyle();
    this.currentValue = 0;
    this.maxValue = 0;
    this.nextValue = 0;
    this.notifier = new Subject();
    this.cacheParams = [];
  }
  get barWidth() {
    var _a, _b;
    return ((_a = this.barStyle) == null ? void 0 : _a.width) || ((_b = this.cell) == null ? void 0 : _b.width) || 0;
  }
  onInit(cell) {
    if (!this.value.style) {
      this.value.style = {
        fillColor: "#ffffff"
      };
    }
    const {
      bgColor = DEFAULT_COLOR,
      borderColor = DEFAULT_COLOR,
      borderWidth = 1,
      borderRadius = 0
    } = this.barStyle || {};
    this.cell = cell;
    const {
      value: color,
      alpha
    } = hexaToNumber(bgColor);
    this.barContainer.beginFill(color, alpha);
    const paramsRect = [0, 0, this.barWidth, this.barHeight];
    if (borderWidth) {
      const {
        value: color2,
        alpha: alpha2
      } = hexaToNumber(borderColor);
      this.barContainer.lineStyle(borderWidth, color2, alpha2);
    }
    if (borderRadius) {
      this.barContainer.drawRoundedRect(...paramsRect, borderRadius);
    } else {
      this.barContainer.drawRect(...paramsRect);
    }
    this.barContainer.endFill();
    this.textContainer.style = {
      fontSize: 10,
      fill: "#ffffff",
      fontWeight: "bold"
    };
    this.textContainer.y -= this.barHeight + this.textContainer.height - 5;
    if (this.text)
      this.addChild(this.textContainer);
    this.addChild(this.barContainer);
    this.barContainer.addChild(this.barFill);
    this.cacheParams = [this.value.current, this.value.max];
    this.updateRender(this.component.logic, true);
    this.firstRender = false;
    super.onInit(cell);
  }
  updateRender(object, firstRender) {
    this.currentValue = this.nextValue;
    this.nextValue = get$1(object, this.value.current) ?? this.nextValue ?? 0;
    this.maxValue = get$1(object, this.value.max) ?? this.maxValue;
    const style = this.barStyle;
    const borderRadius = (style == null ? void 0 : style.borderRadius) ?? 0;
    const borderWidth = (style == null ? void 0 : style.borderWidth) ?? 0;
    if (firstRender) {
      this.currentValue = this.nextValue;
    }
    const getColor2 = (value2) => {
      let determineLastColor = DEFAULT_COLOR;
      const percent = Math.max(0, value2 / this.maxValue * 100);
      const perPercent = style.perPercent;
      if (perPercent) {
        for (const p2 in perPercent) {
          if (percent <= +p2) {
            determineLastColor = perPercent[p2].fillColor;
            break;
          }
        }
      } else {
        determineLastColor = this.value.style.fillColor;
      }
      return determineLastColor;
    };
    let colors = [];
    if (style) {
      colors = transitionColor(getColor2(this.currentValue), getColor2(this.nextValue), 1);
    } else {
      colors = transitionColor(DEFAULT_COLOR, DEFAULT_COLOR, 1);
    }
    const render2 = (up = false) => {
      let currentValue = ~~this.currentValue;
      if (currentValue < 0)
        currentValue = 0;
      if (currentValue > this.maxValue)
        currentValue = this.maxValue;
      const percentBetween = ~~Math.max(0, (currentValue - this.nextValue) * 100 / this.nextValue);
      const colorIndex = Math.max(Math.floor((100 - percentBetween) / (100 / (colors.length - 1))), 0);
      let fillColor = colors[colorIndex];
      this.barFill.clear();
      const {
        value: color,
        alpha
      } = hexaToNumber(fillColor ?? DEFAULT_COLOR);
      this.barFill.beginFill(color, alpha);
      const percent = Math.max(0, currentValue / this.maxValue);
      const bWidth = borderWidth / 4;
      const paramsRect = [bWidth, bWidth, percent * this.barWidth - bWidth, this.barHeight - bWidth];
      if (percent > 0) {
        if (borderRadius) {
          this.barFill.drawRoundedRect(...paramsRect, borderRadius);
        } else {
          this.barFill.drawRect(...paramsRect);
        }
      }
      this.textContainer.text = this.replaceText({
        ...object,
        $current: currentValue,
        $percent: Math.round(percent * 100),
        $max: this.maxValue
      }, this.text);
      this.barFill.endFill();
    };
    if (firstRender) {
      render2();
      return;
    }
    this.notifier.next();
    this.game.clientEngine.tick.pipe(takeUntil(this.notifier)).subscribe(() => {
      const speed = Math.abs(this.currentValue - this.nextValue) / 10;
      let up = false;
      if (this.currentValue < this.nextValue) {
        this.currentValue += speed;
        up = true;
      } else if (this.currentValue > this.nextValue) {
        this.currentValue -= speed;
        up = false;
      }
      render2(up);
      const currentValue = Math.round(this.currentValue);
      if (!up && (~~currentValue <= ~~this.nextValue || currentValue <= 0)) {
        this.notifier.next();
      } else if (up && (~~currentValue >= ~~this.nextValue || currentValue >= this.maxValue)) {
        this.notifier.next();
      }
    });
  }
  onRemove() {
    this.notifier.next();
    this.notifier.complete();
    super.onRemove();
  }
}
BarComponent.id = "bar";
class ShapeComponent extends AbstractComponent {
  constructor() {
    super(...arguments);
    this.type = this.value.type;
    this.container = new Graphics();
    this.cacheParams = [];
  }
  onInit(cell) {
    this.cell = cell;
    this.updateRender(this.component.logic);
    this.addChild(this.container);
    super.onInit(cell);
  }
  updateRender(object) {
    var _a, _b;
    const value2 = this.value;
    const height = this.getValue(object, value2.height) ?? ((_a = this.cell) == null ? void 0 : _a.height) ?? 0;
    const width = this.getValue(object, value2.width) ?? ((_b = this.cell) == null ? void 0 : _b.width) ?? 0;
    this.container.clear();
    const {
      value: color,
      alpha
    } = hexaToNumber(this.value.fill);
    this.container.beginFill(color, alpha);
    if (value2.line) {
      const {
        value: color2,
        alpha: alpha2
      } = hexaToNumber(value2.line.color ?? this.value.fill);
      this.container.lineStyle(this.getValue(object, value2.line.width) ?? 1, color2, this.getValue(object, value2.line.alpha) ?? alpha2);
    }
    switch (this.type) {
      case "circle":
        this.container.drawCircle(0, 0, this.getValue(object, value2.radius));
        break;
      case "ellipse":
        this.container.drawEllipse(0, 0, width, height);
        break;
      case "line":
        if (!value2.line) {
          this.container.lineStyle(1, color, alpha);
        }
        this.container.moveTo(this.getValue(object, value2.x1), this.getValue(object, value2.y1));
        this.container.lineTo(this.getValue(object, value2.x2), this.getValue(object, value2.y2));
        break;
      case "polygon":
        this.container.drawPolygon(value2.points);
        break;
      case "rounded-rect":
        this.container.drawRoundedRect(0, 0, width, height, value2.radius);
        break;
      default:
        this.container.drawRect(0, 0, width, height);
        break;
    }
    this.container.endFill();
  }
}
ShapeComponent.id = "shape";
class DebugComponent extends AbstractComponent {
  constructor() {
    super(...arguments);
    this.color = "#ff0000";
    this.cacheParams = ["map", "position.x", "position.y"];
    this.container = new Graphics();
  }
  onInit(cell) {
    this.addChild(this.container);
    this.updateRender(this.component.logic);
    this.eventMode = "static";
    this.on("pointerdown", () => {
      console.log(this.component.logic);
    });
    super.onInit(cell);
  }
  updateRender(object) {
    const hitbox = object.hitbox;
    const {
      pos,
      w: w2,
      h: h2
    } = hitbox;
    this.container.clear();
    const {
      value: color,
      alpha
    } = hexaToNumber(this.color);
    this.container.beginFill(color, alpha);
    this.container.drawRect(0, 0, w2, h2);
    this.container.endFill();
  }
}
DebugComponent.id = "debug";
class ImageComponent extends AbstractComponent {
  constructor() {
    super(...arguments);
    this.cacheParams = [];
    this.source = "";
  }
  onInit(cell) {
    super.onInit(cell);
    this.setImage();
  }
  setImage() {
    if (typeof this.value == "string") {
      this.source = this.value;
    } else {
      this.source = this.value.source;
    }
    this.updateRender({});
  }
  updateRender(object) {
    this.removeChildren();
    const engine = this.component.getScene().game.clientEngine;
    this.addChild(Sprite.from(engine.getResourceUrl(this.source)));
  }
}
ImageComponent.id = "image";
class TextComponent extends AbstractComponent {
  constructor() {
    super(...arguments);
    this.cacheParams = [];
    this.container = new Text$1("");
    this.originValue = "";
  }
  onInit(cell) {
    if (typeof this.value == "string") {
      this.container.text = this.value;
    } else if (this.value.style) {
      this.container.style = this.value.style;
      this.container.text = this.value.text;
    }
    this.container.style = {
      ...this.container.style,
      wordWrapWidth: cell.width
    };
    this.parseTextAndCache(this.container.text);
    this.originValue = this.container.text;
    this.updateRender(this.component.logic);
    this.addChild(this.container);
    super.onInit(cell);
  }
  updateRender(object) {
    this.container.text = this.replaceText(object, this.originValue);
  }
}
TextComponent.id = "text";
class TileComponent extends AbstractComponent {
  constructor() {
    super(...arguments);
    this.cacheParams = [];
    this.gid = 0;
  }
  onInit(cell) {
    this.cell = cell;
    if (typeof this.value == "number") {
      this.gid = this.value;
    } else {
      this.gid = this.value.gid;
    }
    this.updateRender({});
    super.onInit(cell);
  }
  updateRender(object) {
    var _a, _b;
    this.removeChildren();
    const height = typeof this.value != "number" ? this.getValue(object, this.value.height) : ((_a = this.cell) == null ? void 0 : _a.height) ?? 0;
    const width = typeof this.value != "number" ? this.getValue(object, this.value.width) : ((_b = this.cell) == null ? void 0 : _b.width) ?? 0;
    const scene = this.component.getScene();
    const tilemap = scene.tilemap;
    const tileset = TileLayer.findTileSet(this.gid, tilemap.tilesets);
    if (tileset) {
      const tile = new Tile2({
        gid: this.gid
      }, tileset);
      tile.width = width ?? 0;
      tile.height = height ?? 0;
      this.addChild(tile);
    }
  }
}
TileComponent.id = "tile";
const layoutObject = {
  lines: []
};
const layoutTypes = ["top", "bottom", "left", "right"];
class RpgComponent extends Container {
  constructor(data, scene) {
    super();
    this.data = data;
    this.scene = scene;
    this.h = 1;
    this.w = 1;
    this.animationIsPlaying = false;
    this._x = 0;
    this._y = 0;
    this._rotation = 0;
    this.teleported = 0;
    this.map = "";
    this.z = 0;
    this.fixed = false;
    this.components = {
      top: layoutObject,
      bottom: layoutObject,
      left: layoutObject,
      right: layoutObject,
      center: layoutObject
    };
    this.direction = 0;
    this.container = new Container();
    this.containersLayout = {};
    this.layoutNotifierClear = {
      top: new Subject(),
      bottom: new Subject(),
      left: new Subject(),
      right: new Subject(),
      center: new Subject()
    };
    this.registerComponents = /* @__PURE__ */ new Map();
    this.game = this.scene.game;
    this.id = this.data.id;
    this.setPosition(false);
    this.registerComponents.set(RpgSprite.id, RpgSprite);
    this.registerComponents.set(TextComponent.id, TextComponent);
    this.registerComponents.set(ShapeComponent.id, ShapeComponent);
    this.registerComponents.set(TileComponent.id, TileComponent);
    this.registerComponents.set(ImageComponent.id, ImageComponent);
    this.registerComponents.set(BarComponent.id, BarComponent);
    this.registerComponents.set(DebugComponent.id, DebugComponent);
    this.addChild(this.container);
    for (let layout of [...layoutTypes, "center"]) {
      this.containersLayout[layout] = new Container();
      this.container.addChild(this.containersLayout[layout]);
    }
    RpgPlugin.emit(HookClient.AddSprite, this);
    RpgPlugin.emit(HookClient.SceneAddSprite, [this.scene, this], true);
    this.game.listenObject(data.id).pipe(takeUntil(this.game.getDeleteNotifier(data.id)), map$7((object) => object == null ? void 0 : object.paramsChanged), tap(() => {
      var _a, _b;
      RpgPlugin.emit(HookClient.ChangesSprite, [this, (_a = this.logic) == null ? void 0 : _a["paramsChanged"], (_b = this.logic) == null ? void 0 : _b["prevParamsChanged"]], true);
    }), filter$1((object) => {
      var _a;
      return (_a = this.logic) == null ? void 0 : _a["componentChanged"];
    })).subscribe((val) => {
      var _a;
      if (this.logic) {
        this.updateComponents((_a = this.logic) == null ? void 0 : _a["componentChanged"]);
        this.logic["componentChanged"] = void 0;
      }
    });
  }
  /**
   * the direction of the sprite
   *
   * @prop {Direction} dir
   * @readonly
   * @memberof RpgSprite
   * */
  get dir() {
    return this.direction;
  }
  /**
  * To know if the sprite is a player
  *
  * @prop {boolean} isPlayer
  * @readonly
  * @memberof RpgSprite
  * */
  get isPlayer() {
    return this.data.type == PlayerType.Player;
  }
  /**
   * To know if the sprite is an event
   *
   * @prop {boolean} isEvent
   * @readonly
   * @memberof RpgSprite
   * */
  get isEvent() {
    return this.data.type == PlayerType.Event;
  }
  /**
   * To know if the sprite is a shape
   *
   * @prop {boolean} isShape
   * @since 3.0.0-rc
   * @readonly
   * @memberof RpgSprite
   * */
  get isShape() {
    return isInstanceOf(this.data, RpgShape);
  }
  /**
   * To know if the sprite is the sprite controlled by the player
   *
   * @prop {boolean} isCurrentPlayer
   * @readonly
   * @memberof RpgSprite
   * */
  get isCurrentPlayer() {
    return this.data.id === this.scene.game.playerId;
  }
  /**
   * Retrieves the logic of the sprite
   *
   * @prop {RpgSpriteLogic} logic
   * @readonly
   * @since 3.0.0-beta.4
   * @memberof RpgSprite
   * */
  get logic() {
    return this.scene.game.world.getAll(this.data.id);
  }
  get guiDisplay() {
    return this.logic.guiDisplay;
  }
  set guiDisplay(val) {
    var _a;
    this.logic.guiDisplay = val;
    this.game.setObject((_a = this.logic) == null ? void 0 : _a.id, {
      object: this.logic,
      paramsChanged: {
        guiDisplay: val
      }
    });
  }
  setPosition(smooth = true) {
    if (this.isShape) {
      const {
        width,
        height,
        x: x2,
        y: y2
      } = this.data;
      this.w = width;
      this.h = height;
      this._x = Math.floor(x2);
      this._y = Math.floor(y2);
    } else {
      const {
        position,
        direction
      } = this.data;
      this._x = (position == null ? void 0 : position.x) ?? 0;
      this._y = (position == null ? void 0 : position.y) ?? 0;
      this.z = (position == null ? void 0 : position.z) ?? 0;
      this.direction = direction;
    }
    this._rotation = this.data["rotation"] ?? 0;
    if (!smooth) {
      this.x = this._x;
      this.y = this._y;
      this.angle = this._rotation;
    }
  }
  // TODO
  /*drag() {
      this.interactive = true
      const filter = new filters.ColorMatrixFilter();
       const onDragEnd = () => {
          if (!this.dragMode) return
          this.dragMode.dragging = false
          this.dragMode.data = null
      }
       this
          .on('pointerdown', (event) => {
              this.dragMode = {
                  data: event.data,
                  dragging: true
              }
          })
          .on('pointerup', onDragEnd)
          .on('pointerupoutside', onDragEnd)
          .on('pointermove', () => {
              if (!this.dragMode) return
              const { dragging, data } = this.dragMode
              if (dragging) {
                  const newPosition = data.getLocalPosition(this.parent)
                  this.x = newPosition.x
                  this.y = newPosition.y
              }
          })
  }*/
  update(obj, objChanged, time, deltaRatio) {
    var _a;
    if ((_a = this.dragMode) == null ? void 0 : _a.dragging)
      return {
        moving: true
      };
    const {
      speed,
      teleported,
      map: map2,
      fixed
    } = obj;
    this.data = obj;
    this.setPosition();
    const renderSpeed = speed * deltaRatio;
    if (this._rotation != this.angle) {
      this.angle += Math.min(renderSpeed, this._rotation - this.angle);
    }
    let moving2 = obj.moving ?? false;
    if (!fixed) {
      if (teleported != this.teleported || map2 != this.map) {
        this.x = this._x;
        this.y = this._y;
        this.teleported = teleported;
        this.map = map2;
      }
      this.parent.parent.zIndex = this._y;
      obj.posX = this._x;
      obj.posY = this._y;
      if (this._x > this.x) {
        this.x += Math.min(renderSpeed, this._x - this.x);
        moving2 = true;
      }
      if (this._x < this.x) {
        this.x -= Math.min(renderSpeed, this.x - this._x);
        moving2 = true;
      }
      if (this._y > this.y) {
        this.y += Math.min(renderSpeed, this._y - this.y);
        moving2 = true;
      }
      if (this._y < this.y) {
        this.y -= Math.min(renderSpeed, this.y - this._y);
        moving2 = true;
      }
    }
    this.callMethodInComponents("update", [obj, {
      moving: moving2
    }, deltaRatio]);
    this.onUpdate(obj);
    return {
      moving: moving2
    };
  }
  showAnimation(graphic, animationName) {
    return this.callMethodInComponents("showAnimation", [graphic, animationName]);
  }
  /**
  * Recover the position according to the graphic
  * Normally, the position is that of the hitbox but, we retrieve the top left corner of the graphic
  *
  * You can also pass the `middle` value as first parameter to retrieve the positions from the middle of the sprite
  *
  * @title Get Positions of Graphic
  * @method sprite.getPositionsOfGraphic(align)
  * @param {string} [align] middle
  * @returns { x: number, y: number }
  * @memberof RpgSprite
  */
  getPositionsOfGraphic(align) {
    var _a;
    let sprite;
    if (((_a = this.components.center) == null ? void 0 : _a.lines.length) !== 0) {
      sprite = this.containersLayout.center.getChildAt(0);
    }
    const isMiddle = align == "middle";
    return {
      x: this.x - this.w * ((sprite == null ? void 0 : sprite.anchor.x) ?? 1) + (isMiddle ? this.w / 2 : 0),
      y: this.y - this.h * ((sprite == null ? void 0 : sprite.anchor.y) ?? 1) + (isMiddle ? this.h / 2 : 0)
    };
  }
  /**
   * Get the container by position (center, left, right, top, bottom)
   *
   * @param {LayoutPositionEnum} [position=center]
   * @returns {PIXI.Container}
   *
   * */
  getLayoutContainer(position = "center") {
    return this.containersLayout[position];
  }
  /**
   * Get Current Scene. Scene is a map, battle, menu, etc.
   * @returns {T}
   */
  getScene() {
    return this.scene;
  }
  // Hooks
  onInit() {
  }
  onUpdate(obj) {
  }
  onMove() {
  }
  onChanges(data, old) {
  }
  callMethodInComponents(name, params) {
    for (let component of this.getLayoutContainer().children) {
      if (component[name])
        component[name](...params);
    }
  }
  createGrid(position, gridArray, options, sprite) {
    var _a, _b;
    const gridContainer = new Sprite();
    const {
      height,
      spriteWidth,
      spriteHeight
    } = sprite;
    const width = options.width ?? spriteWidth ?? sprite.width;
    const gridHeight = options.height ?? 20;
    const hitBoxWidth = ((_a = this.logic) == null ? void 0 : _a.hitbox.w) ?? 0;
    const middleWidth = hitBoxWidth / 2 - width / 2;
    const posX = gridContainer.x + (options.marginLeft ?? 0) - (options.marginRight ?? 0);
    const posY = gridContainer.y + (((_b = this.logic) == null ? void 0 : _b.hitbox.h) ?? 0) + (options.marginTop ?? 0) - (options.marginBottom ?? 0);
    switch (position) {
      case "top":
        gridContainer.x = posX + middleWidth;
        gridContainer.y = posY - spriteHeight;
        gridContainer.y -= gridArray.length * gridHeight;
        break;
      case "bottom":
        gridContainer.x = posX + middleWidth;
        gridContainer.y = posY;
        break;
      case "left":
        gridContainer.x = posX - width - (hitBoxWidth < spriteWidth ? hitBoxWidth / 2 : 0);
        gridContainer.y = posY - spriteHeight;
        break;
      case "right":
        gridContainer.x = posX + width + (hitBoxWidth > spriteWidth ? hitBoxWidth / 2 : 0);
        gridContainer.y = posY - spriteHeight;
    }
    for (let y2 = 0; y2 < gridArray.length; y2++) {
      const columns = gridArray[y2].col.length;
      const cellWidth = width / columns;
      for (let x2 = 0; x2 < columns; x2++) {
        const params = gridArray[y2].col[x2];
        const component = this.applyComponent(params);
        component.onRender$.pipe(takeUntil(this.layoutNotifierClear[position]), finalize(() => {
          component.onRemove();
        })).subscribe(() => {
          component.x = Math.round(x2 * cellWidth + cellWidth / 2 - component.width / 2);
          component.y = Math.round(y2 * gridHeight + gridHeight / 2 - component.height / 2);
        });
        component.onInit({
          width: cellWidth,
          height: gridHeight
        });
        gridContainer.addChild(component);
      }
    }
    return gridContainer;
  }
  applyComponent(component) {
    const compClass = this.registerComponents.get(component.id);
    if (!compClass) {
      throw log(`Impossible to find ${component.id} component`);
    }
    return new compClass(this, component.value);
  }
  createComponentCenter(components) {
    var _a, _b, _c;
    const lines = ((_a = components.center) == null ? void 0 : _a.lines) || [];
    this.getLayoutContainer().removeChildren();
    for (let {
      col
    } of lines) {
      for (let component of col) {
        const instance = this.applyComponent(component);
        if (instance.onInit)
          instance.onInit({
            width: ((_b = this.logic) == null ? void 0 : _b.width) ?? this.width,
            height: ((_c = this.logic) == null ? void 0 : _c.height) ?? this.height
          });
        this.getLayoutContainer().addChild(instance);
      }
    }
    this.components = components;
  }
  refreshComponents(components, sprite) {
    for (let type of layoutTypes) {
      const layout = components[type];
      if (layout == null ? void 0 : layout.lines) {
        const layoutContainer = this.getLayoutContainer(type);
        layoutContainer.removeChildren();
        this.layoutNotifierClear[type].next();
        layoutContainer.addChild(this.createGrid(type, layout.lines, layout, sprite));
      }
    }
  }
  updateComponents(components) {
    var _a;
    const graphicChanged = !!((_a = components.center) == null ? void 0 : _a.lines);
    if (graphicChanged) {
      this.createComponentCenter(components);
    }
    if (this.subscriptionGraphic)
      this.subscriptionGraphic.unsubscribe();
    const child = this.getLayoutContainer().children[0];
    if (child instanceof RpgSprite) {
      this.subscriptionGraphic = child.animationSprite().pipe(takeUntil(this.game.getDeleteNotifier(this.id)), filter$1((sprite) => sprite), distinctUntilChanged((p2, q2) => p2.width === q2.width && p2.height === q2.height && p2.anchor.x === q2.anchor.x && p2.anchor.y === q2.anchor.y)).subscribe((sprite) => {
        this.refreshComponents(components, sprite);
      });
    } else {
      this.refreshComponents(components, {
        width: this.data.width,
        height: this.data.height,
        anchor: {
          x: 0,
          y: 0
        },
        x: 0,
        y: 0,
        spriteHeight: this.data.height,
        spriteWidth: this.data.width
      });
    }
  }
}
class EventLayer extends Container {
  constructor() {
    super();
    this.sortableChildren = true;
  }
}
const {
  Viewport: PixiViewport
} = _PixiViewport;
class SceneMap extends Scene$1 {
  constructor(context2, renderer2, options = {}) {
    super(context2);
    this.context = context2;
    this.renderer = renderer2;
    this.options = options;
    this.players = {};
    this.isLoaded = false;
    this.eventsLayers = {};
    this.shapes = {};
    if (options.drawMap === void 0)
      this.options.drawMap = true;
    this.onInit();
  }
  constructMethods() {
    ["getTileIndex", "getTileByIndex", "getTileOriginPosition", "getTileByPosition", "getLayerByName"].forEach((method) => this[method] = this.gameMap[method].bind(this.gameMap));
    ["heightPx", "widthPx", "zTileHeight", "tileHeight", "tileWidth", "data", "layers"].forEach((prop) => this[prop] = this.gameMap[prop]);
  }
  /** @internal */
  async load(obj, prevObj, isUpdate = false) {
    let {
      sounds: sounds2
    } = obj;
    const {
      clientEngine
    } = this.game;
    if (sounds2) {
      if (!isArray$8(sounds2))
        sounds2 = obj.sounds = [sounds2];
    }
    this.gameMap = new RpgCommonMap();
    this.gameMap.load(obj);
    this.gameMap.clearCacheTilesets();
    this.constructMethods();
    RpgCommonMap.bufferClient.set(obj.id, this.gameMap);
    this.tilemap = new TileMap(this.context, this.gameMap.getData());
    Assets.reset();
    let nbLoad = 0;
    const objects = this.game.world.getObjectsOfGroup();
    for (let {
      object
    } of Object.values(objects)) {
      if (isInstanceOf(object, RpgCommonPlayer) && object) {
        object.updateInVirtualGrid();
      }
    }
    const assets = [];
    for (let tileset of this.tilemap.tilesets) {
      let spritesheet = spritesheets.get(tileset.name);
      if (!spritesheet) {
        clientEngine.addSpriteSheet(tileset.image.source, tileset.name);
        spritesheet = spritesheets.get(tileset.name);
      }
      if (spritesheet == null ? void 0 : spritesheet.resource) {
        continue;
      }
      Assets.add(tileset.name, spritesheet.image);
      assets.push(tileset.name);
      nbLoad++;
    }
    if (nbLoad > 0) {
      const assetsLoaded = await Assets.load(assets);
      for (let assetName in assetsLoaded) {
        const spritesheet = spritesheets.get(assetName);
        if (spritesheet)
          spritesheet.resource = assetsLoaded[assetName];
      }
    }
    RpgPlugin.emit(HookClient.SceneMapLoading, Assets);
    this.tilemap.load({
      drawTiles: this.options.drawMap,
      isUpdate
    });
    this.viewport = new PixiViewport({
      screenWidth: this.options.screenWidth,
      screenHeight: this.options.screenHeight,
      worldWidth: obj.width * obj.tilewidth,
      worldHeight: obj.height * obj.tileheight,
      noTicker: true,
      events: this.renderer.events
    });
    this.tilemap.addChild(this.animationLayer);
    this.viewport.clamp({
      direction: "all"
    });
    this.viewport.addChild(this.tilemap, ...this.createEventLayers(obj));
    this.isLoaded = true;
    if (prevObj.sounds && prevObj.sounds instanceof Array) {
      prevObj.sounds.forEach((soundId) => {
        const continueSound = (obj.sounds || []).find((id) => id == soundId);
        if (!continueSound)
          RpgSound.stop(soundId);
      });
    }
    if (sounds2)
      sounds2.forEach((soundId) => RpgSound.play(soundId));
    if (this.onLoad)
      this.onLoad();
    return this.viewport;
  }
  createEventLayers(map2) {
    const containers = [];
    map2.layers.forEach((layerData) => {
      if (layerData.type !== TiledLayerType.ObjectGroup)
        return;
      if (this.eventsLayers[layerData.name]) {
        containers.push(this.eventsLayers[layerData.name]);
        return;
      }
      const layer = new EventLayer();
      this.defaultLayer = this.eventsLayers[layerData.name] = layer;
      containers.push(layer);
    });
    if (containers.length == 0) {
      if (!this.defaultLayer) {
        this.defaultLayer = new EventLayer();
      }
      containers.push(this.defaultLayer);
    }
    this.cameraFollowSprite(this.game.playerId);
    return containers;
  }
  getEventLayer(objectName) {
    for (let layerData of this.data.layers) {
      if (layerData.type != TiledLayerType.ObjectGroup) {
        continue;
      }
      if (!layerData.objects) {
        continue;
      }
      for (let object of layerData.objects) {
        if (object.name == objectName) {
          return this.eventsLayers[layerData.name];
        }
      }
    }
    return this.defaultLayer;
  }
  /** @internal */
  changeTile(x2, y2, layers) {
    var _a;
    for (let layerName in layers) {
      const layerInfo = layers[layerName];
      (_a = this.gameMap) == null ? void 0 : _a.setTile(x2, y2, layerName, layerInfo);
      this.tilemap.changeTile(x2, y2, layerName);
    }
  }
  /** @internal */
  draw(t2, deltaTime, deltaRatio, frame) {
    var _a;
    if (!this.isLoaded) {
      return;
    }
    super.draw(t2, deltaTime, deltaRatio, frame);
    this.tilemap.drawAnimateTile(frame);
    (_a = this.viewport) == null ? void 0 : _a.update(deltaTime);
  }
  // @internal
  updateTilesOverlayAllSprites() {
    const objects = this.objects;
    for (let [id, sprite] of objects) {
      this.updateTilesOverlay(sprite);
    }
  }
  updateTilesOverlay(sprite) {
    if (!this.gameMap)
      return sprite;
    const {
      tileWidth,
      tileHeight
    } = this.gameMap;
    const {
      tilesOverlay
    } = sprite;
    const bounds = sprite.parent.getLocalBounds();
    const width = Math.ceil(bounds.width / tileWidth) * tileWidth;
    const height = Math.ceil(bounds.height / tileHeight) * tileHeight;
    const _x = bounds.x;
    const _y = bounds.y;
    const addTile = (x2, y2) => {
      const tiles = this.tilemap.createOverlayTiles(x2, y2, sprite);
      if (tiles.length)
        tilesOverlay.addChild(...tiles);
    };
    tilesOverlay.removeChildren();
    for (let i2 = _x; i2 <= _x + width; i2 += tileWidth) {
      for (let j2 = _y; j2 <= _y + height; j2 += tileHeight) {
        addTile(i2, j2);
      }
    }
    return sprite;
  }
  onUpdateObject(logic, sprite, moving2) {
    const {
      paramsChanged
    } = logic;
    if (!this.gameMap)
      return sprite;
    if (moving2 || paramsChanged && (paramsChanged.width || paramsChanged.height)) {
      this.updateTilesOverlay(sprite);
    }
    return sprite;
  }
  /** @internal */
  setPlayerPosition(id, {
    x: x2,
    y: y2
  }) {
    this.players[id].x = x2;
    this.players[id].y = y2;
  }
  /** @internal */
  updateScene(obj) {
  }
  addObject(obj, id) {
    var _a;
    const wrapper = new Container();
    const inner = new Container();
    const tilesOverlay = new Container();
    const component = new RpgComponent(obj, this);
    component.tilesOverlay = tilesOverlay;
    inner.addChild(component);
    wrapper.addChild(inner, tilesOverlay);
    this.objects.set(id, component);
    (_a = this.getEventLayer(obj.id)) == null ? void 0 : _a.addChild(wrapper);
    if (component.isCurrentPlayer)
      this.cameraFollowSprite(id);
    component.onInit();
    return component;
  }
  removeObject(id) {
    let sprite = this.objects.get(id);
    if (sprite) {
      if (!sprite.animationIsPlaying) {
        this.objects.delete(id);
        RpgPlugin.emit(HookClient.SceneRemoveSprite, [this, sprite], true);
        RpgPlugin.emit(HookClient.RemoveSprite, sprite);
        sprite.destroy();
      } else {
        sprite.visible = false;
      }
    }
  }
  getShape(name) {
    var _a;
    return (_a = this.game.getShape(name)) == null ? void 0 : _a.object;
  }
  getShapes() {
    const shapes = Object.values(this.game.getShapes());
    return shapes.map((shape) => shape.object);
  }
  cameraFollowSprite(id, options = {}) {
    var _a, _b;
    const sprite = this.getSprite(id);
    const follow = () => {
      var _a2;
      if (sprite)
        (_a2 = this.viewport) == null ? void 0 : _a2.follow(sprite);
    };
    if (options.smoothMove) {
      (_a = this.viewport) == null ? void 0 : _a.plugins.remove("follow");
      let moreOptions = {};
      if (typeof options.smoothMove != "boolean") {
        moreOptions = options.smoothMove;
      }
      (_b = this.viewport) == null ? void 0 : _b.animate({
        position: new Point(sprite == null ? void 0 : sprite.x, sprite == null ? void 0 : sprite.y),
        ...moreOptions,
        callbackOnComplete: follow
      });
    } else {
      follow();
    }
  }
  /**
   * Listen to the events of the smile on the stage
   *
   * @title Listen mouse event
   * @method on(eventName,callback)
   * @since 3.0.0-beta.4
   * @param {string} eventName  Name of the event (see PIXI documentation). Name often used in the codes
   * - click
   * - mousedown
   * - mouseup
   * - mousemove
   * - pointerdown
   * - pointermove
   * - pointerup
   * - (etc...)
   * @param {(position: { x: number, y: number }, ev?: PIXI.InteractionEvent ) => any} callback
   * @example
   * ```ts
   * sceneMap.on('pointerdown', (position) => {
   *      console.log(position)
   * })
   * ```
   * @returns {void}
   * @memberof RpgSceneMap
   */
  on(eventName, cb) {
    if (!this.viewport)
      return;
    this.viewport.eventMode = "static";
    this.viewport.on(eventName, (...args) => {
      const ev = args[0];
      const pos = ev.getLocalPosition(this.viewport);
      if (ev.defaultPrevented)
        return;
      cb(pos, ev);
    });
  }
}
SceneMap.EVENTS_LAYER_DEFAULT = "events-layer-default";
var Scene2;
(function(Scene3) {
  Scene3["Map"] = "map";
})(Scene2 || (Scene2 = {}));
const Ease = {
  linear: (time, _from, to, duration) => {
    return _from + (to - _from) * time / duration;
  },
  easeInQuad: (time, _from, to, duration) => {
    time /= duration;
    return (to - _from) * time * time + _from;
  },
  easeOutQuad: (time, _from, to, duration) => {
    time /= duration;
    return -(to - _from) * time * (time - 2) + _from;
  },
  easeInOutQuad: (time, _from, to, duration) => {
    time /= duration / 2;
    if (time < 1)
      return (to - _from) / 2 * time * time + _from;
    time--;
    return -((to - _from) / 2) * (time * (time - 2) - 1) + _from;
  },
  easeInCubic: (time, _from, to, duration) => {
    time /= duration;
    return (to - _from) * time * time * time + _from;
  },
  easeOutCubic: (time, _from, to, duration) => {
    time /= duration;
    time--;
    return (to - _from) * (time * time * time + 1) + _from;
  },
  easeInOutCubic: (time, _from, to, duration) => {
    time /= duration / 2;
    if (time < 1)
      return (to - _from) / 2 * time * time * time + _from;
    time -= 2;
    return (to - _from) / 2 * (time * time * time + 2) + _from;
  },
  easeInQuart: (time, _from, to, duration) => {
    time /= duration;
    return (to - _from) * time * time * time * time + _from;
  },
  easeOutQuart: (time, _from, to, duration) => {
    time /= duration;
    time--;
    return -(to - _from) * (time * time * time * time - 1) + _from;
  },
  easeInOutQuart: (time, _from, to, duration) => {
    time /= duration / 2;
    if (time < 1)
      return (to - _from) / 2 * time * time * time * time + _from;
    time -= 2;
    return -(to - _from) / 2 * (time * time * time * time - 2) + _from;
  },
  easeInQuint: (time, _from, to, duration) => {
    time /= duration;
    return (to - _from) * time * time * time * time * time + _from;
  },
  easeOutQuint: (time, _from, to, duration) => {
    time /= duration;
    time--;
    return (to - _from) * (time * time * time * time * time + 1) + _from;
  },
  easeInOutQuint: (time, _from, to, duration) => {
    time /= duration / 2;
    if (time < 1)
      return (to - _from) / 2 * time * time * time * time * time + _from;
    time -= 2;
    return (to - _from) / 2 * (time * time * time * time * time + 2) + _from;
  },
  easeInSine: (time, _from, to, duration) => {
    return -(to - _from) * Math.cos(time / duration * (Math.PI / 2)) + (to - _from) + _from;
  },
  easeOutSine: (time, _from, to, duration) => {
    return (to - _from) * Math.sin(time / duration * (Math.PI / 2)) + _from;
  },
  easeInOutSine: (time, _from, to, duration) => {
    return -(to - _from) / 2 * (Math.cos(Math.PI * time / duration) - 1) + _from;
  },
  easeInExpo: (time, _from, to, duration) => {
    return time === 0 ? _from : (to - _from) * Math.pow(2, 10 * (time / duration - 1)) + _from;
  },
  easeOutExpo: (time, _from, to, duration) => {
    return time === duration ? to : (to - _from) * (-Math.pow(2, -10 * time / duration) + 1) + _from;
  },
  easeInOutExpo: (time, _from, to, duration) => {
    if (time === 0)
      return _from;
    if (time === duration)
      return to;
    time /= duration / 2;
    if (time < 1)
      return (to - _from) / 2 * Math.pow(2, 10 * (time - 1)) + _from;
    return (to - _from) / 2 * (-Math.pow(2, -10 * --time) + 2) + _from;
  },
  easeInCirc: (time, _from, to, duration) => {
    time /= duration;
    return -(to - _from) * (Math.sqrt(1 - time * time) - 1) + _from;
  },
  easeOutCirc: (time, _from, to, duration) => {
    time /= duration;
    time--;
    return (to - _from) * Math.sqrt(1 - time * time) + _from;
  },
  easeInOutCirc: (time, _from, to, duration) => {
    time /= duration / 2;
    if (time < 1)
      return -(to - _from) / 2 * (Math.sqrt(1 - time * time) - 1) + _from;
    time -= 2;
    return (to - _from) / 2 * (Math.sqrt(1 - time * time) + 1) + _from;
  },
  easeInElastic: (time, _from, to, duration, amplitude = 0, period = 0) => {
    if (time === 0)
      return _from;
    time /= duration;
    if (time === 1)
      return to;
    if (period === 0)
      period = duration * 0.3;
    let s2;
    if (amplitude < Math.abs(to - _from)) {
      amplitude = to - _from;
      s2 = period / 4;
    } else {
      s2 = period / (2 * Math.PI) * Math.asin((to - _from) / amplitude);
    }
    time--;
    return -(amplitude * Math.pow(2, 10 * time) * Math.sin((time * duration - s2) * (2 * Math.PI) / period)) + _from;
  },
  easeOutElastic: (time, _from, to, duration, amplitude = 0, period = 0) => {
    if (time === 0)
      return _from;
    time /= duration;
    if (time === 1)
      return to;
    if (period === 0)
      period = duration * 0.3;
    let s2;
    if (amplitude < Math.abs(to - _from)) {
      amplitude = to - _from;
      s2 = period / 4;
    } else {
      s2 = period / (2 * Math.PI) * Math.asin((to - _from) / amplitude);
    }
    return amplitude * Math.pow(2, -10 * time) * Math.sin((time * duration - s2) * (2 * Math.PI) / period) + (to - _from) + _from;
  },
  easeInOutElastic: (time, _from, to, duration, amplitude = 0, period = 0) => {
    if (time === 0)
      return _from;
    time /= duration / 2;
    if (time === 2)
      return to;
    if (period === 0)
      period = duration * (0.3 * 1.5);
    let s2;
    if (amplitude < Math.abs(to - _from)) {
      amplitude = to - _from;
      s2 = period / 4;
    } else {
      s2 = period / (2 * Math.PI) * Math.asin((to - _from) / amplitude);
    }
    if (time < 1) {
      time--;
      return -0.5 * (amplitude * Math.pow(2, 10 * time) * Math.sin((time * duration - s2) * (2 * Math.PI) / period)) + _from;
    }
    time--;
    return amplitude * Math.pow(2, -10 * time) * Math.sin((time * duration - s2) * (2 * Math.PI) / period) * 0.5 + (to - _from) + _from;
  },
  // ...
  easeInBack: (time, _from, to, duration, s2 = 1.70158) => {
    time /= duration;
    return (to - _from) * time * time * ((s2 + 1) * time - s2) + _from;
  },
  easeOutBack: (time, _from, to, duration, s2 = 1.70158) => {
    time = time / duration - 1;
    return (to - _from) * (time * time * ((s2 + 1) * time + s2) + 1) + _from;
  },
  easeInOutBack: (time, _from, to, duration, s2 = 1.70158) => {
    s2 *= 1.525;
    time /= duration / 2;
    if (time < 1)
      return (to - _from) / 2 * (time * time * ((s2 + 1) * time - s2)) + _from;
    time -= 2;
    return (to - _from) / 2 * (time * time * ((s2 + 1) * time + s2) + 2) + _from;
  },
  easeInBounce: (time, _from, to, duration) => {
    return to - _from - Ease.easeOutBounce(duration - time, 0, to - _from, duration) + _from;
  },
  easeOutBounce: (time, _from, to, duration) => {
    time /= duration;
    let multiplier = 7.5625;
    if (time < 1 / 2.75) {
      return (to - _from) * (multiplier * time * time) + _from;
    } else if (time < 2 / 2.75) {
      time -= 1.5 / 2.75;
      return (to - _from) * (multiplier * time * time + 0.75) + _from;
    } else if (time < 2.5 / 2.75) {
      time -= 2.25 / 2.75;
      return (to - _from) * (multiplier * time * time + 0.9375) + _from;
    } else {
      time -= 2.625 / 2.75;
      return (to - _from) * (multiplier * time * time + 0.984375) + _from;
    }
  },
  easeInOutBounce: (time, _from, to, duration) => {
    if (time < duration / 2)
      return Ease.easeInBounce(time * 2, 0, to - _from, duration) * 0.5 + _from;
    return Ease.easeOutBounce(time * 2 - duration, 0, to - _from, duration) * 0.5 + (to - _from) * 0.5 + _from;
  }
};
class Timeline {
  constructor(options) {
    this.time = 0;
    this.animation = [];
    this.keyframes = 10;
    if (options) {
      if (options.keyframes)
        this.keyframes = options.keyframes;
    }
  }
  /**
   * Allows you to create complex animations more easily. For example, to display a movement with an Easing function
   *
   * ```ts
   * import { Timeline, Ease } from '@rpgjs/client'
   *
   * new Timeline()
   *      .add(30, ({ scale }) => [{
   *          frameX: 0,
   *          frameY: 1,
   *          scale: [scale]
   *      }], {
   *          scale: {
   *              from: 0,
   *              to: 1,
   *              easing: Ease.easeOutBounce
   *          }
   *      })
   *      .add(100)
   *      .create()
   * ```
   *
   * Here we say
   *
   * - Duration in frames, allowing you to specify the duration of each animation step. If the timeline respects a specific frame rate, e.g. 60 frames per second, 40 frames correspond to an animation duration of 2/3 of a second for each step.
   * - A function that will be called every 1 frame with the `scale` property defined in transform
   * - An object of transformation. Define the properties of your choice to be passed to the callback function
   *      - `to`: the starting value
   *      - `from`: the end value
   *      - `easing`: An easing function (By default, it is a linear function)
   *
   * Note that if you just put a duration (`add(100)`), it will only put a pause on the animation
   *
   * Easing functions available but you can create your own
   *
   * ```ts
   * function myEase(t: number, b: number, c: number, d: number): number { }
   * ```
   *
   * `t`: current time
   * `b`: start value
   * `c`: end value
   * `d`: duration
   *
   * @title Add Animation in timeline
   * @enum {Function}
   *
   * Ease.linear | linear
  * Ease.easeInQuad | easeInQuad
  * Ease.easeOutQuad | easeOutQuad
  * Ease.easeInOutQuad | easeInOutQuad
  * Ease.easeInCubic | easeInCubic
  * Ease.easeOutCubic | easeOutCubic
  * Ease.easeInOutCubic | easeInOutCubic
  * Ease.easeInQuart | easeInQuart
  * Ease.easeOutQuart | easeOutQuart
  * Ease.easeInOutQuart | easeInOutQuart
  * Ease.easeInQuint | easeInQuint
  * Ease.easeOutQuint | easeOutQuint
  * Ease.easeInOutQuint | easeInOutQuint
  * Ease.easeInSine | easeInSine
  * Ease.easeOutSine | easeOutSine
  * Ease.easeInOutSine | easeInOutSine
  * Ease.easeInExpo | easeInExpo
  * Ease.easeOutExpo | easeOutExpo
  * Ease.easeInOutExpo | easeInOutExpo
  * Ease.easeInCirc | easeInCirc
  * Ease.easeOutCirc | easeOutCirc
  * Ease.easeInOutCirc | easeInOutCirc
  * Ease.easeInElastic | easeInElastic
  * Ease.easeOutElastic | easeOutElastic
  * Ease.easeInOutElastic | easeInOutElastic
  * Ease.easeInBack | easeInBack
  * Ease.easeOutBack | easeOutBack
  * Ease.easeInOutBack | easeInOutBack
  * Ease.easeInBounce | easeInBounce
  * Ease.easeOutBounce | easeOutBounce
   * @method timeline.add(duration,cb?,transform?)
   * @param {number} duration
   * @param { (obj?: number, time?: number) => TransformOptions[] } [cb]
   * @param { [property: string]: { to:number, from: number: easing?: Function } } [transform]
   * @returns {Timeline}
   * @memberof Timeline
   */
  add(duration, cb, transform) {
    if (!cb) {
      this.animation.push([{
        time: duration + this.time
      }]);
      this.time += duration;
      return this;
    }
    for (let k4 = 0; k4 < this.keyframes; k4++) {
      const i2 = Math.floor(duration / (this.keyframes - 1) * k4);
      let anim;
      const obj = {};
      for (let prop in transform) {
        const param = transform[prop];
        const cbEasing = param.easing || Ease.linear;
        obj[prop] = cbEasing(i2, param.from, param.to, duration);
      }
      const ret = cb(obj, i2);
      anim = ret.map((el) => {
        el.time = i2 + this.time;
        return el;
      });
      this.animation.push(anim);
    }
    this.time += duration;
    return this;
  }
  /**
   * Allows you to create the animation array to assign to the `animations` property in the Spritesheet
   *
   * ```ts
   * import { Spritesheet, Timeline } from '@rpgjs/server'
   *
   * @Spritesheet({
   *  id: 'sprite',
   *  image: require('./sprite.png'),
   *  width: 192,
   *  height: 228,
   *  framesHeight: 6,
   *  framesWidth: 6,
   *  anchor: [0.5],
   *  textures: {
   *      myanim: {
   *          animations: new Timeline()
   *                          .add(SEE THE ADD METHOD)
   *                          .create()
   *      }
   *  }
   * })
   * export class MyAnim {}
   * ```
   *
   * @title Create the animation array
   * @method timeline.create()
   * @returns {FrameOptions[][]} The animation array
   * @memberof Timeline
   */
  create() {
    return this.animation;
  }
}
class TransitionScene {
  constructor(context2, container) {
    this.context = context2;
    this.container = container;
    this.frameIndex = 0;
    this.animations = [];
    this.complete = () => {
    };
    this.clientEngine = this.context.inject(RpgClientEngine$2);
  }
  addFadeIn() {
    return this.addFading(1, 0);
  }
  addFadeOut() {
    return this.addFading(0, 1);
  }
  addFading(from2, to) {
    this.animations = new Timeline().add(15, ({
      opacity
    }) => [{
      opacity
    }], {
      opacity: {
        from: from2,
        to
      }
    }).create();
    return this;
  }
  onComplete(cb) {
    this.complete = cb;
    return this;
  }
  start() {
    this.updateSubscription = this.clientEngine.tick.subscribe(() => this.update());
  }
  update() {
    const animationFrame = this.animations[this.frameIndex];
    if (!animationFrame) {
      this.complete();
      this.updateSubscription.unsubscribe();
      return;
    }
    const frame = animationFrame[0];
    this.container.alpha = frame.opacity;
    this.frameIndex++;
  }
}
class SpinnerGraphic extends Graphics {
  constructor(clientEngine) {
    super();
    this.clientEngine = clientEngine;
  }
  render(renderer2) {
    super.render(renderer2);
    this.rotation += 0.12;
    const percent = Math.abs(Math.sin(Date.now() / 1e3));
    this.clear().lineStyle(4, 16777215, 1).moveTo(40, 0).arc(0, 0, 40, 0, Math.PI * 2 * percent, false);
  }
}
const {
  elementToPositionAbsolute
} = Utils$1;
var TransitionMode;
(function(TransitionMode2) {
  TransitionMode2[TransitionMode2["None"] = 0] = "None";
  TransitionMode2[TransitionMode2["Fading"] = 1] = "Fading";
})(TransitionMode || (TransitionMode = {}));
var ContainerName;
(function(ContainerName2) {
  ContainerName2["Map"] = "map";
})(ContainerName || (ContainerName = {}));
const EVENTS_MAP = {
  MouseEvent: ["click", "dblclick", "mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "mouseover", "mouseout", "contextmenu", "wheel"],
  KeyboardEvent: ["keydown", "keyup", "keypress", "keydownoutside", "keyupoutside", "keypressoutside"],
  PointerEvent: ["pointerdown", "pointerup", "pointermove", "pointerover", "pointerout", "pointerenter", "pointerleave", "pointercancel"],
  TouchEvent: ["touchstart", "touchend", "touchmove", "touchcancel"]
};
class RpgRenderer {
  constructor(context2) {
    this.context = context2;
    this.gameEngine = this.context.inject(GameEngineClient);
    this.clientEngine = this.context.inject(RpgClientEngine$2);
    this.stage = new Container();
    this.sceneContainer = new Container();
    this.fadeContainer = new Graphics();
    this.spinner = new SpinnerGraphic(this.clientEngine);
    this.options = {};
    this.scene = null;
    this._width = 800;
    this._height = 400;
    this.loadingScene = {
      transitionIn: new Subject(),
      transitionOut: new Subject()
    };
    this.freeze = false;
    this.prevObjectScene = {};
    this.transitionMode = TransitionMode.Fading;
    this.clientEngine.tick.subscribe(({
      timestamp,
      deltaRatio,
      frame,
      deltaTime
    }) => {
      this.draw(timestamp, deltaTime, deltaRatio, frame);
    });
    this.transitionCompleted();
  }
  /** @internal */
  init() {
    return this.onDOMLoaded();
  }
  /** @internal */
  _resize(w2, h2) {
    if (!w2)
      w2 = this.options.canvas.width;
    if (!h2)
      h2 = this.options.canvas.height;
    const scene = this.getScene();
    if (this.scene && (scene == null ? void 0 : scene.viewport)) {
      scene.viewport.screenWidth = w2;
      scene.viewport.screenHeight = h2;
    }
    if (this.vm) {
      this.vm.$el.style = `width:${w2}px;height:${h2}px`;
    }
    this.renderer.resize(w2, h2);
    this._width = w2;
    this._height = h2;
    this.fadeContainer.beginFill(0);
    this.fadeContainer.drawRect(0, 0, w2, h2);
    this.fadeContainer.endFill();
    this.spinner.x = w2 * 0.5;
    this.spinner.y = h2 * 0.5;
  }
  get canvas() {
    return this.renderer.view;
  }
  get height() {
    return this._height;
  }
  set height(val) {
    this._resize(this._width, val);
  }
  get width() {
    return this._width;
  }
  set width(val) {
    this._resize(val, this.height);
  }
  /** @internal */
  async onDOMLoaded() {
    let options = {
      antialias: true,
      ...this.options.canvas
    };
    this.renderer = autoDetectRenderer(options);
    this.selector = document.body.querySelector(this.options.selector);
    this.guiEl = this.selector.querySelector(this.options.selectorGui);
    this.canvasEl = this.selector.querySelector(this.options.selectorCanvas);
    if (!this.guiEl) {
      this.guiEl = document.createElement("div");
      this.guiEl = this.selector.appendChild(this.guiEl);
    }
    elementToPositionAbsolute(this.guiEl);
    if (!this.canvasEl) {
      this.selector.insertBefore(this.renderer.view, this.selector.firstChild);
      const [canvas] = document.querySelector(this.options.selector).children;
      canvas.style.position = "absolute";
    } else {
      this.canvasEl.appendChild(this.renderer.view);
    }
    this.stage.addChild(this.sceneContainer);
    this.stage.addChild(this.fadeContainer);
    this.fadeContainer.addChild(this.spinner);
    this.fadeContainer.visible = false;
    this.fadeContainer.alpha = 0;
    await RpgGui._initialize(this.context, this.guiEl);
    this.resize();
    this.bindMouseControls();
  }
  bindMouseControls() {
    const controlInstance = this.context.inject(KeyboardControls);
    const controls = controlInstance.getControls();
    for (let key in controls) {
      const {
        actionName
      } = controls[key];
      if (EVENTS_MAP.MouseEvent.includes(key)) {
        this.canvas.addEventListener(key, (e3) => {
          controlInstance.applyControl(actionName);
        });
      }
    }
  }
  /** @internal */
  resize() {
    const size2 = () => {
      const {
        offsetWidth,
        offsetHeight
      } = this.canvasEl || this.selector;
      this._resize(offsetWidth, offsetHeight);
      RpgPlugin.emit(HookClient.WindowResize);
    };
    window.addEventListener("resize", size2);
    size2();
  }
  /** @internal */
  getScene() {
    return this.scene;
  }
  /** @internal */
  draw(t2, deltaTime, deltaRatio, frame) {
    if (!this.renderer)
      return;
    if (this.scene && !this.freeze)
      this.scene.draw(t2, deltaTime, deltaRatio, frame);
    this.renderer.render(this.stage);
  }
  /** @internal */
  async loadScene(name, obj) {
    var _a;
    const scene = this.getScene();
    if (scene && scene.data.id == obj.id) {
      const container = await scene.load(obj, this.prevObjectScene, true);
      this.sceneContainer.removeChildren();
      this.sceneContainer.addChild(container);
      scene.updateTilesOverlayAllSprites();
      (_a = this.scene) == null ? void 0 : _a.update();
      return;
    }
    this.loadingScene.transitionIn.next({
      name,
      obj
    });
    this.loadingScene.transitionIn.complete();
  }
  async createScene(name, obj) {
    var _a, _b;
    const container = await ((_a = this.getScene()) == null ? void 0 : _a.load(obj, this.prevObjectScene));
    this.prevObjectScene = {
      ...obj
    };
    this.sceneContainer.children.forEach((child) => {
      if (child.name === ContainerName.Map)
        this.sceneContainer.removeChild(child);
    });
    if (container) {
      container.name = ContainerName.Map;
      this.sceneContainer.addChild(container);
    }
    (_b = this.scene) == null ? void 0 : _b.update();
  }
  /** @internal */
  transitionScene(name) {
    this.freeze = true;
    this.fadeContainer.visible = true;
    RpgPlugin.emit(HookClient.BeforeSceneLoading, {
      name
    });
    this.clientEngine.controls.stopInputs();
    const finish = () => {
      this.clearScene();
      this.loadingScene.transitionOut.next(name);
      this.loadingScene.transitionOut.complete();
    };
    if (this.transitionMode == TransitionMode.Fading) {
      new TransitionScene(this.context, this.fadeContainer).addFadeOut().onComplete(finish).start();
    } else {
      finish();
    }
  }
  /** @internal */
  transitionCompleted() {
    this.loadingScene = {
      transitionIn: new Subject(),
      transitionOut: new Subject()
    };
    this.clientEngine.roomJoin = new Subject();
    forkJoin({
      in: this.loadingScene.transitionIn,
      out: this.loadingScene.transitionOut,
      room: this.clientEngine.roomJoin
    }).subscribe(async (data) => {
      const {
        in: {
          obj,
          name
        }
      } = data;
      const scenes = this.options.scenes || {};
      switch (name) {
        case Scene2.Map:
          const sceneClass = scenes[Scene2.Map] || SceneMap;
          this.scene = new sceneClass(this.context, this.renderer, {
            screenWidth: this.renderer.screen.width,
            screenHeight: this.renderer.screen.height,
            drawMap: this.options.drawMap
          });
          break;
      }
      await this.createScene(name, obj);
      this.freeze = false;
      const finish = () => {
        this.clientEngine.controls.listenInputs();
        this.fadeContainer.visible = false;
        this.transitionCompleted();
        RpgPlugin.emit(HookClient.AfterSceneLoading, this.scene);
      };
      if (this.transitionMode == TransitionMode.Fading) {
        new TransitionScene(this.context, this.fadeContainer).addFadeIn().onComplete(finish).start();
      } else {
        finish();
      }
    });
  }
  /** @internal */
  clearScene() {
    this.scene = null;
    this.sceneContainer.removeChildren();
  }
  /**
   * @title Propagate mouse event to Viewport
   * @method propagateEvent(ev)
   * @stability 1
   * @memberof RpgRenderer
   * @returns {void}
   */
  propagateEvent(ev) {
    const rect = this.canvas.getBoundingClientRect();
    const canvasX = rect.left + window.scrollX;
    const canvasY = rect.top + window.scrollY;
    const realX = ev.clientX - canvasX;
    const realY = ev.clientY - canvasY;
    const boundary = new EventBoundary(this.stage);
    const event = new FederatedPointerEvent(boundary);
    event.global.set(realX, realY);
    event.type = ev.type;
    const hitTestTarget = boundary.hitTest(realX, realY);
    hitTestTarget == null ? void 0 : hitTestTarget.dispatchEvent(event);
    this.canvas.dispatchEvent(new MouseEvent(ev.type, ev));
  }
  /***
   * Propagate events from an HTMLElement to the canvas
   *
   * @title Propagate events
   * @method addPropagateEventsFrom(el)
   * @stability 1
   * @memberof RpgRenderer
   * @returns {void}
   */
  addPropagateEventsFrom(el) {
    for (let [_Constructor, events2] of Object.entries(EVENTS_MAP)) {
      for (let type of events2) {
        el.addEventListener(type, (e3) => {
          const _class = window[_Constructor] ?? MouseEvent;
          this.canvas.dispatchEvent(new _class(type, e3));
        });
      }
    }
  }
}
var browser = {};
var encode$2 = {};
var encodeBuffer = {};
var writeCore = {};
var extBuffer = {};
var bufferish = {};
var bufferGlobal = c$1("undefined" !== typeof Buffer$2 && Buffer$2) || c$1(commonjsGlobal.Buffer) || c$1("undefined" !== typeof window && window.Buffer) || commonjsGlobal.Buffer;
function c$1(B3) {
  return B3 && B3.isBuffer && B3;
}
var toString$2 = {}.toString;
var isarray = Array.isArray || function(arr) {
  return toString$2.call(arr) == "[object Array]";
};
var bufferishArray = { exports: {} };
var hasRequiredBufferishArray;
function requireBufferishArray() {
  if (hasRequiredBufferishArray)
    return bufferishArray.exports;
  hasRequiredBufferishArray = 1;
  var Bufferish2 = requireBufferish();
  var exports = bufferishArray.exports = alloc2(0);
  exports.alloc = alloc2;
  exports.concat = Bufferish2.concat;
  exports.from = from2;
  function alloc2(size2) {
    return new Array(size2);
  }
  function from2(value2) {
    if (!Bufferish2.isBuffer(value2) && Bufferish2.isView(value2)) {
      value2 = Bufferish2.Uint8Array.from(value2);
    } else if (Bufferish2.isArrayBuffer(value2)) {
      value2 = new Uint8Array(value2);
    } else if (typeof value2 === "string") {
      return Bufferish2.from.call(exports, value2);
    } else if (typeof value2 === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    return Array.prototype.slice.call(value2);
  }
  return bufferishArray.exports;
}
var bufferishBuffer = { exports: {} };
var hasRequiredBufferishBuffer;
function requireBufferishBuffer() {
  if (hasRequiredBufferishBuffer)
    return bufferishBuffer.exports;
  hasRequiredBufferishBuffer = 1;
  var Bufferish2 = requireBufferish();
  var Buffer3 = Bufferish2.global;
  var exports = bufferishBuffer.exports = Bufferish2.hasBuffer ? alloc2(0) : [];
  exports.alloc = Bufferish2.hasBuffer && Buffer3.alloc || alloc2;
  exports.concat = Bufferish2.concat;
  exports.from = from2;
  function alloc2(size2) {
    return new Buffer3(size2);
  }
  function from2(value2) {
    if (!Bufferish2.isBuffer(value2) && Bufferish2.isView(value2)) {
      value2 = Bufferish2.Uint8Array.from(value2);
    } else if (Bufferish2.isArrayBuffer(value2)) {
      value2 = new Uint8Array(value2);
    } else if (typeof value2 === "string") {
      return Bufferish2.from.call(exports, value2);
    } else if (typeof value2 === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (Buffer3.from && Buffer3.from.length !== 1) {
      return Buffer3.from(value2);
    } else {
      return new Buffer3(value2);
    }
  }
  return bufferishBuffer.exports;
}
var bufferishUint8array = { exports: {} };
var hasRequiredBufferishUint8array;
function requireBufferishUint8array() {
  if (hasRequiredBufferishUint8array)
    return bufferishUint8array.exports;
  hasRequiredBufferishUint8array = 1;
  var Bufferish2 = requireBufferish();
  var exports = bufferishUint8array.exports = Bufferish2.hasArrayBuffer ? alloc2(0) : [];
  exports.alloc = alloc2;
  exports.concat = Bufferish2.concat;
  exports.from = from2;
  function alloc2(size2) {
    return new Uint8Array(size2);
  }
  function from2(value2) {
    if (Bufferish2.isView(value2)) {
      var byteOffset = value2.byteOffset;
      var byteLength2 = value2.byteLength;
      value2 = value2.buffer;
      if (value2.byteLength !== byteLength2) {
        if (value2.slice) {
          value2 = value2.slice(byteOffset, byteOffset + byteLength2);
        } else {
          value2 = new Uint8Array(value2);
          if (value2.byteLength !== byteLength2) {
            value2 = Array.prototype.slice.call(value2, byteOffset, byteOffset + byteLength2);
          }
        }
      }
    } else if (typeof value2 === "string") {
      return Bufferish2.from.call(exports, value2);
    } else if (typeof value2 === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    return new Uint8Array(value2);
  }
  return bufferishUint8array.exports;
}
var bufferishProto = {};
var bufferLite = {};
bufferLite.copy = copy2;
bufferLite.toString = toString$1;
bufferLite.write = write$1;
function write$1(string, offset) {
  var buffer2 = this;
  var index2 = offset || (offset |= 0);
  var length2 = string.length;
  var chr = 0;
  var i2 = 0;
  while (i2 < length2) {
    chr = string.charCodeAt(i2++);
    if (chr < 128) {
      buffer2[index2++] = chr;
    } else if (chr < 2048) {
      buffer2[index2++] = 192 | chr >>> 6;
      buffer2[index2++] = 128 | chr & 63;
    } else if (chr < 55296 || chr > 57343) {
      buffer2[index2++] = 224 | chr >>> 12;
      buffer2[index2++] = 128 | chr >>> 6 & 63;
      buffer2[index2++] = 128 | chr & 63;
    } else {
      chr = (chr - 55296 << 10 | string.charCodeAt(i2++) - 56320) + 65536;
      buffer2[index2++] = 240 | chr >>> 18;
      buffer2[index2++] = 128 | chr >>> 12 & 63;
      buffer2[index2++] = 128 | chr >>> 6 & 63;
      buffer2[index2++] = 128 | chr & 63;
    }
  }
  return index2 - offset;
}
function toString$1(encoding, start, end) {
  var buffer2 = this;
  var index2 = start | 0;
  if (!end)
    end = buffer2.length;
  var string = "";
  var chr = 0;
  while (index2 < end) {
    chr = buffer2[index2++];
    if (chr < 128) {
      string += String.fromCharCode(chr);
      continue;
    }
    if ((chr & 224) === 192) {
      chr = (chr & 31) << 6 | buffer2[index2++] & 63;
    } else if ((chr & 240) === 224) {
      chr = (chr & 15) << 12 | (buffer2[index2++] & 63) << 6 | buffer2[index2++] & 63;
    } else if ((chr & 248) === 240) {
      chr = (chr & 7) << 18 | (buffer2[index2++] & 63) << 12 | (buffer2[index2++] & 63) << 6 | buffer2[index2++] & 63;
    }
    if (chr >= 65536) {
      chr -= 65536;
      string += String.fromCharCode((chr >>> 10) + 55296, (chr & 1023) + 56320);
    } else {
      string += String.fromCharCode(chr);
    }
  }
  return string;
}
function copy2(target, targetStart, start, end) {
  var i2;
  if (!start)
    start = 0;
  if (!end && end !== 0)
    end = this.length;
  if (!targetStart)
    targetStart = 0;
  var len = end - start;
  if (target === this && start < targetStart && targetStart < end) {
    for (i2 = len - 1; i2 >= 0; i2--) {
      target[i2 + targetStart] = this[i2 + start];
    }
  } else {
    for (i2 = 0; i2 < len; i2++) {
      target[i2 + targetStart] = this[i2 + start];
    }
  }
  return len;
}
var hasRequiredBufferishProto;
function requireBufferishProto() {
  if (hasRequiredBufferishProto)
    return bufferishProto;
  hasRequiredBufferishProto = 1;
  var BufferLite = bufferLite;
  bufferishProto.copy = copy3;
  bufferishProto.slice = slice2;
  bufferishProto.toString = toString3;
  bufferishProto.write = gen("write");
  var Bufferish2 = requireBufferish();
  var Buffer3 = Bufferish2.global;
  var isBufferShim = Bufferish2.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer3;
  var brokenTypedArray = isBufferShim && !Buffer3.TYPED_ARRAY_SUPPORT;
  function copy3(target, targetStart, start, end) {
    var thisIsBuffer = Bufferish2.isBuffer(this);
    var targetIsBuffer = Bufferish2.isBuffer(target);
    if (thisIsBuffer && targetIsBuffer) {
      return this.copy(target, targetStart, start, end);
    } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer && Bufferish2.isView(this) && Bufferish2.isView(target)) {
      var buffer2 = start || end != null ? slice2.call(this, start, end) : this;
      target.set(buffer2, targetStart);
      return buffer2.length;
    } else {
      return BufferLite.copy.call(this, target, targetStart, start, end);
    }
  }
  function slice2(start, end) {
    var f3 = this.slice || !brokenTypedArray && this.subarray;
    if (f3)
      return f3.call(this, start, end);
    var target = Bufferish2.alloc.call(this, end - start);
    copy3.call(this, target, 0, start, end);
    return target;
  }
  function toString3(encoding, start, end) {
    var f3 = !isBufferShim && Bufferish2.isBuffer(this) ? this.toString : BufferLite.toString;
    return f3.apply(this, arguments);
  }
  function gen(method) {
    return wrap;
    function wrap() {
      var f3 = this[method] || BufferLite[method];
      return f3.apply(this, arguments);
    }
  }
  return bufferishProto;
}
var hasRequiredBufferish;
function requireBufferish() {
  if (hasRequiredBufferish)
    return bufferish;
  hasRequiredBufferish = 1;
  (function(exports) {
    var Buffer3 = exports.global = bufferGlobal;
    var hasBuffer = exports.hasBuffer = Buffer3 && !!Buffer3.isBuffer;
    var hasArrayBuffer = exports.hasArrayBuffer = "undefined" !== typeof ArrayBuffer;
    var isArray2 = exports.isArray = isarray;
    exports.isArrayBuffer = hasArrayBuffer ? isArrayBuffer2 : _false;
    var isBuffer2 = exports.isBuffer = hasBuffer ? Buffer3.isBuffer : _false;
    var isView2 = exports.isView = hasArrayBuffer ? ArrayBuffer.isView || _is("ArrayBuffer", "buffer") : _false;
    exports.alloc = alloc2;
    exports.concat = concat2;
    exports.from = from2;
    var BufferArray = exports.Array = requireBufferishArray();
    var BufferBuffer = exports.Buffer = requireBufferishBuffer();
    var BufferUint8Array = exports.Uint8Array = requireBufferishUint8array();
    var BufferProto2 = exports.prototype = requireBufferishProto();
    function from2(value2) {
      if (typeof value2 === "string") {
        return fromString2.call(this, value2);
      } else {
        return auto(this).from(value2);
      }
    }
    function alloc2(size2) {
      return auto(this).alloc(size2);
    }
    function concat2(list, length2) {
      if (!length2) {
        length2 = 0;
        Array.prototype.forEach.call(list, dryrun);
      }
      var ref = this !== exports && this || list[0];
      var result = alloc2.call(ref, length2);
      var offset = 0;
      Array.prototype.forEach.call(list, append);
      return result;
      function dryrun(buffer2) {
        length2 += buffer2.length;
      }
      function append(buffer2) {
        offset += BufferProto2.copy.call(buffer2, result, offset);
      }
    }
    var _isArrayBuffer = _is("ArrayBuffer");
    function isArrayBuffer2(value2) {
      return value2 instanceof ArrayBuffer || _isArrayBuffer(value2);
    }
    function fromString2(value2) {
      var expected = value2.length * 3;
      var that = alloc2.call(this, expected);
      var actual = BufferProto2.write.call(that, value2);
      if (expected !== actual) {
        that = BufferProto2.slice.call(that, 0, actual);
      }
      return that;
    }
    function auto(that) {
      return isBuffer2(that) ? BufferBuffer : isView2(that) ? BufferUint8Array : isArray2(that) ? BufferArray : hasBuffer ? BufferBuffer : hasArrayBuffer ? BufferUint8Array : BufferArray;
    }
    function _false() {
      return false;
    }
    function _is(name, key) {
      name = "[object " + name + "]";
      return function(value2) {
        return value2 != null && {}.toString.call(key ? value2[key] : value2) === name;
      };
    }
  })(bufferish);
  return bufferish;
}
extBuffer.ExtBuffer = ExtBuffer$1;
var Bufferish$5 = requireBufferish();
function ExtBuffer$1(buffer2, type) {
  if (!(this instanceof ExtBuffer$1))
    return new ExtBuffer$1(buffer2, type);
  this.buffer = Bufferish$5.from(buffer2);
  this.type = type;
}
var extPacker = {};
var hasRequiredExtPacker;
function requireExtPacker() {
  if (hasRequiredExtPacker)
    return extPacker;
  hasRequiredExtPacker = 1;
  extPacker.setExtPackers = setExtPackers;
  var Bufferish2 = requireBufferish();
  var Buffer3 = Bufferish2.global;
  var packTypedArray = Bufferish2.Uint8Array.from;
  var _encode;
  var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
  function setExtPackers(codec2) {
    codec2.addExtPacker(14, Error, [packError, encode2]);
    codec2.addExtPacker(1, EvalError, [packError, encode2]);
    codec2.addExtPacker(2, RangeError, [packError, encode2]);
    codec2.addExtPacker(3, ReferenceError, [packError, encode2]);
    codec2.addExtPacker(4, SyntaxError, [packError, encode2]);
    codec2.addExtPacker(5, TypeError, [packError, encode2]);
    codec2.addExtPacker(6, URIError, [packError, encode2]);
    codec2.addExtPacker(10, RegExp, [packRegExp, encode2]);
    codec2.addExtPacker(11, Boolean, [packValueOf, encode2]);
    codec2.addExtPacker(12, String, [packValueOf, encode2]);
    codec2.addExtPacker(13, Date, [Number, encode2]);
    codec2.addExtPacker(15, Number, [packValueOf, encode2]);
    if ("undefined" !== typeof Uint8Array) {
      codec2.addExtPacker(17, Int8Array, packTypedArray);
      codec2.addExtPacker(18, Uint8Array, packTypedArray);
      codec2.addExtPacker(19, Int16Array, packTypedArray);
      codec2.addExtPacker(20, Uint16Array, packTypedArray);
      codec2.addExtPacker(21, Int32Array, packTypedArray);
      codec2.addExtPacker(22, Uint32Array, packTypedArray);
      codec2.addExtPacker(23, Float32Array, packTypedArray);
      if ("undefined" !== typeof Float64Array) {
        codec2.addExtPacker(24, Float64Array, packTypedArray);
      }
      if ("undefined" !== typeof Uint8ClampedArray) {
        codec2.addExtPacker(25, Uint8ClampedArray, packTypedArray);
      }
      codec2.addExtPacker(26, ArrayBuffer, packTypedArray);
      codec2.addExtPacker(29, DataView, packTypedArray);
    }
    if (Bufferish2.hasBuffer) {
      codec2.addExtPacker(27, Buffer3, Bufferish2.from);
    }
  }
  function encode2(input) {
    if (!_encode)
      _encode = requireEncode().encode;
    return _encode(input);
  }
  function packValueOf(value2) {
    return value2.valueOf();
  }
  function packRegExp(value2) {
    value2 = RegExp.prototype.toString.call(value2).split("/");
    value2.shift();
    var out = [value2.pop()];
    out.unshift(value2.join("/"));
    return out;
  }
  function packError(value2) {
    var out = {};
    for (var key in ERROR_COLUMNS) {
      out[key] = value2[key];
    }
    return out;
  }
  return extPacker;
}
var writeType = {};
var int64Buffer = {};
(function(exports) {
  !function(exports2) {
    var UNDEFINED = "undefined";
    var BUFFER = UNDEFINED !== typeof Buffer$2 && Buffer$2;
    var UINT8ARRAY = UNDEFINED !== typeof Uint8Array && Uint8Array;
    var ARRAYBUFFER = UNDEFINED !== typeof ArrayBuffer && ArrayBuffer;
    var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
    var isArray2 = Array.isArray || _isArray;
    var BIT32 = 4294967296;
    var BIT24 = 16777216;
    var storage;
    factory2("Uint64BE", true, true);
    factory2("Int64BE", true, false);
    factory2("Uint64LE", false, true);
    factory2("Int64LE", false, false);
    function factory2(name, bigendian, unsigned) {
      var posH = bigendian ? 0 : 4;
      var posL = bigendian ? 4 : 0;
      var pos0 = bigendian ? 0 : 3;
      var pos1 = bigendian ? 1 : 2;
      var pos2 = bigendian ? 2 : 1;
      var pos3 = bigendian ? 3 : 0;
      var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
      var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
      var proto = Int64.prototype;
      var isName = "is" + name;
      var _isInt64 = "_" + isName;
      proto.buffer = void 0;
      proto.offset = 0;
      proto[_isInt64] = true;
      proto.toNumber = toNumber2;
      proto.toString = toString3;
      proto.toJSON = toNumber2;
      proto.toArray = toArray2;
      if (BUFFER)
        proto.toBuffer = toBuffer;
      if (UINT8ARRAY)
        proto.toArrayBuffer = toArrayBuffer;
      Int64[isName] = isInt64;
      exports2[name] = Int64;
      return Int64;
      function Int64(buffer2, offset, value2, raddix) {
        if (!(this instanceof Int64))
          return new Int64(buffer2, offset, value2, raddix);
        return init2(this, buffer2, offset, value2, raddix);
      }
      function isInt64(b3) {
        return !!(b3 && b3[_isInt64]);
      }
      function init2(that, buffer2, offset, value2, raddix) {
        if (UINT8ARRAY && ARRAYBUFFER) {
          if (buffer2 instanceof ARRAYBUFFER)
            buffer2 = new UINT8ARRAY(buffer2);
          if (value2 instanceof ARRAYBUFFER)
            value2 = new UINT8ARRAY(value2);
        }
        if (!buffer2 && !offset && !value2 && !storage) {
          that.buffer = newArray(ZERO, 0);
          return;
        }
        if (!isValidBuffer(buffer2, offset)) {
          var _storage = storage || Array;
          raddix = offset;
          value2 = buffer2;
          offset = 0;
          buffer2 = new _storage(8);
        }
        that.buffer = buffer2;
        that.offset = offset |= 0;
        if (UNDEFINED === typeof value2)
          return;
        if ("string" === typeof value2) {
          fromString2(buffer2, offset, value2, raddix || 10);
        } else if (isValidBuffer(value2, raddix)) {
          fromArray(buffer2, offset, value2, raddix);
        } else if ("number" === typeof raddix) {
          writeInt32(buffer2, offset + posH, value2);
          writeInt32(buffer2, offset + posL, raddix);
        } else if (value2 > 0) {
          fromPositive(buffer2, offset, value2);
        } else if (value2 < 0) {
          fromNegative(buffer2, offset, value2);
        } else {
          fromArray(buffer2, offset, ZERO, 0);
        }
      }
      function fromString2(buffer2, offset, str2, raddix) {
        var pos = 0;
        var len = str2.length;
        var high = 0;
        var low = 0;
        if (str2[0] === "-")
          pos++;
        var sign2 = pos;
        while (pos < len) {
          var chr = parseInt(str2[pos++], raddix);
          if (!(chr >= 0))
            break;
          low = low * raddix + chr;
          high = high * raddix + Math.floor(low / BIT32);
          low %= BIT32;
        }
        if (sign2) {
          high = ~high;
          if (low) {
            low = BIT32 - low;
          } else {
            high++;
          }
        }
        writeInt32(buffer2, offset + posH, high);
        writeInt32(buffer2, offset + posL, low);
      }
      function toNumber2() {
        var buffer2 = this.buffer;
        var offset = this.offset;
        var high = readInt32(buffer2, offset + posH);
        var low = readInt32(buffer2, offset + posL);
        if (!unsigned)
          high |= 0;
        return high ? high * BIT32 + low : low;
      }
      function toString3(radix) {
        var buffer2 = this.buffer;
        var offset = this.offset;
        var high = readInt32(buffer2, offset + posH);
        var low = readInt32(buffer2, offset + posL);
        var str2 = "";
        var sign2 = !unsigned && high & 2147483648;
        if (sign2) {
          high = ~high;
          low = BIT32 - low;
        }
        radix = radix || 10;
        while (1) {
          var mod = high % radix * BIT32 + low;
          high = Math.floor(high / radix);
          low = Math.floor(mod / radix);
          str2 = (mod % radix).toString(radix) + str2;
          if (!high && !low)
            break;
        }
        if (sign2) {
          str2 = "-" + str2;
        }
        return str2;
      }
      function writeInt32(buffer2, offset, value2) {
        buffer2[offset + pos3] = value2 & 255;
        value2 = value2 >> 8;
        buffer2[offset + pos2] = value2 & 255;
        value2 = value2 >> 8;
        buffer2[offset + pos1] = value2 & 255;
        value2 = value2 >> 8;
        buffer2[offset + pos0] = value2 & 255;
      }
      function readInt32(buffer2, offset) {
        return buffer2[offset + pos0] * BIT24 + (buffer2[offset + pos1] << 16) + (buffer2[offset + pos2] << 8) + buffer2[offset + pos3];
      }
    }
    function toArray2(raw) {
      var buffer2 = this.buffer;
      var offset = this.offset;
      storage = null;
      if (raw !== false && offset === 0 && buffer2.length === 8 && isArray2(buffer2))
        return buffer2;
      return newArray(buffer2, offset);
    }
    function toBuffer(raw) {
      var buffer2 = this.buffer;
      var offset = this.offset;
      storage = BUFFER;
      if (raw !== false && offset === 0 && buffer2.length === 8 && Buffer$2.isBuffer(buffer2))
        return buffer2;
      var dest = new BUFFER(8);
      fromArray(dest, 0, buffer2, offset);
      return dest;
    }
    function toArrayBuffer(raw) {
      var buffer2 = this.buffer;
      var offset = this.offset;
      var arrbuf = buffer2.buffer;
      storage = UINT8ARRAY;
      if (raw !== false && offset === 0 && arrbuf instanceof ARRAYBUFFER && arrbuf.byteLength === 8)
        return arrbuf;
      var dest = new UINT8ARRAY(8);
      fromArray(dest, 0, buffer2, offset);
      return dest.buffer;
    }
    function isValidBuffer(buffer2, offset) {
      var len = buffer2 && buffer2.length;
      offset |= 0;
      return len && offset + 8 <= len && "string" !== typeof buffer2[offset];
    }
    function fromArray(destbuf, destoff, srcbuf, srcoff) {
      destoff |= 0;
      srcoff |= 0;
      for (var i2 = 0; i2 < 8; i2++) {
        destbuf[destoff++] = srcbuf[srcoff++] & 255;
      }
    }
    function newArray(buffer2, offset) {
      return Array.prototype.slice.call(buffer2, offset, offset + 8);
    }
    function fromPositiveBE(buffer2, offset, value2) {
      var pos = offset + 8;
      while (pos > offset) {
        buffer2[--pos] = value2 & 255;
        value2 /= 256;
      }
    }
    function fromNegativeBE(buffer2, offset, value2) {
      var pos = offset + 8;
      value2++;
      while (pos > offset) {
        buffer2[--pos] = -value2 & 255 ^ 255;
        value2 /= 256;
      }
    }
    function fromPositiveLE(buffer2, offset, value2) {
      var end = offset + 8;
      while (offset < end) {
        buffer2[offset++] = value2 & 255;
        value2 /= 256;
      }
    }
    function fromNegativeLE(buffer2, offset, value2) {
      var end = offset + 8;
      value2++;
      while (offset < end) {
        buffer2[offset++] = -value2 & 255 ^ 255;
        value2 /= 256;
      }
    }
    function _isArray(val) {
      return !!val && "[object Array]" == Object.prototype.toString.call(val);
    }
  }(typeof exports.nodeName !== "string" ? exports : commonjsGlobal || {});
})(int64Buffer);
var writeToken = {};
var ieee754$2 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754$2.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e3, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset + i2];
  i2 += d2;
  e3 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e3 = e3 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e3 & (1 << -nBits) - 1;
  e3 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  if (e3 === 0) {
    e3 = 1 - eBias;
  } else if (e3 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e3 = e3 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e3 - mLen);
};
ieee754$2.write = function(buffer2, value2, offset, isLE, mLen, nBytes) {
  var e3, m2, c3;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m2 = isNaN(value2) ? 1 : 0;
    e3 = eMax;
  } else {
    e3 = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c3 = Math.pow(2, -e3)) < 1) {
      e3--;
      c3 *= 2;
    }
    if (e3 + eBias >= 1) {
      value2 += rt / c3;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c3 >= 2) {
      e3++;
      c3 /= 2;
    }
    if (e3 + eBias >= eMax) {
      m2 = 0;
      e3 = eMax;
    } else if (e3 + eBias >= 1) {
      m2 = (value2 * c3 - 1) * Math.pow(2, mLen);
      e3 = e3 + eBias;
    } else {
      m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e3 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e3 = e3 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i2] = e3 & 255, i2 += d2, e3 /= 256, eLen -= 8) {
  }
  buffer2[offset + i2 - d2] |= s2 * 128;
};
var writeUint8 = {};
var constant$1 = writeUint8.uint8 = new Array(256);
for (var i$2 = 0; i$2 <= 255; i$2++) {
  constant$1[i$2] = write0(i$2);
}
function write0(type) {
  return function(encoder2) {
    var offset = encoder2.reserve(1);
    encoder2.buffer[offset] = type;
  };
}
var ieee754$1 = ieee754$2;
var Int64Buffer$2 = int64Buffer;
var Uint64BE$2 = Int64Buffer$2.Uint64BE;
var Int64BE$2 = Int64Buffer$2.Int64BE;
var uint8$2 = writeUint8.uint8;
var Bufferish$4 = requireBufferish();
var Buffer2 = Bufferish$4.global;
var IS_BUFFER_SHIM = Bufferish$4.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer2;
var NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer2.TYPED_ARRAY_SUPPORT;
var Buffer_prototype = Bufferish$4.hasBuffer && Buffer2.prototype || {};
writeToken.getWriteToken = getWriteToken;
function getWriteToken(options) {
  if (options && options.uint8array) {
    return init_uint8array();
  } else if (NO_TYPED_ARRAY || Bufferish$4.hasBuffer && options && options.safe) {
    return init_safe();
  } else {
    return init_token$1();
  }
}
function init_uint8array() {
  var token = init_token$1();
  token[202] = writeN(202, 4, writeFloatBE2);
  token[203] = writeN(203, 8, writeDoubleBE2);
  return token;
}
function init_token$1() {
  var token = uint8$2.slice();
  token[196] = write1(196);
  token[197] = write2(197);
  token[198] = write4(198);
  token[199] = write1(199);
  token[200] = write2(200);
  token[201] = write4(201);
  token[202] = writeN(202, 4, Buffer_prototype.writeFloatBE || writeFloatBE2, true);
  token[203] = writeN(203, 8, Buffer_prototype.writeDoubleBE || writeDoubleBE2, true);
  token[204] = write1(204);
  token[205] = write2(205);
  token[206] = write4(206);
  token[207] = writeN(207, 8, writeUInt64BE);
  token[208] = write1(208);
  token[209] = write2(209);
  token[210] = write4(210);
  token[211] = writeN(211, 8, writeInt64BE);
  token[217] = write1(217);
  token[218] = write2(218);
  token[219] = write4(219);
  token[220] = write2(220);
  token[221] = write4(221);
  token[222] = write2(222);
  token[223] = write4(223);
  return token;
}
function init_safe() {
  var token = uint8$2.slice();
  token[196] = writeN(196, 1, Buffer2.prototype.writeUInt8);
  token[197] = writeN(197, 2, Buffer2.prototype.writeUInt16BE);
  token[198] = writeN(198, 4, Buffer2.prototype.writeUInt32BE);
  token[199] = writeN(199, 1, Buffer2.prototype.writeUInt8);
  token[200] = writeN(200, 2, Buffer2.prototype.writeUInt16BE);
  token[201] = writeN(201, 4, Buffer2.prototype.writeUInt32BE);
  token[202] = writeN(202, 4, Buffer2.prototype.writeFloatBE);
  token[203] = writeN(203, 8, Buffer2.prototype.writeDoubleBE);
  token[204] = writeN(204, 1, Buffer2.prototype.writeUInt8);
  token[205] = writeN(205, 2, Buffer2.prototype.writeUInt16BE);
  token[206] = writeN(206, 4, Buffer2.prototype.writeUInt32BE);
  token[207] = writeN(207, 8, writeUInt64BE);
  token[208] = writeN(208, 1, Buffer2.prototype.writeInt8);
  token[209] = writeN(209, 2, Buffer2.prototype.writeInt16BE);
  token[210] = writeN(210, 4, Buffer2.prototype.writeInt32BE);
  token[211] = writeN(211, 8, writeInt64BE);
  token[217] = writeN(217, 1, Buffer2.prototype.writeUInt8);
  token[218] = writeN(218, 2, Buffer2.prototype.writeUInt16BE);
  token[219] = writeN(219, 4, Buffer2.prototype.writeUInt32BE);
  token[220] = writeN(220, 2, Buffer2.prototype.writeUInt16BE);
  token[221] = writeN(221, 4, Buffer2.prototype.writeUInt32BE);
  token[222] = writeN(222, 2, Buffer2.prototype.writeUInt16BE);
  token[223] = writeN(223, 4, Buffer2.prototype.writeUInt32BE);
  return token;
}
function write1(type) {
  return function(encoder2, value2) {
    var offset = encoder2.reserve(2);
    var buffer2 = encoder2.buffer;
    buffer2[offset++] = type;
    buffer2[offset] = value2;
  };
}
function write2(type) {
  return function(encoder2, value2) {
    var offset = encoder2.reserve(3);
    var buffer2 = encoder2.buffer;
    buffer2[offset++] = type;
    buffer2[offset++] = value2 >>> 8;
    buffer2[offset] = value2;
  };
}
function write4(type) {
  return function(encoder2, value2) {
    var offset = encoder2.reserve(5);
    var buffer2 = encoder2.buffer;
    buffer2[offset++] = type;
    buffer2[offset++] = value2 >>> 24;
    buffer2[offset++] = value2 >>> 16;
    buffer2[offset++] = value2 >>> 8;
    buffer2[offset] = value2;
  };
}
function writeN(type, len, method, noAssert) {
  return function(encoder2, value2) {
    var offset = encoder2.reserve(len + 1);
    encoder2.buffer[offset++] = type;
    method.call(encoder2.buffer, value2, offset, noAssert);
  };
}
function writeUInt64BE(value2, offset) {
  new Uint64BE$2(this, offset, value2);
}
function writeInt64BE(value2, offset) {
  new Int64BE$2(this, offset, value2);
}
function writeFloatBE2(value2, offset) {
  ieee754$1.write(this, value2, offset, false, 23, 4);
}
function writeDoubleBE2(value2, offset) {
  ieee754$1.write(this, value2, offset, false, 52, 8);
}
var IS_ARRAY$1 = isarray;
var Int64Buffer$1 = int64Buffer;
var Uint64BE$1 = Int64Buffer$1.Uint64BE;
var Int64BE$1 = Int64Buffer$1.Int64BE;
var Bufferish$3 = requireBufferish();
var BufferProto$1 = requireBufferishProto();
var WriteToken = writeToken;
var uint8$1 = writeUint8.uint8;
var ExtBuffer = extBuffer.ExtBuffer;
var HAS_UINT8ARRAY = "undefined" !== typeof Uint8Array;
var HAS_MAP$1 = "undefined" !== typeof Map;
var extmap = [];
extmap[1] = 212;
extmap[2] = 213;
extmap[4] = 214;
extmap[8] = 215;
extmap[16] = 216;
writeType.getWriteType = getWriteType;
function getWriteType(options) {
  var token = WriteToken.getWriteToken(options);
  var useraw = options && options.useraw;
  var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;
  var isBuffer2 = binarraybuffer ? Bufferish$3.isArrayBuffer : Bufferish$3.isBuffer;
  var bin = binarraybuffer ? bin_arraybuffer2 : bin_buffer2;
  var usemap = HAS_MAP$1 && options && options.usemap;
  var map2 = usemap ? map_to_map2 : obj_to_map;
  var writeType2 = {
    "boolean": bool,
    "function": nil,
    "number": number,
    "object": useraw ? object_raw : object,
    "string": _string(useraw ? raw_head_size : str_head_size),
    "symbol": nil,
    "undefined": nil
  };
  return writeType2;
  function bool(encoder2, value2) {
    var type = value2 ? 195 : 194;
    token[type](encoder2, value2);
  }
  function number(encoder2, value2) {
    var ivalue = value2 | 0;
    var type;
    if (value2 !== ivalue) {
      type = 203;
      token[type](encoder2, value2);
      return;
    } else if (-32 <= ivalue && ivalue <= 127) {
      type = ivalue & 255;
    } else if (0 <= ivalue) {
      type = ivalue <= 255 ? 204 : ivalue <= 65535 ? 205 : 206;
    } else {
      type = -128 <= ivalue ? 208 : -32768 <= ivalue ? 209 : 210;
    }
    token[type](encoder2, ivalue);
  }
  function uint64(encoder2, value2) {
    var type = 207;
    token[type](encoder2, value2.toArray());
  }
  function int64(encoder2, value2) {
    var type = 211;
    token[type](encoder2, value2.toArray());
  }
  function str_head_size(length2) {
    return length2 < 32 ? 1 : length2 <= 255 ? 2 : length2 <= 65535 ? 3 : 5;
  }
  function raw_head_size(length2) {
    return length2 < 32 ? 1 : length2 <= 65535 ? 3 : 5;
  }
  function _string(head_size) {
    return string;
    function string(encoder2, value2) {
      var length2 = value2.length;
      var maxsize = 5 + length2 * 3;
      encoder2.offset = encoder2.reserve(maxsize);
      var buffer2 = encoder2.buffer;
      var expected = head_size(length2);
      var start = encoder2.offset + expected;
      length2 = BufferProto$1.write.call(buffer2, value2, start);
      var actual = head_size(length2);
      if (expected !== actual) {
        var targetStart = start + actual - expected;
        var end = start + length2;
        BufferProto$1.copy.call(buffer2, buffer2, targetStart, start, end);
      }
      var type = actual === 1 ? 160 + length2 : actual <= 3 ? 215 + actual : 219;
      token[type](encoder2, length2);
      encoder2.offset += length2;
    }
  }
  function object(encoder2, value2) {
    if (value2 === null)
      return nil(encoder2, value2);
    if (isBuffer2(value2))
      return bin(encoder2, value2);
    if (IS_ARRAY$1(value2))
      return array2(encoder2, value2);
    if (Uint64BE$1.isUint64BE(value2))
      return uint64(encoder2, value2);
    if (Int64BE$1.isInt64BE(value2))
      return int64(encoder2, value2);
    var packer = encoder2.codec.getExtPacker(value2);
    if (packer)
      value2 = packer(value2);
    if (value2 instanceof ExtBuffer)
      return ext2(encoder2, value2);
    map2(encoder2, value2);
  }
  function object_raw(encoder2, value2) {
    if (isBuffer2(value2))
      return raw(encoder2, value2);
    object(encoder2, value2);
  }
  function nil(encoder2, value2) {
    var type = 192;
    token[type](encoder2, value2);
  }
  function array2(encoder2, value2) {
    var length2 = value2.length;
    var type = length2 < 16 ? 144 + length2 : length2 <= 65535 ? 220 : 221;
    token[type](encoder2, length2);
    var encode2 = encoder2.codec.encode;
    for (var i2 = 0; i2 < length2; i2++) {
      encode2(encoder2, value2[i2]);
    }
  }
  function bin_buffer2(encoder2, value2) {
    var length2 = value2.length;
    var type = length2 < 255 ? 196 : length2 <= 65535 ? 197 : 198;
    token[type](encoder2, length2);
    encoder2.send(value2);
  }
  function bin_arraybuffer2(encoder2, value2) {
    bin_buffer2(encoder2, new Uint8Array(value2));
  }
  function ext2(encoder2, value2) {
    var buffer2 = value2.buffer;
    var length2 = buffer2.length;
    var type = extmap[length2] || (length2 < 255 ? 199 : length2 <= 65535 ? 200 : 201);
    token[type](encoder2, length2);
    uint8$1[value2.type](encoder2);
    encoder2.send(buffer2);
  }
  function obj_to_map(encoder2, value2) {
    var keys2 = Object.keys(value2);
    var length2 = keys2.length;
    var type = length2 < 16 ? 128 + length2 : length2 <= 65535 ? 222 : 223;
    token[type](encoder2, length2);
    var encode2 = encoder2.codec.encode;
    keys2.forEach(function(key) {
      encode2(encoder2, key);
      encode2(encoder2, value2[key]);
    });
  }
  function map_to_map2(encoder2, value2) {
    if (!(value2 instanceof Map))
      return obj_to_map(encoder2, value2);
    var length2 = value2.size;
    var type = length2 < 16 ? 128 + length2 : length2 <= 65535 ? 222 : 223;
    token[type](encoder2, length2);
    var encode2 = encoder2.codec.encode;
    value2.forEach(function(val, key, m2) {
      encode2(encoder2, key);
      encode2(encoder2, val);
    });
  }
  function raw(encoder2, value2) {
    var length2 = value2.length;
    var type = length2 < 32 ? 160 + length2 : length2 <= 65535 ? 218 : 219;
    token[type](encoder2, length2);
    encoder2.send(value2);
  }
}
var codecBase = {};
var IS_ARRAY = isarray;
codecBase.createCodec = createCodec;
codecBase.install = install;
codecBase.filter = filter;
var Bufferish$2 = requireBufferish();
function Codec(options) {
  if (!(this instanceof Codec))
    return new Codec(options);
  this.options = options;
  this.init();
}
Codec.prototype.init = function() {
  var options = this.options;
  if (options && options.uint8array) {
    this.bufferish = Bufferish$2.Uint8Array;
  }
  return this;
};
function install(props) {
  for (var key in props) {
    Codec.prototype[key] = add(Codec.prototype[key], props[key]);
  }
}
function add(a8, b3) {
  return a8 && b3 ? ab : a8 || b3;
  function ab() {
    a8.apply(this, arguments);
    return b3.apply(this, arguments);
  }
}
function join(filters2) {
  filters2 = filters2.slice();
  return function(value2) {
    return filters2.reduce(iterator2, value2);
  };
  function iterator2(value2, filter2) {
    return filter2(value2);
  }
}
function filter(filter2) {
  return IS_ARRAY(filter2) ? join(filter2) : filter2;
}
function createCodec(options) {
  return new Codec(options);
}
codecBase.preset = createCodec({ preset: true });
var hasRequiredWriteCore;
function requireWriteCore() {
  if (hasRequiredWriteCore)
    return writeCore;
  hasRequiredWriteCore = 1;
  var ExtBuffer2 = extBuffer.ExtBuffer;
  var ExtPacker = requireExtPacker();
  var WriteType = writeType;
  var CodecBase = codecBase;
  CodecBase.install({
    addExtPacker,
    getExtPacker,
    init: init2
  });
  writeCore.preset = init2.call(CodecBase.preset);
  function getEncoder(options) {
    var writeType2 = WriteType.getWriteType(options);
    return encode2;
    function encode2(encoder2, value2) {
      var func = writeType2[typeof value2];
      if (!func)
        throw new Error('Unsupported type "' + typeof value2 + '": ' + value2);
      func(encoder2, value2);
    }
  }
  function init2() {
    var options = this.options;
    this.encode = getEncoder(options);
    if (options && options.preset) {
      ExtPacker.setExtPackers(this);
    }
    return this;
  }
  function addExtPacker(etype, Class, packer) {
    packer = CodecBase.filter(packer);
    var name = Class.name;
    if (name && name !== "Object") {
      var packers = this.extPackers || (this.extPackers = {});
      packers[name] = extPacker2;
    } else {
      var list = this.extEncoderList || (this.extEncoderList = []);
      list.unshift([Class, extPacker2]);
    }
    function extPacker2(value2) {
      if (packer)
        value2 = packer(value2);
      return new ExtBuffer2(value2, etype);
    }
  }
  function getExtPacker(value2) {
    var packers = this.extPackers || (this.extPackers = {});
    var c3 = value2.constructor;
    var e3 = c3 && c3.name && packers[c3.name];
    if (e3)
      return e3;
    var list = this.extEncoderList || (this.extEncoderList = []);
    var len = list.length;
    for (var i2 = 0; i2 < len; i2++) {
      var pair = list[i2];
      if (c3 === pair[0])
        return pair[1];
    }
  }
  return writeCore;
}
var flexBuffer = {};
flexBuffer.FlexDecoder = FlexDecoder;
flexBuffer.FlexEncoder = FlexEncoder;
var Bufferish$1 = requireBufferish();
var MIN_BUFFER_SIZE = 2048;
var MAX_BUFFER_SIZE = 65536;
var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";
function FlexDecoder() {
  if (!(this instanceof FlexDecoder))
    return new FlexDecoder();
}
function FlexEncoder() {
  if (!(this instanceof FlexEncoder))
    return new FlexEncoder();
}
FlexDecoder.mixin = mixinFactory(getDecoderMethods());
FlexDecoder.mixin(FlexDecoder.prototype);
FlexEncoder.mixin = mixinFactory(getEncoderMethods());
FlexEncoder.mixin(FlexEncoder.prototype);
function getDecoderMethods() {
  return {
    bufferish: Bufferish$1,
    write: write5,
    fetch: fetch$1,
    flush,
    push,
    pull,
    read: read$1,
    reserve,
    offset: 0
  };
  function write5(chunk) {
    var prev2 = this.offset ? Bufferish$1.prototype.slice.call(this.buffer, this.offset) : this.buffer;
    this.buffer = prev2 ? chunk ? this.bufferish.concat([prev2, chunk]) : prev2 : chunk;
    this.offset = 0;
  }
  function flush() {
    while (this.offset < this.buffer.length) {
      var start = this.offset;
      var value2;
      try {
        value2 = this.fetch();
      } catch (e3) {
        if (e3 && e3.message != BUFFER_SHORTAGE)
          throw e3;
        this.offset = start;
        break;
      }
      this.push(value2);
    }
  }
  function reserve(length2) {
    var start = this.offset;
    var end = start + length2;
    if (end > this.buffer.length)
      throw new Error(BUFFER_SHORTAGE);
    this.offset = end;
    return start;
  }
}
function getEncoderMethods() {
  return {
    bufferish: Bufferish$1,
    write: write3,
    fetch: fetch2,
    flush,
    push,
    pull: pull2,
    read: read$1,
    reserve,
    send,
    maxBufferSize: MAX_BUFFER_SIZE,
    minBufferSize: MIN_BUFFER_SIZE,
    offset: 0,
    start: 0
  };
  function fetch2() {
    var start = this.start;
    if (start < this.offset) {
      var end = this.start = this.offset;
      return Bufferish$1.prototype.slice.call(this.buffer, start, end);
    }
  }
  function flush() {
    while (this.start < this.offset) {
      var value2 = this.fetch();
      if (value2)
        this.push(value2);
    }
  }
  function pull2() {
    var buffers = this.buffers || (this.buffers = []);
    var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];
    buffers.length = 0;
    return chunk;
  }
  function reserve(length2) {
    var req = length2 | 0;
    if (this.buffer) {
      var size2 = this.buffer.length;
      var start = this.offset | 0;
      var end = start + req;
      if (end < size2) {
        this.offset = end;
        return start;
      }
      this.flush();
      length2 = Math.max(length2, Math.min(size2 * 2, this.maxBufferSize));
    }
    length2 = Math.max(length2, this.minBufferSize);
    this.buffer = this.bufferish.alloc(length2);
    this.start = 0;
    this.offset = req;
    return 0;
  }
  function send(buffer2) {
    var length2 = buffer2.length;
    if (length2 > this.minBufferSize) {
      this.flush();
      this.push(buffer2);
    } else {
      var offset = this.reserve(length2);
      Bufferish$1.prototype.copy.call(buffer2, this.buffer, offset);
    }
  }
}
function write3() {
  throw new Error("method not implemented: write()");
}
function fetch$1() {
  throw new Error("method not implemented: fetch()");
}
function read$1() {
  var length2 = this.buffers && this.buffers.length;
  if (!length2)
    return this.fetch();
  this.flush();
  return this.pull();
}
function push(chunk) {
  var buffers = this.buffers || (this.buffers = []);
  buffers.push(chunk);
}
function pull() {
  var buffers = this.buffers || (this.buffers = []);
  return buffers.shift();
}
function mixinFactory(source) {
  return mixin2;
  function mixin2(target) {
    for (var key in source) {
      target[key] = source[key];
    }
    return target;
  }
}
var hasRequiredEncodeBuffer;
function requireEncodeBuffer() {
  if (hasRequiredEncodeBuffer)
    return encodeBuffer;
  hasRequiredEncodeBuffer = 1;
  encodeBuffer.EncodeBuffer = EncodeBuffer2;
  var preset = requireWriteCore().preset;
  var FlexEncoder2 = flexBuffer.FlexEncoder;
  FlexEncoder2.mixin(EncodeBuffer2.prototype);
  function EncodeBuffer2(options) {
    if (!(this instanceof EncodeBuffer2))
      return new EncodeBuffer2(options);
    if (options) {
      this.options = options;
      if (options.codec) {
        var codec2 = this.codec = options.codec;
        if (codec2.bufferish)
          this.bufferish = codec2.bufferish;
      }
    }
  }
  EncodeBuffer2.prototype.codec = preset;
  EncodeBuffer2.prototype.write = function(input) {
    this.codec.encode(this, input);
  };
  return encodeBuffer;
}
var hasRequiredEncode;
function requireEncode() {
  if (hasRequiredEncode)
    return encode$2;
  hasRequiredEncode = 1;
  encode$2.encode = encode2;
  var EncodeBuffer2 = requireEncodeBuffer().EncodeBuffer;
  function encode2(input, options) {
    var encoder2 = new EncodeBuffer2(options);
    encoder2.write(input);
    return encoder2.read();
  }
  return encode$2;
}
var decode$2 = {};
var decodeBuffer = {};
var readCore = {};
var extUnpacker = {};
var hasRequiredExtUnpacker;
function requireExtUnpacker() {
  if (hasRequiredExtUnpacker)
    return extUnpacker;
  hasRequiredExtUnpacker = 1;
  extUnpacker.setExtUnpackers = setExtUnpackers;
  var Bufferish2 = requireBufferish();
  var Buffer3 = Bufferish2.global;
  var _decode;
  var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
  function setExtUnpackers(codec2) {
    codec2.addExtUnpacker(14, [decode2, unpackError(Error)]);
    codec2.addExtUnpacker(1, [decode2, unpackError(EvalError)]);
    codec2.addExtUnpacker(2, [decode2, unpackError(RangeError)]);
    codec2.addExtUnpacker(3, [decode2, unpackError(ReferenceError)]);
    codec2.addExtUnpacker(4, [decode2, unpackError(SyntaxError)]);
    codec2.addExtUnpacker(5, [decode2, unpackError(TypeError)]);
    codec2.addExtUnpacker(6, [decode2, unpackError(URIError)]);
    codec2.addExtUnpacker(10, [decode2, unpackRegExp]);
    codec2.addExtUnpacker(11, [decode2, unpackClass(Boolean)]);
    codec2.addExtUnpacker(12, [decode2, unpackClass(String)]);
    codec2.addExtUnpacker(13, [decode2, unpackClass(Date)]);
    codec2.addExtUnpacker(15, [decode2, unpackClass(Number)]);
    if ("undefined" !== typeof Uint8Array) {
      codec2.addExtUnpacker(17, unpackClass(Int8Array));
      codec2.addExtUnpacker(18, unpackClass(Uint8Array));
      codec2.addExtUnpacker(19, [unpackArrayBuffer, unpackClass(Int16Array)]);
      codec2.addExtUnpacker(20, [unpackArrayBuffer, unpackClass(Uint16Array)]);
      codec2.addExtUnpacker(21, [unpackArrayBuffer, unpackClass(Int32Array)]);
      codec2.addExtUnpacker(22, [unpackArrayBuffer, unpackClass(Uint32Array)]);
      codec2.addExtUnpacker(23, [unpackArrayBuffer, unpackClass(Float32Array)]);
      if ("undefined" !== typeof Float64Array) {
        codec2.addExtUnpacker(24, [unpackArrayBuffer, unpackClass(Float64Array)]);
      }
      if ("undefined" !== typeof Uint8ClampedArray) {
        codec2.addExtUnpacker(25, unpackClass(Uint8ClampedArray));
      }
      codec2.addExtUnpacker(26, unpackArrayBuffer);
      codec2.addExtUnpacker(29, [unpackArrayBuffer, unpackClass(DataView)]);
    }
    if (Bufferish2.hasBuffer) {
      codec2.addExtUnpacker(27, unpackClass(Buffer3));
    }
  }
  function decode2(input) {
    if (!_decode)
      _decode = requireDecode().decode;
    return _decode(input);
  }
  function unpackRegExp(value2) {
    return RegExp.apply(null, value2);
  }
  function unpackError(Class) {
    return function(value2) {
      var out = new Class();
      for (var key in ERROR_COLUMNS) {
        out[key] = value2[key];
      }
      return out;
    };
  }
  function unpackClass(Class) {
    return function(value2) {
      return new Class(value2);
    };
  }
  function unpackArrayBuffer(value2) {
    return new Uint8Array(value2).buffer;
  }
  return extUnpacker;
}
var readFormat = {};
var ieee754 = ieee754$2;
var Int64Buffer = int64Buffer;
var Uint64BE = Int64Buffer.Uint64BE;
var Int64BE = Int64Buffer.Int64BE;
readFormat.getReadFormat = getReadFormat;
readFormat.readUint8 = uint8;
var Bufferish = requireBufferish();
var BufferProto = requireBufferishProto();
var HAS_MAP = "undefined" !== typeof Map;
var NO_ASSERT = true;
function getReadFormat(options) {
  var binarraybuffer = Bufferish.hasArrayBuffer && options && options.binarraybuffer;
  var int64 = options && options.int64;
  var usemap = HAS_MAP && options && options.usemap;
  var readFormat2 = {
    map: usemap ? map_to_map : map_to_obj,
    array,
    str,
    bin: binarraybuffer ? bin_arraybuffer : bin_buffer,
    ext: ext$1,
    uint8,
    uint16,
    uint32,
    uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),
    int8,
    int16,
    int32,
    int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),
    float32: read(4, readFloatBE2),
    float64: read(8, readDoubleBE2)
  };
  return readFormat2;
}
function map_to_obj(decoder2, len) {
  var value2 = {};
  var i2;
  var k4 = new Array(len);
  var v2 = new Array(len);
  var decode2 = decoder2.codec.decode;
  for (i2 = 0; i2 < len; i2++) {
    k4[i2] = decode2(decoder2);
    v2[i2] = decode2(decoder2);
  }
  for (i2 = 0; i2 < len; i2++) {
    value2[k4[i2]] = v2[i2];
  }
  return value2;
}
function map_to_map(decoder2, len) {
  var value2 = /* @__PURE__ */ new Map();
  var i2;
  var k4 = new Array(len);
  var v2 = new Array(len);
  var decode2 = decoder2.codec.decode;
  for (i2 = 0; i2 < len; i2++) {
    k4[i2] = decode2(decoder2);
    v2[i2] = decode2(decoder2);
  }
  for (i2 = 0; i2 < len; i2++) {
    value2.set(k4[i2], v2[i2]);
  }
  return value2;
}
function array(decoder2, len) {
  var value2 = new Array(len);
  var decode2 = decoder2.codec.decode;
  for (var i2 = 0; i2 < len; i2++) {
    value2[i2] = decode2(decoder2);
  }
  return value2;
}
function str(decoder2, len) {
  var start = decoder2.reserve(len);
  var end = start + len;
  return BufferProto.toString.call(decoder2.buffer, "utf-8", start, end);
}
function bin_buffer(decoder2, len) {
  var start = decoder2.reserve(len);
  var end = start + len;
  var buf = BufferProto.slice.call(decoder2.buffer, start, end);
  return Bufferish.from(buf);
}
function bin_arraybuffer(decoder2, len) {
  var start = decoder2.reserve(len);
  var end = start + len;
  var buf = BufferProto.slice.call(decoder2.buffer, start, end);
  return Bufferish.Uint8Array.from(buf).buffer;
}
function ext$1(decoder2, len) {
  var start = decoder2.reserve(len + 1);
  var type = decoder2.buffer[start++];
  var end = start + len;
  var unpack = decoder2.codec.getExtUnpacker(type);
  if (!unpack)
    throw new Error("Invalid ext type: " + (type ? "0x" + type.toString(16) : type));
  var buf = BufferProto.slice.call(decoder2.buffer, start, end);
  return unpack(buf);
}
function uint8(decoder2) {
  var start = decoder2.reserve(1);
  return decoder2.buffer[start];
}
function int8(decoder2) {
  var start = decoder2.reserve(1);
  var value2 = decoder2.buffer[start];
  return value2 & 128 ? value2 - 256 : value2;
}
function uint16(decoder2) {
  var start = decoder2.reserve(2);
  var buffer2 = decoder2.buffer;
  return buffer2[start++] << 8 | buffer2[start];
}
function int16(decoder2) {
  var start = decoder2.reserve(2);
  var buffer2 = decoder2.buffer;
  var value2 = buffer2[start++] << 8 | buffer2[start];
  return value2 & 32768 ? value2 - 65536 : value2;
}
function uint32(decoder2) {
  var start = decoder2.reserve(4);
  var buffer2 = decoder2.buffer;
  return buffer2[start++] * 16777216 + (buffer2[start++] << 16) + (buffer2[start++] << 8) + buffer2[start];
}
function int32(decoder2) {
  var start = decoder2.reserve(4);
  var buffer2 = decoder2.buffer;
  return buffer2[start++] << 24 | buffer2[start++] << 16 | buffer2[start++] << 8 | buffer2[start];
}
function read(len, method) {
  return function(decoder2) {
    var start = decoder2.reserve(len);
    return method.call(decoder2.buffer, start, NO_ASSERT);
  };
}
function readUInt64BE(start) {
  return new Uint64BE(this, start).toNumber();
}
function readInt64BE(start) {
  return new Int64BE(this, start).toNumber();
}
function readUInt64BE_int64(start) {
  return new Uint64BE(this, start);
}
function readInt64BE_int64(start) {
  return new Int64BE(this, start);
}
function readFloatBE2(start) {
  return ieee754.read(this, start, false, 23, 4);
}
function readDoubleBE2(start) {
  return ieee754.read(this, start, false, 52, 8);
}
var readToken = {};
var ReadFormat = readFormat;
readToken.getReadToken = getReadToken;
function getReadToken(options) {
  var format2 = ReadFormat.getReadFormat(options);
  if (options && options.useraw) {
    return init_useraw(format2);
  } else {
    return init_token(format2);
  }
}
function init_token(format2) {
  var i2;
  var token = new Array(256);
  for (i2 = 0; i2 <= 127; i2++) {
    token[i2] = constant(i2);
  }
  for (i2 = 128; i2 <= 143; i2++) {
    token[i2] = fix(i2 - 128, format2.map);
  }
  for (i2 = 144; i2 <= 159; i2++) {
    token[i2] = fix(i2 - 144, format2.array);
  }
  for (i2 = 160; i2 <= 191; i2++) {
    token[i2] = fix(i2 - 160, format2.str);
  }
  token[192] = constant(null);
  token[193] = null;
  token[194] = constant(false);
  token[195] = constant(true);
  token[196] = flex(format2.uint8, format2.bin);
  token[197] = flex(format2.uint16, format2.bin);
  token[198] = flex(format2.uint32, format2.bin);
  token[199] = flex(format2.uint8, format2.ext);
  token[200] = flex(format2.uint16, format2.ext);
  token[201] = flex(format2.uint32, format2.ext);
  token[202] = format2.float32;
  token[203] = format2.float64;
  token[204] = format2.uint8;
  token[205] = format2.uint16;
  token[206] = format2.uint32;
  token[207] = format2.uint64;
  token[208] = format2.int8;
  token[209] = format2.int16;
  token[210] = format2.int32;
  token[211] = format2.int64;
  token[212] = fix(1, format2.ext);
  token[213] = fix(2, format2.ext);
  token[214] = fix(4, format2.ext);
  token[215] = fix(8, format2.ext);
  token[216] = fix(16, format2.ext);
  token[217] = flex(format2.uint8, format2.str);
  token[218] = flex(format2.uint16, format2.str);
  token[219] = flex(format2.uint32, format2.str);
  token[220] = flex(format2.uint16, format2.array);
  token[221] = flex(format2.uint32, format2.array);
  token[222] = flex(format2.uint16, format2.map);
  token[223] = flex(format2.uint32, format2.map);
  for (i2 = 224; i2 <= 255; i2++) {
    token[i2] = constant(i2 - 256);
  }
  return token;
}
function init_useraw(format2) {
  var i2;
  var token = init_token(format2).slice();
  token[217] = token[196];
  token[218] = token[197];
  token[219] = token[198];
  for (i2 = 160; i2 <= 191; i2++) {
    token[i2] = fix(i2 - 160, format2.bin);
  }
  return token;
}
function constant(value2) {
  return function() {
    return value2;
  };
}
function flex(lenFunc, decodeFunc) {
  return function(decoder2) {
    var len = lenFunc(decoder2);
    return decodeFunc(decoder2, len);
  };
}
function fix(len, method) {
  return function(decoder2) {
    return method(decoder2, len);
  };
}
var hasRequiredReadCore;
function requireReadCore() {
  if (hasRequiredReadCore)
    return readCore;
  hasRequiredReadCore = 1;
  var ExtBuffer2 = extBuffer.ExtBuffer;
  var ExtUnpacker = requireExtUnpacker();
  var readUint8 = readFormat.readUint8;
  var ReadToken = readToken;
  var CodecBase = codecBase;
  CodecBase.install({
    addExtUnpacker,
    getExtUnpacker,
    init: init2
  });
  readCore.preset = init2.call(CodecBase.preset);
  function getDecoder(options) {
    var readToken2 = ReadToken.getReadToken(options);
    return decode2;
    function decode2(decoder2) {
      var type = readUint8(decoder2);
      var func = readToken2[type];
      if (!func)
        throw new Error("Invalid type: " + (type ? "0x" + type.toString(16) : type));
      return func(decoder2);
    }
  }
  function init2() {
    var options = this.options;
    this.decode = getDecoder(options);
    if (options && options.preset) {
      ExtUnpacker.setExtUnpackers(this);
    }
    return this;
  }
  function addExtUnpacker(etype, unpacker) {
    var unpackers = this.extUnpackers || (this.extUnpackers = []);
    unpackers[etype] = CodecBase.filter(unpacker);
  }
  function getExtUnpacker(type) {
    var unpackers = this.extUnpackers || (this.extUnpackers = []);
    return unpackers[type] || extUnpacker2;
    function extUnpacker2(buffer2) {
      return new ExtBuffer2(buffer2, type);
    }
  }
  return readCore;
}
var hasRequiredDecodeBuffer;
function requireDecodeBuffer() {
  if (hasRequiredDecodeBuffer)
    return decodeBuffer;
  hasRequiredDecodeBuffer = 1;
  decodeBuffer.DecodeBuffer = DecodeBuffer2;
  var preset = requireReadCore().preset;
  var FlexDecoder2 = flexBuffer.FlexDecoder;
  FlexDecoder2.mixin(DecodeBuffer2.prototype);
  function DecodeBuffer2(options) {
    if (!(this instanceof DecodeBuffer2))
      return new DecodeBuffer2(options);
    if (options) {
      this.options = options;
      if (options.codec) {
        var codec2 = this.codec = options.codec;
        if (codec2.bufferish)
          this.bufferish = codec2.bufferish;
      }
    }
  }
  DecodeBuffer2.prototype.codec = preset;
  DecodeBuffer2.prototype.fetch = function() {
    return this.codec.decode(this);
  };
  return decodeBuffer;
}
var hasRequiredDecode;
function requireDecode() {
  if (hasRequiredDecode)
    return decode$2;
  hasRequiredDecode = 1;
  decode$2.decode = decode2;
  var DecodeBuffer2 = requireDecodeBuffer().DecodeBuffer;
  function decode2(input, options) {
    var decoder2 = new DecodeBuffer2(options);
    decoder2.write(input);
    return decoder2.read();
  }
  return decode$2;
}
var encoder = {};
var eventLite = { exports: {} };
/**
 * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
 *
 * @copyright Yusuke Kawasaki
 * @license MIT
 * @constructor
 * @see https://github.com/kawanet/event-lite
 * @see http://kawanet.github.io/event-lite/EventLite.html
 * @example
 * var EventLite = require("event-lite");
 *
 * function MyClass() {...}             // your class
 *
 * EventLite.mixin(MyClass.prototype);  // import event methods
 *
 * var obj = new MyClass();
 * obj.on("foo", function() {...});     // add event listener
 * obj.once("bar", function() {...});   // add one-time event listener
 * obj.emit("foo");                     // dispatch event
 * obj.emit("bar");                     // dispatch another event
 * obj.off("foo");                      // remove event listener
 */
(function(module) {
  function EventLite2() {
    if (!(this instanceof EventLite2))
      return new EventLite2();
  }
  (function(EventLite3) {
    module.exports = EventLite3;
    var LISTENERS = "listeners";
    var methods = {
      on: on2,
      once: once3,
      off: off2,
      emit: emit3
    };
    mixin2(EventLite3.prototype);
    EventLite3.mixin = mixin2;
    function mixin2(target) {
      for (var key in methods) {
        target[key] = methods[key];
      }
      return target;
    }
    function on2(type, func) {
      getListeners(this, type).push(func);
      return this;
    }
    function once3(type, func) {
      var that = this;
      wrap.originalListener = func;
      getListeners(that, type).push(wrap);
      return that;
      function wrap() {
        off2.call(that, type, wrap);
        func.apply(this, arguments);
      }
    }
    function off2(type, func) {
      var that = this;
      var listners;
      if (!arguments.length) {
        delete that[LISTENERS];
      } else if (!func) {
        listners = that[LISTENERS];
        if (listners) {
          delete listners[type];
          if (!Object.keys(listners).length)
            return off2.call(that);
        }
      } else {
        listners = getListeners(that, type, true);
        if (listners) {
          listners = listners.filter(ne);
          if (!listners.length)
            return off2.call(that, type);
          that[LISTENERS][type] = listners;
        }
      }
      return that;
      function ne(test) {
        return test !== func && test.originalListener !== func;
      }
    }
    function emit3(type, value2) {
      var that = this;
      var listeners2 = getListeners(that, type, true);
      if (!listeners2)
        return false;
      var arglen = arguments.length;
      if (arglen === 1) {
        listeners2.forEach(zeroarg);
      } else if (arglen === 2) {
        listeners2.forEach(onearg);
      } else {
        var args = Array.prototype.slice.call(arguments, 1);
        listeners2.forEach(moreargs);
      }
      return !!listeners2.length;
      function zeroarg(func) {
        func.call(that);
      }
      function onearg(func) {
        func.call(that, value2);
      }
      function moreargs(func) {
        func.apply(that, args);
      }
    }
    function getListeners(that, type, readonly2) {
      if (readonly2 && !that[LISTENERS])
        return;
      var listeners2 = that[LISTENERS] || (that[LISTENERS] = {});
      return listeners2[type] || (listeners2[type] = []);
    }
  })(EventLite2);
})(eventLite);
var eventLiteExports = eventLite.exports;
encoder.Encoder = Encoder$1;
var EventLite$1 = eventLiteExports;
var EncodeBuffer = requireEncodeBuffer().EncodeBuffer;
function Encoder$1(options) {
  if (!(this instanceof Encoder$1))
    return new Encoder$1(options);
  EncodeBuffer.call(this, options);
}
Encoder$1.prototype = new EncodeBuffer();
EventLite$1.mixin(Encoder$1.prototype);
Encoder$1.prototype.encode = function(chunk) {
  this.write(chunk);
  this.emit("data", this.read());
};
Encoder$1.prototype.end = function(chunk) {
  if (arguments.length)
    this.encode(chunk);
  this.flush();
  this.emit("end");
};
var decoder = {};
decoder.Decoder = Decoder$1;
var EventLite = eventLiteExports;
var DecodeBuffer = requireDecodeBuffer().DecodeBuffer;
function Decoder$1(options) {
  if (!(this instanceof Decoder$1))
    return new Decoder$1(options);
  DecodeBuffer.call(this, options);
}
Decoder$1.prototype = new DecodeBuffer();
EventLite.mixin(Decoder$1.prototype);
Decoder$1.prototype.decode = function(chunk) {
  if (arguments.length)
    this.write(chunk);
  this.flush();
};
Decoder$1.prototype.push = function(chunk) {
  this.emit("data", chunk);
};
Decoder$1.prototype.end = function(chunk) {
  this.decode(chunk);
  this.emit("end");
};
var ext = {};
requireReadCore();
requireWriteCore();
ext.createCodec = codecBase.createCodec;
var codec = {};
requireReadCore();
requireWriteCore();
codec.codec = {
  preset: codecBase.preset
};
browser.encode = requireEncode().encode;
browser.decode = requireDecode().decode;
browser.Encoder = encoder.Encoder;
browser.Decoder = decoder.Decoder;
browser.createCodec = ext.createCodec;
browser.codec = codec.codec;
var lodash_mergewith = { exports: {} };
lodash_mergewith.exports;
(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e3) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function baseTimes(n2, iteratee) {
    var index2 = -1, result = Array(n2);
    while (++index2 < n2) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value2) {
      return func(value2);
    };
  }
  function getValue2(object, key) {
    return object == null ? void 0 : object[key];
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData2 = root2["__core-js_shared__"];
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var maskSrcKey2 = function() {
    var uid2 = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
    return uid2 ? "Symbol(src)_1." + uid2 : "";
  }();
  var nativeObjectToString = objectProto2.toString;
  var objectCtorString = funcToString2.call(Object);
  var reIsNative2 = RegExp(
    "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer3 = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, allocUnsafe2 = Buffer3 ? Buffer3.allocUnsafe : void 0, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var defineProperty = function() {
    try {
      var func = getNative2(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e3) {
    }
  }();
  var nativeIsBuffer = Buffer3 ? Buffer3.isBuffer : void 0, nativeMax = Math.max, nativeNow = Date.now;
  var Map2 = getNative2(root2, "Map"), nativeCreate2 = getNative2(Object, "create");
  var baseCreate = function() {
    function object() {
    }
    return function(proto) {
      if (!isObject2(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  function Hash2(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
    this.size = 0;
  }
  function hashDelete2(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet2(key) {
    var data = this.__data__;
    if (nativeCreate2) {
      var result = data[key];
      return result === HASH_UNDEFINED2 ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key) ? data[key] : void 0;
  }
  function hashHas2(key) {
    var data = this.__data__;
    return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
  }
  function hashSet2(key, value2) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate2 && value2 === void 0 ? HASH_UNDEFINED2 : value2;
    return this;
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  function ListCache2(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear2() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice2.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  function listCacheSet2(key, value2) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      ++this.size;
      data.push([key, value2]);
    } else {
      data[index2][1] = value2;
    }
    return this;
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  function MapCache2(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear2() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map2 || ListCache2)(),
      "string": new Hash2()
    };
  }
  function mapCacheDelete2(key) {
    var result = getMapData2(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  function mapCacheSet2(key, value2) {
    var data = getMapData2(this, key), size2 = data.size;
    data.set(key, value2);
    this.size += data.size == size2 ? 0 : 1;
    return this;
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  function Stack(entries) {
    var data = this.__data__ = new ListCache2(entries);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache2();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value2) {
    var data = this.__data__;
    if (data instanceof ListCache2) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value2]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache2(pairs);
    }
    data.set(key, value2);
    this.size = data.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value2, inherited) {
    var isArr = isArray2(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer2(value2), isType = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length2 = result.length;
    for (var key in value2) {
      if ((inherited || hasOwnProperty2.call(value2, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex(key, length2)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignMergeValue(object, key, value2) {
    if (value2 !== void 0 && !eq2(object[key], value2) || value2 === void 0 && !(key in object)) {
      baseAssignValue(object, key, value2);
    }
  }
  function assignValue(object, key, value2) {
    var objValue = object[key];
    if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value2)) || value2 === void 0 && !(key in object)) {
      baseAssignValue(object, key, value2);
    }
  }
  function assocIndexOf2(array2, key) {
    var length2 = array2.length;
    while (length2--) {
      if (eq2(array2[length2][0], key)) {
        return length2;
      }
    }
    return -1;
  }
  function baseAssignValue(object, key, value2) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value2,
        "writable": true
      });
    } else {
      object[key] = value2;
    }
  }
  var baseFor = createBaseFor();
  function baseGetTag(value2) {
    if (value2 == null) {
      return value2 === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString2(value2);
  }
  function baseIsArguments(value2) {
    return isObjectLike2(value2) && baseGetTag(value2) == argsTag;
  }
  function baseIsNative2(value2) {
    if (!isObject2(value2) || isMasked2(value2)) {
      return false;
    }
    var pattern = isFunction2(value2) ? reIsNative2 : reIsHostCtor2;
    return pattern.test(toSource2(value2));
  }
  function baseIsTypedArray(value2) {
    return isObjectLike2(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
  }
  function baseKeysIn(object) {
    if (!isObject2(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor(source, function(srcValue, key) {
      stack || (stack = new Stack());
      if (isObject2(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray2(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject2(objValue) || isFunction2(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue(object, key, newValue);
  }
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity2), func + "");
  }
  var baseSetToString = !defineProperty ? identity2 : function(func, string) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant2(string),
      "writable": true
    });
  };
  function cloneBuffer(buffer2, isDeep) {
    if (isDeep) {
      return buffer2.slice();
    }
    var length2 = buffer2.length, result = allocUnsafe2 ? allocUnsafe2(length2) : new buffer2.constructor(length2);
    buffer2.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source, array2) {
    var index2 = -1, length2 = source.length;
    array2 || (array2 = Array(length2));
    while (++index2 < length2) {
      array2[index2] = source[index2];
    }
    return array2;
  }
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index2 = -1, length2 = props.length;
    while (++index2 < length2) {
      var key = props[index2];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length2 < 3 ? void 0 : customizer;
        length2 = 1;
      }
      object = Object(object);
      while (++index2 < length2) {
        var source = sources[index2];
        if (source) {
          assigner(object, source, index2, customizer);
        }
      }
      return object;
    });
  }
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
      while (length2--) {
        var key = props[fromRight ? length2 : ++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  function getMapData2(map2, key) {
    var data = map2.__data__;
    return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative2(object, key) {
    var value2 = getValue2(object, key);
    return baseIsNative2(value2) ? value2 : void 0;
  }
  function getRawTag(value2) {
    var isOwn = hasOwnProperty2.call(value2, symToStringTag), tag = value2[symToStringTag];
    try {
      value2[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e3) {
    }
    var result = nativeObjectToString.call(value2);
    if (unmasked) {
      if (isOwn) {
        value2[symToStringTag] = tag;
      } else {
        delete value2[symToStringTag];
      }
    }
    return result;
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  function isIndex(value2, length2) {
    var type = typeof value2;
    length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
    return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length2);
  }
  function isIterateeCall(value2, index2, object) {
    if (!isObject2(object)) {
      return false;
    }
    var type = typeof index2;
    if (type == "number" ? isArrayLike2(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
      return eq2(object[index2], value2);
    }
    return false;
  }
  function isKeyable2(value2) {
    var type = typeof value2;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
  }
  function isMasked2(func) {
    return !!maskSrcKey2 && maskSrcKey2 in func;
  }
  function isPrototype(value2) {
    var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value2 === proto;
  }
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  function objectToString2(value2) {
    return nativeObjectToString.call(value2);
  }
  function overRest(func, start, transform) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index2 = -1, length2 = nativeMax(args.length - start, 0), array2 = Array(length2);
      while (++index2 < length2) {
        array2[index2] = args[start + index2];
      }
      index2 = -1;
      var otherArgs = Array(start + 1);
      while (++index2 < start) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start] = transform(array2);
      return apply(func, this, otherArgs);
    };
  }
  function safeGet(object, key) {
    if (key === "constructor" && typeof object[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object[key];
  }
  var setToString = shortOut(baseSetToString);
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  function toSource2(func) {
    if (func != null) {
      try {
        return funcToString2.call(func);
      } catch (e3) {
      }
      try {
        return func + "";
      } catch (e3) {
      }
    }
    return "";
  }
  function eq2(value2, other) {
    return value2 === other || value2 !== value2 && other !== other;
  }
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value2) {
    return isObjectLike2(value2) && hasOwnProperty2.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
  };
  var isArray2 = Array.isArray;
  function isArrayLike2(value2) {
    return value2 != null && isLength(value2.length) && !isFunction2(value2);
  }
  function isArrayLikeObject(value2) {
    return isObjectLike2(value2) && isArrayLike2(value2);
  }
  var isBuffer2 = nativeIsBuffer || stubFalse;
  function isFunction2(value2) {
    if (!isObject2(value2)) {
      return false;
    }
    var tag = baseGetTag(value2);
    return tag == funcTag2 || tag == genTag2 || tag == asyncTag || tag == proxyTag;
  }
  function isLength(value2) {
    return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
  }
  function isObject2(value2) {
    var type = typeof value2;
    return value2 != null && (type == "object" || type == "function");
  }
  function isObjectLike2(value2) {
    return value2 != null && typeof value2 == "object";
  }
  function isPlainObject2(value2) {
    if (!isObjectLike2(value2) || baseGetTag(value2) != objectTag) {
      return false;
    }
    var proto = getPrototype(value2);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString;
  }
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function toPlainObject(value2) {
    return copyObject(value2, keysIn(value2));
  }
  function keysIn(object) {
    return isArrayLike2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
    baseMerge(object, source, srcIndex, customizer);
  });
  function constant2(value2) {
    return function() {
      return value2;
    };
  }
  function identity2(value2) {
    return value2;
  }
  function stubFalse() {
    return false;
  }
  module.exports = mergeWith;
})(lodash_mergewith, lodash_mergewith.exports);
var lodash_mergewithExports = lodash_mergewith.exports;
const merge = /* @__PURE__ */ getDefaultExportFromCjs(lodash_mergewithExports);
let listenerQueue = [];
let atom = (initialValue, level) => {
  let currentListeners;
  let nextListeners = [];
  let store = {
    lc: 0,
    l: level || 0,
    value: initialValue,
    set(data) {
      store.value = data;
      store.notify();
    },
    get() {
      if (!store.lc) {
        store.listen(() => {
        })();
      }
      return store.value;
    },
    notify(changedKey) {
      currentListeners = nextListeners;
      let runListenerQueue = !listenerQueue.length;
      for (let i2 = 0; i2 < currentListeners.length; i2 += 2) {
        listenerQueue.push(
          currentListeners[i2],
          store.value,
          changedKey,
          currentListeners[i2 + 1]
        );
      }
      if (runListenerQueue) {
        for (let i2 = 0; i2 < listenerQueue.length; i2 += 4) {
          let skip = false;
          for (let j2 = i2 + 7; j2 < listenerQueue.length; j2 += 4) {
            if (listenerQueue[j2] < listenerQueue[i2 + 3]) {
              skip = true;
              break;
            }
          }
          if (skip) {
            listenerQueue.push(
              listenerQueue[i2],
              listenerQueue[i2 + 1],
              listenerQueue[i2 + 2],
              listenerQueue[i2 + 3]
            );
          } else {
            listenerQueue[i2](listenerQueue[i2 + 1], listenerQueue[i2 + 2]);
          }
        }
        listenerQueue.length = 0;
      }
    },
    listen(listener, listenerLevel) {
      if (nextListeners === currentListeners) {
        nextListeners = nextListeners.slice();
      }
      store.lc = nextListeners.push(listener, listenerLevel || store.l) / 2;
      return () => {
        if (nextListeners === currentListeners) {
          nextListeners = nextListeners.slice();
        }
        let index2 = nextListeners.indexOf(listener);
        if (~index2) {
          nextListeners.splice(index2, 2);
          store.lc--;
        }
      };
    },
    subscribe(cb, listenerLevel) {
      let unbind = store.listen(cb, listenerLevel);
      cb(store.value);
      return unbind;
    },
    off() {
    }
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
  };
  return store;
};
const room = atom({});
let Collection$1 = class Collection {
  constructor(collectionClass) {
    this.collectionClass = collectionClass;
    this.collection = /* @__PURE__ */ new Map();
    this.removeCb = (key) => {
    };
    this.addCb = (key, data) => {
    };
  }
  registerRemoveCallback(cb) {
    this.removeCb = cb;
  }
  registerAddCallback(cb) {
    this.addCb = cb;
  }
  detectChanges(data) {
    let newObj = {};
    for (let key in data) {
      const obj = data[key];
      if (obj == null) {
        this.collection.delete(key);
        this.removeCb(key);
        continue;
      }
      const instance = this.collectionClass ? new this.collectionClass(obj, key) : obj;
      if (!this.collection.has(key)) {
        this.addCb(key, instance);
      }
      this.collection.set(key, instance);
      newObj[key] = instance;
    }
    return newObj;
  }
};
class User {
  constructor(data, id) {
    this.id = id;
    Object.assign(this, data);
  }
  isMe() {
    return WorldClass.userId == this.id;
  }
}
class WorldClass {
  constructor() {
    this.obs$ = new BehaviorSubject({});
    this.users = new Collection$1(User);
  }
  get value() {
    return this.obs$.asObservable();
  }
  /**
   * Join an existing room
   *
   * @param {string} roomId
   */
  join(roomId) {
    this.socket.emit(":join", roomId);
  }
  /**
   * Change the value of a property
   *
   * @param {string} prop
   * @param {any} value
   */
  input(prop, value2) {
    this.socket.emit(":input", { prop, value: value2 });
    return {
      catchError: (cb) => this.socket.once(":error", cb)
    };
  }
  /**
  * Do an action
  *
  * @param {string} name
  * @param {any} value
  */
  action(name, value2) {
    this.socket.emit(":action", { name, value: value2 });
    return {
      catchError: (cb) => this.socket.once(":error", cb)
    };
  }
  /**
   * Listen to the changes on a socket
   *
   * @param {string} socket
   * @return {World}
   */
  listen(socket, options = {}) {
    if (options.encoded === void 0)
      options.encoded = true;
    this.socket = socket;
    this.socket.on("uid", (response) => {
      WorldClass.userId = response;
    });
    this.socket.on("connect", () => {
      this.obs$.next({});
    });
    this.socket.on("w", (response) => {
      if (options.encoded) {
        const bufView = new Uint8Array(response);
        response = browser.decode(bufView);
      }
      const [roomId, time, data] = response;
      const lastRoomId = this.obs$.value.roomId;
      let mergeData = {};
      let resetProps = [];
      if (lastRoomId == roomId) {
        data.join = false;
        mergeData = merge(Object.assign({}, this.obs$.value.data || {}), data, (objValue, srcValue, key, object, source, stack) => {
          if (srcValue != null && typeof srcValue == "object") {
            if (Object.values(srcValue).length == 0) {
              return {};
            }
            if (srcValue.$reset) {
              resetProps.push(key);
              delete srcValue.$reset;
              return srcValue;
            }
          }
        });
      } else {
        mergeData = data;
      }
      if (data.users) {
        mergeData.users = this.users.detectChanges(mergeData.users);
      }
      this.obs$.next({
        roomId,
        data: mergeData,
        partial: data,
        time,
        resetProps
      });
      room.set(Object.assign({}, mergeData));
    });
    return this;
  }
  reset() {
    this.obs$ = new BehaviorSubject({});
  }
}
WorldClass.userId = null;
const World = new WorldClass();
function getXHRResponse(xhr) {
  switch (xhr.responseType) {
    case "json": {
      if ("response" in xhr) {
        return xhr.response;
      } else {
        var ieXHR = xhr;
        return JSON.parse(ieXHR.responseText);
      }
    }
    case "document":
      return xhr.responseXML;
    case "text":
    default: {
      if ("response" in xhr) {
        return xhr.response;
      } else {
        var ieXHR = xhr;
        return ieXHR.responseText;
      }
    }
  }
}
var AjaxResponse = function() {
  function AjaxResponse2(originalEvent, xhr, request, type) {
    if (type === void 0) {
      type = "download_load";
    }
    this.originalEvent = originalEvent;
    this.xhr = xhr;
    this.request = request;
    this.type = type;
    var status = xhr.status, responseType = xhr.responseType;
    this.status = status !== null && status !== void 0 ? status : 0;
    this.responseType = responseType !== null && responseType !== void 0 ? responseType : "";
    var allHeaders = xhr.getAllResponseHeaders();
    this.responseHeaders = allHeaders ? allHeaders.split("\n").reduce(function(headers, line) {
      var index2 = line.indexOf(": ");
      headers[line.slice(0, index2)] = line.slice(index2 + 2);
      return headers;
    }, {}) : {};
    this.response = getXHRResponse(xhr);
    var loaded = originalEvent.loaded, total = originalEvent.total;
    this.loaded = loaded;
    this.total = total;
  }
  return AjaxResponse2;
}();
var AjaxError = createErrorClass(function(_super) {
  return function AjaxErrorImpl(message, xhr, request) {
    this.message = message;
    this.name = "AjaxError";
    this.xhr = xhr;
    this.request = request;
    this.status = xhr.status;
    this.responseType = xhr.responseType;
    var response;
    try {
      response = getXHRResponse(xhr);
    } catch (err) {
      response = xhr.responseText;
    }
    this.response = response;
  };
});
var AjaxTimeoutError = function() {
  function AjaxTimeoutErrorImpl(xhr, request) {
    AjaxError.call(this, "ajax timeout", xhr, request);
    this.name = "AjaxTimeoutError";
    return this;
  }
  AjaxTimeoutErrorImpl.prototype = Object.create(AjaxError.prototype);
  return AjaxTimeoutErrorImpl;
}();
function ajaxGet(url2, headers) {
  return ajax({ method: "GET", url: url2, headers });
}
function ajaxPost(url2, body, headers) {
  return ajax({ method: "POST", url: url2, body, headers });
}
function ajaxDelete(url2, headers) {
  return ajax({ method: "DELETE", url: url2, headers });
}
function ajaxPut(url2, body, headers) {
  return ajax({ method: "PUT", url: url2, body, headers });
}
function ajaxPatch(url2, body, headers) {
  return ajax({ method: "PATCH", url: url2, body, headers });
}
var mapResponse = map$7(function(x2) {
  return x2.response;
});
function ajaxGetJSON(url2, headers) {
  return mapResponse(ajax({
    method: "GET",
    url: url2,
    headers
  }));
}
var ajax = function() {
  var create = function(urlOrConfig) {
    var config2 = typeof urlOrConfig === "string" ? {
      url: urlOrConfig
    } : urlOrConfig;
    return fromAjax(config2);
  };
  create.get = ajaxGet;
  create.post = ajaxPost;
  create.delete = ajaxDelete;
  create.put = ajaxPut;
  create.patch = ajaxPatch;
  create.getJSON = ajaxGetJSON;
  return create;
}();
var UPLOAD = "upload";
var DOWNLOAD = "download";
var LOADSTART = "loadstart";
var PROGRESS = "progress";
var LOAD = "load";
function fromAjax(init2) {
  return new Observable(function(destination) {
    var _a, _b;
    var config2 = __assign({ async: true, crossDomain: false, withCredentials: false, method: "GET", timeout: 0, responseType: "json" }, init2);
    var queryParams = config2.queryParams, configuredBody = config2.body, configuredHeaders = config2.headers;
    var url2 = config2.url;
    if (!url2) {
      throw new TypeError("url is required");
    }
    if (queryParams) {
      var searchParams_1;
      if (url2.includes("?")) {
        var parts2 = url2.split("?");
        if (2 < parts2.length) {
          throw new TypeError("invalid url");
        }
        searchParams_1 = new URLSearchParams(parts2[1]);
        new URLSearchParams(queryParams).forEach(function(value2, key2) {
          return searchParams_1.set(key2, value2);
        });
        url2 = parts2[0] + "?" + searchParams_1;
      } else {
        searchParams_1 = new URLSearchParams(queryParams);
        url2 = url2 + "?" + searchParams_1;
      }
    }
    var headers = {};
    if (configuredHeaders) {
      for (var key in configuredHeaders) {
        if (configuredHeaders.hasOwnProperty(key)) {
          headers[key.toLowerCase()] = configuredHeaders[key];
        }
      }
    }
    var crossDomain = config2.crossDomain;
    if (!crossDomain && !("x-requested-with" in headers)) {
      headers["x-requested-with"] = "XMLHttpRequest";
    }
    var withCredentials = config2.withCredentials, xsrfCookieName = config2.xsrfCookieName, xsrfHeaderName = config2.xsrfHeaderName;
    if ((withCredentials || !crossDomain) && xsrfCookieName && xsrfHeaderName) {
      var xsrfCookie = (_b = (_a = document === null || document === void 0 ? void 0 : document.cookie.match(new RegExp("(^|;\\s*)(" + xsrfCookieName + ")=([^;]*)"))) === null || _a === void 0 ? void 0 : _a.pop()) !== null && _b !== void 0 ? _b : "";
      if (xsrfCookie) {
        headers[xsrfHeaderName] = xsrfCookie;
      }
    }
    var body = extractContentTypeAndMaybeSerializeBody(configuredBody, headers);
    var _request = __assign(__assign({}, config2), {
      url: url2,
      headers,
      body
    });
    var xhr;
    xhr = init2.createXHR ? init2.createXHR() : new XMLHttpRequest();
    {
      var progressSubscriber_1 = init2.progressSubscriber, _c = init2.includeDownloadProgress, includeDownloadProgress = _c === void 0 ? false : _c, _d = init2.includeUploadProgress, includeUploadProgress = _d === void 0 ? false : _d;
      var addErrorEvent = function(type, errorFactory) {
        xhr.addEventListener(type, function() {
          var _a2;
          var error2 = errorFactory();
          (_a2 = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _a2 === void 0 ? void 0 : _a2.call(progressSubscriber_1, error2);
          destination.error(error2);
        });
      };
      addErrorEvent("timeout", function() {
        return new AjaxTimeoutError(xhr, _request);
      });
      addErrorEvent("abort", function() {
        return new AjaxError("aborted", xhr, _request);
      });
      var createResponse_1 = function(direction, event) {
        return new AjaxResponse(event, xhr, _request, direction + "_" + event.type);
      };
      var addProgressEvent_1 = function(target, type, direction) {
        target.addEventListener(type, function(event) {
          destination.next(createResponse_1(direction, event));
        });
      };
      if (includeUploadProgress) {
        [LOADSTART, PROGRESS, LOAD].forEach(function(type) {
          return addProgressEvent_1(xhr.upload, type, UPLOAD);
        });
      }
      if (progressSubscriber_1) {
        [LOADSTART, PROGRESS].forEach(function(type) {
          return xhr.upload.addEventListener(type, function(e3) {
            var _a2;
            return (_a2 = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.next) === null || _a2 === void 0 ? void 0 : _a2.call(progressSubscriber_1, e3);
          });
        });
      }
      if (includeDownloadProgress) {
        [LOADSTART, PROGRESS].forEach(function(type) {
          return addProgressEvent_1(xhr, type, DOWNLOAD);
        });
      }
      var emitError_1 = function(status) {
        var msg = "ajax error" + (status ? " " + status : "");
        destination.error(new AjaxError(msg, xhr, _request));
      };
      xhr.addEventListener("error", function(e3) {
        var _a2;
        (_a2 = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _a2 === void 0 ? void 0 : _a2.call(progressSubscriber_1, e3);
        emitError_1();
      });
      xhr.addEventListener(LOAD, function(event) {
        var _a2, _b2;
        var status = xhr.status;
        if (status < 400) {
          (_a2 = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.complete) === null || _a2 === void 0 ? void 0 : _a2.call(progressSubscriber_1);
          var response = void 0;
          try {
            response = createResponse_1(DOWNLOAD, event);
          } catch (err) {
            destination.error(err);
            return;
          }
          destination.next(response);
          destination.complete();
        } else {
          (_b2 = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _b2 === void 0 ? void 0 : _b2.call(progressSubscriber_1, event);
          emitError_1(status);
        }
      });
    }
    var user = _request.user, method = _request.method, async = _request.async;
    if (user) {
      xhr.open(method, url2, async, user, _request.password);
    } else {
      xhr.open(method, url2, async);
    }
    if (async) {
      xhr.timeout = _request.timeout;
      xhr.responseType = _request.responseType;
    }
    if ("withCredentials" in xhr) {
      xhr.withCredentials = _request.withCredentials;
    }
    for (var key in headers) {
      if (headers.hasOwnProperty(key)) {
        xhr.setRequestHeader(key, headers[key]);
      }
    }
    if (body) {
      xhr.send(body);
    } else {
      xhr.send();
    }
    return function() {
      if (xhr && xhr.readyState !== 4) {
        xhr.abort();
      }
    };
  });
}
function extractContentTypeAndMaybeSerializeBody(body, headers) {
  var _a;
  if (!body || typeof body === "string" || isFormData(body) || isURLSearchParams(body) || isArrayBuffer(body) || isFile(body) || isBlob(body) || isReadableStream(body)) {
    return body;
  }
  if (isArrayBufferView(body)) {
    return body.buffer;
  }
  if (typeof body === "object") {
    headers["content-type"] = (_a = headers["content-type"]) !== null && _a !== void 0 ? _a : "application/json;charset=utf-8";
    return JSON.stringify(body);
  }
  throw new TypeError("Unknown body type");
}
var _toString = Object.prototype.toString;
function toStringCheck(obj, name) {
  return _toString.call(obj) === "[object " + name + "]";
}
function isArrayBuffer(body) {
  return toStringCheck(body, "ArrayBuffer");
}
function isFile(body) {
  return toStringCheck(body, "File");
}
function isBlob(body) {
  return toStringCheck(body, "Blob");
}
function isArrayBufferView(body) {
  return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(body);
}
function isFormData(body) {
  return typeof FormData !== "undefined" && body instanceof FormData;
}
function isURLSearchParams(body) {
  return typeof URLSearchParams !== "undefined" && body instanceof URLSearchParams;
}
function isReadableStream(body) {
  return typeof ReadableStream !== "undefined" && body instanceof ReadableStream;
}
function Spritesheet(options) {
  return (target) => {
    if ("images" in options)
      target["images"] = options.images;
    if ("id" in options)
      target["id"] = options.id;
    for (let key in options) {
      target.prototype[key] = options[key];
    }
    return;
  };
}
function Sound$1(options) {
  return (target) => {
    if ("sounds" in options)
      target["sounds"] = options.sounds;
    if ("id" in options)
      target["id"] = options.id;
    for (let key in options) {
      target.prototype[key] = options[key];
    }
  };
}
var __decorate = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c3 = arguments.length, r2 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c3 < 3 ? d2(r2) : c3 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c3 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const {
  extractId,
  isString
} = Utils$1;
let RpgClientEngine$2 = class RpgClientEngine {
  constructor(context2, options) {
    this.context = context2;
    this.options = options;
    this.globalConfig = {};
    this._tick = new BehaviorSubject({
      timestamp: -1,
      deltaTime: 0,
      frame: 0,
      deltaRatio: 1
    });
    this.keyChange = new Subject();
    this.roomJoin = new Subject();
    this.hasBeenDisconnected = false;
    this.serverChanging = false;
    this.isTeleported = false;
    this.lastTimestamp = 0;
    this.clientFrames = /* @__PURE__ */ new Map();
    this.serverFrames = /* @__PURE__ */ new Map();
    this.session = null;
    this.lastConnection = "";
    this.lastScene = "";
    this.matchMakerService = null;
    this.serverFps = 60;
    this.scheduler = new Scheduler();
    this._serverUrl = "";
    this.gameEngine = this.context.inject(GameEngineClient);
    this.objects = this.gameEngine.objects;
    this.envs = {};
    this.envs = options.envs || {};
    this.tick.subscribe(({
      timestamp,
      deltaTime
    }) => {
      if (timestamp != -1)
        this.step(timestamp, deltaTime);
    });
  }
  async _init() {
    this.renderer = this.context.inject(RpgRenderer);
    const pluginLoadResource = async (hookName, type) => {
      const resource = this.options[type] || [];
      this.options[type] = [...arrayFlat(await RpgPlugin.emit(hookName, resource)) || [], ...resource];
    };
    await pluginLoadResource(HookClient.AddSpriteSheet, "spritesheets");
    await pluginLoadResource(HookClient.AddGui, "gui");
    await pluginLoadResource(HookClient.AddSound, "sounds");
    this.renderer.options = {
      selector: "#rpg",
      selectorCanvas: "#canvas",
      selectorGui: "#gui",
      canvas: {},
      gui: [],
      spritesheets: [],
      sounds: [],
      ...this.options
    };
    this.io = this.options.io;
    if (this.options.serverFps)
      this.serverFps = this.options.serverFps;
    this.globalConfig = this.options.globalConfig;
    this.gameEngine.standalone = this.options.standalone;
    this.gameEngine.renderer = this.renderer;
    this.gameEngine.clientEngine = this;
    this.addSpriteSheet(this.renderer.options.spritesheets);
    (this.renderer.options.sounds || []).forEach((sound) => {
      const id = isString(sound) ? extractId(sound) : void 0;
      this.addSound(sound, id);
    });
    if (typeof __RPGJS_PRODUCTION__ != "undefined" && __RPGJS_PRODUCTION__) {
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker.register("/service-worker.js");
        });
      }
    }
    this.controls = this.context.inject(KeyboardControls);
  }
  addResource(resourceClass, cb) {
    let array2 = resourceClass;
    if (!isArray$8(resourceClass)) {
      array2 = [resourceClass];
    }
    cb(array2, this);
  }
  /**
   * Listen to each frame
   *
   * @prop {Observable<{ timestamp: number, deltaTime: number, frame: number }>} tick
   * @readonly
   * @since 3.0.0-beta.5
   * @memberof RpgClientEngine
   * @example
   *
   * ```ts
   * client.tick.subscribe(({ timestamp, deltaTime, frame }) => {
   *
   * })
   * ```
   * */
  get tick() {
    return this.scheduler.tick;
  }
  addSpriteSheet(spritesheetClass, id) {
    if (typeof spritesheetClass === "string") {
      if (!id) {
        throw log("Please, specify the resource ID (second parameter)");
      }
      let AutoSpritesheet = class AutoSpritesheet {
      };
      AutoSpritesheet = __decorate([Spritesheet({
        id,
        image: this.getResourceUrl(spritesheetClass)
      })], AutoSpritesheet);
      spritesheetClass = AutoSpritesheet;
    }
    this.addResource(spritesheetClass, _initSpritesheet);
    return spritesheetClass;
  }
  addSound(soundClass, id) {
    if (typeof soundClass === "string") {
      if (!id) {
        throw log("Please, specify the resource ID (second parameter)");
      }
      let AutoSound = class AutoSound {
      };
      AutoSound = __decorate([Sound$1({
        id,
        sound: this.getResourceUrl(soundClass)
      })], AutoSound);
      soundClass = AutoSound;
    }
    this.addResource(soundClass, _initSound);
    return soundClass;
  }
  getResourceUrl(source) {
    if (window.urlCache && window.urlCache[source]) {
      return window.urlCache[source];
    }
    if (source.startsWith("data:")) {
      return source;
    }
    const staticDir = this.envs.VITE_BUILT;
    if (staticDir) {
      return this.assetsPath + "/" + basename(source);
    }
    return source;
  }
  /**
   * Starts the client side and connects to the server
   *
   * @title Start Client Engine
   * @method start()
   * @returns {Promise< RpgClientEngine >}
   * @memberof RpgClientEngine
   */
  async start(options = {
    renderLoop: true
  }) {
    await this._init();
    await this.renderer.init();
    const {
      maxFps
    } = this.options;
    if (options.renderLoop) {
      this.scheduler.start({
        maxFps
      });
      setInterval(() => {
        this.processInput();
      }, fps2ms(this.serverFps));
    }
    const ret = await RpgPlugin.emit(HookClient.Start, this);
    this.matchMakerService = this.options.globalConfig.matchMakerService;
    const hasFalseValue = ret.findIndex((el) => el === false) != -1;
    if (!hasFalseValue) {
      let serverUri = {};
      if (this.matchMakerService) {
        if (isFunction$5(this.matchMakerService)) {
          serverUri = this.matchMakerService();
        } else {
          serverUri = await lastValueFrom(ajax.getJSON(this.matchMakerService));
        }
      }
      const envUrl = this.envs.VITE_SERVER_URL;
      await this.connection(serverUri.url ? serverUri.url + ":" + serverUri.port : envUrl ? envUrl : void 0);
    }
    return this;
  }
  /**
   * Display the next frame. Useful for unit tests
   *
   * @title Next Frame
   * @since 3.0.0-beta.5
   * @param {number} timestamp Indicate the timestamp of the frame
   * @method nextFrame()
   * @memberof RpgClientEngine
   */
  nextFrame(timestamp) {
    this.scheduler.nextTick(timestamp);
  }
  async sendInput(actionName) {
    const player = this.player;
    if (!player)
      return;
    if (player.canMove) {
      player.pendingMove.push({
        input: actionName,
        frame: this.scheduler.frame
      });
    }
  }
  get player() {
    return this.gameEngine.world.getObject(this.gameEngine.playerId);
  }
  serverReconciliation(player) {
    let garbage = [];
    this.serverFrames.forEach((serverData, frame) => {
      const {
        data: serverPos,
        time: serverTime
      } = serverData;
      const client = this.clientFrames.get(frame);
      if (!client || client && client.data.x != serverPos.x || client.data.y != serverPos.y) {
        if (serverPos.x)
          player.position.x = serverPos.x;
        if (serverPos.y)
          player.position.y = serverPos.y;
      }
      player.position.z = serverPos.z;
      garbage.push(frame);
    });
    garbage.forEach((frame) => {
      this.serverFrames.delete(frame);
      this.clientFrames.delete(frame);
    });
    garbage = [];
  }
  async step(t2, dt) {
    RpgPlugin.emit(HookClient.Step, [this, t2, dt], true);
  }
  async processInput() {
    const player = this.player;
    this.controls.preStep();
    if (player) {
      if (player.pendingMove.length > 0) {
        const {
          inputs: inputEvent
        } = await this.gameEngine.processInput(this.gameEngine.playerId, this.controls.options);
        if (inputEvent.length == 0)
          return;
        const frame = Date.now();
        this.clientFrames.set(frame, {
          data: player.position.copy(),
          time: frame
        });
        if (this.socket) {
          this.socket.emit("move", {
            input: inputEvent,
            frame
          });
        }
        RpgPlugin.emit(HookClient.SendInput, [this, inputEvent], true);
      }
      if (player.canMove)
        this.serverReconciliation(player);
    }
  }
  /**
   *Connect to the server
   *
   * @title Connect to server
   * @method connection()
   * @returns {void}
   * @memberof RpgClientEngine
   */
  async connection(uri) {
    const {
      standalone
    } = this.gameEngine;
    const {
      globalConfig
    } = this;
    this._serverUrl = uri || "";
    if (!standalone) {
      this.socket = this.io(uri, {
        auth: {
          token: this.session
        },
        ...globalConfig.socketIoClient || {}
      });
    } else {
      this.socket = this.io;
    }
    this.socket.on("connect", () => {
      if (RpgGui.exists(PrebuiltGui.Disconnect))
        RpgGui.hide(PrebuiltGui.Disconnect);
      RpgPlugin.emit(HookClient.Connected, [this, this.socket], true);
      this.hasBeenDisconnected = false;
    });
    this.socket.on("playerJoined", (playerEvent) => {
      this.gameEngine.playerId = playerEvent.playerId;
      this.session = playerEvent.session;
    });
    this.socket.on("connect_error", (err) => {
      RpgPlugin.emit(HookClient.ConnectedError, [this, err, this.socket], true);
    });
    this.socket.on("preLoadScene", ({
      id,
      reconnect
    }) => {
      if (this.lastScene == id) {
        return;
      }
      this.lastScene = id;
      this.renderer.transitionScene(id);
      if (reconnect) {
        this.roomJoin.next("");
        this.roomJoin.complete();
      }
    });
    this.socket.on(SocketEvents.GameReload, () => {
      window.location.reload();
    });
    this.socket.on(SocketEvents.LoadScene, ({
      name,
      data
    }) => {
      this.renderer.loadScene(name, data);
    });
    this.socket.on(SocketEvents.ChangeServer, async ({
      url: url2,
      port
    }) => {
      const connection = url2 + ":" + port;
      if (this.lastConnection == connection) {
        return;
      }
      if (this.subscriptionWorld) {
        this.subscriptionWorld.unsubscribe();
      }
      this.lastConnection = connection;
      this.serverChanging = true;
      this.socket.disconnect();
      this.connection(connection);
    });
    this.socket.on("changeTile", ({
      tiles,
      x: x2,
      y: y2
    }) => {
      const scene = this.renderer.getScene();
      scene == null ? void 0 : scene.changeTile(x2, y2, tiles);
    });
    const callMethod = ({
      objectId,
      params,
      name
    }) => {
      const scene = this.renderer.getScene();
      const sprite = scene == null ? void 0 : scene.getPlayer(objectId);
      if (!sprite)
        return;
      switch (name) {
        case SocketMethods.ShowAnimation:
          scene == null ? void 0 : scene.showAnimation({
            attachTo: sprite,
            graphic: params[0],
            animationName: params[1],
            replaceGraphic: params[2]
          });
          break;
        case SocketMethods.CameraFollow:
          const [spriteId, options] = params;
          scene == null ? void 0 : scene.cameraFollowSprite(spriteId, options);
          break;
        case SocketMethods.PlaySound:
          RpgSound.play(params[0]);
          break;
        case SocketMethods.ModeMove:
          const player = this.player;
          const {
            checkCollision
          } = params[0];
          if (player) {
            player.checkCollision = checkCollision;
          }
          break;
      }
    };
    this.socket.on(SocketEvents.CallMethod, callMethod);
    let lastRoomId = "";
    this.subscriptionWorld = World.listen(this.socket).value.subscribe(async (val) => {
      const scene = this.renderer.getScene();
      if (!val.data) {
        return;
      }
      const partialRoom = val.partial;
      if (val.roomId != lastRoomId) {
        this.clientFrames.clear();
        this.serverFrames.clear();
        this.gameEngine.resetObjects();
        lastRoomId = val.roomId;
        this.isTeleported = false;
      }
      const objectsChanged = {};
      const callAction = (objectId, paramsChanged) => {
        if (paramsChanged && SocketEvents.CallMethod in paramsChanged) {
          this.renderer.draw(Date.now(), 1, 1, 1);
          callMethod({
            objectId,
            ...paramsChanged[SocketEvents.CallMethod]
          });
        }
      };
      const change = (prop, root2 = val, localEvent = false) => {
        const list = root2.data[prop];
        const partial = root2.partial[prop];
        const isShape = prop == "shapes";
        if (!partial) {
          return;
        }
        if (val.resetProps.indexOf(prop) != -1) {
          const objects = isShape ? this.gameEngine.getShapes() : this.gameEngine.getObjects();
          for (let key in objects) {
            const obj = objects[key];
            if (obj) {
              this.gameEngine.removeObjectAndShape(key);
            }
          }
        }
        for (let key in partial) {
          const obj = list[key];
          const paramsChanged = partial ? partial[key] : void 0;
          if (obj == null || obj.deleted) {
            callAction(key, paramsChanged);
            this.gameEngine.removeObjectAndShape(key);
            continue;
          }
          if (!obj)
            continue;
          if (!isShape) {
            obj.type = {
              users: PlayerType.Player,
              events: PlayerType.Event
            }[prop];
          }
          if (prop == "users" && this.gameEngine.playerId == key) {
            if (obj.events) {
              const nbEvents = Object.values(obj.events);
              if (nbEvents.length == 0) {
                this.gameEngine.events = {};
              } else {
                change("events", {
                  data: obj,
                  partial: paramsChanged,
                  time: val.time,
                  roomId: val.roomId,
                  resetProps: val.resetProps
                }, true);
              }
            }
            if ((partialRoom == null ? void 0 : partialRoom.pos) && (partialRoom == null ? void 0 : partialRoom.frame) !== void 0) {
              this.serverFrames.set(partialRoom.frame, {
                data: partialRoom.pos,
                time: Date.now()
              });
            }
          }
          objectsChanged[key] = this.gameEngine.updateObject({
            playerId: key,
            params: obj,
            localEvent,
            paramsChanged,
            isShape
          });
          callAction(key, paramsChanged);
        }
      };
      if (partialRoom.join) {
        this.roomJoin.next(partialRoom);
        this.roomJoin.complete();
      }
      change("users");
      change("events");
      change("shapes");
      this.gameEngine.setObjectsChanged(objectsChanged);
      if (scene) {
        scene.update(val);
      }
    });
    this.socket.on("disconnect", (reason) => {
      if (this.serverChanging) {
        return;
      }
      if (RpgGui.exists(PrebuiltGui.Disconnect))
        RpgGui.display(PrebuiltGui.Disconnect);
      RpgPlugin.emit(HookClient.Disconnect, [this, reason, this.socket], true);
      this.hasBeenDisconnected = true;
    });
    RpgGui._setSocket(this.socket);
    if (standalone) {
      await this.socket.connection({
        auth: {
          token: this.session
        }
      });
    }
    this.serverChanging = false;
  }
  get world() {
    return World;
  }
  // shortcuts
  /**
  * VueJS Application instance
  *
  * [https://v3.vuejs.org/api/application-api.html](https://v3.vuejs.org/api/application-api.html)
  *
  * @prop {Vue} [vueApp]
  * @readonly
  * @memberof RpgClientEngine
  * */
  get vueApp() {
    return this.renderer.app;
  }
  /**
   * VueJS Parent component instance
   *
   * [https://v3.vuejs.org/api/instance-properties.html](https://v3.vuejs.org/api/instance-properties.html)
   *
   * @prop {Vue Instance} [vueInstance]
   * @readonly
   * @memberof RpgClientEngine
   * */
  get vueInstance() {
    return this.renderer.vm;
  }
  /**
   * retrieves the current scene (SceneMap if you are on a map)
   *
   * @prop {RpgScene} [scene]
   * @deprecated
   * @readonly
   * @memberof RpgClientEngine
   * */
  get scene() {
    return this.renderer.getScene();
  }
  /**
   * retrieves the current scene (SceneMap if you are on a map)
   *
   * @title Connect to server
   * @method getScene()
   * @returns {RpgScene}
   * @memberof RpgClientEngine
   */
  getScene() {
    return this.renderer.getScene();
  }
  /**
   * get PIXI class
   * @prop {PIXI} [PIXI]
   * @readonly
   * @memberof RpgClientEngine
   */
  get PIXI() {
    return PIXI;
  }
  /**
   * get player id of the current player
   * @prop {string} [playerId]
   * @readonly
   * @memberof RpgClientEngine
   */
  get playerId() {
    return this.gameEngine.playerId;
  }
  /**
   * Finds the game mode from the environment variables sent by the compiler.
   * Can be used in menus to display options according to type
   *
   * @title Game Type
   * @prop {string|undefined} [gameType] mmorpg | rpg or undefined if environment variable not found
   * @readonly
   * @memberof RpgClientEngine
   * @since 4.0.0
   */
  get gameType() {
    var _a;
    return (_a = this.envs) == null ? void 0 : _a["VITE_RPG_TYPE"];
  }
  /**
   * Find out if the game is in production or not, from the environment variables sent by the compiler.
   *
   * @title Game is dev mode
   * @prop {boolean} [isDev]
   * @readonly
   * @memberof RpgClientEngine
   * @since 4.0.0
   */
  get isDev() {
    var _a;
    return !((_a = this.envs) == null ? void 0 : _a["VITE_BUILT"]);
  }
  /**
   * Get the server url. This is the url for the websocket
   *
   * To customize the URL, use the `matchMakerService` configuration
   *
   * @title Server URL
   * @prop {string} [serverUrl] If empty string, server url is same as client url
   * @readonly
   * @memberof RpgClientEngine
   * @since 4.0.0
   */
  get serverUrl() {
    if (!this._serverUrl.startsWith("http")) {
      return "http://" + this._serverUrl;
    }
    return this._serverUrl;
  }
  get assetsPath() {
    var _a;
    return ((_a = this.envs) == null ? void 0 : _a["VITE_ASSETS_PATH"]) || "assets";
  }
  get module() {
    return RpgPlugin;
  }
  reset() {
    this.subscriptionWorld.unsubscribe();
    this.world.reset();
    spritesheets.clear();
    sounds.clear();
    Assets.reset();
    clearTextureCache();
    for (let textureUrl in BaseTextureCache) {
      delete BaseTextureCache[textureUrl];
    }
    for (let textureUrl in TextureCache) {
      delete TextureCache[textureUrl];
    }
    RpgGui.clear();
    RpgCommonMap.bufferClient.clear();
    RpgSound.clear();
  }
};
let instanceContext = null;
function inject(service, args = []) {
  return instanceContext.inject(service, args);
}
function setInject(context2) {
  instanceContext = context2;
}
const entryPoint = (modules, options) => {
  if (!options.globalConfig)
    options.globalConfig = {};
  options = {
    ...options.globalConfig,
    ...options
  };
  const relations = {
    onInit: HookClient.AddSprite,
    onDestroy: HookClient.RemoveSprite,
    onUpdate: HookClient.UpdateSprite,
    onChanges: HookClient.ChangesSprite,
    onMove: HookClient.SpriteMove
  };
  const relationsMap = {
    onAddSprite: HookClient.SceneAddSprite,
    onRemoveSprite: HookClient.SceneRemoveSprite,
    onBeforeLoading: HookClient.BeforeSceneLoading,
    onAfterLoading: HookClient.AfterSceneLoading,
    onMapLoading: HookClient.SceneMapLoading,
    onChanges: HookClient.SceneOnChanges,
    onDraw: HookClient.SceneDraw
  };
  const relationsEngine = {
    onStart: HookClient.Start,
    onStep: HookClient.Step,
    onConnected: HookClient.Connected,
    onDisconnect: HookClient.Disconnect,
    onConnectError: HookClient.ConnectedError,
    onInput: HookClient.SendInput,
    onWindowResize: HookClient.WindowResize
  };
  loadModules(modules, {
    side: "client",
    relations: {
      player: relations,
      sceneMap: relationsMap,
      engine: relationsEngine
    }
  });
  const context2 = new InjectContext();
  setInject(context2);
  return context2.inject(RpgClientEngine$2, [options]);
};
const RMSpritesheet = (framesWidth, framesHeight, frameStand = 1) => {
  if (framesWidth <= frameStand) {
    frameStand = framesWidth - 1;
  }
  const frameY = (direction) => {
    const gap = Math.max(4 - framesHeight, 0);
    return {
      [Direction.Down]: 0,
      [Direction.Left]: Math.max(0, 1 - gap),
      [Direction.Right]: Math.max(0, 2 - gap),
      [Direction.Up]: Math.max(0, 3 - gap)
    }[direction];
  };
  const stand = (direction) => [{
    time: 0,
    frameX: frameStand,
    frameY: frameY(direction)
  }];
  const walk = (direction) => {
    const array2 = [];
    const durationFrame = 10;
    for (let i2 = 0; i2 < framesWidth; i2++) {
      array2.push({
        time: i2 * durationFrame,
        frameX: i2,
        frameY: frameY(direction)
      });
    }
    array2.push({
      time: array2[array2.length - 1].time + durationFrame
    });
    return array2;
  };
  return {
    textures: {
      [Animation$1.Stand]: {
        animations: (direction) => [stand(direction)]
      },
      [Animation$1.Walk]: {
        animations: (direction) => [walk(direction)]
      }
    },
    framesHeight,
    framesWidth
  };
};
const Presets = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RMSpritesheet
}, Symbol.toStringTag, { value: "Module" }));
const RpgResource = {
  spritesheets,
  sounds
};
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
const withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
const isView$1 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback) => {
  if (withNativeBlob$1 && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data);
};
function toArray(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob$1 && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback);
  } else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {
    return callback(toArray(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i2 = 0; i2 < chars.length; i2++) {
  lookup$1[chars.charCodeAt(i2)] = i2;
}
const decode$1 = (base64) => {
  let bufferLength = base64.length * 0.75, len = base64.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup$1[base64.charCodeAt(i2)];
    encoded2 = lookup$1[base64.charCodeAt(i2 + 1)];
    encoded3 = lookup$1[base64.charCodeAt(i2 + 2)];
    encoded4 = lookup$1[base64.charCodeAt(i2 + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
const decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer$1) {
    const decoded = decode$1(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
const mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data instanceof Blob) {
        return data;
      } else {
        return new Blob([data]);
      }
    case "arraybuffer":
    default:
      if (data instanceof ArrayBuffer) {
        return data;
      } else {
        return data.buffer;
      }
  }
};
const SEPARATOR = String.fromCharCode(30);
const encodePayload = (packets, callback) => {
  const length2 = packets.length;
  const encodedPackets = new Array(length2);
  let count = 0;
  packets.forEach((packet, i2) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i2] = encodedPacket;
      if (++count === length2) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
const decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i2 = 0; i2 < encodedPackets.length; i2++) {
    const decodedPacket = decodePacket(encodedPackets[i2], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
let TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size2) {
  if (chunks[0].length === size2) {
    return chunks.shift();
  }
  const buffer2 = new Uint8Array(size2);
  let j2 = 0;
  for (let i2 = 0; i2 < size2; i2++) {
    buffer2[i2] = chunks[0][j2++];
    if (j2 === chunks[0].length) {
      chunks.shift();
      j2 = 0;
    }
  }
  if (chunks.length && j2 < chunks[0].length) {
    chunks[0] = chunks[0].slice(j2);
  }
  return buffer2;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state = 3;
          } else if (expectedLength === 126) {
            state = 1;
          } else {
            state = 2;
          }
        } else if (state === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3;
        } else if (state === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n2 = view.getUint32(0);
          if (n2 > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n2 * Math.pow(2, 32) + view.getUint32(4);
          state = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
const protocol$1 = 4;
function Emitter(obj) {
  if (obj)
    return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on2() {
    this.off(event, on2);
    fn.apply(this, arguments);
  }
  on2.fn = fn;
  this.on(event, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks)
    return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i2 = 0; i2 < callbacks.length; i2++) {
    cb = callbacks[i2];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i2, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i2 = 1; i2 < arguments.length; i2++) {
    args[i2 - 1] = arguments[i2];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {
      callbacks[i2].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};
const globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
function pick(obj, ...attr) {
  return attr.reduce((acc, k4) => {
    if (obj.hasOwnProperty(k4)) {
      acc[k4] = obj[k4];
    }
    return acc;
  }, {});
}
const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
const BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str2) {
  let c3 = 0, length2 = 0;
  for (let i2 = 0, l2 = str2.length; i2 < l2; i2++) {
    c3 = str2.charCodeAt(i2);
    if (c3 < 128) {
      length2 += 1;
    } else if (c3 < 2048) {
      length2 += 2;
    } else if (c3 < 55296 || c3 >= 57344) {
      length2 += 3;
    } else {
      i2++;
      length2 += 4;
    }
  }
  return length2;
}
function encode$1(obj) {
  let str2 = "";
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      if (str2.length)
        str2 += "&";
      str2 += encodeURIComponent(i2) + "=" + encodeURIComponent(obj[i2]);
    }
  }
  return str2;
}
function decode(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i2 = 0, l2 = pairs.length; i2 < l2; i2++) {
    let pair = pairs[i2].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}
class TransportError extends Error {
  constructor(reason, description, context2) {
    super(reason);
    this.description = description;
    this.context = context2;
    this.type = "TransportError";
  }
}
class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(reason, description, context2) {
    super.emitReserved("error", new TransportError(reason, description, context2));
    return this;
  }
  /**
   * Opens the transport.
   */
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  /**
   * Closes the transport.
   */
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    }
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(data) {
    const packet = decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode$1(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
}
const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map$1 = {};
let seed = 0, i$1 = 0, prev;
function encode(num) {
  let encoded = "";
  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);
  return encoded;
}
function yeast() {
  const now = encode(+/* @__PURE__ */ new Date());
  if (now !== prev)
    return seed = 0, prev = now;
  return now + "." + encode(seed++);
}
for (; i$1 < length; i$1++)
  map$1[alphabet[i$1]] = i$1;
let value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
}
const hasCORS = value;
function XHR(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e3) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e3) {
    }
  }
}
function createCookieJar() {
}
function empty() {
}
const hasXHR2 = function() {
  const xhr = new XHR({
    xdomain: false
  });
  return null != xhr.responseType;
}();
class Polling extends Transport {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(opts) {
    super(opts);
    this.polling = false;
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
    if (this.opts.withCredentials) {
      this.cookieJar = createCookieJar();
    }
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this.poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this.polling || !this.writable) {
      let total = 0;
      if (this.polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  poll() {
    this.polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(data) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this.polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this.poll();
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @private
   */
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd, cookieJar: this.cookieJar }, this.opts);
    return new Request(this.uri(), opts);
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(data, fn) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn);
    req.on("error", (xhrStatus, context2) => {
      this.onError("xhr post error", xhrStatus, context2);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context2) => {
      this.onError("xhr poll error", xhrStatus, context2);
    });
    this.pollXhr = req;
  }
}
class Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(uri, opts) {
    super();
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.method = opts.method || "GET";
    this.uri = uri;
    this.data = void 0 !== opts.data ? opts.data : null;
    this.create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  create() {
    var _a;
    const opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this.opts.xd;
    const xhr = this.xhr = new XHR(opts);
    try {
      xhr.open(this.method, this.uri, true);
      try {
        if (this.opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i2 in this.opts.extraHeaders) {
            if (this.opts.extraHeaders.hasOwnProperty(i2)) {
              xhr.setRequestHeader(i2, this.opts.extraHeaders[i2]);
            }
          }
        }
      } catch (e3) {
      }
      if ("POST" === this.method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e3) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e3) {
      }
      (_a = this.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this.opts.withCredentials;
      }
      if (this.opts.requestTimeout) {
        xhr.timeout = this.opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a2;
        if (xhr.readyState === 3) {
          (_a2 = this.opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.parseCookies(xhr);
        }
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this.onLoad();
        } else {
          this.setTimeoutFn(() => {
            this.onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this.data);
    } catch (e3) {
      this.setTimeoutFn(() => {
        this.onError(e3);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this.index = Request.requestsCount++;
      Request.requests[this.index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @private
   */
  onError(err) {
    this.emitReserved("error", err, this.xhr);
    this.cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  cleanup(fromError) {
    if ("undefined" === typeof this.xhr || null === this.xhr) {
      return;
    }
    this.xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this.xhr.abort();
      } catch (e3) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request.requests[this.index];
    }
    this.xhr = null;
  }
  /**
   * Called upon load.
   *
   * @private
   */
  onLoad() {
    const data = this.xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this.cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this.cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i2 in Request.requests) {
    if (Request.requests.hasOwnProperty(i2)) {
      Request.requests[i2].abort();
    }
  }
}
const nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
const WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
const usingBrowserWebSocket = true;
const defaultBinaryType = "arraybuffer";
const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
class WS extends Transport {
  /**
   * WebSocket transport constructor.
   *
   * @param {Object} opts - connection options
   * @protected
   */
  constructor(opts) {
    super(opts);
    this.supportsBinary = !opts.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check()) {
      return;
    }
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e3) => this.onError("websocket error", e3);
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data) => {
        const opts = {};
        try {
          if (usingBrowserWebSocket) {
            this.ws.send(data);
          }
        } catch (e3) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @private
   */
  check() {
    return !!WebSocket;
  }
}
class WT extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    if (typeof WebTransport !== "function") {
      return;
    }
    this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    this.transport.closed.then(() => {
      this.onClose();
    }).catch((err) => {
      this.onError("webtransport error", err);
    });
    this.transport.ready.then(() => {
      this.transport.createBidirectionalStream().then((stream2) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream2.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream2.writable);
        this.writer = encoderStream.writable.getWriter();
        const read2 = () => {
          reader.read().then(({ done: done2, value: value2 }) => {
            if (done2) {
              return;
            }
            this.onPacket(value2);
            read2();
          }).catch((err) => {
          });
        };
        read2();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this.writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      this.writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a;
    (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();
  }
}
const transports = {
  websocket: WS,
  webtransport: WT,
  polling: Polling
};
const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse(str2) {
  const src = str2, b3 = str2.indexOf("["), e3 = str2.indexOf("]");
  if (b3 != -1 && e3 != -1) {
    str2 = str2.substring(0, b3) + str2.substring(b3, e3).replace(/:/g, ";") + str2.substring(e3, str2.length);
  }
  let m2 = re.exec(str2 || ""), uri = {}, i2 = 14;
  while (i2--) {
    uri[parts[i2]] = m2[i2] || "";
  }
  if (b3 != -1 && e3 != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path2) {
  const regx = /\/{2,9}/g, names = path2.replace(regx, "/").split("/");
  if (path2.slice(0, 1) == "/" || path2.length === 0) {
    names.splice(0, 1);
  }
  if (path2.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}
let Socket$1 = class Socket extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(uri, opts = {}) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      uri = parse(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query)
        opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = parse(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = opts.transports || [
      "polling",
      "websocket",
      "webtransport"
    ];
    this.writeBuffer = [];
    this.prevBufferLen = 0;
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode(this.opts.query);
    }
    this.id = null;
    this.upgrades = null;
    this.pingInterval = null;
    this.pingTimeout = null;
    this.pingTimeoutTimer = null;
    if (typeof addEventListener === "function") {
      if (this.opts.closeOnBeforeunload) {
        this.beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this.beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this.offlineEventListener = () => {
          this.onClose("transport close", {
            description: "network connection lost"
          });
        };
        addEventListener("offline", this.offlineEventListener, false);
      }
    }
    this.open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(name) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol$1;
    query.transport = name;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name]);
    return new transports[name](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  open() {
    let transport;
    if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
      transport = "websocket";
    } else if (0 === this.transports.length) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else {
      transport = this.transports[0];
    }
    this.readyState = "opening";
    try {
      transport = this.createTransport(transport);
    } catch (e3) {
      this.transports.shift();
      this.open();
      return;
    }
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  probe(name) {
    let transport = this.createTransport(name);
    let failed = false;
    Socket.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          Socket.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error2 = new Error("probe error: " + err);
      error2.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error2);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this.upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open";
    Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
    if ("open" === this.readyState && this.opts.upgrade) {
      let i2 = 0;
      const l2 = this.upgrades.length;
      for (; i2 < l2; i2++) {
        this.probe(this.upgrades[i2]);
      }
    }
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      this.resetPingTimeout();
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this.sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this.onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this.upgrades = this.filterUpgrades(data.upgrades);
    this.pingInterval = data.pingInterval;
    this.pingTimeout = data.pingTimeout;
    this.maxPayload = data.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this.resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer);
    this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout);
    if (this.opts.autoUnref) {
      this.pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen);
    this.prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this.getWritablePackets();
      this.transport.send(packets);
      this.prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  getWritablePackets() {
    const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i2 = 0; i2 < this.writeBuffer.length; i2++) {
      const data = this.writeBuffer[i2].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i2 > 0 && payloadSize > this.maxPayload) {
        return this.writeBuffer.slice(0, i2);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} callback function.
   * @return {Socket} for chaining.
   */
  write(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }
  send(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  sendPacket(type, data, options, fn) {
    if ("function" === typeof data) {
      fn = data;
      data = void 0;
    }
    if ("function" === typeof options) {
      fn = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const close = () => {
      this.onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  onError(err) {
    Socket.priorWebsocketSuccess = false;
    this.emitReserved("error", err);
    this.onClose("transport error", err);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this.pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (typeof removeEventListener === "function") {
        removeEventListener("beforeunload", this.beforeunloadEventListener, false);
        removeEventListener("offline", this.offlineEventListener, false);
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this.prevBufferLen = 0;
    }
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    let i2 = 0;
    const j2 = upgrades.length;
    for (; i2 < j2; i2++) {
      if (~this.transports.indexOf(upgrades[i2]))
        filteredUpgrades.push(upgrades[i2]);
    }
    return filteredUpgrades;
  }
};
Socket$1.protocol = protocol$1;
function url(uri, path2 = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path2;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
const toString2 = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString2.call(Blob) === "[object BlobConstructor]";
const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString2.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON2) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      if (hasBinary(obj[i2])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i2 = 0; i2 < data.length; i2++) {
      newData[i2] = _deconstructPacket(data[i2], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i2 = 0; i2 < data.length; i2++) {
      data[i2] = _reconstructPacket(data[i2], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}
const RESERVED_EVENTS$1 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
];
const protocol = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer2) {
    this.replacer = replacer2;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str2 = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str2 += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str2 += obj.nsp + ",";
    }
    if (null != obj.id) {
      str2 += obj.id;
    }
    if (null != obj.data) {
      str2 += JSON.stringify(obj.data, this.replacer);
    }
    return str2;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
}
function isObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
class Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str2) {
    let i2 = 0;
    const p2 = {
      type: Number(str2.charAt(0))
    };
    if (PacketType[p2.type] === void 0) {
      throw new Error("unknown packet type " + p2.type);
    }
    if (p2.type === PacketType.BINARY_EVENT || p2.type === PacketType.BINARY_ACK) {
      const start = i2 + 1;
      while (str2.charAt(++i2) !== "-" && i2 != str2.length) {
      }
      const buf = str2.substring(start, i2);
      if (buf != Number(buf) || str2.charAt(i2) !== "-") {
        throw new Error("Illegal attachments");
      }
      p2.attachments = Number(buf);
    }
    if ("/" === str2.charAt(i2 + 1)) {
      const start = i2 + 1;
      while (++i2) {
        const c3 = str2.charAt(i2);
        if ("," === c3)
          break;
        if (i2 === str2.length)
          break;
      }
      p2.nsp = str2.substring(start, i2);
    } else {
      p2.nsp = "/";
    }
    const next = str2.charAt(i2 + 1);
    if ("" !== next && Number(next) == next) {
      const start = i2 + 1;
      while (++i2) {
        const c3 = str2.charAt(i2);
        if (null == c3 || Number(c3) != c3) {
          --i2;
          break;
        }
        if (i2 === str2.length)
          break;
      }
      p2.id = Number(str2.substring(start, i2 + 1));
    }
    if (str2.charAt(++i2)) {
      const payload = this.tryParse(str2.substr(i2));
      if (Decoder.isPayloadValid(p2.type, payload)) {
        p2.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p2;
  }
  tryParse(str2) {
    try {
      return JSON.parse(str2, this.reviver);
    } catch (e3) {
      return false;
    }
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return isObject(payload);
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
}
class BinaryReconstructor {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder,
  Encoder,
  get PacketType() {
    return PacketType;
  },
  protocol
}, Symbol.toStringTag, { value: "Module" }));
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket2 extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    if (RESERVED_EVENTS.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
    if (discardPacket)
      ;
    else if (this.connected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id, ack) {
    var _a;
    const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
    if (timeout === void 0) {
      this.acks[id] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i2 = 0; i2 < this.sendBuffer.length; i2++) {
        if (this.sendBuffer[i2].id === id) {
          this.sendBuffer.splice(i2, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    this.acks[id] = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, [null, ...args]);
    };
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(ev, ...args) {
    const withErr = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
    return new Promise((resolve2, reject) => {
      args.push((arg1, arg2) => {
        if (withErr) {
          return arg1 ? reject(arg1) : resolve2(arg2);
        } else {
          return resolve2(arg1);
        }
      });
      this.emit(ev, ...args);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this._sendConnectPacket(data);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(data) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners2 = this._anyListeners.slice();
      for (const listener of listeners2) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowlegement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if ("function" === typeof ack) {
      ack.apply(this, packet.data);
      delete this.acks[packet.id];
    }
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id, pid) {
    this.id = id;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners2 = this._anyListeners;
      for (let i2 = 0; i2 < listeners2.length; i2++) {
        if (listener === listeners2[i2]) {
          listeners2.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners2 = this._anyOutgoingListeners;
      for (let i2 = 0; i2 < listeners2.length; i2++) {
        if (listener === listeners2[i2]) {
          listeners2.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners2 = this._anyOutgoingListeners.slice();
      for (const listener of listeners2) {
        listener.apply(this, packet.data);
      }
    }
  }
}
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max) {
  this.max = max;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};
let Manager$1 = class Manager extends Emitter {
  constructor(uri, opts) {
    var _a;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || parser;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v2) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v2;
    return this;
  }
  reconnectionAttempts(v2) {
    if (v2 === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v2;
    return this;
  }
  reconnectionDelay(v2) {
    var _a;
    if (v2 === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v2;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v2);
    return this;
  }
  randomizationFactor(v2) {
    var _a;
    if (v2 === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v2;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v2);
    return this;
  }
  reconnectionDelayMax(v2) {
    var _a;
    if (v2 === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v2;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v2);
    return this;
  }
  timeout(v2) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v2;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const onError = (err) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn) {
        fn(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on(socket, "error", onError);
    if (false !== this._timeout) {
      const timeout = this._timeout;
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        onError(new Error("timeout"));
        socket.close();
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn) {
    return this.open(fn);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e3) {
      this.onclose("parse error", e3);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err) {
    this.emitReserved("error", err);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket;
    } else if (this._autoConnect && !socket.active) {
      socket.connect();
    }
    return socket;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i2 = 0; i2 < encodedPackets.length; i2++) {
      this.engine.write(encodedPackets[i2], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
    if (this.engine)
      this.engine.close();
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called upon engine close.
   *
   * @private
   */
  onclose(reason, description) {
    this.cleanup();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
};
const cache = {};
function lookup(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path2 = parsed.path;
  const sameNamespace = cache[id] && path2 in cache[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager$1(source, opts);
  } else {
    if (!cache[id]) {
      cache[id] = new Manager$1(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup, {
  Manager: Manager$1,
  Socket: Socket2,
  io: lookup,
  connect: lookup
});
const distance = (p1, p2) => {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
};
const angle = (p1, p2) => {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  return degrees(Math.atan2(dy, dx));
};
const findCoord = (p2, d2, a8) => {
  const b3 = { x: 0, y: 0 };
  a8 = radians(a8);
  b3.x = p2.x - d2 * Math.cos(a8);
  b3.y = p2.y - d2 * Math.sin(a8);
  return b3;
};
const radians = (a8) => {
  return a8 * (Math.PI / 180);
};
const degrees = (a8) => {
  return a8 * (180 / Math.PI);
};
const isPressed = (evt) => {
  if (isNaN(evt.buttons)) {
    return evt.pressure !== 0;
  }
  return evt.buttons !== 0;
};
const timers = /* @__PURE__ */ new Map();
const throttle = (cb) => {
  if (timers.has(cb)) {
    clearTimeout(timers.get(cb));
  }
  timers.set(cb, setTimeout(cb, 100));
};
const bindEvt = (el, arg, handler) => {
  const types = arg.split(/[ ,]+/g);
  let type;
  for (let i2 = 0; i2 < types.length; i2 += 1) {
    type = types[i2];
    if (el.addEventListener) {
      el.addEventListener(type, handler, false);
    } else if (el.attachEvent) {
      el.attachEvent(type, handler);
    }
  }
};
const unbindEvt = (el, arg, handler) => {
  const types = arg.split(/[ ,]+/g);
  let type;
  for (let i2 = 0; i2 < types.length; i2 += 1) {
    type = types[i2];
    if (el.removeEventListener) {
      el.removeEventListener(type, handler);
    } else if (el.detachEvent) {
      el.detachEvent(type, handler);
    }
  }
};
const prepareEvent = (evt) => {
  evt.preventDefault();
  return evt.type.match(/^touch/) ? evt.changedTouches : evt;
};
const getScroll = () => {
  const x2 = window.pageXOffset !== void 0 ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
  const y2 = window.pageYOffset !== void 0 ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
  return {
    x: x2,
    y: y2
  };
};
const applyPosition = (el, pos) => {
  if (pos.top || pos.right || pos.bottom || pos.left) {
    el.style.top = pos.top;
    el.style.right = pos.right;
    el.style.bottom = pos.bottom;
    el.style.left = pos.left;
  } else {
    el.style.left = pos.x + "px";
    el.style.top = pos.y + "px";
  }
};
const getTransitionStyle = (property, values, time) => {
  const obj = configStylePropertyObject(property);
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      if (typeof values === "string") {
        obj[i2] = values + " " + time;
      } else {
        let st2 = "";
        for (let j2 = 0, max = values.length; j2 < max; j2 += 1) {
          st2 += values[j2] + " " + time + ", ";
        }
        obj[i2] = st2.slice(0, -2);
      }
    }
  }
  return obj;
};
const getVendorStyle = (property, value2) => {
  const obj = configStylePropertyObject(property);
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      obj[i2] = value2;
    }
  }
  return obj;
};
const configStylePropertyObject = (prop) => {
  const obj = {};
  obj[prop] = "";
  const vendors = ["webkit", "Moz", "o"];
  vendors.forEach(function(vendor) {
    obj[vendor + prop.charAt(0).toUpperCase() + prop.slice(1)] = "";
  });
  return obj;
};
const extend = (objA, objB) => {
  for (let i2 in objB) {
    if (objB.hasOwnProperty(i2)) {
      objA[i2] = objB[i2];
    }
  }
  return objA;
};
const safeExtend = (objA, objB) => {
  const obj = {};
  for (let i2 in objA) {
    if (objA.hasOwnProperty(i2) && objB.hasOwnProperty(i2)) {
      obj[i2] = objB[i2];
    } else if (objA.hasOwnProperty(i2)) {
      obj[i2] = objA[i2];
    }
  }
  return obj;
};
const map = (ar, fn) => {
  if (ar.length) {
    for (let i2 = 0, max = ar.length; i2 < max; i2 += 1) {
      fn(ar[i2]);
    }
  } else {
    fn(ar);
  }
};
const clamp = (pos, nipplePos, size2) => ({
  //                          left-clamping        right-clamping
  x: Math.min(Math.max(pos.x, nipplePos.x - size2), nipplePos.x + size2),
  //                          top-clamping         bottom-clamping
  y: Math.min(Math.max(pos.y, nipplePos.y - size2), nipplePos.y + size2)
});
var isTouch = !!("ontouchstart" in window);
var isPointer = window.PointerEvent ? true : false;
var isMSPointer = window.MSPointerEvent ? true : false;
var events = {
  touch: {
    start: "touchstart",
    move: "touchmove",
    end: "touchend, touchcancel"
  },
  mouse: {
    start: "mousedown",
    move: "mousemove",
    end: "mouseup"
  },
  pointer: {
    start: "pointerdown",
    move: "pointermove",
    end: "pointerup, pointercancel"
  },
  MSPointer: {
    start: "MSPointerDown",
    move: "MSPointerMove",
    end: "MSPointerUp"
  }
};
var toBind;
var secondBind = {};
if (isPointer) {
  toBind = events.pointer;
} else if (isMSPointer) {
  toBind = events.MSPointer;
} else if (isTouch) {
  toBind = events.touch;
  secondBind = events.mouse;
} else {
  toBind = events.mouse;
}
function Super() {
}
Super.prototype.on = function(arg, cb) {
  var self2 = this;
  var types = arg.split(/[ ,]+/g);
  var type;
  self2._handlers_ = self2._handlers_ || {};
  for (var i2 = 0; i2 < types.length; i2 += 1) {
    type = types[i2];
    self2._handlers_[type] = self2._handlers_[type] || [];
    self2._handlers_[type].push(cb);
  }
  return self2;
};
Super.prototype.off = function(type, cb) {
  var self2 = this;
  self2._handlers_ = self2._handlers_ || {};
  if (type === void 0) {
    self2._handlers_ = {};
  } else if (cb === void 0) {
    self2._handlers_[type] = null;
  } else if (self2._handlers_[type] && self2._handlers_[type].indexOf(cb) >= 0) {
    self2._handlers_[type].splice(self2._handlers_[type].indexOf(cb), 1);
  }
  return self2;
};
Super.prototype.trigger = function(arg, data) {
  var self2 = this;
  var types = arg.split(/[ ,]+/g);
  var type;
  self2._handlers_ = self2._handlers_ || {};
  for (var i2 = 0; i2 < types.length; i2 += 1) {
    type = types[i2];
    if (self2._handlers_[type] && self2._handlers_[type].length) {
      self2._handlers_[type].forEach(function(handler) {
        handler.call(self2, {
          type,
          target: self2
        }, data);
      });
    }
  }
};
Super.prototype.config = function(options) {
  var self2 = this;
  self2.options = self2.defaults || {};
  if (options) {
    self2.options = safeExtend(self2.options, options);
  }
};
Super.prototype.bindEvt = function(el, type) {
  var self2 = this;
  self2._domHandlers_ = self2._domHandlers_ || {};
  self2._domHandlers_[type] = function() {
    if (typeof self2["on" + type] === "function") {
      self2["on" + type].apply(self2, arguments);
    } else {
      console.warn('[WARNING] : Missing "on' + type + '" handler.');
    }
  };
  bindEvt(el, toBind[type], self2._domHandlers_[type]);
  if (secondBind[type]) {
    bindEvt(el, secondBind[type], self2._domHandlers_[type]);
  }
  return self2;
};
Super.prototype.unbindEvt = function(el, type) {
  var self2 = this;
  self2._domHandlers_ = self2._domHandlers_ || {};
  unbindEvt(el, toBind[type], self2._domHandlers_[type]);
  if (secondBind[type]) {
    unbindEvt(el, secondBind[type], self2._domHandlers_[type]);
  }
  delete self2._domHandlers_[type];
  return this;
};
function Nipple(collection, options) {
  this.identifier = options.identifier;
  this.position = options.position;
  this.frontPosition = options.frontPosition;
  this.collection = collection;
  this.defaults = {
    size: 100,
    threshold: 0.1,
    color: "white",
    fadeTime: 250,
    dataOnly: false,
    restJoystick: true,
    restOpacity: 0.5,
    mode: "dynamic",
    zone: document.body,
    lockX: false,
    lockY: false,
    shape: "circle"
  };
  this.config(options);
  if (this.options.mode === "dynamic") {
    this.options.restOpacity = 0;
  }
  this.id = Nipple.id;
  Nipple.id += 1;
  this.buildEl().stylize();
  this.instance = {
    el: this.ui.el,
    on: this.on.bind(this),
    off: this.off.bind(this),
    show: this.show.bind(this),
    hide: this.hide.bind(this),
    add: this.addToDom.bind(this),
    remove: this.removeFromDom.bind(this),
    destroy: this.destroy.bind(this),
    setPosition: this.setPosition.bind(this),
    resetDirection: this.resetDirection.bind(this),
    computeDirection: this.computeDirection.bind(this),
    trigger: this.trigger.bind(this),
    position: this.position,
    frontPosition: this.frontPosition,
    ui: this.ui,
    identifier: this.identifier,
    id: this.id,
    options: this.options
  };
  return this.instance;
}
Nipple.prototype = new Super();
Nipple.constructor = Nipple;
Nipple.id = 0;
Nipple.prototype.buildEl = function(options) {
  this.ui = {};
  if (this.options.dataOnly) {
    return this;
  }
  this.ui.el = document.createElement("div");
  this.ui.back = document.createElement("div");
  this.ui.front = document.createElement("div");
  this.ui.el.className = "nipple collection_" + this.collection.id;
  this.ui.back.className = "back";
  this.ui.front.className = "front";
  this.ui.el.setAttribute("id", "nipple_" + this.collection.id + "_" + this.id);
  this.ui.el.appendChild(this.ui.back);
  this.ui.el.appendChild(this.ui.front);
  return this;
};
Nipple.prototype.stylize = function() {
  if (this.options.dataOnly) {
    return this;
  }
  var animTime = this.options.fadeTime + "ms";
  var borderStyle = getVendorStyle("borderRadius", "50%");
  var transitStyle = getTransitionStyle("transition", "opacity", animTime);
  var styles = {};
  styles.el = {
    position: "absolute",
    opacity: this.options.restOpacity,
    display: "block",
    "zIndex": 999
  };
  styles.back = {
    position: "absolute",
    display: "block",
    width: this.options.size + "px",
    height: this.options.size + "px",
    marginLeft: -this.options.size / 2 + "px",
    marginTop: -this.options.size / 2 + "px",
    background: this.options.color,
    "opacity": ".5"
  };
  styles.front = {
    width: this.options.size / 2 + "px",
    height: this.options.size / 2 + "px",
    position: "absolute",
    display: "block",
    marginLeft: -this.options.size / 4 + "px",
    marginTop: -this.options.size / 4 + "px",
    background: this.options.color,
    "opacity": ".5",
    transform: "translate(0px, 0px)"
  };
  extend(styles.el, transitStyle);
  if (this.options.shape === "circle") {
    extend(styles.back, borderStyle);
  }
  extend(styles.front, borderStyle);
  this.applyStyles(styles);
  return this;
};
Nipple.prototype.applyStyles = function(styles) {
  for (var i2 in this.ui) {
    if (this.ui.hasOwnProperty(i2)) {
      for (var j2 in styles[i2]) {
        this.ui[i2].style[j2] = styles[i2][j2];
      }
    }
  }
  return this;
};
Nipple.prototype.addToDom = function() {
  if (this.options.dataOnly || document.body.contains(this.ui.el)) {
    return this;
  }
  this.options.zone.appendChild(this.ui.el);
  return this;
};
Nipple.prototype.removeFromDom = function() {
  if (this.options.dataOnly || !document.body.contains(this.ui.el)) {
    return this;
  }
  this.options.zone.removeChild(this.ui.el);
  return this;
};
Nipple.prototype.destroy = function() {
  clearTimeout(this.removeTimeout);
  clearTimeout(this.showTimeout);
  clearTimeout(this.restTimeout);
  this.trigger("destroyed", this.instance);
  this.removeFromDom();
  this.off();
};
Nipple.prototype.show = function(cb) {
  var self2 = this;
  if (self2.options.dataOnly) {
    return self2;
  }
  clearTimeout(self2.removeTimeout);
  clearTimeout(self2.showTimeout);
  clearTimeout(self2.restTimeout);
  self2.addToDom();
  self2.restCallback();
  setTimeout(function() {
    self2.ui.el.style.opacity = 1;
  }, 0);
  self2.showTimeout = setTimeout(function() {
    self2.trigger("shown", self2.instance);
    if (typeof cb === "function") {
      cb.call(this);
    }
  }, self2.options.fadeTime);
  return self2;
};
Nipple.prototype.hide = function(cb) {
  var self2 = this;
  if (self2.options.dataOnly) {
    return self2;
  }
  self2.ui.el.style.opacity = self2.options.restOpacity;
  clearTimeout(self2.removeTimeout);
  clearTimeout(self2.showTimeout);
  clearTimeout(self2.restTimeout);
  self2.removeTimeout = setTimeout(
    function() {
      var display = self2.options.mode === "dynamic" ? "none" : "block";
      self2.ui.el.style.display = display;
      if (typeof cb === "function") {
        cb.call(self2);
      }
      self2.trigger("hidden", self2.instance);
    },
    self2.options.fadeTime
  );
  if (self2.options.restJoystick) {
    const rest = self2.options.restJoystick;
    const newPosition = {};
    newPosition.x = rest === true || rest.x !== false ? 0 : self2.instance.frontPosition.x;
    newPosition.y = rest === true || rest.y !== false ? 0 : self2.instance.frontPosition.y;
    self2.setPosition(cb, newPosition);
  }
  return self2;
};
Nipple.prototype.setPosition = function(cb, position) {
  var self2 = this;
  self2.frontPosition = {
    x: position.x,
    y: position.y
  };
  var animTime = self2.options.fadeTime + "ms";
  var transitStyle = {};
  transitStyle.front = getTransitionStyle(
    "transition",
    ["transform"],
    animTime
  );
  var styles = { front: {} };
  styles.front = {
    transform: "translate(" + self2.frontPosition.x + "px," + self2.frontPosition.y + "px)"
  };
  self2.applyStyles(transitStyle);
  self2.applyStyles(styles);
  self2.restTimeout = setTimeout(
    function() {
      if (typeof cb === "function") {
        cb.call(self2);
      }
      self2.restCallback();
    },
    self2.options.fadeTime
  );
};
Nipple.prototype.restCallback = function() {
  var self2 = this;
  var transitStyle = {};
  transitStyle.front = getTransitionStyle("transition", "none", "");
  self2.applyStyles(transitStyle);
  self2.trigger("rested", self2.instance);
};
Nipple.prototype.resetDirection = function() {
  this.direction = {
    x: false,
    y: false,
    angle: false
  };
};
Nipple.prototype.computeDirection = function(obj) {
  var rAngle = obj.angle.radian;
  var angle45 = Math.PI / 4;
  var angle90 = Math.PI / 2;
  var direction, directionX, directionY;
  if (rAngle > angle45 && rAngle < angle45 * 3 && !obj.lockX) {
    direction = "up";
  } else if (rAngle > -angle45 && rAngle <= angle45 && !obj.lockY) {
    direction = "left";
  } else if (rAngle > -angle45 * 3 && rAngle <= -angle45 && !obj.lockX) {
    direction = "down";
  } else if (!obj.lockY) {
    direction = "right";
  }
  if (!obj.lockY) {
    if (rAngle > -angle90 && rAngle < angle90) {
      directionX = "left";
    } else {
      directionX = "right";
    }
  }
  if (!obj.lockX) {
    if (rAngle > 0) {
      directionY = "up";
    } else {
      directionY = "down";
    }
  }
  if (obj.force > this.options.threshold) {
    var oldDirection = {};
    var i2;
    for (i2 in this.direction) {
      if (this.direction.hasOwnProperty(i2)) {
        oldDirection[i2] = this.direction[i2];
      }
    }
    var same = {};
    this.direction = {
      x: directionX,
      y: directionY,
      angle: direction
    };
    obj.direction = this.direction;
    for (i2 in oldDirection) {
      if (oldDirection[i2] === this.direction[i2]) {
        same[i2] = true;
      }
    }
    if (same.x && same.y && same.angle) {
      return obj;
    }
    if (!same.x || !same.y) {
      this.trigger("plain", obj);
    }
    if (!same.x) {
      this.trigger("plain:" + directionX, obj);
    }
    if (!same.y) {
      this.trigger("plain:" + directionY, obj);
    }
    if (!same.angle) {
      this.trigger("dir dir:" + direction, obj);
    }
  } else {
    this.resetDirection();
  }
  return obj;
};
function Collection2(manager, options) {
  var self2 = this;
  self2.nipples = [];
  self2.idles = [];
  self2.actives = [];
  self2.ids = [];
  self2.pressureIntervals = {};
  self2.manager = manager;
  self2.id = Collection2.id;
  Collection2.id += 1;
  self2.defaults = {
    zone: document.body,
    multitouch: false,
    maxNumberOfNipples: 10,
    mode: "dynamic",
    position: { top: 0, left: 0 },
    catchDistance: 200,
    size: 100,
    threshold: 0.1,
    color: "white",
    fadeTime: 250,
    dataOnly: false,
    restJoystick: true,
    restOpacity: 0.5,
    lockX: false,
    lockY: false,
    shape: "circle",
    dynamicPage: false,
    follow: false
  };
  self2.config(options);
  if (self2.options.mode === "static" || self2.options.mode === "semi") {
    self2.options.multitouch = false;
  }
  if (!self2.options.multitouch) {
    self2.options.maxNumberOfNipples = 1;
  }
  const computedStyle = getComputedStyle(self2.options.zone.parentElement);
  if (computedStyle && computedStyle.display === "flex") {
    self2.parentIsFlex = true;
  }
  self2.updateBox();
  self2.prepareNipples();
  self2.bindings();
  self2.begin();
  return self2.nipples;
}
Collection2.prototype = new Super();
Collection2.constructor = Collection2;
Collection2.id = 0;
Collection2.prototype.prepareNipples = function() {
  var self2 = this;
  var nips = self2.nipples;
  nips.on = self2.on.bind(self2);
  nips.off = self2.off.bind(self2);
  nips.options = self2.options;
  nips.destroy = self2.destroy.bind(self2);
  nips.ids = self2.ids;
  nips.id = self2.id;
  nips.processOnMove = self2.processOnMove.bind(self2);
  nips.processOnEnd = self2.processOnEnd.bind(self2);
  nips.get = function(id) {
    if (id === void 0) {
      return nips[0];
    }
    for (var i2 = 0, max = nips.length; i2 < max; i2 += 1) {
      if (nips[i2].identifier === id) {
        return nips[i2];
      }
    }
    return false;
  };
};
Collection2.prototype.bindings = function() {
  var self2 = this;
  self2.bindEvt(self2.options.zone, "start");
  self2.options.zone.style.touchAction = "none";
  self2.options.zone.style.msTouchAction = "none";
};
Collection2.prototype.begin = function() {
  var self2 = this;
  var opts = self2.options;
  if (opts.mode === "static") {
    var nipple = self2.createNipple(
      opts.position,
      self2.manager.getIdentifier()
    );
    nipple.add();
    self2.idles.push(nipple);
  }
};
Collection2.prototype.createNipple = function(position, identifier) {
  var self2 = this;
  var scroll = self2.manager.scroll;
  var toPutOn = {};
  var opts = self2.options;
  var offset = {
    x: self2.parentIsFlex ? scroll.x : scroll.x + self2.box.left,
    y: self2.parentIsFlex ? scroll.y : scroll.y + self2.box.top
  };
  if (position.x && position.y) {
    toPutOn = {
      x: position.x - offset.x,
      y: position.y - offset.y
    };
  } else if (position.top || position.right || position.bottom || position.left) {
    var dumb = document.createElement("DIV");
    dumb.style.display = "hidden";
    dumb.style.top = position.top;
    dumb.style.right = position.right;
    dumb.style.bottom = position.bottom;
    dumb.style.left = position.left;
    dumb.style.position = "absolute";
    opts.zone.appendChild(dumb);
    var dumbBox = dumb.getBoundingClientRect();
    opts.zone.removeChild(dumb);
    toPutOn = position;
    position = {
      x: dumbBox.left + scroll.x,
      y: dumbBox.top + scroll.y
    };
  }
  var nipple = new Nipple(self2, {
    color: opts.color,
    size: opts.size,
    threshold: opts.threshold,
    fadeTime: opts.fadeTime,
    dataOnly: opts.dataOnly,
    restJoystick: opts.restJoystick,
    restOpacity: opts.restOpacity,
    mode: opts.mode,
    identifier,
    position,
    zone: opts.zone,
    frontPosition: {
      x: 0,
      y: 0
    },
    shape: opts.shape
  });
  if (!opts.dataOnly) {
    applyPosition(nipple.ui.el, toPutOn);
    applyPosition(nipple.ui.front, nipple.frontPosition);
  }
  self2.nipples.push(nipple);
  self2.trigger("added " + nipple.identifier + ":added", nipple);
  self2.manager.trigger("added " + nipple.identifier + ":added", nipple);
  self2.bindNipple(nipple);
  return nipple;
};
Collection2.prototype.updateBox = function() {
  var self2 = this;
  self2.box = self2.options.zone.getBoundingClientRect();
};
Collection2.prototype.bindNipple = function(nipple) {
  var self2 = this;
  var type;
  var handler = function(evt, data) {
    type = evt.type + " " + data.id + ":" + evt.type;
    self2.trigger(type, data);
  };
  nipple.on("destroyed", self2.onDestroyed.bind(self2));
  nipple.on("shown hidden rested dir plain", handler);
  nipple.on("dir:up dir:right dir:down dir:left", handler);
  nipple.on("plain:up plain:right plain:down plain:left", handler);
};
Collection2.prototype.pressureFn = function(touch, nipple, identifier) {
  var self2 = this;
  var previousPressure = 0;
  clearInterval(self2.pressureIntervals[identifier]);
  self2.pressureIntervals[identifier] = setInterval(function() {
    var pressure = touch.force || touch.pressure || touch.webkitForce || 0;
    if (pressure !== previousPressure) {
      nipple.trigger("pressure", pressure);
      self2.trigger("pressure " + nipple.identifier + ":pressure", pressure);
      previousPressure = pressure;
    }
  }.bind(self2), 100);
};
Collection2.prototype.onstart = function(evt) {
  var self2 = this;
  var opts = self2.options;
  var origEvt = evt;
  evt = prepareEvent(evt);
  self2.updateBox();
  var process2 = function(touch) {
    if (self2.actives.length < opts.maxNumberOfNipples) {
      self2.processOnStart(touch);
    } else if (origEvt.type.match(/^touch/)) {
      Object.keys(self2.manager.ids).forEach(function(k4) {
        if (Object.values(origEvt.touches).findIndex(function(t2) {
          return t2.identifier === k4;
        }) < 0) {
          var e3 = [evt[0]];
          e3.identifier = k4;
          self2.processOnEnd(e3);
        }
      });
      if (self2.actives.length < opts.maxNumberOfNipples) {
        self2.processOnStart(touch);
      }
    }
  };
  map(evt, process2);
  self2.manager.bindDocument();
  return false;
};
Collection2.prototype.processOnStart = function(evt) {
  var self2 = this;
  var opts = self2.options;
  var indexInIdles;
  var identifier = self2.manager.getIdentifier(evt);
  var pressure = evt.force || evt.pressure || evt.webkitForce || 0;
  var position = {
    x: evt.pageX,
    y: evt.pageY
  };
  var nipple = self2.getOrCreate(identifier, position);
  if (nipple.identifier !== identifier) {
    self2.manager.removeIdentifier(nipple.identifier);
  }
  nipple.identifier = identifier;
  var process2 = function(nip) {
    nip.trigger("start", nip);
    self2.trigger("start " + nip.id + ":start", nip);
    nip.show();
    if (pressure > 0) {
      self2.pressureFn(evt, nip, nip.identifier);
    }
    self2.processOnMove(evt);
  };
  if ((indexInIdles = self2.idles.indexOf(nipple)) >= 0) {
    self2.idles.splice(indexInIdles, 1);
  }
  self2.actives.push(nipple);
  self2.ids.push(nipple.identifier);
  if (opts.mode !== "semi") {
    process2(nipple);
  } else {
    var distance$1 = distance(position, nipple.position);
    if (distance$1 <= opts.catchDistance) {
      process2(nipple);
    } else {
      nipple.destroy();
      self2.processOnStart(evt);
      return;
    }
  }
  return nipple;
};
Collection2.prototype.getOrCreate = function(identifier, position) {
  var self2 = this;
  var opts = self2.options;
  var nipple;
  if (/(semi|static)/.test(opts.mode)) {
    nipple = self2.idles[0];
    if (nipple) {
      self2.idles.splice(0, 1);
      return nipple;
    }
    if (opts.mode === "semi") {
      return self2.createNipple(position, identifier);
    }
    console.warn("Coudln't find the needed nipple.");
    return false;
  }
  nipple = self2.createNipple(position, identifier);
  return nipple;
};
Collection2.prototype.processOnMove = function(evt) {
  var self2 = this;
  var opts = self2.options;
  var identifier = self2.manager.getIdentifier(evt);
  var nipple = self2.nipples.get(identifier);
  var scroll = self2.manager.scroll;
  if (!isPressed(evt)) {
    this.processOnEnd(evt);
    return;
  }
  if (!nipple) {
    console.error("Found zombie joystick with ID " + identifier);
    self2.manager.removeIdentifier(identifier);
    return;
  }
  if (opts.dynamicPage) {
    var elBox = nipple.el.getBoundingClientRect();
    nipple.position = {
      x: scroll.x + elBox.left,
      y: scroll.y + elBox.top
    };
  }
  nipple.identifier = identifier;
  var size2 = nipple.options.size / 2;
  var pos = {
    x: evt.pageX,
    y: evt.pageY
  };
  if (opts.lockX) {
    pos.y = nipple.position.y;
  }
  if (opts.lockY) {
    pos.x = nipple.position.x;
  }
  var dist = distance(pos, nipple.position);
  var angle$1 = angle(pos, nipple.position);
  var rAngle = radians(angle$1);
  var force = dist / size2;
  var raw = {
    distance: dist,
    position: pos
  };
  var clamped_dist;
  var clamped_pos;
  if (nipple.options.shape === "circle") {
    clamped_dist = Math.min(dist, size2);
    clamped_pos = findCoord(nipple.position, clamped_dist, angle$1);
  } else {
    clamped_pos = clamp(pos, nipple.position, size2);
    clamped_dist = distance(clamped_pos, nipple.position);
  }
  if (opts.follow) {
    if (dist > size2) {
      let delta_x = pos.x - clamped_pos.x;
      let delta_y = pos.y - clamped_pos.y;
      nipple.position.x += delta_x;
      nipple.position.y += delta_y;
      nipple.el.style.top = nipple.position.y - (self2.box.top + scroll.y) + "px";
      nipple.el.style.left = nipple.position.x - (self2.box.left + scroll.x) + "px";
      dist = distance(pos, nipple.position);
    }
  } else {
    pos = clamped_pos;
    dist = clamped_dist;
  }
  var xPosition = pos.x - nipple.position.x;
  var yPosition = pos.y - nipple.position.y;
  nipple.frontPosition = {
    x: xPosition,
    y: yPosition
  };
  if (!opts.dataOnly) {
    nipple.ui.front.style.transform = "translate(" + xPosition + "px," + yPosition + "px)";
  }
  var toSend = {
    identifier: nipple.identifier,
    position: pos,
    force,
    pressure: evt.force || evt.pressure || evt.webkitForce || 0,
    distance: dist,
    angle: {
      radian: rAngle,
      degree: angle$1
    },
    vector: {
      x: xPosition / size2,
      y: -yPosition / size2
    },
    raw,
    instance: nipple,
    lockX: opts.lockX,
    lockY: opts.lockY
  };
  toSend = nipple.computeDirection(toSend);
  toSend.angle = {
    radian: radians(180 - angle$1),
    degree: 180 - angle$1
  };
  nipple.trigger("move", toSend);
  self2.trigger("move " + nipple.id + ":move", toSend);
};
Collection2.prototype.processOnEnd = function(evt) {
  var self2 = this;
  var opts = self2.options;
  var identifier = self2.manager.getIdentifier(evt);
  var nipple = self2.nipples.get(identifier);
  var removedIdentifier = self2.manager.removeIdentifier(nipple.identifier);
  if (!nipple) {
    return;
  }
  if (!opts.dataOnly) {
    nipple.hide(function() {
      if (opts.mode === "dynamic") {
        nipple.trigger("removed", nipple);
        self2.trigger("removed " + nipple.id + ":removed", nipple);
        self2.manager.trigger("removed " + nipple.id + ":removed", nipple);
        nipple.destroy();
      }
    });
  }
  clearInterval(self2.pressureIntervals[nipple.identifier]);
  nipple.resetDirection();
  nipple.trigger("end", nipple);
  self2.trigger("end " + nipple.id + ":end", nipple);
  if (self2.ids.indexOf(nipple.identifier) >= 0) {
    self2.ids.splice(self2.ids.indexOf(nipple.identifier), 1);
  }
  if (self2.actives.indexOf(nipple) >= 0) {
    self2.actives.splice(self2.actives.indexOf(nipple), 1);
  }
  if (/(semi|static)/.test(opts.mode)) {
    self2.idles.push(nipple);
  } else if (self2.nipples.indexOf(nipple) >= 0) {
    self2.nipples.splice(self2.nipples.indexOf(nipple), 1);
  }
  self2.manager.unbindDocument();
  if (/(semi|static)/.test(opts.mode)) {
    self2.manager.ids[removedIdentifier.id] = removedIdentifier.identifier;
  }
};
Collection2.prototype.onDestroyed = function(evt, nipple) {
  var self2 = this;
  if (self2.nipples.indexOf(nipple) >= 0) {
    self2.nipples.splice(self2.nipples.indexOf(nipple), 1);
  }
  if (self2.actives.indexOf(nipple) >= 0) {
    self2.actives.splice(self2.actives.indexOf(nipple), 1);
  }
  if (self2.idles.indexOf(nipple) >= 0) {
    self2.idles.splice(self2.idles.indexOf(nipple), 1);
  }
  if (self2.ids.indexOf(nipple.identifier) >= 0) {
    self2.ids.splice(self2.ids.indexOf(nipple.identifier), 1);
  }
  self2.manager.removeIdentifier(nipple.identifier);
  self2.manager.unbindDocument();
};
Collection2.prototype.destroy = function() {
  var self2 = this;
  self2.unbindEvt(self2.options.zone, "start");
  self2.nipples.forEach(function(nipple) {
    nipple.destroy();
  });
  for (var i2 in self2.pressureIntervals) {
    if (self2.pressureIntervals.hasOwnProperty(i2)) {
      clearInterval(self2.pressureIntervals[i2]);
    }
  }
  self2.trigger("destroyed", self2.nipples);
  self2.manager.unbindDocument();
  self2.off();
};
function Manager2(options) {
  var self2 = this;
  self2.ids = {};
  self2.index = 0;
  self2.collections = [];
  self2.scroll = getScroll();
  self2.config(options);
  self2.prepareCollections();
  var resizeHandler = function() {
    var pos;
    self2.collections.forEach(function(collection) {
      collection.forEach(function(nipple) {
        pos = nipple.el.getBoundingClientRect();
        nipple.position = {
          x: self2.scroll.x + pos.left,
          y: self2.scroll.y + pos.top
        };
      });
    });
  };
  bindEvt(window, "resize", function() {
    throttle(resizeHandler);
  });
  var scrollHandler = function() {
    self2.scroll = getScroll();
  };
  bindEvt(window, "scroll", function() {
    throttle(scrollHandler);
  });
  return self2.collections;
}
Manager2.prototype = new Super();
Manager2.constructor = Manager2;
Manager2.prototype.prepareCollections = function() {
  var self2 = this;
  self2.collections.create = self2.create.bind(self2);
  self2.collections.on = self2.on.bind(self2);
  self2.collections.off = self2.off.bind(self2);
  self2.collections.destroy = self2.destroy.bind(self2);
  self2.collections.get = function(id) {
    var nipple;
    self2.collections.every(function(collection) {
      nipple = collection.get(id);
      return nipple ? false : true;
    });
    return nipple;
  };
};
Manager2.prototype.create = function(options) {
  return this.createCollection(options);
};
Manager2.prototype.createCollection = function(options) {
  var self2 = this;
  var collection = new Collection2(self2, options);
  self2.bindCollection(collection);
  self2.collections.push(collection);
  return collection;
};
Manager2.prototype.bindCollection = function(collection) {
  var self2 = this;
  var type;
  var handler = function(evt, data) {
    type = evt.type + " " + data.id + ":" + evt.type;
    self2.trigger(type, data);
  };
  collection.on("destroyed", self2.onDestroyed.bind(self2));
  collection.on("shown hidden rested dir plain", handler);
  collection.on("dir:up dir:right dir:down dir:left", handler);
  collection.on("plain:up plain:right plain:down plain:left", handler);
};
Manager2.prototype.bindDocument = function() {
  var self2 = this;
  if (!self2.binded) {
    self2.bindEvt(document, "move").bindEvt(document, "end");
    self2.binded = true;
  }
};
Manager2.prototype.unbindDocument = function(force) {
  var self2 = this;
  if (!Object.keys(self2.ids).length || force === true) {
    self2.unbindEvt(document, "move").unbindEvt(document, "end");
    self2.binded = false;
  }
};
Manager2.prototype.getIdentifier = function(evt) {
  var id;
  if (!evt) {
    id = this.index;
  } else {
    id = evt.identifier === void 0 ? evt.pointerId : evt.identifier;
    if (id === void 0) {
      id = this.latest || 0;
    }
  }
  if (this.ids[id] === void 0) {
    this.ids[id] = this.index;
    this.index += 1;
  }
  this.latest = id;
  return this.ids[id];
};
Manager2.prototype.removeIdentifier = function(identifier) {
  var removed = {};
  for (var id in this.ids) {
    if (this.ids[id] === identifier) {
      removed.id = id;
      removed.identifier = this.ids[id];
      delete this.ids[id];
      break;
    }
  }
  return removed;
};
Manager2.prototype.onmove = function(evt) {
  var self2 = this;
  self2.onAny("move", evt);
  return false;
};
Manager2.prototype.onend = function(evt) {
  var self2 = this;
  self2.onAny("end", evt);
  return false;
};
Manager2.prototype.oncancel = function(evt) {
  var self2 = this;
  self2.onAny("end", evt);
  return false;
};
Manager2.prototype.onAny = function(which, evt) {
  var self2 = this;
  var id;
  var processFn = "processOn" + which.charAt(0).toUpperCase() + which.slice(1);
  evt = prepareEvent(evt);
  var processColl = function(e3, id2, coll) {
    if (coll.ids.indexOf(id2) >= 0) {
      coll[processFn](e3);
      e3._found_ = true;
    }
  };
  var processEvt = function(e3) {
    id = self2.getIdentifier(e3);
    map(self2.collections, processColl.bind(null, e3, id));
    if (!e3._found_) {
      self2.removeIdentifier(id);
    }
  };
  map(evt, processEvt);
  return false;
};
Manager2.prototype.destroy = function() {
  var self2 = this;
  self2.unbindDocument(true);
  self2.ids = {};
  self2.index = 0;
  self2.collections.forEach(function(collection) {
    collection.destroy();
  });
  self2.off();
};
Manager2.prototype.onDestroyed = function(evt, coll) {
  var self2 = this;
  if (self2.collections.indexOf(coll) < 0) {
    return false;
  }
  self2.collections.splice(self2.collections.indexOf(coll), 1);
};
const factory = new Manager2();
const nipplejs = {
  create: function(options) {
    return factory.create(options);
  },
  factory
};
const DIRECTIONS$1 = {
  [Direction.Left]: "left",
  [Direction.Right]: "right",
  [Direction.Up]: "up",
  [Direction.Down]: "down"
};
const DIRECTIONS_INVERSE = {
  left: Direction.Left,
  right: Direction.Right,
  up: Direction.Up,
  down: Direction.Down
};
const _sfc_main$h = {
  name: "rpg-controls",
  inject: ["rpgEngine"],
  mounted() {
    const manager = nipplejs.create({
      zone: this.$refs.dPad
    });
    let directions2 = {};
    let moving2 = false;
    manager.on("added", (evt, nipple) => {
      const keyup = (key) => {
        this.rpgEngine.controls.applyControl(key, false);
      };
      const end = () => {
        moving2 = false;
        for (let key in DIRECTIONS$1) {
          keyup(key);
        }
      };
      const move = () => {
        if (moving2) {
          for (let dir in directions2) {
            this.rpgEngine.controls.applyControl(DIRECTIONS_INVERSE[dir], true);
          }
        }
      };
      nipple.on("end", end);
      nipple.on("move", (evt2, data) => {
        if (data.direction) {
          const degree = data.angle.degree;
          const {
            x: x2,
            y: y2,
            angle: angle2
          } = data.direction;
          directions2 = {
            [angle2]: true
          };
          for (let i2 = 0; i2 < 4; i2++) {
            const corner = 90 * i2 + 45;
            if (degree < corner + 20 && degree > corner - 20) {
              directions2 = {
                [x2]: true,
                [y2]: true
              };
            }
          }
          for (let dir in DIRECTIONS$1) {
            const directionName = DIRECTIONS$1[dir];
            if (!directions2[directionName]) {
              keyup(dir);
            }
          }
          moving2 = true;
          move();
        }
      });
      setInterval(move, 400);
    });
  },
  methods: {
    openMenu() {
      this.rpgEngine.controls.applyControl(Control.Back);
    },
    action() {
      this.rpgEngine.controls.applyControl(Control.Action);
    }
  }
};
const main_vue_vue_type_style_index_0_scoped_b0ad1b2d_lang = "";
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _hoisted_1$b = { class: "controls" };
const _hoisted_2$8 = {
  class: "d-pad",
  ref: "dPad"
};
const _hoisted_3$5 = { class: "actions" };
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_propagate = resolveDirective("propagate");
  return withDirectives((openBlock(), createElementBlock("div", _hoisted_1$b, [
    createBaseVNode("div", _hoisted_2$8, null, 512),
    createBaseVNode("div", _hoisted_3$5, [
      createBaseVNode("div", {
        class: "action",
        onClick: _cache[0] || (_cache[0] = (...args) => $options.action && $options.action(...args))
      })
    ]),
    createBaseVNode("div", {
      class: "menu-access",
      onClick: _cache[1] || (_cache[1] = (...args) => $options.openMenu && $options.openMenu(...args))
    })
  ])), [
    [_directive_propagate]
  ]);
}
const ControlGui = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h], ["__scopeId", "data-v-b0ad1b2d"]]);
const sceneMap = {
  onAfterLoading() {
    RpgGui.display(PrebuiltGui.Controls);
  }
};
var __defProp$4 = Object.defineProperty;
var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
var __decorateClass$4 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$4(target, key, result);
  return result;
};
let RpgClientEngine$1 = class RpgClientEngine2 {
};
RpgClientEngine$1 = __decorateClass$4([
  RpgModule({
    gui: [
      ControlGui
    ],
    scenes: {
      map: sceneMap
    }
  })
], RpgClientEngine$1);
const _rpgjs_mobile_gui = {
  client: RpgClientEngine$1
};
const arrow_vue_vue_type_style_index_0_scoped_6e21b8b8_lang = "";
const _sfc_main$g = {
  props: {
    direction: {
      type: String,
      default: "down"
    },
    size: {
      type: Number,
      default: 0.5
    },
    center: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    style() {
      return {
        "border-width": `0 ${this.size}em`,
        "border-top": `${this.size}em solid white`
      };
    }
  }
};
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("i", {
    class: normalizeClass(["arrow", { [$props.direction]: true, center: $props.center }]),
    style: normalizeStyle($options.style)
  }, null, 6);
}
const Arrow = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g], ["__scopeId", "data-v-6e21b8b8"]]);
const window_vue_vue_type_style_index_0_lang = "";
const window_vue_vue_type_style_index_1_scoped_118d4441_lang = "";
const _sfc_main$f = {
  name: "rpg-window",
  props: ["width", "height", "message", "position", "fullWidth", "arrow"],
  data() {
    return {
      loading: false
    };
  },
  computed: {
    classPosition() {
      return {
        [this.position]: true
      };
    },
    css() {
      return {
        "full-width": this.fullWidth
      };
    }
  },
  mounted() {
    this.loading = true;
  },
  components: {
    Arrow
  }
};
const _hoisted_1$a = { key: 0 };
const _hoisted_2$7 = { key: 1 };
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Arrow = resolveComponent("Arrow");
  return openBlock(), createBlock(Transition, { name: "fade" }, {
    default: withCtx(() => [
      $data.loading ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["window", $options.classPosition]),
        style: normalizeStyle({ height: $props.height })
      }, [
        createBaseVNode("div", {
          class: normalizeClass(["window-content", $options.css]),
          style: normalizeStyle({ width: $props.width })
        }, [
          $props.arrow == "up" ? (openBlock(), createElementBlock("div", _hoisted_1$a, [
            createVNode(_component_Arrow, {
              center: true,
              direction: "up"
            })
          ])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "default", {}, void 0, true),
          $props.arrow == "down" ? (openBlock(), createElementBlock("div", _hoisted_2$7, [
            createVNode(_component_Arrow, {
              center: true,
              direction: "down"
            })
          ])) : createCommentVNode("", true)
        ], 6)
      ], 6)) : createCommentVNode("", true)
    ]),
    _: 3
  });
}
const WindowUi = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f], ["__scopeId", "data-v-118d4441"]]);
const _sfc_main$e = {
  name: "rpg-choice",
  inject: ["rpgKeypress"],
  data() {
    return {
      selected: 0,
      scrollHeight: 0
    };
  },
  props: {
    choices: {
      type: Array,
      default: []
    },
    column: {
      type: Number,
      default: 1
    },
    align: {
      type: String,
      default: "left"
    },
    active: {
      type: Boolean,
      default: true
    }
  },
  mounted() {
    this.obsKeyPress = this.rpgKeypress.pipe(debounceTime(100)).subscribe(({
      control
    }) => {
      if (!this.active || !control)
        return;
      const name = control.actionName;
      if (this.column > 1) {
        if (name == Control.Left) {
          this.selected = Math.floor(this.selected - this.choices.length / this.column);
          this.moveCursor();
        } else if (name == Control.Right) {
          this.selected = Math.floor(this.choices.length / this.column + this.selected);
          this.moveCursor();
        }
      }
      if (name == Control.Down)
        this.moveCursor(1);
      else if (name == Control.Up)
        this.moveCursor(-1);
      else if (name == Control.Action)
        this.$emit("selected", this.selected);
      return false;
    });
  },
  methods: {
    moveCursor(move = 0) {
      if (this.choices.length == 0)
        return;
      let diff = 0;
      const checkInView = (container, element, partial) => {
        let cTop = container.scrollTop;
        let cBottom = cTop + container.clientHeight;
        let eTop = element.offsetTop;
        let eBottom = eTop + element.clientHeight + 20;
        let isTotal = eTop >= cTop && eBottom <= cBottom;
        let isPartial = partial && (eTop < cTop && eBottom > cTop || eBottom > cBottom && eTop < cBottom);
        diff = eBottom - cBottom;
        return isTotal || isPartial;
      };
      if (this.selected + move >= this.choices.length) {
        this.selected = 0;
      } else if (this.selected + move < 0) {
        this.selected = this.choices.length - 1;
      } else {
        this.selected = this.selected + move;
      }
      this.$emit("change", this.selected);
      const li = this.$refs[`li-${this.selected}`];
      const ul = this.$parent.$el;
      checkInView(ul, li, false);
      if (diff > 0) {
        this.scrollHeight = `-${diff}px`;
        this.$emit("canScroll", "up");
      } else {
        this.scrollHeight = 0;
        this.$emit("canScroll", null);
      }
      this.$nextTick(() => {
        const lastLi = this.$refs[`li-${this.choices.length - 1}`];
        const inView = checkInView(ul, lastLi, false);
        if (!inView)
          this.$emit("canScroll", "down");
      });
    },
    mouseOver(index2) {
      this.selected = index2;
      this.moveCursor();
    }
  },
  computed: {
    css() {
      return {
        "column-count": this.column > 1 ? this.column : void 0,
        "height": "100%",
        "margin-top": this.scrollHeight,
        "text-align": this.align
      };
    }
  },
  unmounted() {
    this.obsKeyPress.unsubscribe();
  },
  components: {
    Arrow
  }
};
const choice_vue_vue_type_style_index_0_scoped_36b53cc0_lang = "";
const _hoisted_1$9 = { class: "choice-container" };
const _hoisted_2$6 = ["onClick", "onMouseover"];
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$9, [
    createBaseVNode("ul", {
      style: normalizeStyle($options.css),
      ref: "ul"
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($props.choices, (choice, index2) => {
        return openBlock(), createElementBlock("li", {
          key: index2,
          class: normalizeClass({ active: $data.selected == index2 }),
          onClick: ($event) => _ctx.$emit("selected", index2),
          onMouseover: ($event) => $options.mouseOver(index2),
          ref_for: true,
          ref: `li-${index2}`
        }, [
          renderSlot(_ctx.$slots, "default", { choice }, () => [
            createBaseVNode("p", null, [
              createBaseVNode("span", null, toDisplayString(choice.text), 1)
            ])
          ], true)
        ], 42, _hoisted_2$6);
      }), 128))
    ], 4)
  ]);
}
const ChoiceUi = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e], ["__scopeId", "data-v-36b53cc0"]]);
const _sfc_main$d = {
  name: "rpg-dialog",
  inject: ["rpgEngine", "rpgKeypress", "rpgGuiClose", "rpgGui"],
  props: ["message", "choices", "position", "fullWidth", "autoClose", "typewriterEffect"],
  data() {
    return {
      msg: ""
    };
  },
  async mounted() {
    let interval;
    this.rpgEngine.controls.stopInputs();
    if (!this.isChoice && !this.autoClose) {
      this.obsKeyPress = this.rpgKeypress.subscribe(({
        control
      }) => {
        if (control && control.actionName == Control.Action) {
          this.close();
        }
      });
    }
    let index2 = 0;
    const typewriter = () => {
      if (index2 >= this.message.length) {
        clearInterval(interval);
      } else {
        this.msg = this.msg + this.message[index2];
        index2++;
      }
    };
    if (!this.typewriterEffect) {
      this.msg = this.message;
    } else {
      interval = setInterval(typewriter, 20);
    }
  },
  computed: {
    isChoice() {
      return this.choices && this.choices.length > 0;
    }
  },
  methods: {
    close(indexSelect) {
      this.rpgGuiClose("rpg-dialog", indexSelect);
      this.rpgEngine.controls.listenInputs();
    }
  },
  unmounted() {
    if (this.obsKeyPress)
      this.obsKeyPress.unsubscribe();
  },
  components: {
    Window: WindowUi,
    Choices: ChoiceUi,
    Arrow
  }
};
const dialog_vue_vue_type_style_index_0_scoped_0ee896f9_lang = "";
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_choices = resolveComponent("choices");
  const _component_Arrow = resolveComponent("Arrow");
  const _component_window = resolveComponent("window");
  return openBlock(), createBlock(_component_window, {
    position: $props.position,
    fullWidth: $props.fullWidth,
    class: "dialog"
  }, {
    default: withCtx(() => [
      createBaseVNode("p", null, toDisplayString($data.msg), 1),
      $options.isChoice ? (openBlock(), createBlock(_component_choices, {
        key: 0,
        choices: $props.choices,
        onSelected: $options.close
      }, null, 8, ["choices", "onSelected"])) : !$props.autoClose ? (openBlock(), createBlock(_component_Arrow, {
        key: 1,
        direction: "down",
        center: true
      })) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["position", "fullWidth"]);
}
const DialogUi = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d], ["__scopeId", "data-v-0ee896f9"]]);
const bar_vue_vue_type_style_index_0_scoped_45d00ca4_lang = "";
const _sfc_main$c = {
  props: ["nb", "max", "color", "name"],
  computed: {
    percent() {
      return this.nb / this.max * 100;
    }
  }
};
const _hoisted_1$8 = { class: "bar" };
const _hoisted_2$5 = { class: "bar-info space-between" };
const _hoisted_3$4 = { class: "param-name" };
const _hoisted_4$2 = { class: "bar-full" };
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$8, [
    createBaseVNode("div", _hoisted_2$5, [
      createBaseVNode("span", _hoisted_3$4, toDisplayString($props.name), 1),
      createBaseVNode("span", null, toDisplayString($props.nb) + " / " + toDisplayString($props.max), 1)
    ]),
    createBaseVNode("div", _hoisted_4$2, [
      createBaseVNode("div", {
        class: normalizeClass(["bar-content", { [$props.color]: true }]),
        style: normalizeStyle({ width: `${$options.percent}%` })
      }, null, 6)
    ])
  ]);
}
const Bar = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c], ["__scopeId", "data-v-45d00ca4"]]);
const hero_vue_vue_type_style_index_0_scoped_45f12dbd_lang = "";
const _sfc_main$b = {
  props: ["face"],
  inject: ["rpgCurrentPlayer"],
  data() {
    return {
      name: "",
      hp: 0,
      sp: 0,
      maxHp: 0,
      maxSp: 0,
      expForNextlevel: 0,
      exp: 0,
      level: 0,
      _class: {}
    };
  },
  mounted() {
    this.obsCurrentPlayer = this.rpgCurrentPlayer.subscribe(({ object }) => {
      this.name = object.name;
      this.hp = object.hp;
      this.sp = object.sp;
      this.maxHp = object.param.maxHp;
      this.maxSp = object.param.maxSp;
      this.expForNextlevel = object.expForNextlevel;
      this.exp = object.exp;
      this.level = object.level;
    });
  },
  computed: {
    image() {
      return {
        backgroundImage: `url(${this.face})`
      };
    }
  },
  unmounted() {
    this.obsCurrentPlayer.unsubscribe();
  },
  components: {
    Bar
  }
};
const _withScopeId$1 = (n2) => (pushScopeId("data-v-45f12dbd"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$7 = { class: "hero" };
const _hoisted_2$4 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "face-column" }, [
  /* @__PURE__ */ createBaseVNode("div")
], -1));
const _hoisted_3$3 = { class: "name-column" };
const _hoisted_4$1 = { class: "space-between" };
const _hoisted_5$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { class: "param-name" }, "Level", -1));
const _hoisted_6$1 = { class: "bars-column" };
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_bar = resolveComponent("bar");
  return openBlock(), createElementBlock("div", _hoisted_1$7, [
    _hoisted_2$4,
    createBaseVNode("div", _hoisted_3$3, [
      createBaseVNode("ul", null, [
        createBaseVNode("li", null, toDisplayString($data.name), 1),
        createBaseVNode("li", _hoisted_4$1, [
          _hoisted_5$1,
          createTextVNode(),
          createBaseVNode("span", null, toDisplayString($data.level), 1)
        ]),
        createBaseVNode("li", null, [
          createVNode(_component_bar, {
            nb: $data.exp,
            max: $data.expForNextlevel,
            name: "EXP",
            color: "gray"
          }, null, 8, ["nb", "max"])
        ])
      ])
    ]),
    createBaseVNode("div", _hoisted_6$1, [
      createBaseVNode("ul", null, [
        createBaseVNode("li", null, toDisplayString($data._class.name), 1),
        createBaseVNode("li", null, [
          createVNode(_component_bar, {
            nb: $data.hp,
            max: $data.maxHp,
            name: "HP",
            color: "orange"
          }, null, 8, ["nb", "max"])
        ]),
        createBaseVNode("li", null, [
          createVNode(_component_bar, {
            nb: $data.sp,
            max: $data.maxSp,
            name: "SP",
            color: "blue"
          }, null, 8, ["nb", "max"])
        ])
      ])
    ])
  ]);
}
const Hero = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b], ["__scopeId", "data-v-45f12dbd"]]);
const main_vue_vue_type_style_index_0_lang = "";
const main_vue_vue_type_style_index_1_scoped_506e8ae0_lang = "";
const _sfc_main$a = {
  props: {
    goldName: {
      type: String,
      default: "Gold"
    }
  },
  inject: ["rpgCurrentPlayer", "rpgKeypress", "rpgEngine", "rpgStage", "rpgGuiClose", "rpgGui"],
  data() {
    const menu = [
      {
        text: "Items",
        value: "item",
        layout: "ItemsLayout"
      }
      /*  {
          text: 'Skills',
          value: 'skill'
      },  {
          text: 'Equipment',
          value: 'equipment',
          layout: 'EquipmentLayout'
      }, 
      {
          text: 'Status',
          value: 'status',
          layout: 'StatusLayout'
      } */
    ];
    if (this.rpgGui.exists("rpg-save")) {
      menu.push({
        text: "Save",
        value: "save",
        layout: "SaveLayout"
      });
    }
    return {
      player: {},
      active: true,
      gold: 0,
      menu
    };
  },
  mounted() {
    this.obsCurrentPlayer = this.rpgCurrentPlayer.subscribe(({ object }) => {
      this.gold = object.gold;
    });
    this.obsKeyPress = this.rpgKeypress.subscribe(({ control }) => {
      if (!this.active || !control)
        return;
      if (control.actionName == "back") {
        this.rpgStage.filters = [];
        if (this.rpgGui.exists("rpg-controls"))
          this.rpgGui.display("rpg-controls");
        this.rpgGuiClose("rpg-main-menu");
        this.rpgEngine.controls.listenInputs();
      }
    });
  },
  unmounted() {
    this.obsKeyPress.unsubscribe();
    this.obsCurrentPlayer.unsubscribe();
  },
  methods: {
    selectMenu(index2) {
      this.$emit("changeLayout", this.menu[index2].layout);
    }
  },
  components: {
    Hero
  }
};
const _hoisted_1$6 = { class: "menu-row" };
const _hoisted_2$3 = { class: "menu-left" };
const _hoisted_3$2 = { class: "menu-right" };
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_rpg_choice = resolveComponent("rpg-choice");
  const _component_rpg_window = resolveComponent("rpg-window");
  const _component_Hero = resolveComponent("Hero");
  return openBlock(), createElementBlock("div", _hoisted_1$6, [
    createBaseVNode("div", _hoisted_2$3, [
      createVNode(_component_rpg_window, {
        fullWidth: true,
        class: "menu-choice"
      }, {
        default: withCtx(() => [
          createVNode(_component_rpg_choice, {
            choices: $data.menu,
            onSelected: $options.selectMenu,
            ref: "menu"
          }, null, 8, ["choices", "onSelected"])
        ]),
        _: 1
      }),
      createVNode(_component_rpg_window, {
        fullWidth: true,
        class: "gold"
      }, {
        default: withCtx(() => [
          createBaseVNode("p", null, toDisplayString($data.gold) + " " + toDisplayString($props.goldName), 1)
        ]),
        _: 1
      })
    ]),
    createBaseVNode("div", _hoisted_3$2, [
      createVNode(_component_rpg_window, {
        fullWidth: true,
        height: "100%"
      }, {
        default: withCtx(() => [
          createVNode(_component_Hero, { class: "hero-face" })
        ]),
        _: 1
      })
    ])
  ]);
}
const MainLayout = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a], ["__scopeId", "data-v-506e8ae0"]]);
const icon_vue_vue_type_style_index_0_scoped_c3768ae4_lang = "";
const _sfc_main$9 = {
  props: ["name"]
};
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("i", {
    class: normalizeClass($props.name)
  }, null, 2);
}
const Icon = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9], ["__scopeId", "data-v-c3768ae4"]]);
const _sfc_main$8 = {
  inject: ["rpgCurrentPlayer", "rpgKeypress", "rpgSocket"],
  data() {
    return {
      description: "",
      items: [],
      arrow: null
    };
  },
  computed: {
    mapItems() {
      return this.items.filter((it2) => it2).map((it2) => ({
        text: it2.item.name,
        nb: it2.nb,
        consumable: it2.item.consumable
      }));
    }
  },
  mounted() {
    this.obsCurrentPlayer = this.rpgCurrentPlayer.subscribe(({
      object
    }) => {
      this.items = Object.values(object.items || []);
    });
    this.obsKeyPress = this.rpgKeypress.subscribe(({
      control
    }) => {
      if (!control)
        return;
      if (control.actionName == Control.Back) {
        this.$emit("changeLayout", "MainLayout");
      }
    });
    this.selected(0);
  },
  unmounted() {
    this.obsKeyPress.unsubscribe();
    this.obsCurrentPlayer.unsubscribe();
  },
  methods: {
    selected(index2) {
      if (!this.items[index2])
        return;
      this.description = this.items[index2].item.description;
    },
    choiceItem(index2) {
      if (!this.items[index2])
        return;
      const {
        id,
        consumable
      } = this.items[index2].item;
      if (!consumable)
        return;
      this.rpgSocket().emit("gui.interaction", {
        guiId: "rpg-main-menu",
        name: "useItem",
        data: id
      });
    }
  },
  components: {
    Icon
  }
};
const item_vue_vue_type_style_index_0_scoped_bc1f995f_lang = "";
const _hoisted_1$5 = { class: "item-menu" };
const _hoisted_2$2 = { class: "row" };
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_rpg_choice = resolveComponent("rpg-choice");
  const _component_rpg_window = resolveComponent("rpg-window");
  return openBlock(), createElementBlock("div", _hoisted_1$5, [
    createVNode(_component_rpg_window, {
      fullWidth: true,
      height: "80%",
      arrow: $data.arrow
    }, {
      default: withCtx(() => [
        createBaseVNode("div", _hoisted_2$2, [
          createVNode(_component_rpg_choice, {
            choices: $options.mapItems,
            column: 1,
            onChange: $options.selected,
            onSelected: $options.choiceItem,
            ref: "choice",
            onCanScroll: _cache[0] || (_cache[0] = ($event) => $data.arrow = $event)
          }, {
            default: withCtx(({ choice }) => [
              createBaseVNode("p", {
                class: normalizeClass(["space-between item", { "not-consumable": !choice.consumable }])
              }, [
                createBaseVNode("span", null, toDisplayString(choice.text), 1),
                createBaseVNode("span", null, toDisplayString(choice.nb), 1)
              ], 2)
            ]),
            _: 1
          }, 8, ["choices", "onChange", "onSelected"])
        ])
      ]),
      _: 1
    }, 8, ["arrow"]),
    createVNode(_component_rpg_window, {
      fullWidth: true,
      height: "20%"
    }, {
      default: withCtx(() => [
        createBaseVNode("p", null, toDisplayString($data.description), 1)
      ]),
      _: 1
    })
  ]);
}
const ItemsLayout = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8], ["__scopeId", "data-v-bc1f995f"]]);
const _sfc_main$7 = {
  components: {
    Bar
  }
};
const _hoisted_1$4 = { class: "status-menu" };
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Bar = resolveComponent("Bar");
  const _component_rpg_window = resolveComponent("rpg-window");
  return openBlock(), createElementBlock("div", _hoisted_1$4, [
    createVNode(_component_rpg_window, {
      fullWidth: true,
      height: "80%"
    }, {
      default: withCtx(() => [
        createVNode(_component_Bar, {
          nb: 6500,
          max: 9999,
          name: "MaxHP"
        })
      ]),
      _: 1
    })
  ]);
}
const StatusLayout = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
const _sfc_main$6 = {
  inject: ["rpgCurrentPlayer"],
  mounted() {
    this.obsCurrentPlayer = this.rpgCurrentPlayer.subscribe(({ object }) => {
      console.log(object);
    });
  }
};
const _hoisted_1$3 = { class: "equipment-menu" };
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_rpg_window = resolveComponent("rpg-window");
  return openBlock(), createElementBlock("div", _hoisted_1$3, [
    createVNode(_component_rpg_window, {
      fullWidth: true,
      height: "80%"
    })
  ]);
}
const EquipmentLayout = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
const _sfc_main$5 = {
  inject: ["rpgKeypress"],
  mounted() {
    this.obsKeyPress = this.rpgKeypress.subscribe(({
      control
    }) => {
      if (!control)
        return;
      if (control.actionName == Control.Back) {
        this.back();
      }
    });
  },
  unmounted() {
    this.obsKeyPress.unsubscribe();
  },
  methods: {
    back() {
      this.$emit("changeLayout", "MainLayout");
    }
  }
};
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_rpg_save = resolveComponent("rpg-save");
  return openBlock(), createBlock(_component_rpg_save, { onSaved: $options.back }, null, 8, ["onSaved"]);
}
const SaveLayout = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
const back_vue_vue_type_style_index_0_scoped_a7b6b651_lang = "";
const _sfc_main$4 = {
  inject: ["rpgEngine"],
  methods: {
    back() {
      this.rpgEngine.controls.applyControl("back");
    }
  }
};
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "back",
    onClick: _cache[0] || (_cache[0] = (...args) => $options.back && $options.back(...args))
  });
}
const BackButton = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__scopeId", "data-v-a7b6b651"]]);
const main_vue_vue_type_style_index_0_scoped_98ee6de6_lang = "";
const _sfc_main$3 = {
  name: "rpg-main-menu",
  inject: ["rpgEngine", "rpgStage", "rpgGui"],
  data() {
    return {
      layout: "MainLayout"
    };
  },
  mounted() {
    if (this.rpgGui.exists("rpg-controls"))
      this.rpgGui.hide("rpg-controls");
    this.rpgEngine.controls.stopInputs();
    const blur = new this.rpgEngine.PIXI.BlurFilter();
    this.rpgStage.filters = [blur];
  },
  methods: {
    change(name) {
      this.layout = name;
    }
  },
  components: {
    MainLayout,
    ItemsLayout,
    StatusLayout,
    BackButton,
    EquipmentLayout,
    SaveLayout
  }
};
const _hoisted_1$2 = { class: "menu-main" };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_BackButton = resolveComponent("BackButton");
  return openBlock(), createElementBlock("div", _hoisted_1$2, [
    (openBlock(), createBlock(resolveDynamicComponent($data.layout), {
      onChangeLayout: $options.change,
      ref: "layout"
    }, null, 40, ["onChangeLayout"])),
    createVNode(_component_BackButton)
  ]);
}
const MenuUi = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-98ee6de6"]]);
const _sfc_main$2 = {
  name: "rpg-shop",
  inject: ["rpgCurrentPlayer", "rpgKeypress", "rpgGuiClose", "rpgSocket", "rpgEngine", "rpgGui"],
  props: ["items"],
  data() {
    return {
      player: {},
      inventory: [],
      menuActive: true,
      menu: [{
        text: "Buy",
        value: "buy"
      }, {
        text: "Sell",
        value: "sell"
      }, {
        text: "Cancel",
        value: "cancel"
      }],
      currentItem: {},
      mode: "",
      goldName: "Gold",
      step: 0,
      quantity: 1,
      indexSelected: 0,
      doAction: false
    };
  },
  mounted() {
    if (this.rpgGui.exists("rpg-controls"))
      this.rpgGui.hide("rpg-controls");
    this.rpgEngine.controls.stopInputs();
    this.obsCurrentPlayer = this.rpgCurrentPlayer.subscribe(({
      object
    }) => {
      this.player = object;
      this.inventory = Object.values(this.player.items).filter((item) => item);
      if (this.doAction) {
        this.step = 0;
        this.quantity = 1;
        this.doAction = false;
      }
      this.selected(this.indexSelected);
    });
    const interactionBuy = (name) => {
      if (name == Control.Back) {
        this.step = 0;
      } else if (name == Control.Up) {
        const nextPrice = this.currentItem.price * (this.quantity + 1);
        if (nextPrice > this.player.gold) {
          return false;
        }
        this.quantity += 1;
      } else if (name == Control.Down) {
        if (this.quantity - 1 == 0) {
          return false;
        }
        this.quantity -= 1;
      } else if (name == Control.Action) {
        this.doAction = true;
        this.rpgSocket().emit("gui.interaction", {
          guiId: "rpg-shop",
          name: "buyItem",
          data: {
            id: this.currentItem.id,
            nb: this.quantity
          }
        });
      }
    };
    const interactionSell = (name) => {
      if (name == Control.Back) {
        this.step = 0;
      } else if (name == Control.Up) {
        if (this.quantity + 1 > this.currentItem.nb) {
          return false;
        }
        this.quantity += 1;
      } else if (name == Control.Down) {
        if (this.quantity - 1 == 0) {
          return false;
        }
        this.quantity -= 1;
      } else if (name == Control.Action) {
        this.doAction = true;
        this.rpgSocket().emit("gui.interaction", {
          guiId: "rpg-shop",
          name: "sellItem",
          data: {
            id: this.currentItem.id,
            nb: this.quantity
          }
        });
      }
    };
    this.obsKeyPress = this.rpgKeypress.subscribe(({
      control
    }) => {
      if (!control)
        return;
      const name = control.actionName;
      if (!this.mode) {
        if (name == Control.Back) {
          this.close();
        }
      } else if (this.mode) {
        if (this.step == 1) {
          if (this.mode == "buy")
            interactionBuy(name);
          if (this.mode == "sell")
            interactionSell(name);
        } else {
          if (name == Control.Back) {
            this.mode = "";
            this.description = "";
            this.menuActive = true;
          }
        }
      }
    });
  },
  computed: {
    buyerItems() {
      return this.items.map((item) => {
        const playerItem = this.playerItems.find((playerItem2) => playerItem2.id == item.id) || {
          nb: 0
        };
        return {
          ...item,
          nb: playerItem.nb
        };
      });
    },
    listItems() {
      return this.mode == "buy" ? this.buyerItems : this.playerItems;
    },
    totalPrice() {
      let nb = this.currentItem.price * this.quantity;
      if (this.mode == "sell") {
        return Math.floor(nb / 2);
      }
      return nb;
    },
    playerItems() {
      return this.inventory.map(({
        item,
        nb
      }) => ({
        ...item,
        nb
      }));
    }
  },
  methods: {
    selected(index2) {
      if (!this.listItems[index2]) {
        this.currentItem = {};
        this.indexSelected = 0;
        if (this.listItems.length == 0)
          this.mode = "";
        return;
      }
      this.currentItem = this.listItems[index2];
      this.indexSelected = index2;
    },
    changeMenu(index2) {
      const mode = this.menu[index2].value;
      if (mode == "cancel") {
        this.close();
        return;
      }
      this.menuActive = false;
      this.mode = mode;
      this.selected(0);
    },
    choiceItem(index2) {
      const item = this.listItems[index2];
      if (item.price > this.player.gold)
        return;
      this.step = 1;
    },
    price(nb) {
      if (this.mode == "sell") {
        return Math.floor(nb / 2);
      } else {
        return nb;
      }
    },
    close() {
      this.rpgGuiClose();
      this.rpgEngine.controls.listenInputs();
      if (this.rpgGui.exists("rpg-controls"))
        this.rpgGui.display("rpg-controls");
    }
  },
  components: {
    BackButton
  },
  unmounted() {
    this.obsKeyPress.unsubscribe();
    this.obsCurrentPlayer.unsubscribe();
  }
};
const main_vue_vue_type_style_index_0_scoped_ef1d8785_lang = "";
const _withScopeId = (n2) => (pushScopeId("data-v-ef1d8785"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$1 = { class: "row" };
const _hoisted_2$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("hr", null, null, -1));
const _hoisted_3$1 = {
  key: 0,
  class: "shop-content"
};
const _hoisted_4 = { key: 1 };
const _hoisted_5 = { class: "space-between" };
const _hoisted_6 = { class: "cursor" };
const _hoisted_7 = { class: "space-between" };
const _hoisted_8 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", null, null, -1));
const _hoisted_9 = { class: "total" };
const _hoisted_10 = {
  key: 0,
  class: "shop-info"
};
const _hoisted_11 = { class: "space-between" };
const _hoisted_12 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", null, "Possession", -1));
const _hoisted_13 = {
  key: 1,
  class: "bottom"
};
const _hoisted_14 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("hr", null, null, -1));
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_rpg_choice = resolveComponent("rpg-choice");
  const _component_rpg_window = resolveComponent("rpg-window");
  const _component_BackButton = resolveComponent("BackButton");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_rpg_window, {
      fullWidth: true,
      height: "100%",
      class: "shop-menu"
    }, {
      default: withCtx(() => [
        createBaseVNode("div", _hoisted_1$1, [
          createVNode(_component_rpg_choice, {
            choices: $data.menu,
            column: 3,
            onSelected: $options.changeMenu,
            align: "center",
            active: $data.menuActive
          }, null, 8, ["choices", "onSelected", "active"]),
          createBaseVNode("div", null, [
            createBaseVNode("p", null, toDisplayString($data.player.gold) + " " + toDisplayString($data.goldName), 1)
          ])
        ]),
        _hoisted_2$1,
        $data.mode ? (openBlock(), createElementBlock("div", _hoisted_3$1, [
          createBaseVNode("div", {
            class: normalizeClass({ "item-quantity": $data.step == 1 })
          }, [
            $data.step == 0 ? (openBlock(), createBlock(_component_rpg_choice, {
              key: 0,
              choices: $options.listItems,
              column: 1,
              onChange: $options.selected,
              onSelected: $options.choiceItem,
              ref: "list"
            }, {
              default: withCtx(({ choice }) => [
                createBaseVNode("p", {
                  class: normalizeClass(["space-between item", { "can-not-buy": choice.price > $data.player.gold }])
                }, [
                  createBaseVNode("span", null, toDisplayString(choice.name), 1),
                  createBaseVNode("span", null, toDisplayString($options.price(choice.price)), 1)
                ], 2)
              ]),
              _: 1
            }, 8, ["choices", "onChange", "onSelected"])) : (openBlock(), createElementBlock("div", _hoisted_4, [
              createBaseVNode("p", _hoisted_5, [
                createBaseVNode("span", null, toDisplayString($data.currentItem.name), 1),
                createBaseVNode("span", _hoisted_6, [
                  createBaseVNode("span", null, "x " + toDisplayString($data.quantity), 1)
                ])
              ]),
              createBaseVNode("p", _hoisted_7, [
                _hoisted_8,
                createBaseVNode("span", _hoisted_9, toDisplayString($options.totalPrice) + " " + toDisplayString($data.goldName), 1)
              ])
            ]))
          ], 2),
          $data.currentItem.name ? (openBlock(), createElementBlock("div", _hoisted_10, [
            createBaseVNode("p", _hoisted_11, [
              _hoisted_12,
              createBaseVNode("span", null, toDisplayString($data.currentItem.nb), 1)
            ])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        $data.mode ? (openBlock(), createElementBlock("div", _hoisted_13, [
          _hoisted_14,
          createBaseVNode("p", null, toDisplayString($data.currentItem.description), 1)
        ])) : createCommentVNode("", true)
      ]),
      _: 1
    }),
    createVNode(_component_BackButton)
  ], 64);
}
const ShopUi = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-ef1d8785"]]);
const _sfc_main$1 = {
  name: "rpg-disconnect",
  inject: ["rpgStage", "rpgEngine"],
  mounted() {
    const blur = new this.rpgEngine.PIXI.BlurFilter();
    this.rpgStage.filters = [blur];
  },
  unmounted() {
    this.rpgStage.filters = [];
  }
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_rpg_dialog = resolveComponent("rpg-dialog");
  return openBlock(), createBlock(_component_rpg_dialog, {
    message: "Oops, you are disconnected. Please wait!",
    position: "middle",
    autoClose: true
  });
}
const DisconnectUi = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
const alert_vue_vue_type_style_index_0_lang = "";
const guiName = "rpg-notification";
const _sfc_main = {
  props: {
    icon: {
      defaut: ""
    },
    sound: {
      defaut: ""
    },
    message: {
      default: ""
    },
    time: {
      default: 2e3
    },
    position: {
      default: "bottom"
    },
    type: {
      default: ""
    }
  },
  name: guiName,
  inject: ["rpgGui", "rpgResource", "rpgSound", "rpgEngine"],
  data() {
    return {
      show: false
    };
  },
  computed: {
    image() {
      const resourceImage = this.rpgResource.spritesheets.get(this.icon);
      if (!resourceImage) {
        return this.icon;
      }
      return resourceImage.image;
    }
  },
  mounted() {
    setTimeout(() => {
      this.show = true;
      const globalConfig = this.rpgEngine.globalConfig.notification;
      const globalSound = globalConfig && globalConfig.sound;
      const sound = this.sound || globalSound || (this.type == "error" ? "error" : "alert");
      if (sound && globalSound !== null) {
        this.rpgSound.get(sound).play();
      }
    }, 10);
    setTimeout(() => {
      this.show = false;
      setTimeout(() => {
        this.rpgGui.hide(guiName);
      }, 500);
    }, this.time);
  }
};
const _hoisted_1 = {
  key: 0,
  class: "icon"
};
const _hoisted_2 = ["src"];
const _hoisted_3 = { class: "msg" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["alert-panel", $props.position])
  }, [
    createBaseVNode("div", {
      class: normalizeClass(["alert", { show: $data.show, [$props.position]: true, [$props.type]: true }])
    }, [
      $options.image ? (openBlock(), createElementBlock("div", _hoisted_1, [
        createBaseVNode("img", { src: $options.image }, null, 8, _hoisted_2)
      ])) : createCommentVNode("", true),
      createBaseVNode("span", _hoisted_3, toDisplayString($props.message), 1)
    ], 2)
  ], 2);
}
const NotificationUi = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
const vitePluginRequire_1740206734086_82845903 = "/assets/error_002-76810ec3.ogg";
const vitePluginRequire_1740206734086_99188894 = "/assets/confirmation_002-33b17a9a.ogg";
var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __decorateClass$3 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$3(target, key, result);
  return result;
};
let GuiSounds = class {
};
GuiSounds = __decorateClass$3([Sound$1({
  sounds: {
    alert: vitePluginRequire_1740206734086_99188894,
    error: vitePluginRequire_1740206734086_82845903
  }
})], GuiSounds);
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __decorateClass$2 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$2(target, key, result);
  return result;
};
let RpgClientEngine3 = class {
};
RpgClientEngine3 = __decorateClass$2([
  RpgModule({
    gui: [
      DialogUi,
      MenuUi,
      WindowUi,
      ChoiceUi,
      DisconnectUi,
      ShopUi,
      NotificationUi
    ],
    sounds: [
      GuiSounds
    ]
  })
], RpgClientEngine3);
const _rpgjs_default_gui = {
  client: RpgClientEngine3
};
var a = { events: {}, publish: function a2(b3, c3) {
  if (this.events.hasOwnProperty(b3))
    this.events[b3].forEach(function(a8) {
      return a8(c3);
    });
}, subscribe: function a3(b3, c3) {
  if (!this.events.hasOwnProperty(b3))
    this.events[b3] = [];
  this.events[b3].push(c3);
  return { unsubscribe: function() {
    var a8 = this.events[b3].indexOf(c3);
    if (-1 !== a8)
      this.events[b3].splice(a8, 1);
  }.bind(this) };
} };
var a1 = { CONNECT: { NATIVE: "gamepadconnected", ALIAS: "connect" }, DISCONNECT: { NATIVE: "gamepaddisconnected", ALIAS: "disconnect" }, BUTTON_PRESS: { NATIVE: null, ALIAS: "button_press" }, BUTTON_RELEASE: { NATIVE: null, ALIAS: "button_release" }, AXIS_MOVEMENT: { NATIVE: null, ALIAS: "axis_move" } };
var b = { LEFT: { NAME: "left_stick", AXES: { X: 0, Y: 1 } }, RIGHT: { NAME: "right_stick", AXES: { X: 2, Y: 3 } } };
var c = { LEFT: "left", RIGHT: "right", TOP: "top", BOTTOM: "bottom" };
var d = { button_0: 0, button_1: 1, button_2: 2, button_3: 3, button_4: 4, button_5: 5, button_6: 6, button_7: 7, button_8: 8, button_9: 9, button_10: 10, button_11: 11, button_12: 12, button_13: 13, button_14: 14, button_15: 15, button_16: 16, button_17: 17 };
var e = 0.8;
var a22 = function(a8) {
  if (console.warn && "function" == typeof console.warn)
    console.warn(a8);
  else
    console.log(a8);
};
var b1 = function(a8, b3) {
  var c3 = [];
  Object.keys(b3).forEach(function(d2) {
    if (b3[d2] === a8)
      c3.push(d2);
    else if (Array.isArray(b3[d2]) && -1 !== b3[d2].indexOf(a8))
      c3.push(d2);
  });
  return c3;
};
var c1 = function(a8) {
  return !!a8 && !!a8.type && !!a8.playEffect && "function" == typeof a8.playEffect || false;
};
var d1 = function() {
  return !!window.navigator.getGamepads && "function" == typeof window.navigator.getGamepads || false;
};
var f2 = { loopStarted: false, instances: {}, buttonEvents: { joypad: [] }, settings: { axisMovementThreshold: e }, remove: function a4(b3) {
  return delete this.instances[b3];
}, on: function c2(d2, e3) {
  switch (d2) {
    case a1.CONNECT.ALIAS:
      return a.subscribe(a1.CONNECT.ALIAS, e3);
    case a1.DISCONNECT.ALIAS:
      return a.subscribe(a1.DISCONNECT.ALIAS, e3);
    case a1.BUTTON_PRESS.ALIAS:
      return a.subscribe(a1.BUTTON_PRESS.ALIAS, e3);
    case a1.BUTTON_RELEASE.ALIAS:
      return a.subscribe(a1.BUTTON_RELEASE.ALIAS, e3);
    case a1.AXIS_MOVEMENT.ALIAS:
      return a.subscribe(a1.AXIS_MOVEMENT.ALIAS, e3);
  }
}, vibrate: function a5(b3, c3) {
  var f3 = b3.vibrationActuator;
  var g2 = c3 || this.settings.vibration;
  if (c1(f3)) {
    var h2 = f3.type;
    return b3.vibrationActuator.playEffect(h2, g2);
  }
  a22("No vibration actuator interface found - https://developer.mozilla.org/en-US/docs/Web/API/GamepadHapticActuator");
}, set: function a6(b3) {
  var c3 = b3.axisMovementThreshold, d2 = b3.vibration, e3 = b3.customButtonMapping;
  var f3 = parseFloat(c3);
  if (!isNaN(f3))
    this.settings.axisMovementThreshold = f3;
  this.settings.vibration = d2;
  this.settings.customButtonMapping = e3;
}, trigger: function b2(c3, d2) {
  return a.publish(c3, d2);
} };
var j = function(a8) {
  a8.buttons.forEach(function(c3, d12) {
    var e3 = f2.settings.customButtonMapping;
    var f1 = e3 || d;
    var i2 = b1(d12, f1);
    var j2 = f2.buttonEvents;
    if (i2 && i2.length)
      i2.forEach(function(b3) {
        if (c3.pressed) {
          if (!j2.joypad[a8.index][b3])
            j2.joypad[a8.index][b3] = { pressed: true, hold: false, released: false };
          j2.joypad[a8.index][b3].button = c3;
          j2.joypad[a8.index][b3].index = d12;
          j2.joypad[a8.index][b3].gamepad = a8;
        } else if (!c3.pressed && j2.joypad[a8.index][b3]) {
          j2.joypad[a8.index][b3].released = true;
          j2.joypad[a8.index][b3].hold = false;
        }
      });
  });
};
var k3 = function(a8) {
  var c12 = function(a9) {
    return new CustomEvent(a1.AXIS_MOVEMENT.ALIAS, { detail: a9 });
  };
  var g2 = f2.settings.axisMovementThreshold;
  var h2 = a8.axes;
  var i2 = h2.length;
  var j2 = i2 / 2;
  h2.forEach(function(b12, d2) {
    if (Math.abs(b12) > g2) {
      var h3 = null;
      var i3 = null;
      var k4 = b12;
      h3 = d2 < j2 ? b.LEFT.NAME : b.RIGHT.NAME;
      if (d2 === b.LEFT.AXES.X || d2 === b.RIGHT.AXES.X)
        i3 = b12 < 0 ? c.LEFT : c.RIGHT;
      if (d2 === b.LEFT.AXES.Y || d2 === b.RIGHT.AXES.Y)
        i3 = b12 < 0 ? c.TOP : c.BOTTOM;
      var l2 = { gamepad: a8, totalSticks: j2, stickMoved: h3, directionOfMovement: i3, axisMovementValue: k4, axis: d2 };
      return window.dispatchEvent(c12(l2));
    }
  });
};
var m = function(a8, b3) {
  if (b3[a8].pressed) {
    l(a1.BUTTON_PRESS.ALIAS, b3, a8);
    b3[a8].pressed = false;
    b3[a8].hold = true;
    b3[a8].last_event = a1.BUTTON_PRESS.ALIAS;
  } else if (b3[a8].hold)
    ;
  else if (b3[a8].released && b3[a8].last_event === a1.BUTTON_PRESS.ALIAS) {
    l(a1.BUTTON_RELEASE.ALIAS, b3, a8);
    delete b3[a8];
  }
};
var e1 = { id: null, start: function e2() {
  var f1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame;
  var g2 = f2.buttonEvents;
  var h2 = window.navigator.getGamepads();
  h2 = Array.prototype.slice.call(h2);
  h2.forEach(function(d2, e3) {
    if (d2) {
      if (!g2.joypad[e3])
        g2.joypad[e3] = {};
      f2.instances[e3] = d2;
      j(d2);
      k3(d2);
    }
  });
  g2.joypad.forEach(function(a8) {
    if (a8)
      Object.keys(a8).forEach(function(b3) {
        m(b3, a8);
      });
  });
  this.id = f1(this.start.bind(this));
}, stop: function a7(b3) {
  var c3 = window.cancelAnimationFrame || window.webkitCancelAnimationFrame;
  return c3(b3);
} };
var i = function() {
  window.addEventListener(a1.CONNECT.NATIVE, function(e3) {
    a.publish(a1.CONNECT.ALIAS, e3);
    if (!f2.loopStarted) {
      f2.loopStarted = true;
      return e1.start();
    }
  });
  window.addEventListener(a1.DISCONNECT.NATIVE, function(e3) {
    a.publish(a1.DISCONNECT.ALIAS, e3);
    f2.remove(e3.gamepad.index);
    f2.buttonEvents.joypad[e3.gamepad.index] = null;
    if (!Object.keys(f2.instances).length) {
      f2.loopStarted = false;
      return e1.stop(e1.id);
    }
  });
  window.addEventListener(a1.BUTTON_PRESS.ALIAS, function(b3) {
    return a.publish(a1.BUTTON_PRESS.ALIAS, b3);
  });
  window.addEventListener(a1.BUTTON_RELEASE.ALIAS, function(b3) {
    return a.publish(a1.BUTTON_RELEASE.ALIAS, b3);
  });
  window.addEventListener(a1.AXIS_MOVEMENT.ALIAS, function(b3) {
    return a.publish(a1.AXIS_MOVEMENT.ALIAS, b3);
  });
};
var l = function(a8, b3, c3) {
  var d2 = function(b4) {
    return new CustomEvent(a8, { detail: b4 });
  };
  var e3 = b3[c3], f3 = e3.index, g2 = e3.gamepad;
  var h2 = { buttonName: c3, button: b3[c3].button, index: f3, gamepad: g2 };
  window.dispatchEvent(d2(h2));
};
i();
if (d1())
  window.joypad = f2;
else {
  window.joypad = {};
  a22("Your browser does not support the Gamepad API - https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API");
}
const vitePluginRequire_1740206734163_59184053 = "/assets/error_002-76810ec3.ogg";
const vitePluginRequire_1740206734163_59712482 = "/assets/confirmation_002-33b17a9a.ogg";
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __decorateClass$1 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$1(target, key, result);
  return result;
};
let GamePadSounds = class {
};
GamePadSounds = __decorateClass$1([Sound$1({
  sounds: {
    connect: vitePluginRequire_1740206734163_59712482,
    disconnect: vitePluginRequire_1740206734163_59184053
  }
})], GamePadSounds);
const icon = "/assets/gamepad-e5a5597c.svg";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
const joypad = window["joypad"];
let moving = false;
let directions = {};
let axisDate = 0;
const DIRECTIONS = [Direction.Left, Direction.Right, Direction.Up, Direction.Down];
let RpgClientModule = class {
};
RpgClientModule = __decorateClass([
  RpgModule({
    engine: {
      onStart(engine) {
        const globalConfig = engine.globalConfig.gamepad || {};
        if (!globalConfig.connect)
          globalConfig.connect = {};
        if (!globalConfig.disconnect)
          globalConfig.disconnect = {};
        const optionsConnect = {
          message: "Your gamepad is connected !",
          time: 2e3,
          icon,
          sound: "connect",
          ...globalConfig.connect
        };
        const optionsDisconnect = {
          message: "Your gamepad is disconnected !",
          time: 2e3,
          icon,
          sound: "disconnect",
          ...globalConfig.disconnect
        };
        const move = () => {
          if (moving) {
            for (let dir in directions) {
              engine.controls.applyControl(dir, true);
            }
          }
        };
        joypad.on("connect", (e3) => {
          RpgGui.display("rpg-notification", optionsConnect);
          setInterval(move, 400);
        });
        joypad.on("disconnect", (e3) => {
          RpgGui.display("rpg-notification", optionsDisconnect);
        });
        joypad.on("button_press", (e3) => {
          const { buttonName } = e3.detail;
          switch (buttonName) {
            case "button_0":
              engine.controls.applyControl(Control.Action);
              break;
            case "button_1":
            case "button_9":
              engine.controls.applyControl(Control.Back);
              break;
          }
        });
        joypad.on("axis_move", async (e3) => {
          moving = true;
          axisDate = Date.now();
          let direction = e3.detail.directionOfMovement;
          if (direction == "bottom")
            direction = Direction.Down;
          else if (direction == "top")
            direction = Direction.Up;
          else if (direction == "left")
            direction = Direction.Left;
          else if (direction == "right")
            direction = Direction.Right;
          directions = {
            [direction]: true
          };
          for (let dir of DIRECTIONS) {
            if (!directions[dir]) {
              engine.controls.applyControl(dir, false);
            }
          }
          move();
        });
      },
      onStep(engine) {
        let now = Date.now();
        if (now - axisDate > 100 && moving) {
          for (let dir of DIRECTIONS) {
            directions = {};
            moving = false;
            engine.controls.applyControl(dir, false);
          }
        }
      }
    },
    sounds: [
      GamePadSounds
    ]
  })
], RpgClientModule);
const _rpgjs_gamepad = {
  client: RpgClientModule
};
export {
  BehaviorSubject as B,
  EVENTS_MAP as E,
  Presets as P,
  RpgModule as R,
  Spritesheet as S,
  _rpgjs_mobile_gui as _,
  _rpgjs_default_gui as a,
  _rpgjs_gamepad as b,
  RpgPlugin as c,
  RpgRenderer as d,
  entryPoint as e,
  inject as i,
  lookup as l,
  map$7 as m,
  tap as t
};
